{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Gothic Modding Community page","text":"<p>This GitHub page is designed to contain community maintained set of articles, tutorials and documentation for everything Gothic.</p> <p>First two Gothic games use engine called ZenGin, developed by Piranha Bytes and Mad Scientists. If you want to know more about the history of the development, there is a heap of information on the Gothic Archive.</p> <p>The content here is not meant to be taken as the holy word of modding. We are just modders sharing our experiences, knowledge and our favorite work flows.</p> <p>Feel free to open a pull request with your article or propose changes.</p> <p>You can open a pull request in this repository</p>"},{"location":"notready/","title":"Notready","text":"<p>Warning</p> <p>Sorry, this page is not ready yet! </p>"},{"location":"contribute/","title":"How to contribute","text":"<p>The Gothic Modding Community is a community-driven project. We encourage people to contribute.</p> <p>This site is built with a Static Site Generator MkDocs and the Material for MkDocs theme together with multiple other MkDocs plugins.</p> <p>Prerequisites for contribution differ based on the scale and type of the contribution.</p>"},{"location":"contribute/#feedback","title":"Feedback","text":"<p>Using English, you can either open an issue via GitHub or join us on Discord.</p>"},{"location":"contribute/#direct-contribution","title":"Direct contribution","text":"<p>Direct contribution is made via creating a copy of this repository (a fork) and creating a pull request (PR) on GitHub with changes for approval.</p> <p>Don't waste time</p> <p>Please make sure that the content you are contributing does not already exist on the dev page. You can use the search tool to filter GMC for different keywords and contents.</p> <p>How to edit the source files?</p> <p>The source files for the articles are written using the Markdown <code>.md</code> file format (Markdown cheatsheet). Other than that, this site also uses Python Markdown Extensions which add more syntax rules like indented admonitions.</p>"},{"location":"contribute/#minor-changes","title":"Minor changes","text":"<p>Minor changes like fixing typos, grammatical errors or removing/adding words to paragraphs in a single file can be done quickly with the  button in the upper right corner of each article. This will open up a GitHub editing interface which will create a fork with a patch branch after modifying the file and guide the user to open up the pull request.</p> <p>Select the correct branch for the pull request</p> <p>Make sure that the pull request is directed towards the <code>dev</code> or a special <code>pre-merge</code> branch and not the <code>main</code> branch.</p>"},{"location":"contribute/#major-changes","title":"Major changes","text":"<p>More elaborate changes like editing multiple files at once, adding new articles, images, other miscellaneous files or changing the configuration of the page are easier to make via external tools on your local PC. While most of these operations can be done with the GitHub interface, it is rather cumbersome, and it may be harder to spot issues during the process as changes are not immediately visible in the browser in their final form.</p> <p>Some preparation is needed before working on the files as MkDocs requires an installation of Python on the system to run. GitHub works on top of git so an installation of git is also required. A basic familiarity with Terminal/Command Prompt/Powershell command line interfaces is helpful.</p>"},{"location":"contribute/#system-setup-video","title":"System setup (video)","text":"<p>Firstly, you should install Python. You can follow this step-by-step tutorial for Windows or macOS on how to install Python.</p> <p>This video is from 2017?!</p> <p>The process of installing Python hasn't changed since that point. However, please install the latest version of Python 3.</p> <p>To work remotely with GitHub, you can install the latest version of git on your system following this tutorial.</p> <p>If you just plan on editing the content of the articles with Markdown, you can simply install the latest version of Visual Studio Code for GUI git management and Markdown preview or work with any other familiar text editor and omit the environment setup.</p> <p>If you are planning to do some elaborate Python programming, you can follow this step-by-step tutorial for Windows or macOS on how to set up an environment with Visual Studio Code.</p>"},{"location":"contribute/#system-setup-text","title":"System setup (text)","text":"<p>To prepare your system to run the project follow those instructions:</p> <ol> <li> <p>Install the latest version of Python .     Make sure to select the \"Add Python to PATH\" option during the installation process.</p> </li> <li> <p>Open up a Terminal/Command Prompt (cmd)/Powershell window.</p> </li> <li> <p>Check that Python was properly installed with this command (might need a terminal restart):</p> <pre><code>python --version\n</code></pre> </li> <li> <p>Install the latest version of git following this tutorial.</p> </li> <li> <p>Check that git was properly installed with this command (might need a terminal restart):</p> <pre><code>git --version\n</code></pre> </li> <li> <p>(optional) Install the latest version of Visual Studio Code for GUI git management and Markdown preview.</p> </li> </ol>"},{"location":"contribute/#working-locally","title":"Working locally","text":"<p>In order to work locally:</p> <ol> <li>Create a fork on GitHub.</li> <li>On your local PC navigate to a directory where you want to clone your forked repository and open a Terminal window inside.</li> <li> <p>Clone the forked repository, using this command:</p> <pre><code>git clone https://github.com/user-name/forked-repository-name.git &lt;DIR-PATH&gt;\n</code></pre> <p>Instead of <code>https://github.com/user-name/forked-repository-name.git</code> use your own link which can be found after clicking on the green <code>&lt;&gt; Code</code> button and selecting the <code>HTTPS</code> tab.</p> <p>Replace the <code>&lt;DIR-PATH&gt;</code> with a path to a directory or <code>.</code> if you're inside the directory you want the project files to be cloned into.</p> <p>This will automatically create a remote <code>origin</code> repository pointing to your own fork.</p> </li> <li> <p>Add the remote <code>upstream</code> repository using this command:</p> <pre><code>git remote add upstream https://github.com/Gothic-Modding-Community/gmc.git\n</code></pre> </li> <li> <p>(optional) Create a Virtual Environment and activate it.</p> <p>If you work on multiple Python projects, it might be worthwhile to create a Virtual Environment for each project to have separate library directories with installed modules/plugins.</p> <pre><code>python -m venv venv\n</code></pre> <p>This will create a <code>venv</code> directory inside the current Terminal directory. Please keep that name as it's added to the <code>.gitignore</code> project file.</p> <p>Depending on the system, use one of these commands to activate the virtual environment.</p> <p>Linux / macOS<pre><code>source venv/bin/activate\n</code></pre> Windows Powershell<pre><code>venv\\Scripts\\activate.ps1\n</code></pre> Windows Command Prompt (cmd)<pre><code>venv\\Scripts\\activate.bat\n</code></pre></p> <p>After activation there will be a <code>(venv)</code> indicator near the Terminal prompt.</p> <p>Don't close the Terminal</p> <p>The virtual environment must be activated each time a new Terminal window is opened.</p> </li> <li> <p>Install MkDocs with plugins using this command:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>This will install all dependencies.</p> </li> <li> <p>Fetch the git history from <code>upstream</code> using this command:</p> <pre><code>git fetch upstream\n</code></pre> </li> <li> <p>Checkout a new local branch based on the <code>upstream</code> <code>dev</code> branch:</p> <pre><code>git checkout -b name-of-branch --track upstream/dev\n</code></pre> <p>An appropriate name for a branch is either a feature name or short description of what it changes - for example <code>3ds-articles</code>, <code>fix-typos-for-contribution</code>. They do not have to be elaborate, up-to 4 words suffices.</p> </li> <li> <p>Start a server with MkDocs using this command:</p> <pre><code>mkdocs serve\n</code></pre> <p>Visit the local site with this url <code>http://127.0.0.1:8000/gmc/</code>. Any time you make change to any file, the website will rebuild itself and your browser will auto-refresh.</p> <p>The server may be closed using the <code>Control-C</code> shortcut while in the terminal/console.</p> </li> <li> <p>When you are satisfied with a part of work, add and commit the files using these commands:</p> <pre><code>git add .\ngit commit -m \"add 3 articles about ZenGin\"\n</code></pre> <p>An appropriate commit message should be a sentence describing the changes.</p> </li> <li> <p>When you are finished with the work, push the branch to <code>origin</code> using this command:</p> <pre><code>git push origin name-of-branch\n</code></pre> </li> <li> <p>Create the pull request to the appropriate branch.</p> <p>After pushing your local branch to the remote <code>origin</code>, there will be a link available in the Terminal window. Use it to create the pull request using the pushed branch.</p> </li> <li> <p>Another contribution:</p> <p>Before contributing again, always use this command: <pre><code>git fetch upstream </code></pre> to make sure that you have an up-to-date <code>upstream</code> git history. Follow then from step 8.</p> <pre><code>git status\n</code></pre> <p>This command allows to check, if there are any changes in the project compared to the <code>upstream</code> repository.</p> </li> </ol>"},{"location":"contribute/#build-preferences","title":"Build preferences","text":"<p>While working with the project, it's possible to set various environmental variables to configure it to your own preferences:</p> <ul> <li><code>GMC_DEFAULT_LANG</code> - is a 2-character language identifier (it must be present in the <code>mkdocs.yml</code> file), it sets the default language of the site</li> <li><code>GMC_ONLY_DEFAULT_LANG</code> - <code>True</code> or <code>False</code> value, activates the site build to be only in the default language</li> <li><code>GMC_ENABLE_ON_PUBLISH</code> - <code>True</code> or <code>False</code> value, activates all of the final build procedures, like adding of the last modified date, minifying of the resources etc. </li> </ul> <p>Environmental variables can be set temporarily for the currently open Terminal window:</p> Linux<pre><code>export GMC_DEFAULT_LANG=en export GMC_ONLY_DEFAULT_LANG=True; mkdocs serve\n</code></pre> Windows Powershell<pre><code>$env:GMC_DEFAULT_LANG=\"en\"\n$env:GMC_ONLY_DEFAULT_LANG=\"True\"\nmkdocs serve\n</code></pre> Windows Command Prompt (cmd)<pre><code>set GMC_DEFAULT_LANG=en\nset GMC_ONLY_DEFAULT_LANG=True\nmkdocs serve\n</code></pre>"},{"location":"contribute/#build-performance","title":"Build performance","text":"<p>To speed up the build process during development make sure that only 1 language is built, and consider using the <code>--dirtyreload</code> option:</p> <pre><code>mkdocs serve --dirtyreload\n</code></pre> <p>This will cause only changed <code>.md</code> files to rebuild. However, if you make changes to a template in the <code>overrides</code> directory, no changes will be visible after the rebuild, because template modification requires a full rebuild.</p>"},{"location":"contribute/#submit-a-file","title":"Submit a file","text":"<p>If working with git or Markdown is not viable or possible for you, you can submit files in a Google Docs format on the GMC Discord server and we will format and upload it to the page.</p> <p>Only New English Content</p> <p>This option is limited to new content in English. We can't deal with translations in this manner. For translations send a translated <code>.md</code> file via a feedback channel, if you don't want to work directly with git, nor add the file via the GitHub interface.</p>"},{"location":"contribute/#translations","title":"Translations","text":"<p>To provide multilingual support, our site uses the MkDocs i18n plugin.</p>"},{"location":"contribute/#add-new-language-support","title":"Add new language support","text":"<p>To support a new language it needs to be added:</p> <p>Indentation is important</p> <p>You must preserve the correct amount of indentation, aka spacing between entries.</p> <ol> <li> <p>In the <code>mkdocs.yml</code> configuration, in this example we're adding the <code>xx</code> language:</p> <pre><code>plugins:\n- i18n:\n# ...\nlanguages:\nen:\nname: en - English\nbuild: true\nxx:\nname: xx - Language Name\nbuild: true\n</code></pre> </li> <li> <p>In the <code>overrides/main.html</code> file to add the announcement text for untranslated content:</p> <pre><code>{%\n    set announcement = {\n        \"en\": \"This page has not yet been translated into LANGUAGE, therefore it is displayed in English.\",\n        \"xx\": \"yyy\",\n    }\n%}\n{%\n    set call_to_action = {\n        \"en\": \"Support us and translate!\",\n        \"xx\": \"yyy\",\n    }\n%}\n</code></pre> </li> <li> <p>Visit the official theme site.      Make sure that the theme translation is complete there. If it's not, just follow their contribution guide and come back here, there is no need to wait for the changes in the theme.</p> </li> </ol>"},{"location":"contribute/#add-translated-pages","title":"Add translated pages","text":"<p>Each <code>.md</code> file in the <code>docs</code> directory can have a translated version. To add a translation for a given language create a copy with an added language suffix. For example <code>index.md</code> will become <code>index.xx.md</code> for the <code>xx</code> language based on the settings in the <code>mkdocs.yml</code> file.</p> <p>Each untranslated article has the  button in the upper right corner next to the title. It allows to quickly add the translation via the GitHub interface without the need for local file configuration.</p>"},{"location":"genome/","title":"Genome engine","text":"<p>Genome engine is new engine by Piranha Bytes created for the game Gothic 3 and later used for the Risen and ELEX series of games.</p>"},{"location":"genome/object_persistence/","title":"Object persistence","text":"<p>Please note the following warning about Risen 2, 3 and ELEX 1 and 2</p> <p>The following information only applies to Gothic 3 (2006) and Risen (2009). While newer Genome engine games share the same overall concepts, they have significant implementation differences that warrant their own section.</p> <p>The engine is, due to the nature of the games themselves, required to store and load a vast amount of different types of data from the user's hard-drive. In order to streamline this parsing and/or serialization process, Genome implements an object persistence system using its own built-in runtime type information (RTTI) system.</p> <p>Any class derived from <code>bCObjectBase</code> may declare its own member properties in such a way that when the object is then written into a file using the <code>bCAccessorPropertyObject</code> class, its associated properties will be automatically serialized into the stream by using special preprocessor macros. When the object is read back from the file, the class will be automatically initialized using the stored members.</p> <p>Additionally, classes may overload the <code>Read</code> and <code>Write</code> (<code>OnRead</code> and <code>OnWrite</code> in Risen 1) virtual methods that allow the class to save additional data required during parsing such as paths to other necessary files.</p> <p>As this system is quite flexible, it is used to store most of the game's data, from meshes, animations and textures to level and quest data. This is quite different from ZenGin, as its object persistence system is only used for worlds, saves, output units and parts of compiled meshes.</p>"},{"location":"genome/object_persistence/#file-format","title":"File format","text":""},{"location":"genome/object_persistence/#files","title":"Files","text":"<pre><code>struct bCIOStream\n{\nchar data[];\n};\n</code></pre> <pre><code>struct eCArchiveFile\n{\nchar8_t  magic[8];  // \"GENOMFLE\"\nuint16_t version;   // 0001\nuint32_t offset;\nchar data[];\nuint32_t magic;    // DEADBEEF\nuint8_t  version;  // 01\nuint32_t count;\nfor( Count )\n{\nuint16_t length;\nchar8_t  string[length];  // (ASCII)\n}\n};\n</code></pre>"},{"location":"genome/object_persistence/#bcaccessorpropertyobject","title":"bCAccessorPropertyObject","text":"<pre><code>bCAccessorPropertyObject::Read {\nuint16_t    version;    // 0x0001\nbool        hasPropertyObject;\nif (hasPropertyObject)\n{\nbCPropertyObjectSingleton::ReadObject\n{\nuint16_t    version;    // 0x0001\nbool        isPersistable;    // 0x01 (GETrue)\nbCString    className;\nbCPropertyObjectFactory::ReadObject\n{\nuint16_t    version;        // 0x0001\nbool        isRoot;            // 0x00 (GEFalse)\nuint16_t    classVersion;\nbTPropertyObject&lt;%,%&gt;::Read\n{\nbCPropertyObjectBase::Read\n{\nuint16_t version;    // 0x00C9 (201)\n}\nuint32_t size;\n}\nbTPropertyObject&lt;%,%&gt;::ReadData\n{\nbCPropertyObjectBase::ReadData\n{\nuint16_t version;    // 0x00C9 (201)\nuint32_t count;\nfor (count)\n{\nbCString    name;\nbCString    type;\nuint16_t    version;    // 0x001E (30)\nuint32_t    size;\nuint8_t        value[size];\n}\n}\n%::Read\n{\n// ClassName::OnRead/OnWrite()\n// uint16_t ClassVersion; ...\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"genome/object_persistence/#ecprocessibleelement","title":"eCProcessibleElement","text":"Gothic 3Risen <pre><code>eCProcessibleElement::Load\n{\nuint32_t magic; // 0xD0DEFADE\nbCAccessorPropertyObject::Read\n{\n// Look above for bCAccessorPropertyObject definition\n}\n}\n</code></pre> <pre><code>eCProcessibleElement::Load\n{\nbCAccessorPropertyObject::Read\n{\n// Look above for bCAccessorPropertyObject definition\n}\n}\n</code></pre>"},{"location":"genome/object_persistence/#implementation","title":"Implementation","text":""},{"location":"genome/object_persistence/#a-practical-example","title":"A practical example","text":"<p>Let's propose that we have a class which is declared like so:</p> <pre><code>class gCMyClass : public bCObjectRefBase\n{\npublic:\ngCMyClass()                {}\nvirtual ~gCMyClass()    {}\nvirtual bEResult Write(bCOStream&amp;); // OnWrite for Risen\nvirtual bEResult Read(bCIStream&amp;);  // OnRead for Risen\nprivate:\nDECLARE_PROPERTY(myInt, int);\nint someData;\n};\n</code></pre> <p>The hypothetical class then implements these virtual functions:</p> <pre><code>bEResult gCMyClass::Write(bCOStream&amp; file)\n{\nfile &lt;&lt; someData;\nreturn bEResult_Ok;\n}\nbEResult gCMyClass::Read(bCIStream&amp; file)\n{\nfile &gt;&gt; someData;\nreturn bEResult_Ok;\n}\n</code></pre> <p>We then initialize the class in the following way:</p> <pre><code>gCMyClass object;\nobject.myInt = 1;\nobject.someData = 1;\n</code></pre> <p>If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII stream, the result would look like this:</p> <pre><code>\n</code></pre>"},{"location":"genome/tools/","title":"Tools","text":"<p>Piranha Bytes did not release a modkit for their Genome engine, but the modding community has released a wide range of tools to work with the game's files and the engine itself.</p> <p>Info</p> <p>This page is under construction, for now, only handful of links are present.</p>"},{"location":"genome/tools/#gothic-3-sdk","title":"Gothic 3 SDK","text":"<p>Georgeto, inspired by NiceDE's Risen SDK, has created an SDK for Gothic 3. It can be used to manipulate the engine in the similar way Union is able to manipulate ZenGin. GitHub repository</p>"},{"location":"zengin/","title":"ZenGin","text":"<p>The game engine ZenGin is used by Gothic 1 and 2. This section contains the documentation of the various aspects of ZenGin modding.</p>"},{"location":"zengin/meshes/","title":"Meshes","text":"<p>Everything about 3D models in ZenGin.</p>"},{"location":"zengin/music/","title":"Music","text":"<p>How to get your custom music.</p>"},{"location":"zengin/sound/","title":"Sound","text":"<p>Sound effects and dialogues are sound files playing during the game.</p> <p>This is Gothic VDFS. It is a tool that allows you to pack and unpack files in .VDF and .MOD format.</p> <p></p> <p>Let us start with unpacking \"Sound\" file:</p> <ol> <li>In the \"(Viewer)\" tab, in the \"Filename\", go to your Gothic or Gothic II/Data folder and choose \"Sound.VDF\".</li> <li>Create a folder on your desktop or any other easily accessible place on your computer. Name it however you want.</li> <li>Go to \"Root path\" and choose the folder you just created.</li> <li>Press \"Extract volume\" if you want to unpack all sound files.</li> </ol> <p>The chosen file should be unpacking right now. </p> <p>Here are the files we just extracted: </p> <p>It can oftentimes be tricky to find the sound you are looking for, but we will leave that for later. Let's just see how can we change a sound file in the game now.</p> <ol> <li>Get yourself any short sound file.</li> <li>In order for the sound to work in the game, it needs to be in mono .wav format. A lot of programs let you convert a file such as Audacity, so do just that;</li> <li>Rename your converted file into \"INV_CHANGE.WAV\" and replace it in SFX folder you just extracted;</li> <li>Go back to Gothic VDFS, go to (Builder) tab;</li> <li>In \"Filename\" you choose how do you want your file to be called and its location. I recommend creating separate folder and putting it there. You can also name the file however you want, as long as it has higher time stamp (more on that later) than original Sounds file. To create it as .VDF file, choose \"All file\" in the \"Save file as\" and call it \"Sounds.VDF\";</li> <li>In \"Root path\" go to and choose \"_WORK\" folder;</li> <li>In the field just below \"Comment\", add a * character and then click on the + next to it;</li> <li>Press \"Build\", and if you did everything right, the folder is being packed back into .VDF file;</li> </ol> <p>That's how a successful process looks like: </p> <p>Now get the file you just created, and put it in your Gothic/Data folder replacing the old one. The file we just replaced changes the sound in main menu and the inventory. If you can hear it, congratulations, you did it!</p>"},{"location":"zengin/textures/","title":"Textures","text":"<p>Textures are pictures that get projected onto a 3D models and on a 2D user interface in the game. We will discuss how to work with textures in this section.</p>"},{"location":"zengin/video/","title":"Video","text":"<p>To get a video cutscene, intro or outro into the game, the video needs to be in a proper format - BINK video format <code>.bik</code>.</p>"},{"location":"zengin/video/#editing-the-video","title":"Editing the video","text":"<p>The video you recorded and want to use has to be edited. My go-to editor for this is kdenlive. It works very well, it is free and open source, and it supports BINK video as an input, which is great if you want to include subtitles in the video.</p> <p>My version of kdenlive does not know how to export video straight to <code>.bik</code> so I just export my video to <code>.mp4</code> and then convert it with RAD Video Tools.</p>"},{"location":"zengin/video/#rad-video-tools","title":"RAD Video Tools","text":"<p>RAD Video Tools is a tool for converting other video formats to BINK <code>.bik</code> that Gothic can use.</p> <p>Warning</p> <p>Gothic 1 bink implementation has some problems as you have to set the audio compression to 104 and above in RAD tools to get video to work in Gothic 1.</p> <p>NicoDE's comment: </p> <p>Add 100 to the audio compression level when encoding videos, e.g. 104 for level 4 with old sound format (should be mentioned in the RAD Video Tools documentation) for G1 without updated Miles libraries.  </p> <p>Note</p> <p>Newest Union (1.0m at the time of writing) has a new patch for BINK video playback. The issue with sound should be fixed.</p>"},{"location":"zengin/worlds/","title":"Worlds","text":"<p>Worlds, saved as <code>.ZEN</code> files in ZenGin, are archives that contain the world mesh (model), BSP tree and the information of all objects in the world.</p> <p>Spacer is used to create these <code>.ZEN</code> files. There are other world editors.</p>"},{"location":"zengin/anims/","title":"Animation","text":""},{"location":"zengin/anims/#animations-in-zengin","title":"Animations in ZenGin","text":"<p>Animations are (apart from maybe advanced programming work using Ikarus or Union) one of the most advanced modding techniques, since you not only must understand the way they work, but also know how to write the animation script and understand the whole scheme selection system, naming convention and of course know how to animate (that is my biggest problem :D). To get a new animation into ZenGin (the Gothic engine) is not difficult per se, I would describe it as tedious.</p> <p>Luckily, there are tools to help us to achieve our goal - get a new animation to be used by the engine, and in effect, to be used and seen in the game.</p> <p>To describe the whole process, I constructed this small tutorial, to help other people to get animations working and to spare them many hours of searching the excellent forum posts, that describe parts of the process. __</p> <p>Excluding advanced programming work with Ikarus or Union, animations are arguably the most advanced modding discipline of ZenGin engine. Its difficulty stems for the fact that you not only have to understand the general concept, but also learn how to write the animation scripts and understand the whole scheme selection system, including naming conventions and, most important for last - actually know how to animate. Adding new animations into ZenGin is more tedious than actually difficult.</p> <p>There are tool to help with this endeavor - to get a new animation implemented in the engine, and seeing its effects in game. Following tutorial has been constructed to help others to get their animations working without having to scour old forum posts for hours.</p>"},{"location":"zengin/anims/#prerequisites---tools--materials","title":"Prerequisites - Tools &amp; Materials","text":"<ol> <li>Gothic Mod Development Kit (MDK)<ul> <li>Gothic 1 MDK - link</li> <li>Gothic 2 MDK - link</li> </ul> </li> <li>Blender</li> <li>Kerrax's Import Export plugin - follow the installation instructions to install the plugin, make sure to set up the texture paths too</li> <li>Tool for decompiling animations GothicSourcer, or use phoenix or write your own using ZenLib</li> </ol>"},{"location":"zengin/anims/#the-workflow","title":"The workflow","text":"<p>This is the basic step-by-step workflow on how to get the animation into the game.</p> <ol> <li>Load the actor (character or object) into your 3D software</li> <li>Create your animation</li> <li>Export the animation as an <code>.asc</code> file</li> <li>Write the MDS file</li> <li>Run the game to compile your animations</li> <li>Test your animations in-game using a Daedalus script or a console command</li> </ol> <p>Sounds simple enough, except there is a lot missing. Even though the steps start with loading the actor into blender, understanding the system of animations to get high quality assets into your mod is more important.</p>"},{"location":"zengin/anims/#animation-types","title":"Animation \"types\"","text":"<p>There are two main types of animations - <code>skeletal</code> and <code>morphmesh</code> animations. Character body animations are skeletal, and we animate the skeleton and the entire model (skin) moves around it. Morph mesh animation is, on the other hand, used for facial animations such as eating, blinking or talking and for animated meshes like wave water ferns or fish in Khorinis' harbor.</p> <p>This guide focuses on skeletal animations. There are few different ones, all of which will have their own demonstration in the future. Categories are:</p> <ol> <li>Standalone animation - waving, bowing, eating</li> <li>MOBSI animations - bed, alchemy table, anvil</li> <li>Item animations - sweeping the floor with a broomstick, using the horn, playing the lute</li> <li>Mandatory animations - running, walking, sneaking</li> <li>Combined/interpolated animations - picking stuff up, aiming with a bow/crossbow</li> </ol> <p>All of these animations are defined in an MDS file which will be talked about in the next sections.</p>"},{"location":"zengin/anims/events/","title":"EventBlocks","text":""},{"location":"zengin/anims/events/#animation-event-blocks","title":"Animation event blocks","text":"<p>We often need to perform some other actions together with our animation, such as playing a sound effect, inserting item into NPC's hand or changing an item instance into a different one, like turning a raw steel into hot raw steel.</p> <p>Example: <pre><code>ani (\"s_RunL\" 1 \"s_RunL\" 0.0 0.1 M. \"Hum_RunLoop_M01.asc\" F 12 31)\n{\n*eventSFXGrnd    (12    \"Run\")\n*eventSFXGrnd    (21    \"Run\")\n}\n</code></pre></p> <p>The example shows the animation and its event block. We place these events into a block surrounded by curly brackets.</p> <p>There are many events to choose from to choose from. Here are some examples: Sound effects <pre><code>*eventSFXGrnd (12 \"Run\")\n*eventSFX     (10 \"Swim\")\n</code></pre> Particle effects <pre><code>*eventPFX     (12       \"ZMODELLANDDUST\"   \"Bip01\")\n*eventPFX     (35   1    \"BUBBLES\"          \"BIP01 HEAD\"    ATTACH)\n*eventPFXStop (45   1)\n</code></pre> Morph mesh animations</p> <p>\u26a0 Heads are animated using morph meshes and whilst this feature is almost never used in the original game, Chronicles of Myrtana uses it plenty. I intend to dedicate separate section to <code>morphMesh</code> animation in the future.</p> <p><pre><code>*eventMMStartAni (14    \"T_HURT\")\n</code></pre> Event tags <pre><code>*eventTag (5 \"DEF_FIGHTMODE\"    \"\")\n*eventTag (0 \"DEF_HIT_LIMB\"  \"ZS_RIGHTHAND\")\n*eventTag (0 \"DEF_OPT_FRAME\" \"6\")\n*eventTag (0 \"DEF_HIT_END\"   \"29\")\n*eventTag (0 \"DEF_WINDOW\"    \"18 35\")\n*eventTa  (4 \"DEF_INSERT_ITEM\"   \"ZS_LEFTHAND\")\n*eventTa  (4 \"DEF_CREATE_ITEM\"   \"ZS_RIGHTHAND\" \"ItMw_1H_Sledgehammer_01\")\n*eventTa  (9 \"DEF_EXCHANGE_ITEM\" \"ZS_LEFTHAND\"  \"ItMiSwordbladehot\")\n*eventTa  (4 \"DEF_REMOVE_ITEM\")\n</code></pre></p>"},{"location":"zengin/anims/mds/","title":"MDS - model animation script","text":"<p>Tip</p> <p>The MDS syntax is very simple and scripts can be edited in any text editor. It is, however, easier to work in an editor with a proper syntax highlighting. Daedalus Language Server's dev branch already merged the MDS grammar for syntax highlighting, we can expect it in the next release.</p> <p>Model animation script is a file describing what skeleton should be used, what body meshes work with this set of animations and how should the animations be named, how fast they run, what animation is supposed to start after the current one is finished and much more. These files are located in <code>Gothic\\_work\\DATA\\Anims\\</code> directory.</p> <p>Whilst the code seems long and terrifying, it is in fact rather simple, and this guide will try to explain it whole.</p> <p>Don't forget to use the search</p> <p>If you search this file for <code>t_Yes</code>, you will get an example of the first type of animation - \"standalone\"</p> <p>To play the animation in game you use this console command <code>play ani t_yes</code>.</p> <p></p>"},{"location":"zengin/anims/mds/#syntax-and-keywords","title":"Syntax and keywords","text":"<p>Let us get a quick look at the naming convention to get a basic idea what is going on before we start.</p> <p>The first letter indicates a type of animation (transition - <code>t_</code> - or state - <code>s_</code>). Then depending on the animation type we have:</p> <p>Transition animation <pre><code>t_Run_2_Sneak\n</code></pre> Transition animation from the run animation to the sneak animation. <pre><code>t_BSANVIL_Stand_2_S0\n</code></pre> Transition animation for the blacksmith's anvil from standing to state 0.</p> <p>State animation <pre><code>s_Run\n</code></pre> State animation for the looping animation. <pre><code>s_BSANVIL_S0\n</code></pre> State animation for the blacksmith's anvil and its first state.</p>"},{"location":"zengin/anims/mds/#ani","title":"ani","text":"<p>This is the main command you will be using while defining new animations.</p> <p>Example: <pre><code>ani    (\"t_Yes\" 2 \"\" 0.1 0.1 M. \"Hum_Yes_M01.asc\" F 1 44)\n</code></pre> Syntax: <pre><code>ani (ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ASC_NAME ANI_DIR START_FRAME END_FRAME)\n</code></pre> <code>ani</code> - is a keyword, we are defining new animation</p> <p>Let's describe all the parameters</p> <p><code>ANI_NAME</code>    - animation name, we use it in Daedalus as animation identifier</p> <p>There is a naming convention, that is recommended and sometimes required to be used.</p> <ul> <li>prefix <code>t_</code> - transition animations</li> <li>prefix <code>s_</code> - state animations - they usually run in a loop</li> <li>prefix <code>c_</code> - animations used for animation combining/interpolation</li> </ul> <p><code>LAYER</code>       - layer number for multi-layer animations</p> <p><code>NEXT_ANI</code>    - name of the next animations</p> <p><code>BLEND_IN</code>    - time in seconds describing animation blending at the start</p> <p>If we set it to 0.5, it takes 0.5 seconds for this animation to take full effect. At 0.0 s the previous animation has full effect on the bones of the skeleton, at 0.1 s it is influenced by 20% by this animation and at 0.5s it is completely influenced by this animation and the previous one has no effect.</p> <p><code>BLEND_OUT</code>   - time in seconds describing animation blending at the end</p> <p><code>FLAGS</code>       - flags, that describe animation behavior</p> <ul> <li>M - specifies a movement animation, the animation of the model translates into a changed position in the game world</li> <li>R - the same as M but for rotation</li> <li>E - this flag makes this animation run only, if the animation in the same layer are finished, this is used in the movement animations. The animation <code>s_walk</code> (walking loop animation) runs, when the player is walking,when he stops the transition animation to standing state is played <code>t_walk_2_stand</code>. This animation uses the E flag to wait for the walk cycle animation to finish, to smoothly transition into the standing state.</li> <li>F - the engine ignores height coordinate - doesn't keep the model \"glued\" to the ground (falling/flying animation)</li> <li>I - specifies idle animation - breathing, standing with a drawn weapon and moving the weapon</li> </ul> <p><code>ASC_NAME</code>    - name of the source file exported from Blender</p> <p><code>ANI_DIR</code>     - direction of the animation</p> <ul> <li>F - forward</li> <li>R - reverse</li> </ul> <p><code>START_FRAME</code> - on what frame from the source file the animation starts</p> <p><code>END_FRAME</code>   - on what frame from the source file the animation ends</p>"},{"location":"zengin/anims/mds/#anialias","title":"aniAlias","text":"<p>Generally considered as one of the most useful commands, <code>aniAlias</code> is used to create an alias (hard link for UNIX users) for an already defined animation.</p> <p>Example: <pre><code>aniAlias (\"t_Sneak_2_Run\" 1 \"s_Run\" 0.0    0.1    M. \"t_Run_2_Sneak\" R)\n</code></pre> Syntax: <pre><code>aniAlias (ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ALIAS_NAME ANI_DIR)\n</code></pre></p> <p><code>ANI_NAME</code>   - name of the new animation</p> <p><code>LAYER</code>      - layer the animation is on</p> <p><code>NEXT_ANI</code>   - name of the next animations</p> <p><code>BLEND_IN</code>   - time in seconds describing animation blending at the start</p> <p><code>BLEND_OUT</code>  - time in seconds describing animation blending at the end</p> <p><code>FLAGS</code>      - flags, that describe animation behavior</p> <p><code>ALIAS_NAME</code> - name of the animation we want to use as a source for the alias</p> <p><code>ANI_DIR</code>    - direction of the animation</p> <p>If we look for the animation in the example we can see that there is a related one just one line above <pre><code>ani            (\"t_Run_2_Sneak\" 1 \"s_Sneak\" 0.1 0.0 M. \"Hum_Sneak_M01.asc\"     F 0 10)\naniAlias    (\"t_Sneak_2_Run\" 1 \"s_Run\"      0.0 0.1 M. \"t_Run_2_Sneak\"      R)\n</code></pre> In this example we are defining <code>t_Sneak_2_Run</code> animation and we are specifying that the animation after this one is finished will be <code>s_Run</code> and that it is being made by reversing animation <code>t_Run_2_Sneak</code> by specifying the <code>R</code> flag.</p>"},{"location":"zengin/anims/mds/#aniblend","title":"aniBlend","text":"<p>AniBlend is used to define animations that are a result of blending of two animations. This animation is not animated by hand, but it is dynamically generated by the engine during run-time.</p> <p>Example <pre><code>aniBlend (\"t_RunR_2_Run\" \"s_Run\" 0.2 0.2)\n</code></pre> Syntax: <pre><code>aniBlend (ANI_NAME NEXT_ANI BLEND_IN BLEND_OUT)\n</code></pre></p> <p><code>ANI_NAME</code>   - name of the new animation</p> <p><code>NEXT_ANI</code>   - name of the next animations</p> <p><code>BLEND_IN</code>   - time in seconds describing animation blending at the start</p> <p><code>BLEND_OUT</code>  - time in seconds describing animation blending at the end</p>"},{"location":"zengin/anims/mds/#anisync","title":"aniSync","text":"<p>Not used in the game.</p>"},{"location":"zengin/anims/mds/#anibatch","title":"aniBatch","text":"<p>Not used in the game.</p>"},{"location":"zengin/anims/mds/#animation-state-machine","title":"Animation state machine","text":"<p>More complex animations such as MOBSI animations form a state machine - an animation set.</p> <p>MDS script for the big chest<pre><code>Model (\"CHESTBIG_OCCRATELARGE\")\n{\nmeshAndTree (\"CHESTBIG_OCCRATELARGE.asc\")\naniEnum\n{\n// Closed chest\nani         (\"s_S0\"                 1   \"s_S0\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"  F   20  20)\n// Opening the chest \nani         (\"t_S0_2_S1\"            1   \"s_S1\"  0.0 0.0 M.  \"CHESTBIG_USE.ASC\"  F   50  79)\n{\n*eventSFX   (50 \"chest_try\")\n*eventSFX   (55 \"chest_open\")\n}\n// Opened chest\nani         (\"s_S1\"                 1   \"s_S1\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"  F   80  80)\n// Closing the chest\nani         (\"t_S1_2_S0\"            1   \"s_S0\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"  R   50  79)\n{\n*eventSFX   (78 \"chest_close\")\n}\n// Pick lock broken\nani         (\"t_S0_Try\"             1   \"s_S0\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"          F   96  124)\n{\n*eventSFX   (100    \"chest_try\")\n*eventSFX   (115    \"Hammer\")\n}\n}\n}\n</code></pre> <pre><code>stateDiagram-v2\n    s_S0      : Closed chest\n    t_S0_2_S1 : Opening the chest\n    s_S1      : Opened chest\n    t_S1_2_S0 : Closing the chest\n    t_S0_Try  : Pick lock broken\n    [*] --&gt; s_S0\n    s_S0 --&gt; s_S0\n\n    s_S0 --&gt; t_S0_2_S1\n    t_S0_2_S1 --&gt; s_S1\n    s_S1 --&gt; s_S1\n\n    s_S1 --&gt; t_S1_2_S0\n    t_S1_2_S0 --&gt; s_S0\n\n    s_S0 --&gt; t_S0_Try\n    t_S0_Try --&gt; s_S0</code></pre></p>"},{"location":"zengin/anims/standalone_ani/","title":"Standalone animation","text":"<p>Acknowledgment</p> <p>This tutorial would not be possible without the ZenGin documentation available in the mod-kit. Further credits also go to Mark56 who helped me understand animations in the first place, Fawkes and his request for me to do some animations for his excellent mod - Replay Mod, and last but not least Flosha from the Phoenix team who was the one for whom I offered to write this tutorial to help with the development of the Phoenix project.</p>"},{"location":"zengin/anims/standalone_ani/#standalone-animation","title":"Standalone animation","text":"<p>Let us start with the easiest animation - a very simple gesturing animation.</p> <p>Info</p> <p>You can find some of the videos that are mentioned in the text below in this play-list.</p> <p>Firstly we have to have the animation source files ready. Best way to decompile them is using Gothic Sourcer. In GothicSourcer you choose Tools &gt; Decompiler models &gt; Dynamic (MDS or MSB) and choose an MDS file of your choice - <code>Humans.mds</code> in our case and then click the decompile button.</p>"},{"location":"zengin/anims/standalone_ani/#animating","title":"Animating","text":"<p>Open Blender, File &gt; Import &gt; Kerrax ASCII model (.asc), navigate to the folder with your decompiled animation files and select <code>HUM_BODY_NAKED0.ASC</code>. This file contains the skeleton and skin model for human NPCs.</p> <p>What bone hierarchy is this model using?</p> <p>If you open the <code>.mds</code> file, you can see a command <code>meshAndTree</code> that specifies what model contains the skeleton. And there lies our answer:</p> <pre><code>Model (\"HuS\")\n{\nmeshAndTree (\"Hum_Body_Naked0.ASC\" DONT_USE_MESH)\n</code></pre> <p>A windows pops up and you can read some interesting information about the model you are about to import. We are interested in the fact that Completely replace current scene is ticked, we want to use Armature modifier, and we also want to Try to connect bones and Use sample meshes from folder. You should provide a path to a directory with the sample meshes - these are meshes for items, that usually go into slot bones. Lastly, the space transformation scale should be set to 0.01. This is because ZenGin works with centimeter units and one unit in Blender is a meter.</p> <p>Click import and wait for the magic to happen.</p> <p></p> <p>This video shows a freshly imported model with all default meshes.</p> <p>Note</p> <p>If we now want to play (or edit) existing animation, we can now load it on top of this. Just as before File &gt; Import &gt; Kerrax ASCII model (.asc) and select different animation file (or armor file), for example <code>Hum_SmokeHerb_Layer_M01.asc</code> for an animation file.  </p> <p></p> <p>Gothic characters are modular and you can change their heads on the fly, even during gameplay as seen in this amazing video from my dear friend and colleague Fawkes - Head changing. Let's add a head so that we can see how the whole body will behave while we are animating. File &gt; Import &gt; Kerrax ASCII model (.asc), navigate to your head model. You will have to decompile it like we did with the body itself. We will import <code>HUM_HEAD_PONY.ASC</code>. Please make sure to select the target bone for importing Bip01 Head, this will attach the head to the proper bone, just like the engine does it.</p> <p></p> <p>Now we have everything ready to start animating. The video shows the DopeSheet a nice way to edit keyframes.</p> <p>DopeSheet</p> <p>Blender's dope sheet can be used to copy entire sets of keyframes. It is useful if we want to create a looping animation.</p> <p>We can import an animation into Blender as a base.</p> <p>Tip</p> <p>If you don't know the name of the animation, just go into the game and make your character perform the animation you want. While in MARVIN mode, you can press <code>G</code> and the animation information together with other info will be displayed right on the screen</p> <p></p> <p>In this video we can see that the idle standing animation is <code>s_run</code>. We want to make an animation that is going to start from this idle animation, so we will import it into blender. We find it by looking into the <code>.mds</code> file, look for <code>s_run</code> name and get the name of the file. <pre><code>ani    (\"s_Run\" 1 \"s_Run\" 0.1 0.1 MI \"Hum_RunAmbient_M01.asc\" F 1 50)  </code></pre> As we can see, we have to import the <code>Hum_RunAmbient_M01.asc</code> file.</p> <p>Next goes the first trick. Since we want our animation to end exactly, as it started - ether because we want the hero to continue his standing animation, or we want to make a looping animation, we somehow have to copy the pose. We use the DopeSheet screen, to delete all keyframes and then copy the keyframe set from keyframe number 0 and drag it somewhere to the end of the timeline.</p> <p></p> <p>Once the animation is done, we have to export it into an <code>asc</code> format again, File &gt; Export &gt; Kerrax ASCII model (.asc) and then save it to <code>_work\\data\\Anims\\asc\\</code> so the engine can see it and convert it. There are many options here that we will explore later, but we have tick Export animation and pick bones that we want to export - this is useful for animations that are played on different layers (dialogue gestures, scratching head, scratching a shoulder,...).</p>"},{"location":"zengin/anims/standalone_ani/#animation-script","title":"Animation script","text":"<p>Now that we have exported the animation, we now have to define it in <code>Humans.mds</code>.</p> <p>Open the file, scroll to the end and define a new animation.</p> <p>Attention</p> <p>All <code>ani</code> code has to be between the curly brackets, this means you have to insert it before the last two closing curly brackets <code>} }</code>.</p> <p>Example: <pre><code>ani (\"t_backpain\" 1 \"\" 0.0 0.0 M. \"Hum_back.ASC\" F 0 121)  </code></pre></p> <p>Save the <code>Humans.mds</code> file and try it in game. Nothing happens! The reason is that the <code>mds</code> has been already compiled, and we have to recompile it. The easiest is to go to <code>Anims\\_compiled</code> and delete <code>HUMANS.MSB</code>. Run the game and try to play the animation again (<code>play ani t_backpain</code> in MARVIN console) and now everything should work.</p> <p></p> <p>Amazing, now you have your first animation in the game. And you can use it to do some fun stuff, like in dialogues using the <code>AI_PlayAni</code> function.</p>"},{"location":"zengin/anims/standalone_ani/#example-dialogue","title":"Example dialogue","text":"<pre><code>instance DIA_Xardas_Back (C_INFO)\n{\nnpc         = NONE_100_Xardas;\nnr          = 11;\ncondition   = DIA_Xardas_Back_Condition;\ninformation = DIA_Xardas_Back_Info;\npermanent   = TRUE;\ndescription = \"What's wrong?\";\n};\nfunc int DIA_Xardas_Back_Condition () {\nreturn TRUE;\n};\nfunc void DIA_Xardas_Back_Info () {\nAI_Output (self, hero, \"DIA_Xardas_MOB_14_00\"); // My back hurts so much.\n// This is our animation!!!!!\nAI_PlayAni(self, \"T_BACKPAIN\"); AI_Output (self, hero, \"DIA_Xardas_MOB_14_01\"); // How do YOU feel?\nAI_Output (hero, self, \"DIA_Xardas_MOB_14_02\"); // My back is fine.\nAI_StopProcessInfos(self);\n};\n</code></pre>"},{"location":"zengin/general_info/directory_structure/","title":"ZenGin directory structure","text":"<p>Modding is all about changing the game files. To achieve that, we have to know the directory (folder) structure of a Gothic game.</p> <pre><code>\u251c\u2500\u2500 Data\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 $Templates$\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 modvdf\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Plugins\n\u251c\u2500\u2500 Miles\n\u251c\u2500\u2500 Saves\n\u251c\u2500\u2500 System\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Autorun\n\u2514\u2500\u2500 _work\n    \u2514\u2500\u2500 DATA\n        \u251c\u2500\u2500 Anims\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 _Compiled\n        \u251c\u2500\u2500 Meshes\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 _Compiled\n        \u251c\u2500\u2500 Music\n        \u251c\u2500\u2500 Presets\n        \u251c\u2500\u2500 Scripts\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 _compiled\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 content\n        \u2502\u00a0\u00a0     \u2514\u2500\u2500 CUTSCENE\n        \u251c\u2500\u2500 Sound\n        \u251c\u2500\u2500 Textures\n        \u251c\u2500\u2500 Video\n        \u2514\u2500\u2500 Worlds\n</code></pre>"},{"location":"zengin/general_info/directory_structure/#data","title":"<code>Data</code>","text":"<p>Data directory contains <code>.vdf</code> volumes of the game. These contain <code>anims.vdf</code> - animations, <code>speech.vdf</code> - dubbing, <code>worlds.vdf</code> - world ZEN files.</p>"},{"location":"zengin/general_info/directory_structure/#saves","title":"<code>Saves</code>","text":"<p>Contains saved games.</p>"},{"location":"zengin/general_info/directory_structure/#system","title":"<code>System</code>","text":"<p>The system directory contains the game executable, <code>GothicStarter.exe</code>, <code>GothicStarter_mod.exe</code>, configuration <code>.ini</code> files, mod <code>.ini</code> files and mod icons and description <code>.rtf</code> files.</p> <p><code>system/Autorun</code> is a Union specific directory, it serves as a default search directory for Daedalus injection scripts with zParserExtender and Union plugins.</p>"},{"location":"zengin/general_info/directory_structure/#_workdata","title":"<code>_work/DATA</code>","text":"<p>This is where the magic happens:</p> <ul> <li><code>Anims</code> - contains animations and animated models.<ul> <li><code>_compiled</code> - contains compiled animations.</li> </ul> </li> <li><code>Meshes</code> - contains meshes source and compiled files.<ul> <li><code>_compiled</code> - contains compiled meshes.</li> </ul> </li> <li><code>Music</code> - contains music files.</li> <li><code>Presets</code> - contains basic presets.</li> <li><code>Scripts</code><ul> <li><code>_compiled</code> - contains compiled scripts - <code>.dat</code> files.</li> <li><code>Content</code> - contains scripts that make up the content of the game.</li> <li><code>System</code> - contains scripts that make up the menu.</li> </ul> </li> <li><code>Sound</code> - contains sound effects <code>.wav</code> or <code>.ogg</code> format (Union only).</li> <li><code>Video</code> - contains videos in <code>.bik</code> format.</li> </ul>"},{"location":"zengin/general_info/object_persistence/","title":"Object persistence","text":"<p>In order to simplify the process of loading and saving data of various types to and from the user's hard-drive, ZenGin implements a simple object persistence system using the <code>zCArchiver</code> class and its derivatives that allow the individual engine classes to implement a routine specifying which data should be saved or loaded from disk and in which manner.</p> <p>An object that is derived from the <code>zCObject</code> class may overload the <code>Archive</code> and <code>Unarchive</code> virtual methods. The class may then call on an interface provided by the <code>zCArchiver</code> class within these methods which allows it to directly read from or write to a stream using several modes. Those are ASCII and BinSafe by default. There are, however, more options, as is explained below.</p>"},{"location":"zengin/general_info/object_persistence/#archive-format","title":"Archive format","text":"<p>In order to better understand how this process works, it would be best to look at an example of a .ZEN file containing an instance of an <code>oCWorld</code> object.</p>"},{"location":"zengin/general_info/object_persistence/#header","title":"Header","text":"<p>When you open up a ZenGin archive, you will see the following at the start of the file:</p> <pre><code>ZenGin Archive\nver 1\nzCArchiverGeneric\nASCII\nsaveGame 0\ndate 7.1.2001 23:9:19\nuser roeske\nEND\nobjects 2594     \nEND\n</code></pre> <p>Let's look at each of these properties and what they mean:</p> <p><code>ZenGin Archive</code></p> <p>This simply specifies that the following data is an <code>zCArchiver</code> archive.</p> <p><code>ver 1</code></p> <p>Version specification. Can be either <code>0</code> or <code>1</code>. Both Gothic 1 and 2 are already on version 1, although version 0 archives can also be occasionally found.</p> <p><code>zCArchiverGeneric</code></p> <p>Specifies which derived <code>zCArchiver</code> class should be used to read this archive. Accepted values are <code>zCArchiverGeneric</code> for ASCII and Binary archives, and <code>zCArchiverBinSafe</code> for BinSafe archives. More info below. This property might not be present in older archives.</p> <p><code>ASCII</code></p> <p>This is the most important part of the header as it specifies in which format should the data be stored. There are 4 different modes:</p> <ul> <li>ASCII - The simplest one. It stores data in human-readable ASCII notation (not unlike JSON for example). This is usually used when saving data during development and/or testing, while the final version of said data will most likely be stored as BIN_SAFE.</li> <li>ASCII_PROPS - Same as ASCII except with more additional data that the developer can specify for visual clarity. In practice, it is not used anywhere and mostly serves only to prettify debug info (try typing <code>ZWORLD VOBPROPS</code> in the console and look in zSpy ;) ).</li> <li>BINARY - Binary representation of the class instance, which mostly copies the data 1:1 into/from the stream. In practice, this format is only used to store savefiles (.SAV).</li> <li>BIN_SAFE - BinSafe, short for Binary Safe, is an extended version of Binary which stores type information along with the data itself. This is meant to make error checking for invalid data easier. There are other changes which are explained below. Most, if not all world files (.ZEN), are stored in this format.</li> </ul> <p><code>saveGame 0</code></p> <p>Specifies if this archive is a savefile. This property might not be present in older archives.</p> <p><code>date 7.1.2001 23:9:19</code></p> <p>The date at which this archive was created.</p> <p><code>user roeske</code></p> <p>The user which created the archive. This property might not be present in older archives.</p> <p><code>END</code></p> <p>Tells the parses that this is the end of the header.</p> <p>We may additionally find a property called <code>csum</code> in version 0 archives which stores the checksum of the whole archive. This property is, however, unused and equals <code>00000000</code> by default.</p> <p>In order to correctly read the archive's header across varying engine versions, one should not count on the properties always being in the same order or even being there at all.</p> <p>If the archive utilizes <code>zCArchiverGeneric</code> then this header will also be followed by a short section specifying the number of object instances in this archive. This value will be used to initialize the objectList, which is an array of pointers where the addresses of loaded objects will be stored for later referencing. This property would be directly part of the main header in older versions.</p> <pre><code>objects 2594 END  \n</code></pre> <p>If the archive is created using <code>zCArchiverBinSafe</code>, this data will be stored in the following binary structure:</p> <pre><code>struct BinSafeArchiveHeader  {  uint32_t version;     // Always equals 2 uint32_t objectCount;  // Serves the same function as \"objects n\" uint32_t chunkPos;    // Offset to chunk hash table};\n};  </code></pre>"},{"location":"zengin/general_info/object_persistence/#contents","title":"Contents","text":"<p>Looking further into the archive, we see what appears to be a nested structure.</p> <pre><code>[% oCWorld:zCWorld 64513 0]\n    [VobTree % 0 0]\n        childs0=int:1\n        [% zCVobLevelCompo:zCVob 12289 1]\n            pack=int:0\n            presetName=string:\n            bbox3DWS=rawFloat:-71919.9609 -13091.8232 -59900 108999.992 20014.0352 67399.9922 \n            trafoOSToWSRot=raw:0000803f0000000000000000000000000000803f0000000000000000000000000000803f\n            trafoOSToWSPos=vec3:0 0 0\n            vobName=string:LEVEL-VOB\n            visual=string:SURFACE.3DS\n            showVisual=bool:0\n            visualCamAlign=enum:0\n            cdStatic=bool:1\n            cdDyn=bool:0\n            staticVob=bool:0\n            dynShadow=enum:0\n            [visual zCMesh 0 2]\n            []\n            [ai % 0 0]\n            []\n        []\n        ...\n</code></pre> <p>We primarily differentiate between chunks and properties within ZenGin archives:  </p>"},{"location":"zengin/general_info/object_persistence/#chunks","title":"Chunks","text":"<p>A chunk is a structure that groups properties together. For most of the time, a chunk represents a class instance. This is, however, not always true as classes may arbitrarily create chunks as is needed. For example, the sample above contains a chunk called <code>VobTree</code>, which does not represent a class instance, but only serves to make the reading of the archive easier.  </p> <p>While in ASCII mode, the start of a chunk is represented using square brackets.  </p> <p><code>[% oCWorld:zCWorld 64513 0]</code> </p> <p>There are 4 pieces of data separated by spaces inside the start of each chunk, which are:  </p> <ul> <li>Object name - The name of the chunk to use while reading. If the chunk has no name, then it will be simply equal to <code>%</code>.  </li> <li>Class name - The name of the class which this chunk represents. Class names are stored with their full inheritance hierarchy (e.g. <code>oCMobLadder:oCMobInter:oCMOB:zCVob</code>). In case the chunk is not an object, but an arbitrary chunk, then this field will be equal to <code>%</code> (<code>%</code> can also mean that this chunk is a nullptr). In some cases you may encounter the symbol <code>\u00a7</code> instead. This means that the object already exists and that the parser should look for it in the objectList using the object index. Using this mechanism, a single instance can be referenced multiple times without worrying about duplicity.  </li> <li>Class version - Used to ensure that the data being read is compatible with the current game/engine version, so that there are no mismatches in the data pattern. This value is different for every class and varies between game versions.  </li> <li>Object index - An index into the objectList under which this object will be stored. If the class name is equal to <code>\u00a7</code>, then this value will be used to retrieve an existing instance from the objectList.  </li> </ul> <p>If this is a Binary archive, the same data will be stored in the following binary structure:  </p> <pre><code>struct BinaryObjectHeader\n{\nuint32_t    objectSize;        // Size of the whole object in bytes\nuint16_t    classVersion;\nuint32_t    objectIndex;\nchar        objectName[];    // Null-terminated string\nchar        className[];    // Null-terminated string\n};\n</code></pre> <p>Oddly enough, if the archive is BinSafe, then the data will be encoded the same way as in ASCII mode, except that it will be stored as a type-checked property.</p> <pre><code>struct BinSafeObjectHeader\n{\nuint32_t    type;    // 0x1 = TYPE_STRING\nuint16_t    length;    // Length of the text\nchar        text[];    // [% oCWorld:zCWorld 64513 0]\n};\n</code></pre> <p>In ASCII mode <code>[]</code> represents the end of the current chunk.</p>"},{"location":"zengin/general_info/object_persistence/#properties","title":"Properties","text":"<p>We find properties inside the chunks which are key-value pairs that classes use to store the actual data. Each property stores its name, type and value. In ASCII mode the format for this is<code>name=type:value</code>.</p> <p>For example:</p> <p><code>visual=string:SURFACE.3DS</code></p> <p>By default, <code>zCArchiver</code> allows to store properties of the following types:</p> <ul> <li> <p>Int - A regular 32-bit integer. In ASCII mode, int gets stored as <code>name=int:1</code>, while in Binary mode, it's just the raw value stored as 4 bytes.</p> </li> <li> <p>Byte - A 8-bit integer. ASCII mode doesn't differentiate between Int and Byte, so this will be stored as <code>name=int:1</code> regardless. Binary mode stores only the single byte.</p> </li> <li> <p>Word - A 16-bit integer. ASCII mode doesn't differentiate between Int and Word, so this will be stored as <code>name=int:1</code> regardless. Binary mode stores only the 2 bytes.</p> </li> <li> <p>Float - A standard IEEE 754 32-bit floating point number. In ASCII mode the format is <code>name=float:1.0</code>, while in Binary mode the float gets stored raw as 4 bytes.</p> </li> <li> <p>Bool - Stores a single-byte boolean value. In ASCII mode its <code>name=bool:1</code> and in Binary mode it's a single byte.</p> </li> <li> <p>String - An ASCII encoded string. While in ASCII mode, strings are stored as <code>name=string:value</code>. In Binary mode, strings are NULL terminated.</p> </li> <li> <p>Vec3 - A three component vector, mainly used to store positional data. The ASCII mode format is <code>name=vec3:1.0 1.0 1.0</code>. In Binary mode the three components of the vector are stored in series, which equals to a total size of 12 bytes.</p> </li> <li> <p>Color - A 32-bit color value stored as BGRA. In ASCII mode the color is stored as <code>name=color:255 255 255 255</code> while in Binary mode it's just 4 raw bytes.</p> </li> <li> <p>Raw - Raw binary data. In order to maintain readability, in ASCII mode this gets stored as a hex encoded string such as <code>name=raw:63D15B07</code>. In Binary mode, only the data itself is stored, without any other info. Be aware that due to this you must know the size of the data beforehand.</p> </li> <li> <p>RawFloat - An array of floats, mainly used to store bounding boxes. In ASCII mode, the floats are stored as <code>name=rawFloat:1.0 1.0 1.0 1.0 1.0 1.0</code>. In Binary mode the floats are stored in series as raw bytes. Same as with <code>Raw</code>, you must know the size of the array beforehand.</p> </li> <li> <p>Enum - An enum value. In ASCII mode, it gets stored as <code>name=enum:1</code>. In Binary mode, it behaves the same as <code>Int</code>.</p> </li> </ul> <p>As you might have noticed, binary mode doesn't perform any kind of checks on if it's reading the right property or even data of the correct type. This is why BinSafe mode exists, as it stores the property type in along with the data itself.</p> <pre><code>enum TYPE\n{\nTYPE_STRING        = 0x1,\nTYPE_INTEGER    = 0x2,\nTYPE_FLOAT        = 0x3,\nTYPE_BYTE        = 0x4,\nTYPE_WORD        = 0x5,\nTYPE_BOOL        = 0x6,\nTYPE_VEC3        = 0x7,\nTYPE_COLOR        = 0x8,\nTYPE_RAW        = 0x9,\nTYPE_RAWFLOAT    = 0x10,\nTYPE_ENUM        = 0x11\nTYPE_HASH        = 0x12,\n};\nstruct BinSafeProperty\n{\nTYPE type;\nunion\n{\nstruct\n{\nuint16_t    stringLength;\nchar        stringValue[];\n}\nuint32_t    integerOrHashOrEnumValue;\nfloat        floatValue;\nuint8_t        byteOrBoolValue;\nzVEC3        vec3Value;\nzCOLOR        colorValue;\nstruct\n{\nuint16_t    rawLength;\nchar        rawValue[];\n}\nstruct\n{\nuint16_t    rawFloatLength;\nfloat        rawFloatValue[];\n}        };\n};\n</code></pre> <p>Looking at the enumeration of types, you might notice that BinSafe mode has an additional property type called Hash. BinSafe archives include a hash table which is stored in the following manner:</p> <pre><code>struct BinSafeHashTable\n{\nuint32_t chunkCount;\nfor (chunkCount)\n{\nuint16_t    stringLength;\nuint16_t    linearValue;\nuint32_t    hashValue;\nchar        text[stringLength];\n}\n};\n</code></pre> <p>Instead of storing the raw value, properties may save a hash instead, which is then used to look up the corresponding value from the hash table.</p>"},{"location":"zengin/general_info/object_persistence/#implementation","title":"Implementation","text":"<p>As mentioned in the opening paragraph, classes may use the described functionality by overloading the <code>Archive</code> and <code>Unarchive</code> virtual methods, which pass an instance of <code>zCArchiver</code> by reference. When the class instance is then serialized and/or parsed, these methods are called and perform the desired serialization/parsing work.</p> <p>The class uses methods provided by the <code>zCArchiver</code> instance within these routines. These methods return/accept a value of a specific type (e.g. ReadInt/WriteInt), while they do the actual reading/writing work behind the scenes based on the current mode (ASCII/Binary/BinSafe). The programmer writing the class then does not care whether the final archive will be saved as ASCII, Binary or BinSafe, as they only use the <code>zCArchiver</code> Read* and Write* methods.</p>"},{"location":"zengin/general_info/object_persistence/#a-practical-example","title":"A practical example","text":"<p>Let's propose that we have a class which is declared like so:</p> <pre><code>class zCMyClass : public zCObject\n{\npublic:\nzCMyClass()                {}\nvirtual ~zCMyClass()    {}\nvirtual void Archive(zCArchiver&amp;);\nvirtual void Unarchive(zCArchiver&amp;);\nint myInt;\nzCMyClass* myObject;\nzCMyClass* secondPointerToMyObject;\n};\n</code></pre> <p>The hypothetical class then implements these virtual functions:</p> <pre><code>void zCMyClass::Archive(zCArchiver&amp; archiver)\n{\narchiver.WriteInt(\"myInt\", myInt);\narchiver.WriteObject(\"myObject\", myObject);\narchiver.WriteChunkStart(\"myChunk\", 0);\narchiver.WriteObject(\"secondPointerToMyObject\", secondPointerToMyObject);\narchiver.WriteChunkEnd();\n}\nvoid zCMyClass::Unarchive(zCArchiver&amp; archiver)\n{\narchiver.ReadInt(\"myInt\", myInt);\nmyObject = dynamic_cast&lt;zCMyClass*&gt;(archiver.ReadObject(\"myObject\"));\narchiver.ReadChunkStart(\"myChunk\");\nsecondPointerToMyObject = dynamic_cast&lt;zCMyClass*&gt;(archiver.ReadObject(\"secondPointerToMyObject\"));\narchiver.ReadChunkEnd();\n}\n</code></pre> <p>We then initialize the class in the following way:</p> <pre><code>zCMyClass object;\nobject.myInt = 12121212;\nobject.myObject = new zCMyClass();\nobject.myObject-&gt;myInt = 34343434;\nobject.secondPointerToMyObject = object.myObject;\n</code></pre> <p>If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII archive, the result would look like this:</p> <pre><code>ZenGin Archive\nver 1\nzCArchiverGeneric\nASCII\nsaveGame 0\ndate 3.7.2022 0:0:0\nuser GMC\nEND\nobjects 2     \nEND\n\n[% zCMyClass 0 0]\n    myInt=int:12121212\n    [myObject zCMyClass 0 1]\n        myInt=int:34343434\n        [myObject % 0 0]\n        []\n        [myChunk % 0 0]\n            [secondPointerToMyObject % 0 0]\n            []\n        []\n    []\n    [myChunk % 0 0]\n        [secondPointerToMyObject \u00a7 0 1]\n        []\n    []\n[]\n</code></pre> <p>Notice how <code>secondPointerToMyObject</code> doesn't have any contents. The character <code>\u00a7</code> tells the parser that this object already exists in the objectList, and that instead of creating a new instance, it should return an existing instance which is stored under index <code>1</code> in the objectList.  This allows an instance to be referenced from multiple places, without the need to worry about duplicity.</p> <p>If we used Binary or BinSafe mode, we would see a big blob of binary data instead. This would, of course, store the exact same data, although in a slightly less human-readable format.</p>"},{"location":"zengin/general_info/object_persistence/#final-thoughts","title":"Final thoughts","text":"<p>We hope this helps you better understand the inner workings of ZenGin. If you want to see how Piranha Bytes went about implementing a much more advanced version of this system for their next engine, check out Genome's object persistence system.</p>"},{"location":"zengin/general_info/vdfs/","title":"VDFS","text":"<p>VDFS is the virtual file system used by ZenGin to distribute and store many, but not all, game assets.</p>"},{"location":"zengin/general_info/vdfs/#tools","title":"Tools","text":"<p>The community created variety of different modding tools for work with VDFS volumes over the times, such as:</p> <p>GothicVDFS</p> <ul> <li>Viewing</li> <li>Extracting</li> <li>Building <code>.mod</code> and <code>.vdf</code> archives</li> </ul> <p>VDFS Tool</p> <ul> <li>Viewing</li> <li>Extracting</li> <li>Building</li> <li>Optimizing</li> <li>Compressing <code>.mod</code> and <code>.vdf</code> archives</li> </ul>"},{"location":"zengin/scripts/","title":"Scripts","text":"<p>ZenGin uses its own scripting language called Daedalus. It is similar to C programming language, so if you know some C programming, it will be quite easy to get started.</p> <p>The <code>Scripts</code> directory is where the scripts live. You will be able to find Daedalus script files - <code>.d</code> extension and <code>.src</code> files, that list all files to be compiled.</p> <p>Daedalus scripts can be edited in any text editor. To get useful features like syntax highlighting you can use community developed tools like </p> <ul> <li>Gothic Sourcer</li> <li>Daedalus VS Code extension</li> </ul>"},{"location":"zengin/scripts/classes/c_info/","title":"C_INFO Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>The <code>C_INFO</code> class is used to define dialogues in the game.</p>"},{"location":"zengin/scripts/classes/c_info/#class-definition","title":"Class definition","text":"<p>Class definition as it is defined in <code>Scripts/Content/_intern/Classes.d</code> script file.</p> C_Info Daedalus class <pre><code>class C_Info\n{\nvar int    npc;         // npc instance has the dialogue\nvar int    nr;          // number of the dialogue (for sorting)\nvar int    important;   // should the npc start the dialogue automatically\nvar func   condition;   // condition function\nvar func   information; // function called on selecting the dialogue\nvar string description; // text in the dialogue box\nvar int    trade;       // should the dialogue show the trade window\nvar int    permanent;   // should the dialogue be permanent or only one time deal\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_info/#class-members","title":"Class members","text":"Variable Type Description npc int npc instance to have the dialogue nr int dialogue order number important int npc addresses player automatically condition func condition function whether the dialogue is shown or not information func function called on dialogue selection - contains the dialogue lines and other logic description string text shown in the dialogue box trade int is it a trade dialogue permanent int does the dialogue stay after being played once"},{"location":"zengin/scripts/classes/c_info/#class-member-overview","title":"Class member overview","text":"<p>Description of the class member variables.</p>"},{"location":"zengin/scripts/classes/c_info/#npc","title":"npc","text":"<p>Sets what NPC will have this dialogue instance. Set an NPC instance. <pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\nnpc    = PC_Thief; // NPC instance for Diego\n// ...\n};\n</code></pre></p>"},{"location":"zengin/scripts/classes/c_info/#nr","title":"nr","text":"<p>The <code>nr</code> member variables determines the order of shown dialogues. Dialogues are ordered in the ascending order - instances with higher <code>nr</code> are below instances with lower <code>nr</code>.</p> <pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\n// ...\nnr = 1;\n// ...\n};\n</code></pre> <p>Note</p> <p>This is why the end dialogues usually have <code>nr = 999;</code> this is the highest number out of any dialogues therefore will always show up at the bottom. (999 is not the highest number the <code>nr</code> can store, it is just considered the highest number, as there will hardly be 998 dialogue instances for a single character)</p>"},{"location":"zengin/scripts/classes/c_info/#important","title":"important","text":"<p>The <code>important</code> member variable determines whether the NPC will automatically address the player or not.</p> <ul> <li><code>important = TRUE</code> - the NPC will address the player</li> <li><code>important = FALSE</code> - the player has to talk to the NPC</li> </ul> <p>When <code>important</code> is set to <code>TRUE</code>, the description is not needed since the dialogue is never shown in the dialogue box.  </p> <p>Info</p> <p>If there are multiple important dialogues that satisfy their condition function, they will be played in the order specified by <code>nr</code>.</p> <p>Tip</p> <p><code>important</code> variable is of the type integer, and it is initialized by the engine to the value of <code>0</code>. If you do not want your dialogue to be important, you can omit the <code>important</code> member variable since it will be initialized to <code>0</code> by the engine.</p>"},{"location":"zengin/scripts/classes/c_info/#condition","title":"condition","text":"<p>Condition function with signature <code>func int f()</code>. If the function returns <code>TRUE</code> the dialogue is displayed, if it returns <code>FALSE</code> it is not displayed. The function name does not have to follow a particular naming convention but a naming convention is used throughout all the Gothic scripts: <code>{DialogueName}_Condition</code>.</p> Conditioned dialogueUnconditioned dialogue <pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\n// ...\ncondition = Info_Diego_Gamestart_Condition;\n// ...\n};\nfunc int Info_Diego_Gamestart_Condition()\n{\nif (Kapitel &lt; 2) // Show only when chapter is less than 2\n{\nreturn TRUE;\n};\nreturn FALSE; // Not needed, but added for readability\n};\n</code></pre> <pre><code>instance Info_Diego_EXIT_Gamestart(C_INFO)\n{\n// ...\ncondition = Info_Diego_EXIT_Gamestart_Condition;\n// ...\n};\nfunc int Info_Diego_EXIT_Gamestart_Condition()\n{\nreturn TRUE; // or return 1;\n};\n</code></pre> <p>Tip</p> <p>It is not necessary to return <code>FALSE</code> from dialogue conditions, but in other cases it can very rarely cause subtle bugs. It is thus good practice to always return some value, even if that is <code>FALSE</code>.</p>"},{"location":"zengin/scripts/classes/c_info/#information","title":"information","text":"<p>The <code>information</code> function contains the function name (without double quotes <code>\"\"</code> as <code>func</code> is a type in Daedalus) that is called when the dialogue option is selected. It contains the lines NPCs will say, items that will be transferred, quests related logic and much more. The function name does not have to follow a particular naming convention, but a naming convention is used throughout all the Gothic scripts: <code>{DialogueName}_Info</code>.</p> <pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\nnpc         = PC_Thief;\nnr          = 1;\ncondition   = Info_Diego_Gamestart_Condition;\ninformation = Info_Diego_Gamestart_Info;\npermanent   = FALSE;\nimportant   = TRUE;\n};\nfunc int Info_Diego_Gamestart_Condition()\n{\nif (Kapitel &lt; 2)\n{\nreturn TRUE;\n};\nreturn FALSE;\n};\nfunc void Info_Diego_Gamestart_Info()\n{\nAI_Output(self,hero,\"Info_Diego_Gamestart_11_00\"); //I'm Diego.\nAI_Output(hero,self,\"Info_Diego_Gamestart_15_01\"); //I'm...\nAI_Output(self,hero,\"Info_Diego_Gamestart_11_02\"); //I'm not interested in who you are. You've just arrived. I look after the new arrivals. That's all for now.\nAI_Output(self,hero,\"Info_Diego_Gamestart_11_03\"); //If you plan to stay alive for a while, you should talk to me. But of course I won't keep you from choosing your own destruction. Well, what do you think?\nB_Kapitelwechsel(1); // Show the chapter 1 screen\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_info/#description","title":"description","text":"<p>Specify a string that will be shown in the dialogue window.</p> <pre><code>instance DIA_XARDAS_GMC(C_INFO)\n{\n// ...\ndescription = \"Hello, is this the GMC site?\";\n};\n</code></pre> <p></p>"},{"location":"zengin/scripts/classes/c_info/#trade","title":"trade","text":"<p>If <code>trade</code> is set to <code>TRUE</code> the trading interface will be launched after the content <code>information</code> function is finished. Fisk's trade dialogue<pre><code>instance  Stt_311_Fisk_Trade (C_INFO)\n{\nnpc         = Stt_311_Fisk;\nnr          = 800;\ncondition   = Stt_311_Fisk_Trade_Condition;\ninformation = Stt_311_Fisk_Trade_Info;\npermanent   = TRUE;\ndescription = \"Show me your goods.\";\ntrade       = TRUE;\n};\nfunc int  Stt_311_Fisk_Trade_Condition()\n{\nreturn TRUE;\n};\nfunc void  Stt_311_Fisk_Trade_Info()\n{\nAI_Output (other, self, \"Stt_311_Fisk_Trade_15_00\"); //Show me your goods.\n};\n</code></pre></p> <p>Trivia</p> <p>Trade manager has been added to ZenGin not that long before the release of Gothic 1 (as discussed and discovered on Phoenix the Game Discord server with the acquisition of Gothic version <code>0.94k</code>). In version 0.94 the trade manager worked quite differently and used a special (nowadays unused) Daedalus class <code>C_ItemReact</code>.</p>"},{"location":"zengin/scripts/classes/c_info/#permanent","title":"permanent","text":"<p>Dialogues with <code>permanent = TRUE</code> do not disappear after the dialogue is played. This is used for dialogues where you ask for directions or flavor dialogues for unnamed NPCs.</p> <p>Bug</p> <p>Frequently used external function <code>Npc_KnowsInfo</code> which returns true if the dialogue instance has been played has had a bug in the implementation for a long time. This bug made it impossible to use this function with dialogue instances with <code>permanent = TRUE</code> as it would always return <code>FALSE</code>. This has been fixed in <code>Union 1.0m</code>.</p>"},{"location":"zengin/scripts/classes/c_info/#zparserextender","title":"zParserExtender","text":"<p>zParserExtender implements some Quality of Life features for dialogues. More information can be found in Dialogue constants article</p>"},{"location":"zengin/scripts/classes/c_info/#af-script-packet","title":"AF Script Packet","text":"<p>Enhanced Info Manager (implemented using Ikarus and LeGo) adds tonne of customisation and additional features to dialogues. More information can be found in the AFSP Enhanced Information Manager article</p>"},{"location":"zengin/scripts/classes/c_item/","title":"C_ITEM Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>The <code>C_ITEM</code> class is used to define new items in the game.</p>"},{"location":"zengin/scripts/classes/c_item/#class-definition","title":"Class definition","text":"<p>Class definition as it is defined in <code>Scripts/Content/_intern/Classes.d</code> script file. </p> C_Item Daedalus class <pre><code>class C_Item\n{\n// For all Items\nvar int    id;                         // ID of the item\nvar string name;                       // Name of the item\nvar string nameID;                     // Name ID\nvar int    hp;                         // Current health of the item\nvar int    hp_max;                     // Maximum health of the item\nvar int    mainflag;                   // Item category flag\nvar int    flags;                      // Item type flag\nvar int    weight;                     // Weight of the item\nvar int    value;                      // Value of the item\n// For weapons\nvar int    damageType;                 // Damage type\nvar int    damageTotal;                // Total amount of damage\nvar int    damage[DAM_INDEX_MAX];      // Array of damage types\n// For armours\nvar int    wear;                       // Flag to specify where to wear an item\nvar int    protection[PROT_INDEX_MAX]; // Protection array of different damage types\n// For food\nvar int    nutrition;                  // The amount of HP healed\n// Ben\u00f6tigte Attribute zum Benutzen des Items\nvar int    cond_atr[3];                // Array of NPC attributes needed to equip the item\nvar int    cond_value[3];              // Array of values corresponding to the cond_atr arry\n// Attributes to be changed on equip\nvar int    change_atr[3];              // Array of attributes that will be changed on equip\nvar int    change_value[3];            // Array of values of the attributes defined in change_atr\n// Parser functions\nvar func   magic;\nvar func   on_equip;                   // Called on equpping an item\nvar func   on_unequip;                 // Called on unequipping an item\nvar func   on_state[4];\nvar func   owner;                      // Owner of the item: instance name\nvar int    ownerGuild;                 // Owner of the item: guild\nvar int    disguiseGuild;              // NPC guild set when equipping an item\n// 3DS model file\nvar string visual;                     // Item model file\n// NPC mesh change, when equipping an item\nvar string visual_change;              // .asc file\nvar string effect;                     // Effect instance\nvar int    visual_skin;                // Texture variation\nvar string scemeName;                  // Animation sceme name\nvar int    material;                   // Material of the object\nvar int    munition;                   // Ammo instance\nvar int    spell;                      // ID if the spell that this item does\nvar int    range;                      // Range of the weapon\nvar int    mag_circle;                 // Circle of magic needed to use this item\nvar string description;                // The name of the item shown in the preview box\nvar string text[ITM_TEXT_MAX];         // Array of string describing the item (left side)\nvar int    count[ITM_TEXT_MAX];        // Array of integers (the right side)\n// Parameters for displaying items in the inventory\nvar int    inv_zbias                   // How far away is the item from the screen\nvar int    inv_rotx                    // X-axis rotation\nvar int    inv_roty                    // Y-axis rotation\nvar int    inv_rotz                    // Z-axis rotation\nvar int    inv_animate                 // Should the item rotate in the inventory\n};\n</code></pre> <p>It has many member variables but not all of them are used for every item. It is not necessary to define every one of these variables for every item as it was discussed on InsideGothic.</p>"},{"location":"zengin/scripts/classes/c_item/#class-members","title":"Class members","text":"<p>A selection of the most important class members.</p>"},{"location":"zengin/scripts/classes/c_item/#change_atr--change_value","title":"change_atr &amp; change_value","text":"<p><code>change_atr</code> stores the attributes that will be changed by the amount specified in <code>change_value</code>.</p> <p>NPCs have these attributes: <pre><code>const int ATR_HITPOINTS      =  0;  // Hit points\nconst int ATR_HITPOINTS_MAX  =  1;  // Max hitpoints\nconst int ATR_MANA           =  2;  // Mana\nconst int ATR_MANA_MAX       =  3;  // Max mana\nconst int ATR_STRENGTH       =  4;  // Strength\nconst int ATR_DEXTERITY      =  5;  // Dexterity\nconst int ATR_REGENERATEHP   =  6;  // HP regeneration per second\nconst int ATR_REGENERATEMANA =  7;  // Mana regeneration per second\n</code></pre></p> <p>This can be used on all equipable items to change the attributes. As an example we can create a sword that has a 10 point dexterity bonus.</p> <pre><code>instance ItMw_testSword (C_Item)\n{\n// some code\nchange_atr[0]   = ATR_DEXTERITY;\nchange_value[0] = 10;\n// some code\n};\n</code></pre> <p>Warning</p> <p>Do not change <code>ATR_HITPOINTS</code>, <code>ATR_MANA</code>, <code>ATR_HITPOINTS_MAX</code> or <code>ATR_MANA_MAX</code> as it will result in unwanted behaviour with max health or max mana.</p> <p>You can change <code>ATR_HITPOINTS_MAX</code> and <code>ATR_MANA_MAX</code> attributes in on_equip and on_unequip</p>"},{"location":"zengin/scripts/classes/c_item/#cond_atr--cond_value","title":"cond_atr &amp; cond_value","text":"<p><code>cond_atr</code> stores the attributes that will be checked as a requirement to equip an item, the amount specified in <code>cond_value</code>.</p> <p>The next example sword is equipable only if the NPC has at least 5 strength. If the requirements are not met <code>G_CanNotUse()</code> is called. <pre><code>instance ItMw_testSword (C_Item)\n{\n// some code\ncond_atr[2]     = ATR_STRENGTH;\ncond_value[2]   = 5;\n// some code\n};\n</code></pre></p> <p>Try injecting the code below zParserExtender to test it in game right away. It is compatible with G2NotR.</p> <p><pre><code>instance ItMw_testSword (C_Item)\n{\nname            = TXT_Spells[10]; // demonstrates the usage of direct constr array access\nmainflag        = ITEM_KAT_NF;\nflags           = ITEM_SWD;\nmaterial        = MAT_METAL;\nvalue           = 10;\ndamageTotal     = 10;\ndamagetype      = DAM_EDGE;\nrange           = 100;\ncond_atr[2]     = ATR_STRENGTH;\ncond_value[2]   = 5;\nchange_atr[0]   = ATR_DEXTERITY;\nchange_value[0] = 10;\nvisual          = \"ItMw_010_1h_Sword_short_01.3DS\";\ndescription     = name;\nTEXT[2]         = NAME_Damage;      COUNT[2] = damageTotal;\nTEXT[3]         = NAME_Str_needed;  COUNT[3] = cond_value[2];\nTEXT[4]         = NAME_OneHanded;\nTEXT[5]         = NAME_Value;       COUNT[5] = value;\n};\n</code></pre> To insert it into the game use <code>insert ItMw_testSword</code> in console.</p>"},{"location":"zengin/scripts/classes/c_item/#text--count-arrays","title":"text &amp; count arrays","text":"<p>These two arrays are used to put information into the item information box.   The maximum number of lines is 6. This is defined in the engine, but for script side class definition is declared in the scripts too. <pre><code>const int ITM_TEXT_MAX = 6;\n</code></pre> This example shows an item with all elements of <code>TEXT</code> and <code>COUNT</code> array filled. </p> <p>Note</p> <p>Please notice the last <code>COUNT</code> element. It did not take the value we entered, but shows <code>10</code> which is the <code>value</code> of the item. This behaviour can be changed with Ikarus or Union.</p> <p></p> <p>You can find the code below <pre><code>instance ItMw_testSword (C_Item)\n{\nname          = TXT_Spells[10];\nmainflag      = ITEM_KAT_NF;\nflags         = ITEM_SWD;\nmaterial      = MAT_METAL;\nvalue         = 10;\ndamageTotal   = 10;\ndamagetype    = DAM_EDGE;\nrange         = 100;\ncond_atr[2]   = ATR_STRENGTH;\ncond_value[2] = 5;\nchange_atr[0] = ATR_DEXTERITY;\nchange_value[0] = 10;\nvisual        = \"ItMw_010_1h_Sword_short_01.3DS\";\ndescription   = name;\nTEXT[0]       = \"Line 0\";     COUNT[0]      = 0; TEXT[1]       = \"Line 1\";     COUNT[1]      = 1; TEXT[2]       = \"Line 2\";     COUNT[2]      = 2; TEXT[3]       = \"Line 3\";     COUNT[3]      = 3; TEXT[4]       = \"Line 4\";     COUNT[4]      = 34;\nTEXT[5]       = \"Line 5\";     COUNT[5]      = 35;\n};\n</code></pre></p>"},{"location":"zengin/scripts/classes/c_item/#description--name","title":"description &amp; name","text":"<p><code>description</code> - determines the name of the item in the inventory</p> <p><code>name</code> - determines the focus name of the item in the world</p> <p>In the scripts you often find that the description is assigned the value of <code>name</code>. <pre><code>instance ItMw_testSword (C_Item)\n{\nname = \"New amazing sword\";\n// ...\ndescription   = name; // description now has the same value as '    // ...name'\n// ...\n};\n</code></pre> This is used in the case where you want to show the name of the item on focus too.</p> <p>There is a second way used in the scripts though with, for example,magic scrolls - the focus name in the world is \"Scroll\" and in inventory the scroll carries the name of the spell. This is how it is done: <pre><code>instance ItSc_InstantFireball (C_Item)\n{\nname                 =    NAME_Spruchrolle; // const string = \"Scroll\"\n// ...\ndescription            =     NAME_SPL_InstantFireball; // const string = \"Fireball\"\n// ...\n};\n</code></pre></p>"},{"location":"zengin/scripts/classes/c_item/#hp--hp_max","title":"hp &amp; hp_max","text":"<p>Both of these parameters are unused.</p> <p>Trivia</p> <p>In alpha ZenGin versions the player was able to destroy objects. This feature was abandoned during the course of the development. This video shows the reconstruction of this feature. </p>"},{"location":"zengin/scripts/classes/c_svm/","title":"C_SVM Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>The <code>C_SVM</code> class is used to define sound dialogues (smalltalk, reactions) that are defined for every C_NPC.voice.</p>"},{"location":"zengin/scripts/classes/c_svm/#class-definition","title":"Class definition","text":"<p><code>C_SVM</code> class is the only class with variable number of members. The <code>C_SVM</code> definition in the scripts dictates the content of the class. Every Gothic game has a different number of SVM entries. As an interesting information (more than anything else) we include a table with the numbers of voice lines and voices below.</p> Game voice lines voices Gothic 1 136 17 Gothic Sequel 110 17 (30 planned) Gothic 2 202 19 Gothic 2 Addon 235 19 Chronicles of Myrtana 1346 73 Returning New Balance 495 19"},{"location":"zengin/scripts/classes/c_svm/#rules","title":"Rules","text":"<p>The number of instances is defined by a constant integer with a specified name read by the engine. <pre><code>const int SVM_MODULES = 18;\n</code></pre></p> <p>Info</p> <p>The value <code>SVM_MODULES = 18</code> means 18 SVMs will be parsed by the engine and because the first one, <code>SVM_0</code>, is empty, the final number of voices is 18 - 1 = 17.</p> <p>Instances of the <code>C_SVM</code> class must have the name <code>SVM_XXX</code>. <pre><code>instance svm_1(c_svm)\n{\n// ...\n};\n</code></pre> The first instance <code>svm_0</code> is always empty, it is used internally by the engine. <pre><code>instance svm_0(c_svm) {};\n</code></pre></p>"},{"location":"zengin/scripts/classes/c_svm/#usage-in-the-scripts","title":"Usage in the scripts","text":"<p>While some defined SVMs are used automatically by the engine - the 20 smalltalk lines for example, others are used in the scripts. To instruct the engine to run a specific SVM, external function <code>AI_OutputSVM</code> is used. In the original scripts it is wrapped in a script function B_Say. To reference the SVM, you use the <code>$</code> symbol followed by the name of the member variable in the <code>C_SVM</code> class definition. <pre><code>// some code\n{\nPrintScreen    (\"Not enough skill points!\", -1,-1,\"FONT_OLD_20_WHITE.TGA\",1);\nB_Say (self, other, \"$NOLEARNNOPOINTS\");\n};\n// some code\n</code></pre> Here the <code>$NOLEARNNOPOINTS</code> references the <code>var string NoLearnNoPoints</code> in SVM.D. The voice is then chosen automatically by the engine. <pre><code>class C_SVM\n{\n//...\n// Teacher comments\nvar string NoLearnNoPoints;       // NPC teacher doesn't teach - not enough learning points!\nvar string NoLearnOverMax;        // NPC teacher doesn't teach - cannot teach above 100 points!\nvar string NoLearnYouAlreadyKnow; // You have to know something to become a master!\nvar string NoLearnYoureBetter;    // You are better than the teacher!\n//...\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/","title":"Daedalus extenders","text":"<p>The default scripting language Daedalus can be quite limiting. Over the years the community created quite a few extenders to, well, extend the functionality. Before Union came along, the standard to interface with the engine was the script library Ikarus and a collection of packages LeGo built on top of that. Not so recently, an additional script packet was made (and is actively being worked on) AF Script Packet that offers even more functionality and is built on tom of Ikarus &amp; LeGo. With the adoption of Union and plugins the Union system can use a new extender emerged called zParserExtender. Other Union plugins can, of course, implement their own external functions.</p>"},{"location":"zengin/scripts/extenders/afsp/","title":"AF Script Packet","text":"<p>Auronen &amp; Fawkes' Script Packet is a script package built on top of Ikarus and LeGo. It implements many features and there is also a Union version which is in its infancy stage.</p> <p>Note</p> <p>AFSP's documentation is lacking (@Auronen: \"My fault\"). The authors will host the documentation on GMC.</p> Contacts Authors  Fawkes &amp; Auronen GitHub  AFSP Forum  AFSP"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/","title":"Enhanced Information Manager","text":"<p>Warning</p> <p>This is a quick paste-in of and old version of AFSP's documentation and the information should be taken with a grain of salt. It may not be up-to-date since AFSP is being developed all the time and this is only a demo page.</p> <p>Enhanced Information Manager allows you to more precisely control the Information Manager (dialogue manager). Change color, font and much more! This package \"scans\" the dialogue string for modifiers and alters the string based on the modifiers you specify.</p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#initialization","title":"Initialization","text":"<p>To use this feature you have to:</p> <ol> <li>Add <code>_headers_G[1/2]_EnhancedInfoManager.src</code> or <code>_headers_G[1/2]_All.src</code> to your <code>Gothic.src</code> after Ikarus and LeGo initialization.</li> <li>Call <code>G12_EnhancedInfoManager_Init();</code> from your <code>INIT_GLOBAL()</code> function in <code>Startup.d</code></li> </ol>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-colour","title":"Change colour","text":"<p>Set font color for a dialogue choice. <pre><code>h@[hex color value]\n</code></pre> Set font color for highlighted dialogue choice. <pre><code>hs@[hex color value]\n</code></pre> Example<pre><code>description = \"h@2a85a3 hs@2ea9d1 This dialogue is blue.\";\n</code></pre></p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-font","title":"Change font","text":"<p>Set font itself for a dialogue choice. <pre><code>f@[font name]\n</code></pre> Set font itself for highlighted dialogue choice. <pre><code>fs@[font name]\n</code></pre> Example<pre><code>description = \"f@font_old_20_white.tga fs@font_old_10_white.tga This dialogue has a different font, when selected.\";\n</code></pre></p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-text-alignment","title":"Change text alignment","text":"<p>Align text left. <pre><code>al@\n</code></pre> Align text center. <pre><code>ac@\n</code></pre> Align text right. <pre><code>ar@\n</code></pre> Example<pre><code>description = \"al@ This dialogue has LEFT alignment.\";\ndescription = \"ac@ This dialogue has CENTER alignment.\";\ndescription = \"ar@ This dialogue has RIGHT alignment.\";\n</code></pre></p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#disable-dialogue","title":"Disable dialogue","text":"<p>Player cannot highlight (and select) this dialogue. <pre><code>d@\n</code></pre></p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#text-input-field","title":"Text input field","text":"<p>Input field allows you to turn a dialogue choice into an input text field. <pre><code>a@\n</code></pre> Example<pre><code>INSTANCE DIA_Xardas_Password (C_Info)\n{\nnpc         = NONE_100_Xardas;\nnr          = 1;\ncondition   = DIA_Xardas_Password_Condition;\ninformation = DIA_Xardas_Password_Info;\npermanent   = FALSE;\ndescription = \"a@ What is the password to get to the Mages of Water?\";\n};\nFUNC INT DIA_Xardas_Password_Condition () {\nreturn TRUE;\n};\nFUNC VOID DIA_Xardas_Password_Info () {\nif (Hlp_StrCmp (InfoManagerAnswer, \"TETRIANDOCH\"))\n{\nPrintScreen (\"Yes that is correct!\", -1, -1, \"font_old_10_white.tga\", 3);\n}\nelse\n{\nPrintScreen (\"No that is wrong!\", -1, -1, \"font_old_10_white.tga\", 3);\n};\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#dialogue-numbers","title":"Dialogue numbers","text":"<p>This feature shows a dialogue number next to the dialogue line (visual for Dialogue keyboard controls). To turn this on you just set <code>InfoManagerNumKeysNumbers</code> variable to true. (in your <code>INIT_GLOBAL()</code> function). <pre><code>InfoManagerNumKeysNumbers = TRUE;\n</code></pre></p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#dialogue-keyboard-controls","title":"Dialogue keyboard controls","text":"<p>Note</p> <p>This has also been fixed in Union and we noticed a strange behavior with different keyboard layouts.</p> <p>This feature changes the way number keys affect dialogue selection. The first dialogue is no longer 0 and you highlight the dialogue option by pressing appropriate number. <pre><code>InfoManagerNumKeysControls = TRUE;\n</code></pre></p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#spinners","title":"Spinners","text":"<p>This is by far the most flashy feature of EIM as it allows you to use left/right arrow keys on a dialogue option to increase/decease numerical value. This can be used in many ways.</p> <p>This feature is a bit more complex:  </p> <ol> <li> <p>Set up a standard dialogue</p> <p>Notice</p> <p>Notice we are using \"dummy\" as a description, since it is going to get updated. If something goes wrong the \"dummy\" string shows up and you can clearly tell something went wrong.</p> <pre><code>INSTANCE PC_Pan_Cook_Meat (C_Info)\n{\nnr           = 1;\ncondition    = PC_Pan_Cook_Meat_Condition;\ninformation  = PC_Pan_Cook_Meat_Info;\npermanent    = TRUE;\ndescription  = \"dummy\"; //Description is updated in PC_Pan_Cook_Meat_Condition\n};\n</code></pre> </li> <li> <p>Most of the magic takes place in the condition function (apart from the code behind the scenes, of course).</p> <pre><code>var int selectedMeat; // global variable for this spinner value\nFUNC INT PC_Pan_Cook_Meat_Condition ()\n{\nif (PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN)\n{\nvar string lastSpinnerID;\nvar int total; total = NPC_HasItems (self, ItFoMuttonRaw);\nif (selectedMeat == 0) { selectedMeat = 1; }; //Default initial value\n//Check currently selected spinned ID --&gt; is it this one?\nif (Hlp_StrCmp (InfoManagerSpinnerID, \"CookMeat\"))\n{\n//Setup spinner if spinner ID has changed\nif (!Hlp_StrCmp (InfoManagerSpinnerID, lastSpinnerID))\n{\n//Restore previous value\nInfoManagerSpinnerValue = selectedMeat;\n};\n//Page Up/Down quantity\nInfoManagerSpinnerPageSize = 5;\n//Min/Max value (Home/End keys)\nInfoManagerSpinnerValueMin = 1;\nInfoManagerSpinnerValueMax = total;\n//Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT\nselectedMeat = InfoManagerSpinnerValue;\n};\nlastSpinnerID = InfoManagerSpinnerID; //Remember last active spinner ID\nvar string newDescription;\n//Spinner ID 'CookMeat'\nnewDescription = \"s@CookMeat Cook some meat: \";\nnewDescription = ConcatStrings (newDescription, IntToString (selectedMeat));\nnewDescription = ConcatStrings (newDescription, \" / \");\nnewDescription = ConcatStrings (newDescription, IntToString (total));\n//Update description\nPC_Pan_Cook_Meat.description = newDescription;\nreturn TRUE;\n};\nreturn FALSE;\n};\n</code></pre> </li> <li> <p>We can use the spinner value stored in <code>selectedMeat</code> variable here in the info function to create the meat (or do other stuff with it).</p> <pre><code>FUNC VOID PC_Pan_Cook_Meat_Info () {\n//If we don't have any meat ... don't cook any :)\nif (!NPC_HasItems (self, ItFoMuttonRaw)) { return; };\n//This should not happen - but you never know!\nif (selectedMeat &lt; 1) { return; };\n//This should not happen either! but just in case\nif (selectedMeat &gt; (NPC_HasItems (self, ItFoMuttonRaw))) {\nselectedMeat = NPC_HasItems (self, ItFoMuttonRaw);\n};\nNPC_RemoveInvItems (self, ItFoMuttonRaw, selectedMeat);\nCreateInvItems (self, ItFoMutton, selectedMeat);\n//Reset value for next time\nselectedMeat = 1;\n};\n</code></pre> </li> </ol>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#spinners-full-code-example","title":"Spinners: Full code example","text":"Spinner example <pre><code>INSTANCE PC_Pan_Cook_Meat (C_Info)\n{\nnr           = 1;\ncondition    = PC_Pan_Cook_Meat_Condition;\ninformation  = PC_Pan_Cook_Meat_Info;\npermanent    = TRUE;\ndescription  = \"dummy\"; //Description is updated in PC_Pan_Cook_Meat_Condition\n};\nvar int selectedMeat;\nFUNC INT PC_Pan_Cook_Meat_Condition ()\n{\nif (PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN)\n{\nvar string lastSpinnerID;\nvar int total; total = NPC_HasItems (self, ItFoMuttonRaw);\nif (selectedMeat == 0) { selectedMeat = 1; }; //Default initial value\n//Check currently selected spinned ID --&gt; is it this one?\nif (Hlp_StrCmp (InfoManagerSpinnerID, \"CookMeat\"))\n{\n//Setup spinner if spinner ID has changed\nif (!Hlp_StrCmp (InfoManagerSpinnerID, lastSpinnerID))\n{\n//Restore previous value\nInfoManagerSpinnerValue = selectedMeat;\n};\n//Page Up/Down quantity\nInfoManagerSpinnerPageSize = 5;\n//Min/Max value (Home/End keys)\nInfoManagerSpinnerValueMin = 1;\nInfoManagerSpinnerValueMax = total;\n//Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT\nselectedMeat = InfoManagerSpinnerValue;\n};\nlastSpinnerID = InfoManagerSpinnerID; //Remember last active spinner ID\nvar string newDescription;\n//Spinner ID 'CookMeat'\nnewDescription = \"s@CookMeat Cook some meat: \";\nnewDescription = ConcatStrings (newDescription, IntToString (selectedMeat));\nnewDescription = ConcatStrings (newDescription, \" / \");\nnewDescription = ConcatStrings (newDescription, IntToString (total));\n//Update description\nPC_Pan_Cook_Meat.description = newDescription;\nreturn TRUE;\n};\nreturn FALSE;\n};\nFUNC VOID PC_Pan_Cook_Meat_Info ()\n{\n//If we don't have any meat ... don't cook any :)\nif (!NPC_HasItems (self, ItFoMuttonRaw)) { return; };\n//This should not happen - but you never know!\nif (selectedMeat &lt; 1) { return; };\n//This should not happen either! but just in case\nif (selectedMeat &gt; (NPC_HasItems (self, ItFoMuttonRaw)))\n{\nselectedMeat = NPC_HasItems (self, ItFoMuttonRaw);\n};\nNPC_RemoveInvItems (self, ItFoMuttonRaw, selectedMeat);\nCreateInvItems (self, ItFoMutton, selectedMeat);\n//Reset value for next time\nInfoManagerSpinnerValue = 1;\n};\nINSTANCE PC_Pan_Cook_Meat_Exit (C_Info)\n{\nnr          = 999;\ncondition   = PC_Pan_Cook_Meat_Exit_Condition;\ninformation = PC_Pan_Cook_Meat_Exit_Info;\npermanent   = TRUE;\ndescription = \"End\";\n};\nFUNC INT PC_Pan_Cook_Meat_Exit_Condition ()\n{\nif (PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN)\n{\nreturn TRUE;\n};\nreturn FALSE;\n};\nFUNC VOID PC_Pan_Cook_Meat_Exit_Info ()\n{\nif (PLAYER_MOBSI_PRODUCTION != MOBSI_DIALOG_NONE)\n{\nPLAYER_MOBSI_PRODUCTION = MOBSI_DIALOG_NONE;\nhero.aivar[AIV_INVINCIBLE] = FALSE;\nAI_StopProcessInfos (hero);\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/","title":"Ikarus","text":"<p>Ikarus is a Daedalus library for Gothic. It exploits the interpreter to allow arbitrary memory access and defines tonne of useful functions for interfacing with the engine. </p> Contacts Author  Sektenspinner &amp; contributors GitHub  Ikarus Forum  Ikarus <p>Note</p> <p>Ikarus is hosted on GitHub and the documentation is built in. The translation is planned.</p>"},{"location":"zengin/scripts/extenders/ikarus/examples/","title":"Ikarus examples","text":"<p>A collection of examples ported from the original Ikarus documentation.</p> <p>Note</p> <p>The original Ikaurs documentation is a part of the code. You can find it in the github repository</p>"},{"location":"zengin/scripts/extenders/ikarus/examples/#open-focused-chest-or-door","title":"Open focused chest or door","text":"<pre><code>func void OpenFocussedChestOrDoor() {\nvar oCNpc her; her = Hlp_GetNpc(hero);\n// No focus vob at all?\nif (!her.focus_vob) {\nPrint (\"No focus!\");\nreturn;\n};\n// Focus vob not a lockable vob?\nif (!Hlp_Is_oCMobLockable(her.focus_vob))\n{\nPrint (\"No chest or door in focus!\");\nreturn;\n};\nvar oCMobLockable Lockable;\nLockable = MEM_PtrToInst (her.focus_vob);\nif (Lockable.bitfield &amp; oCMobLockable_bitfield_locked) {\nLockable.bitfield = Lockable.bitfield &amp; ~ oCMobLockable_bitfield_locked;\nPrint (ConcatStrings (\"Opened the following vob: \", Lockable._zCObject_objectName));\n} else\n{\nPrint (ConcatStrings ( Lockable._zCObject_objectName, \"wasn't even complete!\"));\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#print-camera-position","title":"Print camera position","text":"<pre><code>func void PrintCameraPos()\n{\n// Initialize global instances (which only exist once):\n// Initializes MEM_World, MEM_Game, etc. including MEM_Camera\nMEM_InitGlobalInst();\n/* The camera object is not a vob (but something abstract), \n    do not know where and how there are position data.\n    I prefer to work on the camera vob : */\nvar zCVob camVob;\ncamVob = MEM_PtrToInst (MEM_Camera.connectedVob);\n/* Here you have to know how the transformation matrix is structured:\n    It consists of three vectors, the x, y and z directions of the local coordinate system of the camera vob\n    in world coordinates (where z specifies the\n    line of sight). These vectors are\n    denoted by v1, v2, v3.\n    In addition, in the 4th column there is the translation,\n    that is, the position of the camera.\n    v1_x v2_x v3_x x\n    v1_y v2_y v3_y y\n    v1_z v3_z v3_z z\n    0 0 0 0\n    The matrix is stored row by row in memory.\n    Since we are interested in the last column are the indices\n    in the trafoWorld Array 3, 7 and 11 that we need. */\nPrint (ConcatStrings (\"x: \",IntToString(roundf(camVob.trafoObjToWorld[3]))));\nPrint (ConcatStrings (\"y: \",IntToString(roundf(camVob.trafoObjToWorld[7]))));\nPrint (ConcatStrings (\"z: \",IntToString(roundf(camVob.trafoObjToWorld[11]))));\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#start-rain","title":"Start rain","text":"<pre><code>func void StartRain()\n{\n// Initialize global instances\n// This also includes Skycontroller\nMEM_InitGlobalInst(); // start at the beginning of the day (12:00 noon)\nMEM_SkyController.rainFX_timeStartRain = 0; //FLOATNULL;\n// end at the end of the day (12:00 noon of the next day)\nMEM_SkyController.rainFX_timeStopRain = 1065353216; //FLOATEINS;\n/* Note: The start and end times are floating point numbers.\n    * 0 stands for the beginning of the day 1 for the end of the day.\n    * a day in the game begins at 12:00 p.m.\n    * For the structure of the floating point format, google for IEEE-745.*/\n/* Result: rain all day! (unless you are in a zone\n    * in which it snows, then snow all day) */\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#nested-loop","title":"Nested loop","text":"<pre><code>// Should enumerate all pairs (x,y) with 0 &lt;= x &lt; max_x, 0 &lt;= j &lt; max_y\nfunc void printpairs(var int max_x, var int max_y)\n{\n// Initialize labels\nMEM_InitLabels();\n// PrintDebug should be used, i.e. activate debug output\nMEM_SetShowDebug (1);\nvar int x; var int y; x = 0;\n// while (x &lt; max_x)\nvar int x_loop; x_loop = MEM_StackPos.position;\nif (x &lt; max_x)\n{ y = 0;\n// while (y &lt; max_y) \nvar int y_loop; y_loop = MEM_StackPos.position;\nif (y &lt; max_y)\n{ var string out; out = \"(\";\nout = ConcatStrings (out, IntToString (x));\nout = ConcatStrings (out, \", \");\nout = ConcatStrings (out, IntToString (y));\nout = ConcatStrings (out, \")\");\nPrintDebug (out);\ny += 1;\n//continue y_loop \nMEM_StackPos.position = y_loop;\n};\nx += 1;\n// continue x_loop\nMEM_StackPos.position = x_loop;\n};\n};\n/*\n    Output of a call printpairs(4,2) would then be: \n    00:36 Info: 5 U: Skript: (0, 0) .... \n    00:36 Info: 5 U: Skript: (0, 1) .... \n    00:36 Info: 5 U: Skript: (1, 0) .... \n    00:36 Info: 5 U: Skript: (1, 1) .... \n    00:36 Info: 5 U: Skript: (2, 0) .... \n    00:36 Info: 5 U: Skript: (2, 1) .... \n    00:36 Info: 5 U: Skript: (3, 0) .... \n    00:36 Info: 5 U: Skript: (3, 1) .... \n*/\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#calling-a-function-by-their-name","title":"Calling a function by their name","text":"<pre><code>// This example doesn't show why MEM_CallByString * is useful, but how to use the function.\nvar zCVob someObject;\nfunc int MyFunction(var int param1, var string str1, var int param2, var string str2)\n{\nPrint (ConcatStrings (str1, str2)); //(*)\nreturn 100 * param1 + param2;\n};\nfunc void foo()\n{ var int result;\n// The code between A and B is in this case equivalent to:\n// result = MyFunction(42, \"Hello\", 23, \"World!\");\n// Lay the call arguments on the call stack\nMEM_PushIntParam (42);\nMEM_PushStringParam (\"Hello \");\nMEM_PushIntParam (23);\nMEM_PushStringParam (\"World!\");\nMEM_CallByString (\"MYFUNCTION\");\n// the function puts the result (of type int in this case) on the stack\n// we pop the int result and save it to a variable\nresult = MEM_PopIntResult();\n// print the result\nPrint (IntToString (result));\n};\n/*\n    Note: Since symbol indices are continuous and someObject's symbol index \n    is simply given by someObject itself, could\n    MEM_CallByString(\"MYFUNCTION\"); \n    also be replaced here by \n    MEM_CallByID(someObject + 1);\n*/\n}\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/","title":"Configuration file access","text":"<p>This part of Ikarus gives you access to <code>Gothic.ini</code> and loaded mod configuration files.</p>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>func void MEM_InitAll () {};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#read-functions","title":"Read functions","text":""},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_getgothopt","title":"MEM_GetGothOpt","text":"<p>Searches the <code>Gothic.ini</code> for an option. <pre><code>func string MEM_GetGothOpt(var string sectionname, var string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - settings section like <code>[GAME]</code></li> <li><code>optionname</code> - one setting entry like <code>playLogoVideos</code></li> <li><code>return</code> - the option value as a string, returns empty string if it was not found</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_getmodopt","title":"MEM_GetModOpt","text":"<p>Searches the loaded mod ini file for option. <pre><code>func void MEM_GetModOpt(var string sectionname, var string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - settings section like <code>[INFO]</code></li> <li><code>optionname</code> - one setting entry like <code>Title</code></li> <li><code>return</code> - the option value as a string, of it was not found, empty string is returned</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_gothoptsectionexists","title":"MEM_GothOptSectionExists","text":"<p>Checks whether a section exists in <code>Gothic.ini</code> <pre><code>func int MEM_GothOptSectionExists(var string sectionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - settings section like <code>[GAME]</code></li> <li><code>return</code> - <code>TRUE</code> if section exist <code>FALSE</code> otherwise</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_modoptsectionexists","title":"MEM_ModOptSectionExists","text":"<p>Checks whether a section exists in loaded mod ini file <pre><code>func int MEM_ModOptSectionExists(var string sectionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - settings section like <code>[INFO]</code></li> <li><code>return</code> - <code>TRUE</code> if section exist <code>FALSE</code> otherwise</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_gothoptexists","title":"MEM_GothOptExists","text":"<p>Checks whether an option exists in <code>Gothic.ini</code> <pre><code>func int MEM_GothOptExists(var string sectionname,\nvar string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - settings section like <code>[GAME]</code></li> <li><code>optionname</code> - one setting entry like <code>playLogoVideos</code></li> <li><code>return</code> - <code>TRUE</code> if option in a section exist <code>FALSE</code> otherwise</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_modoptexists","title":"MEM_ModOptExists","text":"<p>Checks whether an option exists in loaded mod ini file <pre><code>func int MEM_ModOptExists(var string sectionname, var string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - settings section like <code>[INFO]</code></li> <li><code>optionname</code> - one setting entry like <code>Title</code></li> <li><code>return</code> - <code>TRUE</code> if option in a section exist <code>FALSE</code> otherwise</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#write-functions","title":"Write functions","text":"<p>Warning</p> <p>Mod configuration is never saved to disk, therefore there are no separate functions for writing to it</p>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_setgothopt","title":"MEM_SetGothOpt","text":"<p>The option <code>option</code> in the section <code>section</code> is set to the <code>value</code>. If the section and/or option does not exist, it will be created. <pre><code>func void MEM_SetGothOpt(var string section, var string option, var string value) {};\n</code></pre></p> <ul> <li><code>section</code> - the section where the option should located</li> <li><code>option</code> - option to write/overwrite</li> <li><code>value</code> - value to set the option to</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_applygothopt","title":"MEM_ApplyGothOpt","text":"<p>Applies the changes and saves the ini to disk <pre><code>func void MEM_ApplyGothOpt() {};\n</code></pre></p> <p>Tip</p> <p>If you introduce new options, it is best to follow certain practices. It is a good practice to name your options in a clear manner and place them in a section named the same as your mod. Do not place your mod options into the <code>[GAME]</code> or <code>[PERFORMANCE]</code> sections.</p>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#key-functions","title":"Key functions","text":"<p>The <code>Gothic.ini</code> contains the assignment of physical keys (e.g. \"W\") to logical keys (e.g. \"keyUp\").</p>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_getkey","title":"MEM_GetKey","text":"<p>Returns the primary key assigned to logical key. <pre><code>func int MEM_GetKey (var string name) {};\n</code></pre></p> <ul> <li><code>name</code> - name of the logical key</li> <li><code>return</code> - key assigned to logical key</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_getsecondarykey","title":"MEM_GetSecondaryKey","text":"<p>Returns a secondary key assigned to logical key. <pre><code>func int MEM_GetSecondaryKey(var string name) {};\n</code></pre></p> <ul> <li><code>name</code> - name of the logical key</li> <li><code>return</code> - key assigned to logical key</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_setkeys","title":"MEM_SetKeys","text":"<p>Sets keyboard keys of the logical key. <pre><code>func void MEM_SetKeys(var string name, var int primary, var int secondary) {};\n</code></pre></p> <ul> <li><code>name</code> - name of the logical key</li> <li><code>primary</code> - primary key to be assigned, can be taken from Ikarus_Const_G1/Ikarus_Const_G2 file.</li> <li><code>secondary</code> - secondary key to be assigned, can be taken from Ikarus_Const_G1/Ikarus_Const_G2 file.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_setkey","title":"MEM_SetKey","text":"<p>Sets the primary keyboard key of the logical key. <pre><code>func void MEM_SetKey(var string name, var int key) {};\n</code></pre></p> <ul> <li><code>name</code> - name of the logical key</li> <li><code>key</code> - primary key to be assigned, can be taken from Ikarus_Const_G1/Ikarus_Const_G2 file.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/ini_access/#mem_setsecondarykey","title":"MEM_SetSecondaryKey","text":"<p>Sets the secondary keyboard key of the logical key. <pre><code>func void MEM_SetSecondaryKey(var string name, var int key) {};\n</code></pre></p> <ul> <li><code>name</code> - name of the logical key</li> <li><code>key</code> - secondary key to be assigned, can be taken from Ikarus_Const_G1/Ikarus_Const_G2 file.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/keyboard/","title":"Keyboard interaction","text":"<p>This part of Ikarus implements function that make interaction with keyboard possible.</p>"},{"location":"zengin/scripts/extenders/ikarus/keyboard/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>func void MEM_InitAll () {};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/keyboard/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/keyboard/#functions","title":"Functions","text":"<p>Tip</p> <p>Different players use different keys for specific actions! However, it is possible to get key assigned to the action from Gothic.ini. See Ini access</p>"},{"location":"zengin/scripts/extenders/ikarus/keyboard/#mem_keystate","title":"MEM_KeyState","text":"<p>Returns the state of the <code>key</code>. <pre><code>func int MEM_KeyState(var int key) {};\n</code></pre></p> <ul> <li><code>key</code> - checked key</li> <li><code>return</code> - key state</li> </ul> <p>Key states</p> <ul> <li><code>KEY_UP</code> - The key is not pressed and was not pressed before. (\"not pressed\")</li> <li><code>KEY_PRESSED</code> - The key is pressed and was not previously pressed. (\"new pressed\")</li> <li><code>KEY_HOLD</code> - The key is pressed and was also pressed before. (\"still pressed\")</li> <li><code>KEY_RELEASED</code> - The key is not pressed and was previously pressed. (\"let go\")</li> </ul> <p><code>KEY_PRESSED</code> or <code>KEY_RELEASED</code> will be returned if the state of the key has changed since the last query.</p> <p><code>KEY_UP</code> or <code>KEY_HOLD</code> are returned if the state has not changed.</p>"},{"location":"zengin/scripts/extenders/ikarus/keyboard/#mem_insertkeyevent","title":"MEM_InsertKeyEvent","text":"<p>Makes the game think that the key was pressed. <pre><code>func void MEM_InsertKeyEvent(var int key) {};\n</code></pre></p> <ul> <li><code>key</code> - key to be \"pressed\"</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/","title":"Elementary memory access","text":"<p>This part of Ikarus makes it possible to read and write memory as different data types - integers, strings, arrays of integers and strings and bytes.</p> <p>If <code>address &lt;= 0</code>, an error is thrown. Otherwise, an attempt is made to read or write at this address. If the address falls into invalid range, for example in a code segment,access violation will occur (Gothic crashes). In the case of string operations, it is also necessary that at the specified position a valid zString already exists.</p>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>func void MEM_InitAll () {};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#read-functions","title":"Read functions","text":""},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_readint","title":"MEM_ReadInt","text":"<p>Reads int from the <code>address</code>. <pre><code>func int MEM_ReadInt (var int address) {};\n</code></pre></p> <ul> <li><code>address</code> - memory address to read from</li> <li><code>return</code> - integer value if the address is correct</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_readstring","title":"MEM_ReadString","text":"<p>Reads string from the <code>address</code>. <pre><code>func string MEM_ReadString (var int address) {};\n</code></pre></p> <ul> <li><code>address</code> - memory address to read from</li> <li><code>return</code> - string if the address is correct</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_readbyte","title":"MEM_ReadByte","text":"<p>Reads byte from the <code>adr</code>. <pre><code>func int MEM_ReadByte (var int adr) {};\n</code></pre></p> <ul> <li><code>adr</code> - memory address to read from</li> <li><code>return</code> - byte value if the address is correct</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_readintarray","title":"MEM_ReadIntArray","text":"<p>Reads int from the array at the <code>arrayAddress</code>. <pre><code>func int MEM_ReadIntArray (var int arrayAddress, var int offset) {};\n</code></pre></p> <ul> <li><code>arrayAddress</code> - memory address of array</li> <li><code>offset</code> - array offset (array index)</li> <li><code>return</code> - string from array if the address is correct</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_readstringarray","title":"MEM_ReadStringArray","text":"<p>Info</p> <p><code>MEM_ReadStringArray</code> has been already moved to the LeGo PermMem package.</p>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_readbytearray","title":"MEM_ReadByteArray","text":"<p>Reads byte from the array at the <code>arrayAddress</code>. <pre><code>func int MEM_ReadByteArray (var int arrayAddress, var int offset) {};\n</code></pre></p> <ul> <li><code>arrayAddress</code> - memory address of array</li> <li><code>offset</code> - array offset (array index)</li> <li><code>return</code> - byte from array if the address is correct</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#write-functions","title":"Write functions","text":""},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_writeint","title":"MEM_WriteInt","text":"<p>Writes int value in the <code>address</code>. <pre><code>func void MEM_WriteInt (var int address, var int val) {};\n</code></pre></p> <ul> <li><code>address</code> - memory address to write into</li> <li><code>val</code> - int value to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_writestring","title":"MEM_WriteString","text":"<p>Writes string in the <code>address</code>. <pre><code>func void MEM_WriteString (var int address, var string val) {};\n</code></pre></p> <ul> <li><code>address</code> - memory address to write into</li> <li><code>val</code> - string to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_writebyte","title":"MEM_WriteByte","text":"<p>Only the byte at address <code>adr</code> is changed here, not a whole four-byte word. That is, the three subsequent bytes remain untouched. If <code>0 &lt;= val &lt; 256</code> does not apply in <code>MEM_WriteByte</code>, a warning is issued and val is trimmed accordingly. In particular, shouldn't be negative numbers are passed. <pre><code>func void MEM_WriteByte (var int adr, var int val) {};\n</code></pre></p> <ul> <li><code>address</code> - memory address to write into</li> <li><code>val</code> - byte to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_writeintarray","title":"MEM_WriteIntArray","text":"<p>Writes int value in the array at <code>arrayAddress</code>. <pre><code>func void MEM_WriteIntArray (var int arrayAddress, var int offset, var int value) {};\n</code></pre></p> <ul> <li><code>arrayAddress</code> - memory address of array</li> <li><code>offset</code> - array offset (array index)</li> <li><code>val</code> - int value to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_writestringarray","title":"MEM_WriteStringArray","text":"<p>Writes string value in the array at <code>arrayAddress</code>. <pre><code>func void MEM_WriteStringArray (var int arrayAddress, var int offset, var string value) {};\n</code></pre></p> <ul> <li><code>arrayAddress</code> - memory address of array</li> <li><code>offset</code> - array offset (array index)</li> <li><code>val</code> - string to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#mem_writebytearray","title":"MEM_WriteByteArray","text":"<p>Writes byte value in the array at <code>arrayAddress</code>. <pre><code>func void MEM_WriteByteArray (var int arrayAddress, var int offset, var int value) {};\n</code></pre></p> <ul> <li><code>arrayAddress</code> - memory address of array</li> <li><code>offset</code> - array offset (array index)</li> <li><code>val</code> - byte to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/mem_access/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/ikarus/mem_access/#usage-of-mem_writeint","title":"Usage of MEM_WriteInt","text":"<p>An example of using MEM_WriteInt is the following Ikarus function, which turns debugging messages on and off: <pre><code>func void MEM_SetShowDebug (var int on)\n{\nMEM_WriteInt(showDebugAddress, on);\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/","title":"LeGo","text":"<p>LeGo (LehonaGottfried) is a script packet built on top of Ikarus.</p> Contacts Author  Lehona, Gottfried &amp; contributors GitHub  LeGo Forum  LeGo <p>Note</p> <p>The code for LeGo is hosted on GitHub and LeGo has its very own documentation page. </p>"},{"location":"zengin/scripts/extenders/lego/ai_function/","title":"AI Function","text":"<p>This package allows time-delayed functions to be called by enqueuing the functions in the AI queue of the NPC in question. This can be very useful for e.g. cutscenes.</p>"},{"location":"zengin/scripts/extenders/lego/ai_function/#dependencies","title":"Dependencies","text":"<ul> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/lego/ai_function/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_AI_Function</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_AI_Function);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/ai_function/#implementation","title":"Implementation","text":"<p> AI_Function.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/ai_function/#functions","title":"Functions","text":"<p>The script function <code>function</code> is called with a delay: it joins the AI queue of <code>slf</code>. <pre><code>func void AI_Function(c_npc slf, func function) {};\n</code></pre></p> <ul> <li><code>slf</code> - NPC in whose AI queue the function is queued</li> <li><code>function</code> - name of function to be queued</li> </ul> <p>Additionally there are some overloads of <code>AI_Function</code>, which allow to call functions with parameters. <pre><code>func void AI_Function_I  (c_npc slf, func function, int    param)                 {}; //Int\nfunc void AI_Function_N  (c_npc slf, func function, int    param)                 {}; //Instance (e.g. NPC)\nfunc void AI_Function_S  (c_npc slf, func function, string param)                 {}; //String\nfunc void AI_Function_II (c_npc slf, func function, int    param1, int    param2) {}; // Int, Int\nfunc void AI_Function_NN (c_npc slf, func function, int    param1, int    param2) {}; // Instance, Instance\nfunc void AI_Function_SS (c_npc slf, func function, string param1, string param2) {}; //String, String\nfunc void AI_Function_IS (c_npc slf, func function, int    param1, string param2) {}; //Int, String\nfunc void AI_Function_SI (c_npc slf, func function, string param1, int    param2) {}; //String, Int\nfunc void AI_Function_NS (c_npc slf, func function, int    param1, string param2) {}; //Instance, String\nfunc void AI_Function_SN (c_npc slf, func function, string param1, int    param2) {}; //String, Istance\nfunc void AI_Function_IN (c_npc slf, func function, int    param1, int    param2) {}; //Int, Instance\nfunc void AI_Function_NI (c_npc slf, func function, int    param1, int    param2) {}; //Instance, Int\n</code></pre> Unfortunately, functions with more than two parameters cannot be called, but parameters can be passed indirectly via global variables.</p> <p>In the called function, <code>slf</code> can be accessed as follows: <pre><code>var oCNpc slf; slf = _^(ECX);\n</code></pre></p> <p>Info</p> <p>From LeGo 2.7.2 the global instance <code>self</code> is provided correctly and can be used directly.</p>"},{"location":"zengin/scripts/extenders/lego/ai_function/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/ai_function/#enqueueing-a-simple-function","title":"Enqueueing a simple function","text":"<p>Before a function is called, any Npc should first complete its AI queue.</p> <p>Here the hero is supposed to run to a waypoint, and only when he has arrived is to start a tracking shot. <pre><code>func void Example1() {\nNpc_ClearAIQueue(hero);\nAI_GotoWP(hero, \"MYWAYPOINT\");\nAI_Function_S(hero, Wld_SendTrigger, \"CAMERASTART\");\n};\n</code></pre> As soon as the hero has reached the waypoint, <code>Wld-SendTrigger(\"CAMERASTART\");</code> is called.</p>"},{"location":"zengin/scripts/extenders/lego/anim8/","title":"Anim8","text":"<p>This package allows int or float values to be \"animated\" over a period of time. It is possible to string several commands together and to set the type of movement. The new version of PrintS from Interface uses Anim8.</p>"},{"location":"zengin/scripts/extenders/lego/anim8/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Anim8</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Anim8);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/anim8/#implementation","title":"Implementation","text":"<p> Anim8.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/anim8/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_new","title":"Anim8_New","text":"<p>Creates a new Anim8 object that can be filled with commands. <pre><code>func int Anim8_New(var int initialValue, var int IsFloat) {};\n</code></pre></p> <ul> <li><code>initialValue</code> - The initial value to start animating from. Can be an integer or an Ikarus float</li> <li><code>IsFloat</code> - If the <code>initialValue</code> is an Ikarus float, this parameter must be set to <code>TRUE</code>. If it is an integer, it must be set to <code>FALSE</code>.</li> <li><code>return</code> - A handle of the Anim8 object.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_newext","title":"Anim8_NewExt","text":"<p>Creates a new Anim8 object with advanced options. Extends the <code>Anim8_New</code> function. <pre><code>func int Anim8_NewExt(var int value, var func handler, var int data, var int IsFloat) {};\n</code></pre></p> <ul> <li><code>value</code> - The initial value to start animating from. Can be an integer or an Ikarus float</li> <li><code>handler</code> - This function is called whenever the object is updated.      The signature of the functions depends on the <code>data</code> value: <code>data != 0</code>: <code>func void handler(var int data, var int value) {};</code>, <code>data == 0</code>: <code>func void handler(var int value) {};</code>.</li> <li><code>data</code>- Optional parameter to send an additional value to the <code>handler</code> function. If <code>data == 0</code>, it is ignored.</li> <li><code>IsFloat</code> - If the <code>initialValue</code> is an Ikarus float, this parameter must be set to <code>TRUE</code>. If it is an integer, it must be set to <code>FALSE</code>.</li> <li><code>return</code> - A handle of the Anim8 object. </li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_delete","title":"Anim8_Delete","text":"<p>Deletes an Anim8 object created with <code>Anim8_New</code>. <pre><code>func void Anim8_Delete(var int hndl) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_get","title":"Anim8_Get","text":"<p>Returns the current value of the object. <pre><code>func int Anim8_Get(var int hndl) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>return</code> - Value of the object</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_set","title":"Anim8_Set","text":"<p>Sets the value of the object. <pre><code>func void Anim8_Set(var int hndl, var int value) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>value</code> - New value of the object</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_empty","title":"Anim8_Empty","text":"<p>Indicates whether the object is empty, i.e. has no more commands to process. <pre><code>func int Anim8_Empty(var int hndl) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>return</code> - <code>TRUE</code> if object is empty (has no more commands), <code>FALSE</code> otherwise.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_removeifempty","title":"Anim8_RemoveIfEmpty","text":"<p>If desired, Anim8 can automatically delete an object after it is empty. <pre><code>func void Anim8_RemoveIfEmpty(var int hndl, var int on) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>on</code> - <code>TRUE</code>: enable, <code>FALSE</code>: disable</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_removedataifempty","title":"Anim8_RemoveDataIfEmpty","text":"<p>With <code>Anim8_NewExt</code> handler and data can be set. If this function is called with <code>TRUE</code>, <code>data</code> is taken as a handle and <code>delete(data)</code> is called if the object is empty. Works only if <code>Anim8_RemoveIfEmpty</code> is also activated. <pre><code>func void Anim8_RemoveDataIfEmpty(var int hndl, var int on) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>on</code> - <code>TRUE</code>: enable, <code>FALSE</code>: disable</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_1","title":"Anim8","text":"<p>Packet core. Gives the object a new command to process. <pre><code>func void Anim8(var int hndl, var int target, var int span, var int interpol) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>target</code> - Target value of this command. When the object's value has reached this value, the command is considered completed and deleted</li> <li><code>span</code> - How many milliseconds should the command last?</li> <li><code>interpol</code> - What form of movement to use? (See constants for this)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8q","title":"Anim8q","text":"<p>As already mentioned above, Anim8 can also process several commands one after the other. While Anim8 completely resets the object and deletes all commands, Anim8q just appends a new command to the list. This will be processed as soon as the previous one is completed. <pre><code>func void Anim8q(var int hndl, var int target, var int span, var int interpol) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>target</code> - Target value of this command. When the object's value has reached this value, the command is considered completed and another one in the queue will start</li> <li><code>span</code> - Action duration in milliseconds</li> <li><code>interpol</code> - What form of movement to use? (See constants for this)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#anim8_callonremove","title":"Anim8_CallOnRemove","text":"<p>Registers a function to be called when the object is deleted (e.g. by <code>Anim8_RemoveIfEmpty</code>) <pre><code>func void Anim8_CallOnRemove(var int hndl, var func dfnc) {};\n</code></pre></p> <ul> <li><code>hndl</code> - Handle returned from <code>Anim8_New</code></li> <li><code>dfnc</code> - This function is called when the object is deleted</li> </ul>"},{"location":"zengin/scripts/extenders/lego/anim8/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/anim8/#count-up-to-a-number","title":"Count up to a number","text":"<p>Count from 0 to 10 in 10 seconds. We use the <code>Print_Ext</code> function from Interface to display the text. <pre><code>func void Example1()\n{\n// First we create a handle to a text:\nvar int MyText; MyText = Print_Ext(20, 20, \"0\", Font_Screen, COL_White, -1);\n// After that we create a new, extended Anim8 object.\n// It gets a handler and the handle to the text as data:\nvar int MyAnim8; MyAnim8 = Anim8_NewExt(0, MyLoop1, MyText, FALSE); // Start value 1, MyLoop1 as handler, MyText as data and no float\n// Now the command to count to 10:\nAnim8(MyAnim8, 10, 10000, A8_Constant); // With MyAnim8 to 10 within 10000ms with constant motion.\n// So that the text and the Anim8 object are deleted after the process. \n// Now we have to do two more things:\nAnim8_RemoveIfEmpty(MyAnim8, TRUE);\nAnim8_RemoveDataIfEmpty(MyAnim8, TRUE);\n};\nfunc void MyLoop1(var int MyText, var int Number)\n{\nvar zCViewText t; t = _^(myText);\n// Now the text is set to the value of the Anim8 object:\nt.text = IntToString(Number);\n// As I said, everything is deleted fully automatically\n};\n</code></pre> A similar example can be found in the Interface examples.</p>"},{"location":"zengin/scripts/extenders/lego/anim8/#moving-zcvob-in-loop","title":"Moving zCVob in loop","text":"<p>And now a bit more Gothic-specific application: I want a vob to constantly move back and forth (without a mover!). FrameFunctions are used for the loop: <pre><code>var zCVob MyVob;\nvar int MyVobAni;\nfunc void Example2()\n{\n// First we use Ikarus to get a pointer to a known VOB:\nMyVob = MEM_PtrToInst(MEM_SearchVobByName(\"MYVOB\"));\n// Of course, there must be a vob with the appropriate name in the world for this.\n// Since the positions of a vob are floats, this time Anim8 must also use floats:\nMyVobAni = Anim8_New(MyVob.trafoObjToWorld[3], TRUE);\n// The X position of the vob serves as the starting value.\n// We will also move it along this axis.\n// Now start a loop that \"nudges\" the vob over and over again:\nFF_Apply(MyVobLoop);\n};\nfunc void MyVobLoop()\n{\n// Just to be safe, we get the pointer to the VOB again\nMyVob = MEM_PtrToInst(MEM_SearchVobByName(\"MYVOB\"));\n// Whenever there are no more commands, we add new ones:\nif(Anim8_Empty(MyVobAni))\n{\n// First move by three meters:\nAnim8(MyVobAni, addf(MyVob.trafoObjToWorld[3], mkf(300)), 1000, A8_SlowEnd);\n// Then wait half a second:\nAnim8q(MyVobAni, 0, 500, A8_Wait);\n// And then back again:\nAnim8q(MyVobAni, MyVob.trafoObjToWorld[3], 1000, A8_SlowEnd);\n// And wait another half a second:\nAnim8q(MyVobAni, 0, 500, A8_Wait);\n// Note the 'q' in the follow-up commands.\n// While Anim8 completely resets the command list, i.e. starts again, Anim8q appends the command to the queue.\n// So you can tinker with a command sequence.\n};\n// Of course, we must set the \"animated\" value to the VOB itself\nMyVob.trafoObjToWorld[3] = Anim8_Get(MyVobAni);\n};\n</code></pre> That's it. A few lines of nice code and no mover. Great. We don't use a handler in this case because it doesn't offer the possibility to check for Anim8_Empty.</p>"},{"location":"zengin/scripts/extenders/lego/bars/","title":"Bars","text":"<p>This package makes it very easy to add new bars, for e.g. stamina.</p>"},{"location":"zengin/scripts/extenders/lego/bars/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> <li>View</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Bars</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Bars);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/bars/#implementation","title":"Implementation","text":"<p> Bars.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/bars/#functions","title":"Functions","text":"<p>Note</p> <p>If the <code>GothicBar</code> prototype is selected as the initial type (<code>GothicBar@</code> as the constructor), the user's own bars are visually indistinguishable from those used in Gothic.</p>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_create","title":"Bar_Create","text":"<p>Creates a new bar from a constructor instance. <pre><code>func int Bar_Create(var int inst) {};\n</code></pre></p> <ul> <li><code>inst</code> - constructor instance of <code>Bar</code> class</li> <li><code>return</code> - handle to the new bar </li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_delete","title":"Bar_Delete","text":"<p>Deletes a bar from the screen and from memory.  <pre><code>func void Bar_Delete(var int bar) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setmax","title":"Bar_SetMax","text":"<p>Changes a bar's maximum value but does not update its bar length (only <code>Bar_SetPercent</code>, <code>Bar_SetPromille</code> and <code>Bar_SetValue</code>) <pre><code>func void Bar_SetMax(var int bar, var int max) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>max</code> - the new maximum value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setvalue","title":"Bar_SetValue","text":"<p>Sets the value of the bar. <pre><code>func void Bar_SetValue(var int bar, var int val) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>val</code> - new value of the bar</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setpercent","title":"Bar_SetPercent","text":"<p>Sets the value of the bar but as a percentage (0..100). <pre><code>func void Bar_SetPercent(var int bar, var int perc) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>perc</code> - new value of the bar in percent</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setpromille","title":"Bar_SetPromille","text":"<p>Sets the value of the bar but per mille (0..1000). <pre><code>func void Bar_SetPromille(var int bar, var int pro) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>pro</code> - new value of the bar in per mille</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_hide","title":"Bar_Hide","text":"<p>Hides a bar. It will not be deleted.  <pre><code>func void Bar_Hide(var int bar) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_show","title":"Bar_Show","text":"<p>Displays a bar again after using <code>Bar_Hide</code>.  <pre><code>func void Bar_Show(var int bar) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_moveto","title":"Bar_MoveTo","text":"<p>Move the bar to virtual position.  <pre><code>func void Bar_MoveTo(var int bar, var int x, var int y) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>x</code> - new horizontal position in virtual coordinates</li> <li><code>y</code> - new vertical position in virtual coordinates</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_movetopxl","title":"Bar_MoveToPxl","text":"<p>Move the bar to pixel position.  <pre><code>func void Bar_MoveToPxl(var int bar, var int x, var int y) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>x</code> - new horizontal position in pixels</li> <li><code>y</code> - new vertical position in pixels</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setalpha","title":"Bar_SetAlpha","text":"<p>Sets the transparency of the bar. <pre><code>func void Bar_SetAlpha(var int bar, var int alpha) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>alpha</code> - transparency value (0..255) </li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setbartexture","title":"Bar_SetBarTexture","text":"<p>Sets the foreground texture of the bar. <pre><code>func void Bar_SetBarTexture(var int bar, var string barTex) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>barTex</code> - the new foreground texture</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setbacktexture","title":"Bar_SetBackTexture","text":"<p>Sets the background texture of the bar. <pre><code>func void Bar_SetBackTexture(var int bar, var string backTex) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>backTex</code> - The new background texture</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_resize","title":"Bar_Resize","text":"<p>Resize an existing bar. <pre><code>func void Bar_Resize(var int bar, var int width, var int height) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>width</code> - new width in virtual coordinates</li> <li><code>height</code> - new height in virtual coordinates</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#bar_resizepxl","title":"Bar_ResizePxl","text":"<p>Resize existing bar (in pixels). <pre><code>func void Bar_ResizePxl(var int bar, var int x, var int y) {};\n</code></pre></p> <ul> <li><code>bar</code> - handle returned from <code>Bar_Create</code></li> <li><code>x</code> - new width in pixels</li> <li><code>y</code> - new height in pixels</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bars/#examples","title":"Examples","text":"<p>Note</p> <p>The bars assume a certain basic understanding of the PermMem module. </p>"},{"location":"zengin/scripts/extenders/lego/bars/#display-a-simple-bar","title":"Display a simple bar","text":"<p>As a first example, let's just create a bar that does nothing. It should only be half full (or half empty?). <pre><code>func void Example_1()\n{\nvar int bar; bar = Bar_Create(GothicBar@); // Create a new bar\nBar_SetPercent(bar, 50);                   // And set the value to 50%\n};\n</code></pre> Finished. Without any settings? And what is <code>GothicBar@</code>? Let's take a look at a more elaborate example.</p>"},{"location":"zengin/scripts/extenders/lego/bars/#a-dedicated-experience-bar","title":"A dedicated experience bar","text":"<p>Bars implement the <code>Bar</code> class. It looks like this: <pre><code>class Bar\n{\nvar int x;          // X position on the screen (middle of the bar)\nvar int y;          // Y position on the screen (middle of the bar)\nvar int barTop;     // Top/bottom margin\nvar int barLeft;    // Left/right margin\nvar int width;      // Bar width\nvar int height;     // Bar height\nvar string backTex; // Background texture\nvar string barTex;  // Actual bar texture\nvar int value;      // Current value\nvar int valueMax;   // Maximum value\n};\n</code></pre> The <code>GothicBar</code> prototype is a bar that mimics the standard Gothic status bar. <pre><code>prototype GothicBar(Bar)\n{\nx = Print_Screen[PS_X] / 2;\ny = Print_Screen[PS_Y] - 20;\nbarTop = 3;\nbarLeft = 7;\nwidth = 180;\nheight = 20;\nbackTex = \"Bar_Back.tga\";\nbarTex = \"Bar_Misc.tga\";\nvalue = 100;\nvalueMax = 100;\n};\n</code></pre></p> <p>It is much easier to set up a new instance using this prototype. <code>GothicBar</code> without modifications can be found as the <code>GothicBar@</code> instance, which we used to create the bar in the example above. <code>GothicBar</code> is located in the middle of the screen and looks exactly like the Gothic underwater bar. But let us make a bar that is located in the top left of the screen and displays players experience points. Derive <code>GothicBar</code> again and only change the position. Of course add a loop using the FrameFunctions: <pre><code>// Instance created from \ninstance Bar_1(GothicBar)\n{\nx = 100;\ny = 20;\n};\nfunc void Example_1()\n{\n// Example_1 could e.g. be called in Init_Global\nFF_ApplyOnce(Loop_1);\n};\nfunc void Loop_1()\n{\n// Example_1 gets this loop running.\n// Here the bar should be constructed once\n// and then adapted to the EXP of the hero:\nvar int MyBar;\nif(!Hlp_IsValidHandle(MyBar))\n{\nMyBar = Bar_Create(Bar_1); // Our Bar_1\n};\n// The rest is probably self-explanatory:\nBar_SetMax(MyBar, hero.exp_next);\nBar_SetValue(MyBar, hero.exp);\n};\n</code></pre></p> <p>Note</p> <p>This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website.</p>"},{"location":"zengin/scripts/extenders/lego/bloodsplats/","title":"Bloodsplats","text":"<p>If this package is activated, red blood splatters will appear on the screen when the hero takes damage. For this, the damage perception for the hero is redirected to <code>_B_HeroDamage()</code>. To use the <code>Bloodsplats</code>, the enclosed textures must be available. Also, the VFX \"HERO_HURT\" (also included) should be entered in the <code>VfxInst.d</code> to create an even better hit effect. All textures used here are from CGTextures.com. If you use <code>Bloodsplats</code> in your modification, this site must be noted in the credits.</p> <p>Tip</p> <p>See user constants to edit behavior of this packet.</p>"},{"location":"zengin/scripts/extenders/lego/bloodsplats/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> <li>View</li> <li>Random</li> <li>Anim8</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bloodsplats/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Bloodsplats</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Bloodsplats);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/bloodsplats/#implementation","title":"Implementation","text":"<p> Bloodsplats.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/bloodsplats/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/bloodsplats/#bloodsplat","title":"Bloodsplat","text":"<p>Puts a blood splatter on the screen. <pre><code>func void Bloodsplat(int damage) {};\n</code></pre></p> <ul> <li><code>damage</code> - the damage (affects the size of the splatter)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/bloodsplats/#bloodsplats_rage","title":"Bloodsplats_Rage","text":"<p>Pretty pointless feature that smears the entire screen. <pre><code>func void Bloodsplats_Rage() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/console_commands/","title":"Console Commands","text":"<p>This package allows you to create new console commands.</p>"},{"location":"zengin/scripts/extenders/lego/console_commands/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/lego/console_commands/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_ConsoleCommands</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_ConsoleCommands);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/console_commands/#implementation","title":"Implementation","text":"<p> ConsoleCommands.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/console_commands/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/console_commands/#cc_register","title":"CC_Register","text":"<p>Registers a new console command. <pre><code>func void CC_Register(var func f, var string cmdPrefix, var string description) {};\n</code></pre></p> <ul> <li><code>f</code> - This function is executed when the <code>cmdPrefix</code> command is entered in the console. The function signature is <code>func string f(var string p0)</code>. The string passed is everything that was specified in the console after the actual command. The return value is then displayed in the console.</li> <li><code>cmdPrefix</code> - This is a command that can be entered in the console.</li> <li><code>description</code> - This text appears next to the command (in zSpy) when you use the <code>help</code> command in the console.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/console_commands/#cc_remove","title":"CC_Remove","text":"<p>Removes a function from the console commands. <pre><code>func void CC_Remove(var func f) {};\n</code></pre></p> <ul> <li>f - This function will be removed, i.e. the associated command will no longer work.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/console_commands/#cc_active","title":"CC_Active","text":"<p>Checks whether the function passed is already part of a console command. <pre><code>func int CC_Active(var func f) {};\n</code></pre></p> <ul> <li><code>f</code> - function being checked</li> <li><code>return</code> - <code>TRUE</code> if there is a corresponding function, <code>FALSE</code> otherwise.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/console_commands/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/console_commands/#basic-command-example","title":"Basic command example","text":"<p>As a basic example - let us create a version command that prints a version of our modification. Firstly, we declare a constant <code>string</code> variable to hold the version string to be shown. <pre><code>const string Mod_Version = \"My mod version 0.1alpha\";\n</code></pre> Next we create the command function.</p> <p>Note</p> <p>Notice the correct function signature. If you do not adhere to the correct function signature, the command will crash the game.</p> <p><pre><code>// This function is called by our console\nfunc string CC_ModVersion (var string param)\n{\nreturn Mod_Version;\n};\n</code></pre> We then have to register the functions. For convenience, I created a new <code>RegisterConsoleFunctions</code> function to initialize all console commands. The function is really simple. <pre><code>func void RegisterConsoleFunctions()\n{\nCC_Register (CC_ModVersion, \"mod_version\", \"Version of my amazing mod.\");\n};\n</code></pre> Lastly, we have to call this function from <code>INIT_GLOBAL</code> function. <pre><code>func void INIT_GLOBAL()\n{\n// will be called for every world (from INIT_&lt;LevelName&gt;)\nGame_InitGerman();\n// Ikarus initialization\nMEM_InitAll();\n// LeGo initialization\nLeGo_Init(LeGo_ConsoleCommands);\n// Here we register all of our commands\nRegisterConsoleFunctions();\n// the rest of the code \n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/","title":"Dialoggestures","text":"<p>This package can modify the NPCs' gestures during dialogue to better bring out emotions.</p>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#dependencies","title":"Dependencies","text":"<ul> <li>AI_Function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#initialization","title":"Initialization","text":"<p>No initialization</p>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#implementation","title":"Implementation","text":"<p> Dialoggestures.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/dialoggestures/#diag","title":"DIAG","text":"<p>With this function the dialog gestures for all NPCs can be overridden. To understand the principle, it is recommended to take a look at the examples. </p> <p>The full name of the animation can be described as follows: <pre><code>DIAG_Prefix + aniName + DIAG_Suffix + ((rand() % (max - (min - 1))) + min).ToString(\"00\");\n</code></pre> <code>DIAG_Prefix</code> and <code>DIAG_Suffix</code> are user constants.</p> <pre><code>func void DIAG(string AniName, int Min, int Max) {};\n</code></pre> <ul> <li><code>AniName</code> - The new dialogue gesture</li> <li><code>Min</code> - Lowest animation number</li> <li><code>Max</code> - Highest animation number</li> </ul>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#diag_reset","title":"DIAG_Reset","text":"<p>Resets the dialog gestures to the default. <pre><code>func void DIAG_Reset() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#diag_setani","title":"DIAG_SetAni","text":"<p>Sets animation directly. <pre><code>func void DIAG_SetAni(var string AniName) {};\n</code></pre></p> <ul> <li><code>AniName</code> - animation name</li> </ul>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#diag_setminmax","title":"DIAG_SetMinMax","text":"<p>Sets animation numbers directly. <pre><code>func void DIAG_SetMinMax(var int min, var int max) {};\n</code></pre></p> <ul> <li><code>min</code> - Lowest animation number</li> <li><code>max</code> - Highest animation number</li> </ul>"},{"location":"zengin/scripts/extenders/lego/dialoggestures/#examples","title":"Examples","text":"<p>Note</p> <p>See Examples in the Trialoge article.</p>"},{"location":"zengin/scripts/extenders/lego/focusnames/","title":"Focusnames","text":"<p>This package colors the focus names of the NPCs in appropriate colors according to the behavior defined below (alpha values are taken into account). Also affects monsters. (Mobs/Items get Color_Neutral)</p>"},{"location":"zengin/scripts/extenders/lego/focusnames/#dependencies","title":"Dependencies","text":"<ul> <li>Interface</li> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/lego/focusnames/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Focusnames</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Focusnames);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/focusnames/#implementation","title":"Implementation","text":"<p> Focusnames.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/focusnames/#usage","title":"Usage","text":"<p>If you want to change colors for any behavior edit the following functions directly in <code>Focusnames.d</code> file.</p>"},{"location":"zengin/scripts/extenders/lego/focusnames/#focusnames_color_friendly","title":"Focusnames_Color_Friendly","text":"<pre><code>func int Focusnames_Color_Friendly()\n{\nreturn RGBA(0,   255, 0,   255); // Green\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/focusnames/#focusnames_color_neutral","title":"Focusnames_Color_Neutral","text":"<pre><code>func int Focusnames_Color_Neutral()\n{\nreturn RGBA(255, 255, 255, 255); // White\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/focusnames/#focusnames_color_angry","title":"Focusnames_Color_Angry","text":"<pre><code>func int Focusnames_Color_Angry()\n{\nreturn RGBA(255, 180, 0,   255); // Orange\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/focusnames/#focusnames_color_hostile","title":"Focusnames_Color_Hostile","text":"<pre><code>func int Focusnames_Color_Hostile()\n{\nreturn RGBA(255, 0,   0,   255); // Red\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/frame_functions/","title":"FrameFunctions","text":"<p>The FrameFunctions package allows to call any number of functions called on every frame, or every spicified time delay.</p>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> <li>PermMem</li> <li>HookEngine</li> <li>Timer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_FrameFunctions</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_FrameFunctions);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#implementation","title":"Implementation","text":"<p> FrameFunctions.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_apply","title":"FF_Apply","text":"<p>Adds the Daedalus function <code>function</code> to the frame functions list. <code>function</code> is called each frame. <pre><code>func void FF_Apply(var func function) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applygt","title":"FF_ApplyGT","text":"<p>Adds the Daedalus function <code>function</code> to the frame function list. <code>function</code> is called every frame except when the game is paused. <pre><code>func void FF_ApplyGT(var func function) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyext","title":"FF_ApplyExt","text":"<p>Adds the Daedalus function <code>function</code> to the frame function list. The function <code>function</code> is called every <code>delay</code> milliseconds and it runs only <code>cycles</code> number of times. <pre><code>func void FF_ApplyExt(var func function, var int delay, var int cycles) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>delay</code> - delay between calls in milliseconds. (0 = every frame)</li> <li><code>cycles</code> - how many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyextgt","title":"FF_ApplyExtGT","text":"<p>Adds the Daedalus function <code>function</code> to the frame function list. The function <code>function</code> is called every <code>delay</code> milliseconds and it runs only <code>cycles</code> number of times. Gets called only when the game is not paused. <pre><code>func void FF_ApplyExtGT(var func function, var int delay, var int cycles) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>delay</code> - delay between calls in milliseconds. (0 = every frame)</li> <li><code>cycles</code> - how many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyextdata","title":"FF_ApplyExtData","text":"<p>Adds the Daedalus function <code>function</code> to the frame function list. The function <code>function</code> is called every <code>delay</code> milliseconds and it runs only <code>cycles</code> number of times. The integer parameter <code>data</code> is passed to the function <code>function</code>.  <pre><code>func void FF_ApplyExtData(var func function, var int delay, var int cycles, var int data) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>delay</code> - delay between calls in milliseconds. (0 = every frame)</li> <li><code>cycles</code> - how many times should the function be called (-1 = endless)</li> <li><code>data</code> - value passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyextdatagt","title":"FF_ApplyExtDataGT","text":"<p>Adds the Daedalus function <code>function</code> to the frame function list. The function <code>function</code> is called every <code>delay</code> milliseconds and it runs only <code>cycles</code> number of times. The integer parameter <code>data</code> is passed to the function <code>function</code>. Gets called only when the game is not paused. <pre><code>func void FF_ApplyExtData(var func function, var int delay, var int cycles, var int data) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>delay</code> - delay between calls in milliseconds. (0 = every frame)</li> <li><code>cycles</code> - how many times should the function be called (-1 = endless)</li> <li><code>data</code> - value passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyonce","title":"FF_ApplyOnce","text":"<p>Alias to FF_Apply, which only adds the function once, even after multiple calls. <pre><code>func void FF_ApplyOnce(var func function) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyoncegt","title":"FF_ApplyOnceGT","text":"<p>Alias to FF_ApplyGT, which only adds the function once, even after multiple calls. Loop doesn't run if the game is paused. <pre><code>func voidoften FF_ApplyOnceGT(var func function) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyonceext","title":"FF_ApplyOnceExt","text":"<p>Alias to FF-ApplyExt, which adds the function only once after repeated calls. <pre><code>func void FF_ApplyOnceExt(var func function, var int delay, var int cycles) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>delay</code> - delay between calls in milliseconds. (0 = every frame)</li> <li><code>cycles</code> - how many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_applyonceextgt","title":"FF_ApplyOnceExtGT","text":"<p>Alias to FF_ApplyExtGT, which adds the function only once after repeated calls. Loop doesn't run if the game is paused. <pre><code>func void FF_ApplyOnceExtGT(var func function, var int delay, var int cycles) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>delay</code> - delay between calls in milliseconds. (0 = every frame)</li> <li><code>cycles</code> - how many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_active","title":"FF_Active","text":"<p>Checks whether the function <code>function</code> is active. <pre><code>func int FF_Active(var func function) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>return</code> - <code>TRUE</code> if the function is active, <code>FALSE</code> if it is not</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_remove","title":"FF_Remove","text":"<p>Removes specified Daedalus function from the list. <pre><code>func void FF_Remove(var func function) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#ff_removedata","title":"FF_RemoveData","text":"<p>Removes specified Daedalus function with the specified value from the list (see <code>FF_ApplyExtData</code> ). <pre><code>func void FF_RemoveData(var func function, var int data) {};\n</code></pre></p> <ul> <li><code>function</code> - name of the function</li> <li><code>data</code> - value previously passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/frame_functions/#a-function-called-every-frame","title":"A function called every frame","text":"<p>In this example function <code>MyFunc</code> will be executed on every frame. <pre><code>func void Example1()\n{\nFF_Apply(MyFunc);\n};\nfunc void MyFunc() {};\n</code></pre> After the <code>Example1</code> function is executed the function <code>MyFunc</code> is called on every frame.</p> <p>The easiest and best way to run a function from the beginning is to call <code>FF-Apply</code> directly in the <code>Init-Globals</code> (under LeGo-Init), there is a small problem: If the game is loaded, <code>Init-Globals</code> is called a second time, the function is added to the list again and is therefore always called twice.</p> <p>To avoid this effect, you should check whether the function is already active: <pre><code>func void Example1()\n{\nif(!FF_Active(MyFunc))\n{\nFF_Apply(MyFunc);\n};\n};\n</code></pre></p> <p>However, since LeGo version 2.2 there is an even more pleasant method to do this: <pre><code>func void Example1()\n{\nFF_ApplyOnce(MyFunc);\n};\n</code></pre> <code>FF_ApplyOnce</code> function already implements the check for function activity.</p>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#calling-delayed-function","title":"Calling delayed function","text":"<p>Let's create a function, that is called once after 3 seconds. <pre><code>func void Example2()\n{\nFF_ApplyExt(MyFunc2, 3000, 1); // 3000 ms = 3 s, this function is called only once\n};\nfunc void MyFunc2() {};\n</code></pre></p> <p>There is also a <code>Once</code> variant of this function, that prevents adding it twice into the frame function list. <pre><code>func void Example2()\n{\nFF_ApplyOnceExt(MyFunc2, 3000, 1);\n};\n</code></pre></p> <p>Note</p> <p><code>FF_ApplyExt(MyFunc, 0, -1)</code> is the same as <code>FF_Apply(MyFunc)</code>.</p>"},{"location":"zengin/scripts/extenders/lego/frame_functions/#framefunction-with-timer","title":"FrameFunction with Timer","text":"<p>Since LeGo 2.2, FrameFunctions package uses the Timer package, so it's possible to pause FrameFunctions at will: <pre><code>func void Example3()\n{\nFF_ApplyOnceExt(MyFunc3, 4000, 2);\n};\nfunc void MyFunc3()\n{\nTimer_SetPaused(!Timer_GetPaused());\n};\n</code></pre> This would pause the timer after 4 seconds and let it continue after 8 seconds.</p> <p>Warning</p> <p>Because the timer doesn't run, the frame function execution is stopped as well. This script won't work. If the timer is to be paused, it must be paused outside of FrameFunctions.</p> <p>Note</p> <p>This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website</p>"},{"location":"zengin/scripts/extenders/lego/gamestate/","title":"Gamestate","text":"<p>Gamestate package allows to check for different game states (game start, game load or level change).</p>"},{"location":"zengin/scripts/extenders/lego/gamestate/#dependencies","title":"Dependencies","text":"<ul> <li>EventHandler</li> <li>Saves</li> </ul>"},{"location":"zengin/scripts/extenders/lego/gamestate/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Gamestate</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Gamestate);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/gamestate/#implementation","title":"Implementation","text":"<p> Gamestate.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/gamestate/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/gamestate/#gamestate_addlistener","title":"Gamestate_AddListener","text":"<p>Adds a listener/handler to the game-state event. <pre><code>func void Gamestate_AddListener(var func listener) {};\n</code></pre></p> <ul> <li><code>listener</code> - This function will be called on a game-state change. The current game-state is passed as a parameter.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/gamestate/#gamestate_removelistener","title":"Gamestate_RemoveListener","text":"<p>Removes game-state listener. <pre><code>func void Gamestate_RemoveListener(var func listener) {};\n</code></pre></p> <ul> <li><code>listener</code> - listener function to be removed.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/gamestate/#examples","title":"Examples","text":"<p>There are now two possibilities: either you do it directly into the Init-Global, or you use the EventHandler.</p>"},{"location":"zengin/scripts/extenders/lego/gamestate/#init_global","title":"Init_Global","text":"<pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame) {\nMEM_Info(\"New game started.\");\n}\nelse if(Gamestate == Gamestate_Loaded)\n{\nMEM_Info(\"Game loaded.\");\n}\nelse if(Gamestate == Gamestate_WorldChange)\n{\nMEM_Info(\"Worldshift.\");\n}\nelse\n{\nMEM_Info(\"I don't pass.\");\n};\n};\n</code></pre> <p>This might be useful when working with PermMem, where PermMem objects do not need to be recreated after the game loads.</p> <p>You can also think up something like this: <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame)\n{\nFF_Apply(MyLoop);\nFF_Apply(My2ndLoop);\n};\n};\n</code></pre> This would have the same effect as: <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nFF_ApplyOnce(MyLoop);\nFF_ApplyOnce(My2ndLoop);\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/gamestate/#event-handler","title":"Event Handler","text":"<p>It is quickly explained: <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nGamestate_AddListener(MyGamestateListener);\n};\nfunc void MyGamestateListener(var int state)\n{\nif(state == Gamestate_NewGame)\n{\nMEM_Info(\"New game started.\");\n}\nelse if(state == Gamestate_Loaded)\n{\nMEM_Info(\"Game loaded.\");\n}\nelse if(state == Gamestate_WorldChange)\n{\nMEM_Info(\"Worldshift.\");\n}\nelse\n{\nMEM_Info(\"I don't pass.\");\n};\n};\n</code></pre> This is the same as the <code>Init_Global</code> example, but it may look more elegant to some.</p> <p>Note</p> <p>This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website</p>"},{"location":"zengin/scripts/extenders/lego/int64/","title":"Int64","text":"<p>Int64 implements basic arithmetic for 64-bit integers based on machine code (hence the function signatures are also in machine code style). Furthermore, Int64 offers the constructor int64@ for Int64 objects, but mk64 expects a pointer, not a handle.</p>"},{"location":"zengin/scripts/extenders/lego/int64/#dependencies","title":"Dependencies","text":"<p>No dependencies</p>"},{"location":"zengin/scripts/extenders/lego/int64/#initialization","title":"Initialization","text":"<p>No Initialization</p>"},{"location":"zengin/scripts/extenders/lego/int64/#implementation","title":"Implementation","text":"<p> Int64.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/int64/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/int64/#mk64","title":"mk64","text":"<p>Writes <code>lo</code> and <code>hi</code> in one place (dest). Makes Int64, <code>hi</code> has to be <code>-1</code> for negative 32bit <code>lo</code>. <pre><code>func void mk64(var int dest, var int hi, var int lo) {};\n</code></pre></p> <ul> <li><code>dest</code> - A pointer to an Int64 object or just 8 bytes of free memory.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/int64/#neg64","title":"neg64","text":"<p>Negates the integer: <code>*dest &lt;- -(*dest)</code> <pre><code>func void neg64(var int dest) {};\n</code></pre></p> <ul> <li><code>dest</code> - A pointer to an Int64 object or just 8 bytes of free memory.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/int64/#add64","title":"add64","text":"<p>Adds <code>src</code> to <code>dest</code>: <code>*dest &lt;- *dest + *src</code> <pre><code>func void add64(var int dest, var int src) {};\n</code></pre></p> <ul> <li><code>dest</code> - A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>src</code> - A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/int64/#sub64","title":"sub64","text":"<p>Subtracts <code>src</code> from <code>dest</code>: <code>*dest &lt;- *dest - *src</code> <pre><code>func void sub64(var int dest, var int src) {};\n</code></pre></p> <ul> <li><code>dest</code> - A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>src</code> - A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/int64/#mul64","title":"mul64","text":"<p>Multiplies <code>dest</code> by <code>src</code>: <code>*dest &lt;- (*dest) * (*src)</code> <pre><code>func void mul64(var int dest, var int src) {};\n</code></pre></p> <ul> <li><code>dest</code> - A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>src</code> - A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/int64/#div64","title":"div64","text":"<p>Divides <code>dest</code> by <code>src</code>: <code>*dest &lt;- *dest / *src</code> <pre><code>func void mul64(var int dest, var int src) {};\n</code></pre></p> <ul> <li><code>dest</code> - A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>src</code> - A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/item_helper/","title":"ItemHelper","text":"<p>This package is very simple - it retrieves a <code>oCItem</code> pointer from an <code>C_Item</code> instance valid for the current world and session.</p> <p>Warning</p> <p>Make sure every world has waypoint with name <code>TOT</code> (\"dead\" in German). Ikarus &amp; LeGo need this waypoint to spawn helper NPCs. This is especially important in Gothic 1 since G1 vanilla worlds do not have the <code>TOT</code> waypoint.</p>"},{"location":"zengin/scripts/extenders/lego/item_helper/#dependencies","title":"Dependencies","text":"<p>No dependencies</p>"},{"location":"zengin/scripts/extenders/lego/item_helper/#initialization","title":"Initialization","text":"<p>No initialization</p>"},{"location":"zengin/scripts/extenders/lego/item_helper/#implementation","title":"Implementation","text":"<p> ItemHelper.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/item_helper/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/item_helper/#itm_getptr","title":"ITM_GetPtr","text":"<pre><code>func int ITM_GetPtr(var int instance) {};\n</code></pre> <ul> <li><code>instance</code>- <code>C_Item</code> instance to get the pointer of</li> <li><code>return</code>- <code>oCItem</code> pointer of the <code>C_Item</code> instance</li> </ul>"},{"location":"zengin/scripts/extenders/lego/locals/","title":"Locals","text":"<p>Daedalus doesn't offer any local variables, which can quickly lead to problems with recursive functions. Locals allows variables to be saved temporarily on a pseudo-stack. Locals is a very specific package. People who work normally with Daedalus will never really need it. There is also the <code>final</code> function, which can be used to emulate something similar to the <code>final</code> clause in Java.</p>"},{"location":"zengin/scripts/extenders/lego/locals/#dependencies","title":"Dependencies","text":"<ul> <li>StringBuilder</li> </ul>"},{"location":"zengin/scripts/extenders/lego/locals/#initialization","title":"Initialization","text":"<p>No initialization</p>"},{"location":"zengin/scripts/extenders/lego/locals/#implementation","title":"Implementation","text":"<p> Locals.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/locals/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/locals/#locals_1","title":"Locals","text":"<p>All that has to be done to enable the <code>Locals</code> is to write this function at the beginning of the function that should receive \"real\" local variables. <pre><code>func void locals() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/locals/#final","title":"Final","text":"<p>It's hard to explain how to use it, but very easy to understand once you've seen an example. <pre><code>func int Final() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/locals/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/locals/#final_1","title":"Final","text":"<p>With <code>final()</code> it is very easy to emulate Java's <code>final</code> clause, i.e. a block of code can be specified that is executed after this function is exited, regardless of when or where the function is exited. <pre><code>func void testFinal()\n{\nif (final())\n{\nMEM_InfoBox(\"Final was called.\");\n};\nMEM_InfoBox(\"This will appear before Final\");\n};\n</code></pre> Few lines of code say more than a thousand words.</p>"},{"location":"zengin/scripts/extenders/lego/misc/","title":"Misc","text":"<p>The Misc package introduces various helper functions that did not fit into any other package.</p>"},{"location":"zengin/scripts/extenders/lego/misc/#dependencies","title":"Dependencies","text":"<p>No dependencies</p>"},{"location":"zengin/scripts/extenders/lego/misc/#initialization","title":"Initialization","text":"<p>No initialization</p>"},{"location":"zengin/scripts/extenders/lego/misc/#implementation","title":"Implementation","text":"<p> Misc.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/misc/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/misc/#atan2f","title":"atan2f","text":"<p>Calculates the arcus tangent of an angle between the origin and (x, y) point <pre><code>func float atan2f(var int x, var int y) {};\n</code></pre></p> <ul> <li><code>x</code> -  x-coordinate</li> <li><code>y</code> -  y-coordinate</li> <li><code>return</code> - arcus tangent in radians as Ikarus <code>float</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/misc/#sin","title":"sin","text":"<p>Calculates the sine of an angle given in radians. <pre><code>func float sin (var float angle) {};\n</code></pre></p> <ul> <li><code>angle</code> - the angle in radians as a Ikarus <code>float</code></li> <li><code>return</code> - sine of the angle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/misc/#cos","title":"cos","text":"<p>Calculates the cosine of an angle given in radians. <pre><code>func float cos (var float angle) {};\n</code></pre></p> <ul> <li><code>angle</code> - the angle in radians as a Ikarus <code>float</code></li> <li><code>return</code> - cosine of the angle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/misc/#tan","title":"tan","text":"<p>Calculates the tangent of an angle given in radians. <pre><code>func float tan (var float angle) {};\n</code></pre></p> <ul> <li><code>angle</code> - the angle in radians as a Ikarus <code>float</code></li> <li><code>return</code> - tangent of the angle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/misc/#asin","title":"asin","text":"<p>Calculates the arcus sine <pre><code>func float asin (var float sine) {};\n</code></pre></p> <ul> <li><code>sine</code> - the sine of an angle</li> <li><code>return</code> - arcus sine of the angle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/misc/#acos","title":"acos","text":"<p>Calculates the arcus cosine <pre><code>func float acos (var float cosine) {};\n</code></pre></p> <ul> <li><code>sine</code> - the cosine of an angle</li> <li><code>return</code> - arcus cosine of the angle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/misc/#distance2d","title":"distance2D","text":"<p>Calculates the distance between two points on a two-dimensional plane <pre><code>func int distance2D(var int x1, var int x2, var int y1, var int y2) {};\n</code></pre></p> <ul> <li><code>x1</code> - X-coordinate of the first point</li> <li><code>x2</code> - X-coordinate of the second point</li> <li><code>y1</code> - Y-coordinate of the first point</li> <li><code>y2</code> - Y-coordinate of the second point</li> <li><code>return</code> - the distance between the two points</li> </ul>"},{"location":"zengin/scripts/extenders/lego/misc/#distance2df","title":"distance2Df","text":"<p>Calculates the distance between two points on a two-dimensional plane as Ikarus <code>floats</code> <pre><code>func float distance2Df(var float x1, var float x2, var float y1, var float y2) {};\n</code></pre></p> <ul> <li><code>x1</code> - X-coordinate of the first point</li> <li><code>x2</code> - X-coordinate of the second point</li> <li><code>y1</code> - Y-coordinate of the first point</li> <li><code>y2</code> - Y-coordinate of the second point</li> <li><code>return</code> - the distance between the two points as Ikarus <code>float</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/names/","title":"Names","text":"<p>Allows the user to change NPC name e.g. after he shows up.</p>"},{"location":"zengin/scripts/extenders/lego/names/#dependencies","title":"Dependencies","text":"<p>No dependencies</p>"},{"location":"zengin/scripts/extenders/lego/names/#initialization","title":"Initialization","text":"<p>No Initialization</p>"},{"location":"zengin/scripts/extenders/lego/names/#implementation","title":"Implementation","text":"<p> Names.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/names/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/names/#setname","title":"SetName","text":"<p>Should be set in InitGlobal(). <pre><code>func void SetName(c_npc npc, string name) {};\n</code></pre></p> <ul> <li><code>npc</code> - The NPC to be named</li> <li><code>name</code> - The name of the NPC</li> </ul>"},{"location":"zengin/scripts/extenders/lego/names/#showname","title":"ShowName","text":"<p>Permanently displays the name set by <code>SetName</code> function above the npc. <pre><code>func void ShowName(c_npc npc) {};\n</code></pre></p> <ul> <li><code>npc</code> - The NPC whose name should be shown</li> </ul>"},{"location":"zengin/scripts/extenders/lego/names/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/names/#show-the-name-of-an-npc-later","title":"Show the name of an NPC later","text":"<p><pre><code>instance PAL_100_Friend(c_npc)\n{\nname = \"Paladin\";\n// [...]\n};\nfunc void Init_Global()\n{\nSetName(PAL_100_Friend, \"Arto\");\n};\n</code></pre> At the start of the game, the name \"Paladin\" is displayed above <code>PAL_100_Friend</code>.</p> <p>If <code>ShowName(PAL_100_Friend);</code> is used during a dialogue, the name \"Arto\" is permanently visible above the npc.</p>"},{"location":"zengin/scripts/extenders/lego/random/","title":"Random","text":"<p>Provides more random randomization than <code>Hlp_Random()</code> function.</p>"},{"location":"zengin/scripts/extenders/lego/random/#dependencies","title":"Dependencies","text":"<p>No dependencies</p>"},{"location":"zengin/scripts/extenders/lego/random/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Random</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Random);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/random/#implementation","title":"Implementation","text":"<p> Random.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/random/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/random/#r_next","title":"r_Next","text":"<p>Returns a random number. <pre><code>func int r_Next() {};\n</code></pre></p> <ul> <li><code>return</code> - random number</li> </ul>"},{"location":"zengin/scripts/extenders/lego/random/#r_max","title":"r_Max","text":"<p>Returns a random number from 0 to 'max'. <pre><code>func int r_Max(int max) {};\n</code></pre></p> <ul> <li><code>max</code> - maximum value</li> <li><code>return</code> - random number in the specified range</li> </ul>"},{"location":"zengin/scripts/extenders/lego/random/#r_minmax","title":"r_MinMax","text":"<p>Returns a random number from 'min' to 'max'. <pre><code>func int r_MinMax(int min, int max) {};\n</code></pre></p> <ul> <li><code>min</code> - minimum value</li> <li><code>max</code> - maximum value</li> <li><code>return</code> - random number in the specified range</li> </ul>"},{"location":"zengin/scripts/extenders/lego/random/#r_init","title":"r_Init","text":"<p>Initializes the random number generator. Happens optionally in <code>LeGo_Init</code>. <pre><code>func void r_Init(int seed) {};\n</code></pre></p> <ul> <li><code>initVal</code> - seed value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/random/#r_defaultinit","title":"r_DefaultInit","text":"<p>Initializes the random number generator based on the current time. <pre><code>func void r_DefaultInit() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/talents/","title":"Talents","text":"<p>The Talents package does two things:</p> <ol> <li>save any number of values for a specific NPC (effectively AIVar array extension).</li> <li>identify NPC by unique ID.</li> </ol> <p>Talents package uses one free AIVar variables, the default is AIVar with the index 89 that can be customized in <code>Userconst.d</code> the <code>AIV_TALENT</code> constant.</p>"},{"location":"zengin/scripts/extenders/lego/talents/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> </ul>"},{"location":"zengin/scripts/extenders/lego/talents/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_PermMem</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_PermMem);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/talents/#implementation","title":"Implementation","text":"<p> Talents.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/talents/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/talents/#npc_getid","title":"NPC_GetID","text":"<p>Returns unique ID specific for provided NPC.</p> <pre><code>func int NPC_GetID(var c_npc slf) {};\n</code></pre> <ul> <li><code>slf</code> NPC</li> <li><code>return</code> NPCs unique ID</li> </ul>"},{"location":"zengin/scripts/extenders/lego/talents/#npc_findbyid","title":"NPC_FindByID","text":"<p>Finds the NPC pointer of an NPC with the given ID. <pre><code>func int NPC_FindByID(var int ID) {};\n</code></pre></p> <ul> <li><code>ID</code> - NPC ID</li> <li><code>return</code> - NPC pointer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/talents/#tal_createtalent","title":"TAL_CreateTalent","text":"<p>Creates a talent into which you can later save a value for every NPC (just like AI_Var). <pre><code>func int TAL_CreateTalent() {};\n</code></pre></p> <ul> <li><code>return</code> - Value that can be later used as a talent index</li> </ul>"},{"location":"zengin/scripts/extenders/lego/talents/#tal_setvalue","title":"TAL_SetValue","text":"<p>Sets a new value to the specified talent. <pre><code>func void TAL_SetValue(var c_npc npc, var int talent, var int value) {};\n</code></pre></p> <ul> <li><code>npc</code> - Set the talent value for this NPC</li> <li><code>talent</code> - Talent ID</li> <li><code>value</code> - Value to be set</li> </ul>"},{"location":"zengin/scripts/extenders/lego/talents/#tal_getvalue","title":"TAL_GetValue","text":"<p>Returns the value of a saved talent for specified NPC. <pre><code>func int TAL_GetValue(var c_npc npc, var int talent) {};\n</code></pre></p> <ul> <li><code>npc</code> - Get the talent value from this NPC</li> <li><code>talent</code> - Talent ID</li> </ul>"},{"location":"zengin/scripts/extenders/lego/timer/","title":"Timer","text":"<p>Timer is a better alternative to the timers that Gothic offers. The FrameFunctions and Anim8 packages are already based on it. It isn't possible to modify the current time, as this would only cause difficulties.</p>"},{"location":"zengin/scripts/extenders/lego/timer/#dependencies","title":"Dependencies","text":"<p>No dependencies</p>"},{"location":"zengin/scripts/extenders/lego/timer/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Timer</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Timer);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/timer/#implementation","title":"Implementation","text":"<p> Timer.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/timer/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/timer/#timer_1","title":"Timer","text":"<p>Returns the current playing time. If a new game is started, the time is 0. It is measured in milliseconds. <pre><code>func int Timer() {};\n</code></pre></p> <ul> <li><code>return</code> - Current playing time in milliseconds</li> </ul>"},{"location":"zengin/scripts/extenders/lego/timer/#timergt","title":"TimerGT","text":"<p>Returns the current game time, but the timer is paused when the game is paused (in the menu or status screen). <pre><code>func int TimerGT() {};\n</code></pre></p> <ul> <li><code>return</code> - Current playing time in milliseconds</li> </ul>"},{"location":"zengin/scripts/extenders/lego/timer/#timerf","title":"TimerF","text":"<p>Alias to <code>Timer</code> function that returns the time as an Ikarus float value. <pre><code>func int TimerF() {};\n</code></pre></p> <ul> <li><code>return</code> - Current playing time as an Ikarus float value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/timer/#timer_setpause","title":"Timer_SetPause","text":"<p>Pauses the timer (and thus all FrameFunctions and running animations). <pre><code>func void Timer_SetPause(int on) {};\n</code></pre></p> <ul> <li><code>on</code> - pause on/off</li> </ul>"},{"location":"zengin/scripts/extenders/lego/timer/#timer_setpauseinmenu","title":"Timer_SetPauseInMenu","text":"<p>The timer can automatically pause when the game is paused. (status screen, main menu...) <pre><code>func void Timer_SetPauseInMenu(int on) {};\n</code></pre></p> <ul> <li><code>on</code> - automatic pause on/off</li> </ul>"},{"location":"zengin/scripts/extenders/lego/timer/#timer_ispaused","title":"Timer_IsPaused","text":"<p>This can be used to query whether the timer is currently paused. <pre><code>func int Timer_IsPaused() {};\n</code></pre></p> <ul> <li><code>return</code> - <code>TRUE</code> if the timer is paused, <code>FALSE</code> otherwise</li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/","title":"Trialoge","text":"<p>This package allows you to create conversations with any number of NPCs and control the camera during the dialog.</p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#dependencies","title":"Dependencies","text":"<ul> <li>AI_Function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Trialoge</code> flag. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Trialoge);\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#implementation","title":"Implementation","text":"<p> Trialoge.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/trialoge/#equipweapon","title":"EquipWeapon","text":"<p>Sektenspinner's function. (Taken from the forum.)  <pre><code>func void EquipWeapon(var c_npc slf, var int ItemInstance) {};\n</code></pre></p> <ul> <li><code>slf</code> - NPC to have a weapon equipped</li> <li><code>ItemInstance</code> - weapon instance to be equipped</li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/#npc_getarmor","title":"Npc_GetArmor","text":"<p>Returns NPC's equipped armor. <pre><code>func int Npc_GetArmor(var c_npc slf) {};\n</code></pre></p> <ul> <li><code>slf</code> - NPC to get the armour from</li> <li><code>return</code> - armor instance</li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/#npc_getmeleeweapon","title":"Npc_GetMeleeWeapon","text":"<p>Returns NPC's equipped melee weapon. <pre><code>func int Npc_GetMeleeWeapon(var c_npc slf) {};\n</code></pre></p> <ul> <li><code>slf</code> - NPC to get the weapon from</li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/#diacam_update","title":"DiaCAM_Update","text":"<p>Sektenspinner's function. Updates the dialogue camera. (Used internally.) <pre><code>func void DiaCAM_Update() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#diacam_disable","title":"DiaCAM_Disable","text":"<p>Completely disable the dialogue cameras. <pre><code>func void DiaCAM_Disable() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#diacam_enable","title":"DiaCAM_Enable","text":"<p>Resets the dialogue cameras to the default settings. <pre><code>func void DiaCAM_Enable() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_wait","title":"TRIA_Wait","text":"<p>Makes <code>self</code> and <code>other</code> wait for each other, e.g. for <code>AI_GotoW</code>P actions for synchronization.  <pre><code>func void TRIA_Wait() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_invite","title":"TRIA_Invite","text":"<p>Invites an NPC into a conversation. Must be called before <code>TRIA_Start</code>. <pre><code>func void TRIA_Invite(c_npc slf) {};\n</code></pre></p> <ul> <li><code>slf</code> - The invited NPC</li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_start","title":"TRIA_Start","text":"<p>Starts trialogues. Before that, all NPC's should be invited by <code>TRI_Invite</code>. <pre><code>func void TRIA_Start() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_barrier","title":"TRIA_Barrier","text":"<p>Similar to <code>TRIA_Wait</code> but applies to all participating NPCs. <pre><code>func void TRIA_Barrier() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_next","title":"TRIA_Next","text":"<p>Sets the called npc to <code>self</code>. <pre><code>func void TRIA_Next(c_npc n0) {};\n</code></pre></p> <ul> <li><code>n0</code> - can be addressed with <code>self</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_cam","title":"TRIA_Cam","text":"<p>Starts a tracking shot.  <pre><code>func void TRIA_Cam(string evt) {};\n</code></pre></p> <ul> <li><code>evt</code> - the name of the tracking shot in Spacer. If <code>\"\"</code> is passed, the running trace shot will be aborted</li> </ul>"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_finish","title":"TRIA_Finish","text":"<p>Ends an ongoing trialogue. Must always be called at the end, otherwise no further trialogues can be started. <pre><code>func void TRIA_Finish() {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/lego/trialoge/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/trialoge/#a-simple-trialogue","title":"A Simple Trialogue","text":"<p>The following conversation is resolved via the trialogues:</p> <ol> <li>Arto:    Sorry hero, but you can't pass here</li> <li>Hero:    Why not?</li> <li>Horka:   The city has been closed.</li> <li>Hero:    I have some gold with me, can we trade?</li> <li>Squelto: No. We are not open to bribery.</li> <li>Hero:    Sure?</li> <li>Arto:    I have to ask you to leave now</li> <li>Hero:    Well... <pre><code>instance TRIA_Test (C_INFO)\n{\nnpc         = PAL_100_Friend;\nnr          = 10;\ncondition   = TRIA_Test_condition;\ninformation = TRIA_Test_info;\nimportant   = FALSE;\npermanent   = 1;\ndescription = \"TRIALOGTEST\";\n};\nfunc int TRIA_Test_condition()\n{\nreturn TRUE;\n};\nfunc void TRIA_Test_info()\n{\nvar c_npc Arto; Arto       = Hlp_GetNpc(PAL_100_Friend); // He is the owner of dialogue\nvar c_npc Horka; Horka     = Hlp_GetNpc(PAL_101_Horka);\nvar c_npc Squelto; Squelto = Hlp_GetNpc(PAL_102_Squelto);\nTRIA_Invite(Horka);   // Invite Horka into this dialogue\nTRIA_Invite(Squelto); // Invite Squelto into this dialog\nTRIA_Start();         // Start the conversation\n// The hero and Arto do not have to/may not be invited. They are in dialogue anyway.\n// Hero now talks to Arto (self = Arto, other = Hero)\nTRIA_Next(Arto);\nDIAG_Reset();\nAI_Output (self, other, \"TRIA_TEST_00\"); //Sorry hero, but you can't pass here\n// Hero now talks to Horka (self = Horka, other = Hero)\nTRIA_Next(Horka);\nAI_Output (other, self, \"TRIA_TEST_01\"); //Why not?\nAI_GotoNpc(self, other);\nAI_TurnToNpc(other, self);\nAI_Output (self, other, \"TRIA_TEST_02\"); //The city has been closed.\n// Held looks around conspiratorially during the next sentence\nDIAG(\"Nervous\", 1, 2);\nAI_Output (other, self, \"TRIA_TEST_03\"); //I have some gold with me, can we trade?\n// Hero should now move normally again\nDIAG_Reset();\n// Start tracking shot\nTRIA_Cam(\"CAMERASTART\");\n// Hero now talks to Squelto (self = Squelto, other = Hero)\nTRIA_Next(Squelto);\nAI_TurnToNpc(other, self);\nDIAG(\"No\", 0, 1);\nAI_Output (self, other, \"TRIA_TEST_04\"); //No. We are not open to bribery.\n// Hero talks to Arto again (self = Arto, other = Hero)\nTRIA_Next(Arto);\n// Hero should now articulate questioningly\nDIAG(\"NotSure\", 0, 1);\nAI_Output (other, self, \"TRIA_TEST_05\"); //Sure?\nAI_TurnToNpc(other, self);\n// tracking shot end\nTRIA_Cam(\"\");\n// Arto should react angrily\nDIAG(\"Angry\", 0, 4);\nAI_Output (self, other, \"TRIA_TEST_06\"); //I have to ask you to leave now\n// Hero should now move normally again\nDIAG_Reset();\nAI_Output (other, self, \"TRIA_TEST_07\"); //Well...\nTRIA_Finish(); // End\n};\n</code></pre></li> </ol> <p>Note</p> <p>In addition, here are still dialog gestures used.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/","title":"User constants","text":"<p>All constants that the user can either use or even change freely are defined in Userconst.d file.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#read-only","title":"Read only","text":"<p>These constants may only be used, not changed.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#anim8","title":"Anim8","text":"<p>These constants are used by Anim8 and Anim8q.</p> <ul> <li><code>A8_Constant</code> - Constant movement speed</li> <li><code>A8_SlowEnd</code> - Evenly decelerated movement</li> <li><code>A8_SlowStart</code> - Evenly accelerated movement</li> <li><code>A8_Wait</code> - Do nothing. The target value is ignored here</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#buttons","title":"Buttons","text":"<p>The following bit masks can be applied to the status of a button:</p> <ul> <li><code>int BUTTON_ACTIVE</code> - The button is active, it reacts to the mouse</li> <li><code>int BUTTON_ENTERED</code> - The mouse is \"within\" the button</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#interface","title":"Interface","text":"<p>Dimensions:</p> <ul> <li><code>PS_X</code>, <code>PS_Y</code> - Use with <code>Print_Screen</code> or <code>Print_ToVirtual</code> functions</li> <li><code>PS_VMax</code> - Highest possible value of a virtual coordinate</li> </ul> <p>16 basic colors that can be used as <code>zColor</code> parameters:</p> <ul> <li><code>COL_Aqua</code></li> <li><code>COL_Black</code></li> <li><code>COL_Blue</code></li> <li><code>COL_Fuchsia</code></li> <li><code>COL_Gray</code></li> <li><code>COL_Green</code></li> <li><code>COL_Lime</code></li> <li><code>COL_Maroon</code></li> <li><code>COL_Navy</code></li> <li><code>COL_Olive</code></li> <li><code>COL_Purple</code></li> <li><code>COL_Red</code></li> <li><code>COL_Silver</code></li> <li><code>COL_Teal</code></li> <li><code>COL_White</code></li> <li><code>COL_Yellow</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#gamestate","title":"Gamestate","text":"<p>Gamestate can assume these values:</p> <ul> <li><code>Gamestate_NewGame</code> - New game started</li> <li><code>Gamestate_Loaded</code> - A game has been loaded</li> <li><code>Gamestate_WorldChange</code> - The world has changed</li> <li><code>Gamestate_Saving</code> - The game is saved</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#cursor","title":"Cursor","text":"<p>These constants are sent with Cursor_Event:</p> <ul> <li><code>CUR_LeftClick</code> - The left mouse button was pressed</li> <li><code>CUR_RightClick</code> - The right mouse button was pressed</li> <li><code>CUR_MidClick</code> - The middle mouse button was pressed</li> <li><code>CUR_WheelUp</code> - Mouse wheel up</li> <li><code>CUR_WheelDown</code> - Mouse wheel down</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#modifiable","title":"Modifiable","text":"<p>These constants are often used by packages and may be changed freely.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#bloodsplats","title":"Bloodsplats","text":"<p>This constant is only used in Bloodsplats_Rage:</p> <ul> <li> <p><code>Bloodsplat_Num</code> - Maximum number on screen</p> </li> <li> <p><code>Bloodsplat_Tex</code> - Highest Texture ID (<code>\"BLOODSPLAT\" + texID + \".TGA\"</code>)</p> </li> <li><code>Bloodsplat_Dam</code> - Texture size damage multiplier (<code>damage * 2</code><code>Bloodsplat_Dam</code>)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#cursor_1","title":"Cursor","text":"<ul> <li><code>Cursor_Texture</code> - This texture is used to display the cursor (default: \"CURSOR.TGA\")</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#interface_1","title":"Interface","text":"<ul> <li><code>Print_LineSeparator</code> - Text boxes can be printed in multiple lines. This character separates the lines from each other.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#prints","title":"PrintS","text":"<p>All position and size information is completely virtual:</p> <ul> <li><code>PF_PrintX</code> - Start position on the X axis</li> <li><code>PF_PrintY</code> - Start position on the Y axis</li> <li><code>PF_TextHeight</code> - Space between individual lines</li> </ul> <p>The times are given in ms:</p> <ul> <li><code>PF_FadeInTime</code> - Time to fade in the text</li> <li><code>PF_FadeOutTime</code> - Time to fade out the text</li> <li><code>PF_MoveYTime</code> - Time needed to \"slip down\"</li> <li><code>PF_WaitTime</code> - Time during which the print is fully visible</li> </ul> <p>Finally, the font can be modified:</p> <ul> <li><code>PF_Font</code> - Default: \"FONT_OLD_10_WHITE.TGA\"</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#names","title":"Names","text":"<ul> <li><code>AIV_Name</code> - Used AIVar (default:89)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#dialoggestures","title":"Dialoggestures","text":"<ul> <li><code>DIAG_Prefix</code> - Animation prefix (\"DG_\")</li> <li><code>DIAG_Suffix</code> - Animation suffix (\"_\")</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/","title":"zParserExtender","text":"<p>zParserExtender extends ZenGins parser and adds many useful features. It significantly extends the functionality of scripts with added functionality and new external functions. It also enhances script compilation, allowing to compile OU files directly with the game and allowing for runtime script injection. Since the Union version <code>1.0m</code> zParserExtender is fully integrated in Union itself.</p> <p>Note</p> <p>This is mostly a translation of the original release post</p> Contacts Author  Gratt GitHub  zParserExtender Forum  zParserExtender"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/","title":"Trigger functions and the <code>C_Trigger</code> class","text":"<p>zParserExtender also implements cyclical functions called triggers - not to be confused with triggers in ZEN files, similar to a part of the functionality implemented in LeGo AI_Functions. These functions are called independently after a specified period of time. These triggers can also store user information. Up to 16 int variables can be stored in each trigger as well as <code>self</code>, <code>other</code> and <code>victim</code> instances.</p>"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#class-definition","title":"Class definition","text":"<p>To define a trigger, the <code>C_Trigger</code> class is used:</p> <pre><code>/// Union zPraserExtender Trigger class\nclass C_Trigger\n{\nvar int Delay; // defines the frequency (in miliseconds) at which the function will be called.\nvar int Enabled; // determines if the trigger is active. If the value is equal to zero, the trigger is destroyed.\nvar int AIVariables[16]; // user data, which can be set independently when creating trigger (yes, you can write there absolutely everything you want).\n// Hidden variable members\n/*\n        - Func   - The function that the trigger will call.\n        - Self   - The NPC that will be placed in `self` when the function is called.\n        - Other  - An NPC that will be placed in `other` when the function is called.\n        - Victim - The NPC that will be placed in `victim` when the function is called.\n    */\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#creating-instances","title":"Creating instances","text":"<p>There are two external functions that are used to create <code>C_Trigger</code> instance.</p> <pre><code>// function returns a trigger with no NPC (self, other or victim) bound to it\nfunc C_Trigger AI_StartTriggerScript(   var string funcName,\nvar int delay) {};\n// function is extended, if certain participants need to be assigned to it\nfunc C_Trigger AI_StartTriggerScriptEx( var string funcName,\nvar int delay,\nvar C_Npc slf,\nvar C_Npc oth,\nvar C_Npc vct) {};\n</code></pre> <p>Both of these functions return an instance of <code>C_Trigger</code> instance. You can of course configure the instance after its creation. You can, for example, fill in the <code>AIVariables</code> with relevant data. The trigger function has the required signature if 'func int f()'. It must return a value indicating the state of the loop. If the function returns <code>LOOP_END</code> the trigger will be stopped and the instance deleted. If <code>LOOP_CONTINUE</code> is returned, the function will be called again after <code>Delay</code> ms have passed.</p>"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#poison-example","title":"Poison example","text":"<pre><code>// Implement a trigger to simulate the effect of poison debuff:\n// Let's create a trigger on function `c_loop` with a call interval of 1 second.\n// When the function is called, the instance hero will be placed in self (although it can be any other NPC if desired).\n// The rest of the instances are left null (not used).\nvar C_Trigger trigger;\ntrigger = AI_StartTriggerScriptEx(\"c_loop\", 1000, hero, null, null);\ntrigger.AIVariables[0] = 15; // how many times the function should be called\ntrigger.AIVariables[1] = 5;  // how much damage to deal each iteration\n</code></pre> <p>The trigger function</p> <pre><code>func int c_loop()\n{\n// Create a loop end check, if the number of\n// available iterations has reached 0. If it did\n// we stop the trigger by returning the LOOP_END value.\nif (SelfTrigger.AIVariables[0] &lt;= 0)\n{\nreturn Loop_end;\n};\nSelfTrigger.Delay -= 20;         // Accelerate loop each call by 20 ms\nSelfTrigger.AIVariables[0] -= 1; // Reduce number of remaining repeats\nself.Attribute[ATR_HITPOINTS] -= SelfTrigger.AIVariables[1]; // Take health from self\nreturn LOOP_CONTINUE;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#trigger-scope","title":"Trigger scope","text":"<p>Triggers can be divided into two types:</p> <ul> <li>Global trigger ( AI_StartTriggerScript ) trigger created using this function works in all worlds. A trigger is considered global by default if neither <code>self</code> nor <code>other</code> nor <code>victim</code> has been provided for it.</li> <li>Local trigger ( AI_StartTriggerScriptEx) trigger created with this function only works in the world in which it was created. A trigger is considered local if it has been presented with at least one NPC in <code>self</code>, <code>other</code> or <code>victim</code> (not null). If you want to create a trigger without linking it to any NPC, it is recommended to simply pass hero as <code>self</code> to the trigger.</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#saving","title":"Saving","text":"<p>The plugin creates a new save archive to save the information of the triggers that does not conflict with any of the built-in save files.</p>"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#searching","title":"Searching","text":"<p>To search for a specific trigger, for example by NPC, the trigger external functions can be used.</p> <pre><code>// This way you can disable all triggers running on the `hero` instance\nvar C_Trigger trigget = FirstTrigger;\nvar C_Trigger trigget_saved;\nwhile (!Hlp_IsNULL(trigget))\n{\ntrigget_saved = trigger;\ntrigger = AI_GetNextTriggerBySelf(hero);\ntrigget_saved.Enabled = false;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/dialogues/","title":"Dialogue constants","text":"<p>To simplify dialogues, you can define up to 2 auxiliary variables or constants. Values corresponding to the current <code>C_Info</code> instance will be dynamically written there.</p>"},{"location":"zengin/scripts/extenders/zparserextender/dialogues/#dia_currentinstance","title":"DIA_CurrentInstance","text":"<p><pre><code>var int DIA_CurrentInstance\n</code></pre> Contains the ID of the current <code>C_Info</code> instance. Can greatly simplify code or make it more reusable. Should be defined in scripts.  </p> Example usage<pre><code>Info_ClearChoices(DIA_CurrentInstance);\nInfo_AddChoice(DIA_CurrentInstance, /*text*/, /*func*/);\nNpc_KnowsInfo(hero, DIA_CurrentInstance); // In this case DIA_CurrentInstance contains the last C_Info instance??\n</code></pre> Create a wrapper function based on this variable<pre><code>func int C_HeroKnowsCurrentInfo()\n{\nreturn Npc_KnowsInfo(hero, DIA_CurrentInstance);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/dialogues/#dia_currentname","title":"DIA_CurrentName","text":"<p><pre><code>var string DIA_CurrentName;\n</code></pre> Contains the name of the current instance of <code>C_Info</code>. Can be useful for debugging purposes. Should be defined in scripts. Usage scenarios: <pre><code>Hlp_PrintConsole(DIA_CurrentName);\nHlp_PrintConsole(Str_Format(\"%s[%s]\", DIA_CurrentName, self.name);\nHlp_StrCmp(DIA_CurrentName, \"DIA_DiegoOw_Teach\");\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/events/","title":"Event functions","text":"<p>Event functions are functions sharing the same name. It can be defined multiple times but only once per file. Such functions are useful for implementing callback type functions. Every time an event is called, all instances of the same name will be called. The event is <code>func</code> with a return type <code>event</code>. Events are defined globally, meaning they ignore namespace they are in. To call an event from a script, use the external function <code>Hlp_DoEvent(var string funcName)</code>.</p> <pre><code>func void GiveXP()\n{\nHlp_DoEvent(\"OnGiveXP\");\n};\nfunc event OnGiveXP()\n{\n// TODO\n// This function can be defined in many files to do different things\n// more appropriate for that file's context and all of them will be\n// called, when function GiveXP (above) is called.\n};\n</code></pre> <p>Plugin implements two of these event functions</p> <ul> <li><code>func event GameInit()</code> - called when entering the main menu on game start</li> <li><code>func event GameLoop()</code> - called every frame when a world is loaded</li> </ul> <p>Define these in any file in your scripts, they will be automatically called</p>"},{"location":"zengin/scripts/extenders/zparserextender/extern/","title":"Extern binding","text":"<p>The <code>extern</code> binding allows you to secure your code against overriding or undefined symbol. Keyword <code>extern</code> before declaration means that if object of the same name exists, source object should be used. If not, a new one will be created. <pre><code>extern instance PC_Hero(C_Npc) {\n// TODO\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/","title":"External functions","text":"<p>External functions are Daedalus functions (defined in the engine itself) used to interface with the engine. zParseExtender adds a rather huge amount of new functions that help scripters to interface with the engine in more ways than what was possible before without script extenders such as Ikarus and LeGo.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#cast-data-type-conversion-functions","title":"CAST data type conversion functions","text":"<p>External functions for data type conversion and pointer casting.</p> <pre><code>func instance Cast_PointerToInstance( var int address ) {};\nfunc int Cast_InstanceToPointer( var instance object ) {};\nfunc C_NPC Cast_PointerToNpc( var int address ) {};\nfunc C_ITEM Cast_PointerToItem( var int address ) {};\nfunc int Cast_InstanceIsNpc( var instance object ) {};\nfunc int Cast_InstanceIsItem( var instance object ) {};\nfunc int Cast_InstanceIsMob( var instance object ) {};\nfunc int Cast_GetInstanceIndex( var instance object ) {};\n/// Returns the class identifier of a class by its name\n///\n/// @param className name of the class\n/// @return class identifier\nfunc int Cast_GetClassID( var string className ) {};\n/// Returns class identifier of the zCObject vob class\n///\n/// @param object object instance\n/// @return class zCObject identifier\nfunc int Cast_GetVobClassID( var instance object ) {};\n/// Checks if the classId class is the parent class of the object\n///\n/// @param classId class identifier, from Cast_GetClassID function\n/// @param object object instance\n/// @return class zCObject identifier\nfunc int Cast_CheckVobClassID( var int classId, var instance object ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#hlp-help-functions","title":"HLP help functions","text":"<p>Helper functions used for safety checks or to get specific information from the engine.</p> <pre><code>func int Hlp_HasFocusVob( var C_NPC npc ) {};\nfunc instance Hlp_GetFocusVob( var C_NPC npc ) {};\nfunc string Hlp_GetFocusVobName( var C_NPC npc ) {};\nfunc int Hlp_GetStringLength( var string str ) {};\nfunc int IsNAN( var float value ) {};\nfunc int Hlp_KeyToggled( var int key ) {};\nfunc int Hlp_KeyPressed( var int key ) {};\nfunc int Hlp_LogicalKeyToggled( var int key ) {};\nfunc int Hlp_GameOnPause() {};\nfunc void Hlp_MessageBox( var string message ) {};\nfunc void Hlp_PrintConsole(var string message) {};\nfunc int Hlp_ReadOptionInt(var string optName, var string section, var string entry, var int default) {};\nfunc float Hlp_ReadOptionFloat(var string optName, var string section, var string entry, var float default) {};\nfunc string Hlp_ReadOptionString(var string optName, var string section, var string entry, var string default) {};\nfunc int Hlp_OptionIsExists(var string optName, var string section, var string entry) {};\nfunc void Hlp_WriteOptionInt(var string optName, var string section, var string entry, var int value) {};\nfunc void Hlp_WriteOptionFloat(var string optName, var string section, var string entry, var float value) {};\nfunc void Hlp_WriteOptionString(var string optName, var string section, var string entry, var string value) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#wld-world-manipulation-functions","title":"WLD world manipulation functions","text":"<p>Functions related to the world. </p> <pre><code>func void Wld_ChangeLevel( var string world, var string waypoint ) {};\nfunc instance Wld_FindVob( var string vobname ) {};\nfunc void Wld_PlayEffectVob(    var string effect,\nvar instance pvob,\nvar int level,\nvar int damage,\nvar int damage_type,\nvar int damage_speed ) {};\nfunc void Wld_PlayEffectAt(     var string effect,\nvar instance coord,\nvar int level,\nvar int damage,\nvar int damage_type,\nvar int damage_speed ) {};\nfunc void Wld_ToggleRain( var float weight, var flaot time ) {};\nfunc void Wld_SetWeatherType( var int type ) {};\nfunc int Wld_GetWeatherType() {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#mdl-model-functions","title":"MDL model functions","text":"<p>Functions to tweak animation and other model related settings.</p> <pre><code>func int Mdl_GetAnimationIndex( var C_NPC npc, var string ani_name ) {};\nfunc string Mdl_GetAnimationName( var C_NPC npc, var int ani_index ) {};\nfunc int Mdl_AnimationIsExists( var C_NPC npc, var int ani_index ) {};\nfunc int Mdl_AnimationIsActive( var C_NPC npc, var int ani_index ) {};\nfunc float Mdl_SetAllAnimationsFPS( var C_NPC npc, var float fps ) {};\nfunc float Mdl_ResetAllAnimationsFPS( var C_NPC npc ) {};\nfunc float Mdl_SetAnimationFPS( var C_NPC npc, var int idx, var float fps ) {};\nfunc float Mdl_ResetAnimationFPS( var C_NPC npc, var int ani_index ) {};\nfunc void Mdl_SetVisible( var C_NPC npc, var int isVisible ) {};\n/// Applies or moves existing overlay to the top of the list\n///\n/// @param mdsName name of the overlay\nfunc void Mdl_ApplyOverlayMds_AtFirst( var string mdsName ) {};\n/// Sets a multipler for animation speed\n/// 1.0 = 100% speed (normal speed)\n///\n/// @param npc npc to be affected\n/// @param multiplier speed of the animation\nfunc void Mdl_SetNpcSpeedMultiplier( var C_Npc npc, var float multiplier ) {};\n/// Resets the animation speed of an NPC\n///\n/// @param npc npc to be affected\nfunc void Mdl_ResetNpcSpeedMultiplier( var C_Npc npc ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#npc-character-functions","title":"NPC character functions","text":"<p>NPC related functions.</p> <pre><code>func void Npc_SetAsHero( var C_NPC npc ) {};\nfunc void Npc_OpenInventory( var C_NPC npc ) {};\nfunc void Npc_OpenInventorySteal( var C_NPC npc ) {};\nfunc void Npc_OpenInventoryTrade( var C_NPC npc ) {};\n/// Returns an item in NPC's left hand slot\n///\n/// @param npc npc to be affected\nfunc C_Item Npc_GetLeftHandItem( var C_Npc npc ) {};\n/// Returns an item in NPC's right hand slot\n///\n/// @param npc npc to be affected\nfunc C_Item Npc_GetRightHandItem( var C_Npc npc ) {};\n/// Returns an item from a slot with the slotName\n///\n/// @param npc npc to be affected\n/// @param slotName name of the slot\nfunc C_Item Npc_GetSlotItem( var C_Npc npc, var string slotName ) {};\n/// Places an instance of the oCVom class (including items and NPCs) object into the slotName of the NPC\n/// The copyInInv parameter determines wheter a copy of the object should remian in the character's inventory\n///\n/// @param npc npc to remove the item from\n/// @param slotName name of the slot fro which to remove the item\n/// @param object object to be inserted into the slot\n/// @param copyInInv should a copy of the object stay in character inventory\nfunc void Npc_PutInSlot(var C_Npc npc, var string slotName, var instance object, var int copyInInv) {};\n/// Removes an object from the slotName of the NPC.\n/// The dropIt parameter in Gothic 2 defines, wheter or not the object should drop out of the slot. In Gothic 1, this parameter is reserved and must be 0.\n///\n/// @param npc npc to remove the item from\n/// @param slotName name of the slot fro which to remove the item\n/// @param dropIt should the object be dropped\nfunc void Npc_RemoveFromSlot(var C_Npc npc, var string slotName, var int dropIt) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#mob-interactive-object-functions","title":"MOB interactive object functions","text":"<p>Functions to manipulate interactive objects like destroying MOBs, setting lockpick combination and such.</p> <pre><code>func void Mob_Destroy( var instance object ) {};\nfunc void Mob_RemoveItem( var instance object, var int item ) {};\nfunc void Mob_RemoveItems( var instance object, var int item, var int cnt ) {};\nfunc void Mob_InsertItem( var instance object, var int item ) {};\nfunc void Mob_InsertItems( var instance object, var int item, var int cnt ) {};\nfunc string Mob_GetLockCombination( var instance object ) {};\nfunc void Mob_SetLockCombination( var instance object, var string comb ) {};\nfunc int Mob_IsLocked( var instance object ) {};\nfunc void Mob_SetLocked( var instance object, var int locked ) {};\nfunc instance Mob_GetKeyInstance( var instance object ) {};\nfunc void Mob_SetKeyInstance( var instance object, var int key ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#ai-functions-for-working-with-ai","title":"AI functions for working with AI","text":"<p>Functions to work with the new <code>C_Trigger</code> class and NPC's AI queue.</p> <pre><code>func void AI_CallScript(var string funcName, var C_Npc slf, var C_Npc oth) {};\nfunc C_Trigger AI_StartTriggerScript(var string funcName, var int delay) {};\nfunc C_Trigger AI_StartTriggerScriptEx(var string funcName, var int delay, var C_Npc slf, var C_Npc oth, var C_Npc vct) {};\nconst int selfID   = 0;\nconst int otherID  = 1;\nconst int victimID = 2;\nfunc int Hlp_IsNULL(var instance pointer) {};\nfunc C_Trigger AI_GetTriggerByID(var int ID) {};\nfunc int AI_GetTriggersNum() {};\nfunc C_Trigger AI_GetTriggerNPC(var int npcID) {};\nfunc func AI_GetTriggerFunc(var C_Trigger trigger) {};\nfunc string AI_GetTriggerFuncName(var C_Trigger trigger) {};\nAI_GetNextTriggerByFunc(var C_Trigger startTrigger, var func function) {};\nAI_GetNextTriggerByFuncName(var C_Trigger startTrigger, var string functionName) {};\nAI_GetNextTriggerBySelf(var C_Trigger startTrigger, var C_Npc self) {};\nAI_GetNextTriggerByOther(var C_Trigger startTrigger, var C_Npc other) {};\nAI_GetNextTriggerByVictim(var C_Trigger startTrigger, var C_Npc victim) {};\nAI_GetNextTriggerByNPCs(var C_Trigger startTrigger, var C_Npc self, var C_Npc other, var C_Npc victim) {};\n/// Returns the name of the current Steam user\n/// Returns empty string when not run with Steam\n///\n/// @return string containing the Steam username, or empty string\nfunc string Hlp_GetSteamPersonalName() {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#par-functions-for-parser-manipulation","title":"PAR functions for parser manipulation","text":"<p>Parser functions are used to manipulate the parsers. Retrieve SymbolID, access arrays and such.</p> <pre><code>func int Par_GetParserID(var string parName) {};\nfunc int Par_GetSymbolID(var int parId, var string symName) {};\nfunc int Par_GetSymbolLength(var int parId, var int symId) {};\nfunc int Par_GetSymbolValueInt(var int parId, var int symId) {};\nfunc float Par_GetSymbolValueFloat(var int parId, var int symId) {};\nfunc string Par_GetSymbolValueString(var int parId, var int symId) {};\nfunc instance Par_GetSymbolValueInstance(var int parId, var int symId) {};\nfunc int Par_GetSymbolValueIntArray(var int parId, var int symId, var int arrayId) {};\nfunc float Par_GetSymbolValueFloatArray(var int parId, var int symId, var int arrayId) {};\nfunc string Par_GetSymbolValueStringArray(var int parId, var int symId, var int arrayId) {};\nfunc void Par_SetSymbolValueInt(var int value, var int parId, var int symId, var int arrayId) {};\nfunc void Par_SetSymbolValueFloat(var float value, var int parId, var int symId, var int arrayId) {};\nfunc void Par_SetSymbolValueString(var string value, var int parId, var int symId, var int arrayId) {};\nfunc void Par_SetSymbolValueInstance(var instance value, var int parId, var int symId, var int arrayId) {};\nfunc void Par_SetSymbolValueIntArray(var int value, var int parId, var int symId, var int arrayId) {};\nfunc void Par_SetSymbolValueFloatArray(var float value, var int parId, var int symId, var int arrayId) {};\nfunc void Par_SetSymbolValueStringArray(var string value, var int parId, var int symId, var int arrayId) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#vob-functions-for-object-manipulation","title":"VOB functions for object manipulation","text":"<p>VOB functions allow you to manipulate game world objects.</p> <pre><code>/// Returns the current position of the object in the world\n/// \n/// @param vob vob to ge the position of\n/// @return C_Position instace - position of the VOB\nfunc C_Position Vob_GetVobPosition( var C_Vob vob ) {};\n/// Sets the current position of the object in the world\n/// \n/// @param vob vob to get the position of\n/// @param pos new position of the vob\nfunc void Vob_SetVobPosition( var C_Vob vob, var C_Position pos ) {};\n/// Returns the universal data of the zCVob object\n///\n/// @param vob VOB to get the position of\n/// @return general vob data C_Vob_Data\nfunc C_Vob_Data Vob_GetVobData( var C_Vob vob ) {};\n/// Sets the universal data to a zCVob object\n///\n/// @param vob VOB to get the position of\n/// @param data general vob data C_Vob_Data\nfunc void Vob_SetVobData( var C_Vob vob, var C_Vob_Data data ) {};\n/// Returns zCVobLight object data\n///\n/// @param vobLight vobLight object\n/// @return C_Light_Data of the light\nfunc C_Light_Data Vob_GetLightData( var C_Vob vobLight ) {};\n/// Sets the data of a zCVobLight object\n///\n/// @param vobLight object to apply the light data to\n/// @param data C_Light_Data light data to be set\nfunc void Vob_SetLightData( var C_Vob vobLight, var C_Light_Data data ) {};\n/// Clears the list of animation colours for the light source\n///\n/// @param vobLight light vob\nfunc void Vob_ClearLightAniList( var C_Vob vobLight ) {};\n/// Adds a color to the colour list\n///\n/// @param vobLight object to apply the colour to\n/// @param col colour to be applied\nfunc void Vob_AddLightAniColor( var C_Vob vobLight, var C_Color col ) {};\n/// Adds a color to the colour list\n///\n/// @param vobLight object to apply the colour to\n/// @param r red colour channel\n/// @param g green colour channel \n/// @param b blue colour channel\nfunc void Vob_AddLightAniColorRGB(  var C_Vob vobLight,\nvar int r,\nvar int g,\nvar int b ) {};\n/// Returns the data of the oCMOB object\n///\n/// @param mob oCMOB object\n/// @return mob data\nfunc C_Mob_Data Vob_GetMobData( var C_Vob mob ) {};\n/// Sets the data of the oCMOB object\n///\n/// @param mob oCMOB object\n/// @param data C_Mob_Data to be set \nfunc void Vob_SetMobData( var C_Vob mob, var C_Mob_Data data ) {};\n/// Returns the data of the oCMobInter object\n///\n/// @param mobInter oCMobInter object\n/// @return MobInter_Data of the object\nfunc MobInter_Data Vob_GetMobInterData( var C_Vob mobInter ) {};\n/// Sets the data of the oCMobInter object\n///\n/// @param mobInter oCMobInter object\n/// @param data MobInter_Data of the object\nfunc void Vob_SetMobInterData( var C_Vob mobInter, var C_MobInter_Data data ) {};\n/// Returns the data of the oCMobLockable object\n///\n/// @param mobLock oCMobLockable object\n/// @param data MobInter_Data of the object\nfunc C_MobLockable_Data Vob_GetMobInterData( var C_Vob mobLock ) {};\n/// Sets the data of the oCMobLockable object\n///\n/// @param mobLock oCMobLockable object\n/// @param data C_MobLockable_Data of the object\nfunc void Vob_SetMobInterData( var C_Vob mobLock, var C_MobLockable_Data data ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#string-function","title":"String function","text":"<p>Functions to manipulate and format strings.</p> <pre><code>/// Returns formatted string using format specifiers\n/// \n/// Format specifiers:\n/// %s - inserts a string\n/// %i - inserts a integer number\n/// %x - inserts a integer in hexadecimal\n/// %f - inserts a floating point number\n/// %b - inserts a logical expression\n/// %p - inserts a pointer\n/// \n/// @return formatted string\nfunc string Str_Format( var string format, ... ) {};\n/// Returns a string in the current language, otherwise in English.\n/// Arguments MUST be encoded in UTF-8! The result string will be converted to apropriate ANSI string.\n///\n/// @param russian Russian string\n/// @param english English string\n/// @param german  German string\n/// @param polish  Polish string\n///\n/// @return string in the current language\nfunc string Str_GetLocalizedString( var string russian, var string english, var string german, var string polish ) {};\n/// Returns a string in the current language, otherwise in English.\n/// Offers additional languages\n///\n/// @param russian  Russian string\n/// @param english  English string\n/// @param german   German string\n/// @param polish   Polish string\n/// @param czech    Czech  string\n/// @param romanian Romanian string\n/// @param italian  Italian string\n/// @param spanish  Spanish string\n///\n/// @return string in the current language\nfunc string Str_GetLocalizedStringEx( var string russian, var string english, var string german, var string polish, var string czech, var string romanian, var string italian, var string spanish ) {};\n/// Converts UTF-8 string into an ANSI string with codePage\n///\n/// @param utf8 string encoded in UTF8\n/// @param codePage codePage id, can be obtained from Str_GetCurrentCP \nfunc string Str_UTF8_to_ANSI( var string utf8, var int codePage ) {};\n/// Return the code page corresponding to the current language set in the Union System\nfunc int Str_GetCurrentCP() {};\n/// Returns the length of a string\n///\n/// @param str string to be measured\n/// @return length of the string\nfunc int Str_GetLength( var int str ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#menu-function","title":"Menu function","text":"<pre><code>/// Find all C_MenuItem object instances by the mask and automatically places them in the current menu instance\n/// \n/// @param mask regex like mask for searching\nfunc void Menu_SearchItems( var string mask ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#log-functions","title":"Log functions","text":"<p>As discussed on Inside Gothic, vanilla Gothic has no way of getting the status of a quest. These functions implement that functionality.</p> <pre><code>/// Returns the status of diary topic\n/// Not found   - (-1)\n/// Free        - 0\n/// Running     - 1\n/// Success     - 2\n/// Failure     - 3\n/// Obsolete    - 4\n///\n/// @param topic name of the topic\n/// @return topic status\nfunc int Log_GetTopicStatus(var string topic) {};\n/// Returns the topic the diary topic is in\n/// Not found   - (-1)\n/// Missions    - 0\n/// Notes       - 1\n/// All         - 2\n///\n/// @param topic name of the topic\n/// @return topic section\nfunc int Log_GetTopicSection(var string topic) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/#event-functions-and-variables","title":"Event functions and variables","text":"<p>On top of external functions, zParserExtender also adds event functions and constants</p> <pre><code>func event GameLoop() {};\nfunc event GameInit() {};\nconst instance null;\nconst float NaN;\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/","title":"Engine classes","text":"<p>zParserExtender implements various proxy classes that can be used to access game world objects.</p> <p>Warning</p> <p>It is not recommended to implement complex mechanics using these classes and functions. They are present as a simple backup option for accessing game world objects and for quick fixes.</p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_vob","title":"C_VOB","text":"<p>This class represents basic pointer to a game world object.</p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_color","title":"C_Color","text":"<p>Represents color in the RGBA format <pre><code>class C_Color\n{\nvar int R; // red channel value\nvar int G; // green channel value\nvar int B; // blue channel value\nvar int A; // alpha channel value\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_position","title":"C_Position","text":"<p>Represents 3D position in the world <pre><code>class C_Position\n{\nvar int X; // X coordinate\nvar int Y; // Y coordinate\nvar int Z; // Z coordinate\n};\n</code></pre> Externals: <pre><code>/// Returns the current position of the object in the world\n/// \n/// @param vob vob to ge the position of\n/// @return C_Position instace - position of the VOB\nfunc C_Position Vob_GetVobPosition( var C_Vob vob ) {};\n/// Sets the current position of the object in the world\n/// \n/// @param vob vob to get the position of\n/// @param pos new position of the vob\nfunc void Vob_SetVobPosition( var C_Vob vob, var C_Position pos ) {};\n</code></pre></p> <p>Note</p> <p>The following classes define properties of <code>C_VOB</code> objects or classes derived from it.</p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_vob_data","title":"C_VOB_DATA","text":"<p>Represents universal <code>zCVob</code> class <pre><code>class C_VOB_DATA\n{\nvar string Name;              // object name\nvar float VisualAlpha;        // object's transparency 0.0 - 1.0\nvar int ShowVisual;           // display the mode\nvar int DrawBBox3D;           // show objects bounding box\nvar int VisualAlphaEnabled;   // enables objects transparency\nvar int PhysicsEnabled;       // enables object's physics\nvar int IgnoredByTraceRay;    // allow any object collisions\nvar int CollDetectionStatic;  // allow collision with static world polygons\nvar int CollDetectionDynamic; // allow collision with dynamic world objects\nvar int CastDynShadow;        // display shadow of the object\nvar int LightColorStatDirty;  // allow static liging of the object\nvar int LightColorDynDirty;   // allow dynamic lighing of the object\nvar int SleepingMode;         // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only)\nvar int DontWriteIntoArchive; // turns of the serialization of this object to the save file \n};\n</code></pre> Externals: <pre><code>/// Returns the universal data of the zCVob object\n///\n/// @param vob VOB to get the position of\n/// @return general vob data C_Vob_Data\nfunc C_Vob_Data Vob_GetVobData( var C_Vob vob ) {};\n/// Sets the universal data to a zCVob object\n///\n/// @param vob VOB to get the position of\n/// @param data general vob data C_Vob_Data\nfunc void Vob_SetVobData( var C_Vob vob, var C_Vob_Data data ) {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_light_data","title":"C_LIGHT_DATA","text":"<p>Represents <code>zCVobLight</code> objects <pre><code>class C_LIGHT_DATA\n{\nvar int R;                // red light intensity\nvar int G;                // green light intensity\nvar int B;                // blue light intensity\nvar int Range;            // radius\nvar int RangeInv;         // \nvar int RangeBackup;      // \nvar int RangeAniActFrame; // current light animation frame for the radius\nvar int RangeAniFPS;      // speed of light animation for the radius\nvar int ColorAniActFrame; // current light animation frame for colour\nvar int ColorAniFPS;      // speed of light animation for colour\nvar int SpotConeAngleDeg; // angle of cone light source\nvar int IsStatic;         // whether the source is static\nvar int RangeAniSmooth;   // [UNUSED]\nvar int RangeAniLoop;     // [UNUSED]\nvar int ColorAniSmooth;   // allows soft transitions between colours\nvar int ColorAniLoop;     // [UNUSED]\nvar int IsTurnedOn;       // whether the light source is on\nvar int LightQuality;     // source quality (when statically compiling light) (0 - high, 1 - medium, 2 - low)\nvar int LightType;        // type of source (at static light compilation) (0 - point, 1 - cone)\n};\n</code></pre> Externals: <pre><code>/// Returns zCVobLight object data\n///\n/// @param vobLight vobLight object\n/// @return C_Light_Data of the light\nfunc C_Light_Data Vob_GetLightData( var C_Vob vobLight ) {};\n/// Sets the data of a zCVobLight object\n///\n/// @param vobLight object to apply the light data to\n/// @param data C_Light_Data light data to be set\nfunc void Vob_SetLightData( var C_Vob vobLight, var C_Light_Data data ) {};\n/// Clears the list of animation colours for the light source\n///\n/// @param vobLight light vob\nfunc void Vob_ClearLightAniList( var C_Vob vobLight ) {};\n/// Adds a color to the colour list\n///\n/// @param vobLight object to apply the colour to\n/// @param col colour to be applied\nfunc void Vob_AddLightAniColor( var C_Vob vobLight, var C_Color col ) {};\n/// Adds a color to the colour list\n///\n/// @param vobLight object to apply the colour to\n/// @param r red colour channel\n/// @param g green colour channel \n/// @param b blue colour channel\nfunc void Vob_AddLightAniColorRGB(  var C_Vob vobLight,\nvar int r,\nvar int g,\nvar int b ) {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_mob_data","title":"C_MOB_DATA","text":"<p>Represents  data for the used oCMOB object <pre><code>class C_MOB_DATA\n{\nvar string VisibleName;     // name shown above the object\nvar int Hitpoints;          // number of hitpoints\nvar int Damage;             // damage the object can cause\nvar int IsDestroyed;        // if the object is destroyed\nvar int Moveable;           // whether the object can be moved\nvar int Takeable;           // whether the object can be taken\nvar int FocusOverride;      // if the object will redefine focus in combat mode\nvar int SndMat;             // object's material (0 - wood, 1 - stone, 2 - metal, 3 - skin, 4 - clay, 5 - glass)\nvar string VisualDestroyed; // model when the object is destroyed\nvar string OwnerStr;        // name of the instance of the owner of the object\nvar string OwnerGuildStr;   // name of the guild of the object\nvar int Owner;              // instance of the owner\nvar int OwnerGuild;         // guild instance\nvar int FocusNameIndex;     // the script string of the displayed name\n};\n</code></pre> <pre><code>/// Returns the data of the oCMOB object\n///\n/// @param mob oCMOB object\n/// @return mob data\nfunc C_Mob_Data Vob_GetMobData( var C_Vob mob ) {};\n/// Sets the data of the oCMOB object\n///\n/// @param mob oCMOB object\n/// @param data C_Mob_Data to be set \nfunc void Vob_SetMobData( var C_Vob mob, var C_Mob_Data data ) {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_mobinter_data","title":"C_MOBINTER_DATA","text":"<p>Represents data for the interactive object <code>oCMobInter</code> <pre><code>class C_MOBINTER_DATA\n{\nvar string TriggerTarget;   // object name which will be triggered by OnTrigger\nvar string UseWithItem;     // name of the object instance that is needed for interaction\nvar string Sceme;           // name of the scene that corresponds to the object and character animations\nvar string ConditionFunc;   // scripting condition under which the interaction can be performed\nvar string OnStateFuncName; // the name pattern of the functions that will be called when the object changes the state\nvar int State;              // the current state of the object\nvar int State_num;          // number of object's states\nvar int State_target        // current state of the object\nvar int Rewind;             // prohibits object updating\nvar int MobStateAni;        // current animation of the object\nvar int NpcStateAni;        // current character animation\n};\n</code></pre> <pre><code>/// Returns the data of the oCMobInter object\n///\n/// @param mobInter oCMobInter object\n/// @return MobInter_Data of the object\nfunc MobInter_Data Vob_GetMobInterData( var C_Vob mobInter ) {};\n/// Sets the data of the oCMobInter object\n///\n/// @param mobInter oCMobInter object\n/// @param data MobInter_Data of the object\nfunc void Vob_SetMobInterData( var C_Vob mobInter, var C_MobInter_Data data ) {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_moblockable_data","title":"C_MOBLOCKABLE_DATA","text":"<p>Represents data for the locked interactive object <code>oCMobLockable</code> <pre><code>class C_MOBLOCKABLE_DATA\n{\nvar int Locked;         // whether the object is locked\nvar int AutoOpen;       // [UNUSED]\nvar int PickLockNr;     // current rotation number \nvar string KeyInstance; // key instance name for the object\nvar string PickLockStr; // combination to open the object (\"LRRLR\")\n};\n</code></pre> <pre><code>/// Returns the data of the oCMobLockable object\n///\n/// @param mobLock oCMobLockable object\n/// @param data MobInter_Data of the object\nfunc C_MobLockable_Data Vob_GetMobInterData( var C_Vob mobLock ) {};\n/// Sets the data of the oCMobLockable object\n///\n/// @param mobLock oCMobLockable object\n/// @param data C_MobLockable_Data of the object\nfunc void Vob_SetMobInterData( var C_Vob mobLock, var C_MobLockable_Data data ) {};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/hooks/","title":"Hooking Daedalus","text":"<p>Daedalus hooking is one of the most powerful features of this plugin. Hooking is a mechanism that allows you to replace any scripted object with a new one. To do this, you must define a new object with the same type, name and in the same namespace.</p> <p>Hook/replacement will be performed only if the <code>MergeMode</code> setting is set to true for the current script in the META block or in the parameter of the same name in the <code>.ini</code> file of the mod.</p> <p>Warning</p> <p>If you forget to turn on the <code>MergeMode</code>, the compilation will fail with the redefinition error.</p> <p>When an object (instance, function or variable) is hooked/replaced, the original one is available under the same name with the <code>_old</code> suffix (<code>PC_Hero</code> -&gt; <code>PC_Hero_old</code>). This allows you to refer to the old object.</p>"},{"location":"zengin/scripts/extenders/zparserextender/hooks/#function-hook-example","title":"Function hook example","text":"<pre><code>func void ZS_Attack_Loop()\n{\n// if the enemy is a player and has no weapon, then\n// also sheath the weapon.\nif (Npc_IsPlayer(other) &amp;&amp; !Npc_HasReadiedWeapon(other))\n{\nreturn LOOP_END;\n};\n// otherwise call the original function\nreturn ZS_Attack_Loop_Old();\n};\n</code></pre> <p>This kind of substitution works for instances and variables too.</p> <p>Warning</p> <p>While hooking an instances, you have to take care not to call the prototype. Prototype should be always changed back to the original class.</p> <p>This is wrong<pre><code>instance pc_hero(Npc_Default)\n{\npc_hero_old();\nname = \"Pepe\";\n};\n</code></pre> This leads to a double call of <code>prototype Npc_Default</code> which is considered an unsafe practice with undefined behaviour.</p> <p>The correct way is to call it like this: <pre><code>instance pc_hero(C_NPC) // no prototype Npc_Default\n{\npc_hero_old();\nname = \"Pepe\";\n};  </code></pre> This way the prototype is called in the original function <code>pc_hero_old()</code> and not for the second time when creating the new hooked instance.</p>"},{"location":"zengin/scripts/extenders/zparserextender/hooks/#dialogue-hook-example","title":"Dialogue hook example","text":"<p>The hooking mechanism is designed to introduce new dialogues into the game as well as replacing old ones with hooks. The scripter can create new merchants, quests, dialogues, as well as attach svm phrases to them.</p> <p>All new or replaced dialogues will immediately become available, including from saves. In the event that new dialogs are disabled (plugin or script removed), the engine will continue to keep them in the save file, which will allow the dialogs to return at any time with the same state they were in the last time.</p> <p>Warning</p> <p>Currently not working as intended (I think). The old dialogue is still used and as a result you will end up with both the old and the new dialogue (unless you edit the old condition function).</p> <pre><code>instance DIA_XARDAS_HELLO(C_INFO)\n{\nDIA_XARDAS_HELLO_old();\nimportant = FALSE;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/injection/","title":"Daedalus Injection","text":"<p>Script injection is a process of injecting Daedalus scripts on runtime without the need to recompile the scripts. This is essential for Union plugins that need to alter the scripts in a certain way, either for hotfixes or just for testing scripts without the need to recompile the whole <code>.dat</code> file.</p> <p>To inject a script, simply put a <code>.d</code> or <code>.src</code> file in <code>Gothic/System/Autorun</code> directory and run the game.</p> <p>Tip</p> <p>Automatic injection does not extend to nested directories in the Autorun directory directly, but you can put a <code>.src</code> file into <code>Autorun</code> directory and the rest into a subdirectory to keep a cleaner structure.</p> <p>Scripts in subdirectories can be accessed in two ways</p> <ol> <li>They are specified in a <code>.src</code> file</li> <li>The script file is an API script</li> </ol>"},{"location":"zengin/scripts/extenders/zparserextender/injection/#api-script","title":"API script","text":"<p>API scripts are <code>.d</code> files placed in <code>Autorun</code> subdirectories and are used as a dependency. It is assumed that the API script is not called on its own (or from a <code>.src</code>) file, but is called using the dependency keyword <code>After</code> in one of the injected script files' META block.</p> <p>These scripts are meant to contain ready-made solution that need to be used by many other scripts as a dependency.</p> <p>Warning</p> <p>If the file specified in the <code>After</code> tag in the META block does not exist, the current file will not be parsed and injected since the dependency is missing, and it would fail. Due to this it is best to ship the dependency in the Autorun directory even if it comes from a different plugin.</p>"},{"location":"zengin/scripts/extenders/zparserextender/meta/","title":"META block","text":"<p>The META block is optional. If it is specified, it has to be the very first thing in the file without any indent or a comment above it.</p> <p>Syntax: <pre><code>META\n{\nParser // specifies into which compiled file the scripts are going to be injected\n/*\n        Code    Name              DAT file\n        ---     ------            -------\n        Game    parser            Gothic.dat\n        SFX     parserSoundFX     SFX.dat\n        PFX     parserParticleFX  ParticleFX.dat\n        VFX     parserVisualFX    VisualFX.dat\n        Camera  parserCamera      Camera.dat\n        Menu    parserMenu        Menu.dat\n        Music   parserMusic       Music.dat\n    */\nMergeMode   // 0 - if confilct occurs = comilation error, 1 - if conflict occurs = hook\nEngine      // comma separated list of engines for which the scripts will be injected \n/*\n        Code  Engine          Human readable name\n        ---   -----           -----------------------\n        G1    Gothic I        Gothic I Classic\n        G1A   Gothic Sequel   Gothic I Addon &lt;3\n        G2    Gothic II       Gothic II Classic\n        G2A   Gothic II NoTR  Gothic II Addon\n    */\nNativeWhile // use native while\nNamespace   // namespace of this script file\nUsing       // comma separated list of namespaces, that are considered local for this script file\nMod         // specify for which mod should this code be injected\nAfter       // comma separated list of scripts, after which this script should be parsed\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/","title":"Namespaces","text":"<p>zParserExtender also implements namespaces. Namespaces ensure that all symbols inside the namespace are unique.</p>"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#defining-a-namespace","title":"Defining a namespace","text":"<p>To define a namespace the new keyword <code>namespace</code> is used.</p> Regular scriptsInjectable scripts <pre><code>namespace zTestNamespace\n{\nvar int var01;\nfunc void func01() { };\n};\n</code></pre> <pre><code>META\n{\nNamespace = zTestNamespace;\n};\nvar int var01;\nfunc void func01() { };\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#namespace-nesting","title":"Namespace nesting","text":"<p>Namespaces can be nested for finer control. In case of injection, the namespace defined in META is applied to all code inside the script.</p> <p>To go deeper into the namespaces you use the namespace operator <code>:</code>. This code shows function with the same name within three different namespaces. The call in <code>GameInit</code> is made from the global namespace. <pre><code>namespace zTestNamespace01\n{\nfunc void func01() { };\n};\nnamespace zTestNamespace02\n{\nfunc void func01() { };\n};\nnamespace zTestNamespace03\n{\nnamespace zTestNamespace04\n{\nfunc void func01() { };\n};\n};\nfunc event GameInit()\n{\n// In this case, the reference is from global namespace to zTestNamespace\nzTestNamespace01:func01();\nzTestNamespace02:func01();\nzTestNamespace03:zTestNamespace04:func01();\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#namespace-traversal","title":"Namespace traversal","text":"<p>To go up a namespace tree you use the namespace operator <code>:</code> without specifying a namespace. Number of operators determines how many levels you go up.</p> Exiting nested namespaces<pre><code>func void func01()\n{\nHlp_MessageBox(\"#1\");\n};\nnamespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#2\");\n};\nnamespace zTestNamespace02\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#3\");\n};\nnamespace zTestNamespace03\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#4\");\n};\nfunc event GameInit()\n{\n:::func01(); // Calls the function 3 levels up\n::func01();  // Calls the function 2 levels up\n:func01();   // Calls the function 1 level up\nfunc01();    // Calls the function from the current namespace\n};\n};\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#optional-namespace-specification","title":"Optional namespace specification","text":"<p>There are three cases where the namespace prefix is optional</p> Shares the same namespaceIf the function is in higher level namespaceIf <code>using</code> is specified in the META block <pre><code>namespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#1\");\n};\nfunc event GameInit()\n{\n// Function call from the current namespace\nfunc01();\n};\n};\n</code></pre> <pre><code>func void func01()\n{\nHlp_MessageBox(\"#1\");\n};\nnamespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#2\");\n};\nnamespace zTestNamespace02\n{\nfunc event GameInit()\n{\n// Function call from the global namespace\nfunc01();\n};\n};\n};\n</code></pre> <pre><code>META\n{\nusing = zTestNamespace01;\n};\nnamespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#1\");\n};\n};\nfunc event GameInit()\n{\n// Calls the function with the namespace specified in the META block\nfunc01();\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#global-namespace-and-daedalus-hooking","title":"Global namespace and Daedalus hooking","text":"<p>Namespace can not only be defined to an existing symbol but also to define new ones. Next code example shows how to implement a hook to a global instance.</p> <p><pre><code>namespace zTestNamespace01\n{\nconst string Var01 = \"New instance name\";\n// Hooking the global instance\ninstance :ItAr_Pir_L_Addon(C_Item)\n{\nItAr_Pir_L_Addon_Old();\nname = Var01;\n};\n};\n</code></pre> To hook an object, both signature and namespace has to match. It is syntactically allowed to hook an instance from a different space. Specify explicitly to which namespace the object will belong. This means that to hook instance <code>ItAr_Pir_L_Addon</code> from the namespace <code>zTestNamespace01</code> to a global namespace, you have to refer to the global namespace using the namespace operator <code>:</code>. Since the function will be defined globally (as every symbol in ZenGin), it will be a part of the <code>zTestNamespace01</code> which means that all functions will be local to this namespace.</p>"},{"location":"zengin/scripts/extenders/zparserextender/other/","title":"Other functions of the extender","text":""},{"location":"zengin/scripts/extenders/zparserextender/other/#ini-parameters","title":"ini parameters","text":"<p>The choice of ini file depends on how the game was launched. If it was launched from Gothic.exe, then the parameters will be read from <code>SystemPack.ini</code>. If it was launched through GothicStarter.exe, then they will be read from the ini of the mod.</p> <pre><code>[zParserExtender]\nLoadScript(obsolete) =\n;specifies a parser-script format script to run the scripts. The parameter is currently invalid.\nMergeMode = True\n;specifies whether injections will produce hooks.\nCompileDat = False\n;Determines if a copy of DAT file which has been modified by injection will be created.\nCompileOU = False\n;determines if a copy of an injection-modified OU file will be created.\nNativeWhile = False\n;Determines if a WHILE loop will be compiled. Defaults to False (for Ninja compatibility).\nMessagesLevel = 1\n;sets the output level. The higher the level, the more information will be printed to the debug console.\nStringIndexingMode = -1\n;defines string indexing mode (see string indexing). Default value is -1.\n;Default   = -1 - The default mode for the moment is Repair mode.\n;Disabled  =  0 - Do nothing with the indices.\n;TopSymbol =  1 - The plugin finds the uppermost unnamed string and sets a counter for it.\n;Repair    =  2 - The plugin goes through the whole string table and, if the indexing order is broken, puts the correct names. The counter is set on the basis of the search.\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/other/#marvin-console-commands","title":"MARVIN console commands","text":"<p>zParserExtender adds console commands that save copies of the <code>.dat</code> files with the injected code.</p> <p>Warning</p> <p>If the mod uses Ikarus, the <code>CompileDat</code> option (in the <code>.ini</code> file) should be used since a fatal error may occur whe using the command.</p> <pre><code>Parser SaveDat OU        - exports OU.Edited.bin\nParser SaveDat Game      - exports Gothic.Edited.dat\nParser SaveDat SFX       - exports SFX.Edited.dat\nParser SaveDat PFX       - exports ParticleFX.Edited.dat\nParser SaveDat VFX       - exports VisualFX.Edited.dat\nParser SaveDat Camera    - exports Camera.Edited.dat\nParser SaveDat Menu      - exports Menu.Edited.dat\nParser SaveDat Music     - exports Music.Edited.dat\nParser Export Stringlist - exports the full string table to Scripts\\Exports\\StringList.d\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/other/#launch-options","title":"Launch options","text":"<p>Command line parameters can be passed to the game's exe via the command line or using GothicStarter_Mod.</p> <pre><code>zReparse_OU     - parses and creates OU.bin\nzReparse_Game   - parses and creates Gothic.dat\nzReparse_SFX    - parses and creates SFX.dat\nzReparse_PFX    - parses and creates ParticleFX.dat\nzReparse_VFX    - parses and creates VisualFX.dat\nzReparse_Camera - parses and creates Camera.dat\nzReparse_Menu   - parses and creates Menu.dat\nzReparse_Music  - parses and creates Music.dat\n</code></pre> <p>Note</p> <p>If you want to compile OU, you also have to include the Game parameter</p> <p>-zReparse_Game -zReparse_OU</p>"},{"location":"zengin/scripts/extenders/zparserextender/other/#const-array-access","title":"Const array access","text":"<p>The original zParser doesn't allow direct access to <code>const string</code> arrays. zParserExtender allows you to do so.</p> <p>Example: <pre><code>func event GameInit()\n{\nHlp_MessageBox(TXT_INV_CAT[4]); // Prints \"Artifacts\"\n};\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/other/#other-engine-fixes","title":"Other engine fixes","text":"<ol> <li>When creating an item instance, the instance is placed into the global <code>item</code> instance</li> <li>On DAT file load, the engine restores the original symbol hierarchy</li> <li>When loading a save, the engine now skips unknown symbols, instead of crashing</li> </ol>"},{"location":"zengin/scripts/extenders/zparserextender/testelse/","title":"Test-else statements","text":"<p>The test-else bind statement can be used to define sections of code to be compiled. If the code is within the boundaries of the inactive test-else branch, it will not be compiled. This operator can take values as input that are converted to logical values. For example, if an object is passed as an argument, the parser will check for its existence. If it is an engine tag, it will return the result of matching the current engine with the tag:</p> <p>Valid values:</p> <ul> <li>instance name - <code>PC_HERO</code>, <code>ItMi_Gold</code>, ...</li> <li>engine tag - <code>G1</code>, <code>G1A</code>, <code>G2</code>, <code>G2A</code></li> <li>Steam Overlay activity - <code>Steam</code></li> </ul> <p>The result can be combined from several arguments. Round brackets <code>()</code> ca be used to specify priority and expressions support the logical negation operator <code>!</code>, logical AND <code>&amp;&amp;</code> and OR <code>||</code>.</p> <p>The operator can be used anywhere in the script file. It is syntactically similar to <code>if else</code> statement, but curly braces <code>{}</code> can be omitted for single-line operations. For example: SteamActivated constant is set only when Steam is active<pre><code>test Steam var const SteamActivated = 1;\n</code></pre></p> Example of a logical expression with an else branch<pre><code>test SteamActivated &amp;&amp; G2A {\n// TODO\n}\nelse {\n// TODO\n}\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/while/","title":"Native WHILE loop","text":"<p>Just like Ikarus zParserExtender implements a while loop.</p> <pre><code>var int value; value = 10;\nwhile(value &gt; 0)\n{\nif (value == 8)\n{\ncontinue;\n};\nif (value == 2)\n{\nbreak;\n};\n};\n</code></pre> <p>Note</p> <p>To activate <code>while</code> it is necessary to set <code>NativeWhile</code> setting in SystemPack.ini <pre><code>[ZPARSE_EXTENDER]\nNativeWhile = true\n</code></pre></p> <p>Compiled while loop works in vanilla engine without the plugin.</p>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/","title":"Sign post teleportation","text":"<p>This is a short \"problem-solving\" example, where we try to demonstrate the power of Daedalus injection using zParserExtender. GaroK asked me if there is a way to teleport to all the sign posts in Khorinis to gather information for a Gothic wiki article. The goal is to introduce a function that will teleport you to every signpost in Khorinis with the press of a button.</p>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#the-problem","title":"The problem","text":"<p>In ZenGin you can teleport to named game objects with the <code>goto vob {vobname}</code> command. But since the signposts do not have a vobname defined, I had to figure out a different approach.</p>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#ascii-zen","title":"ASCII ZEN","text":"<p>We want to get all the signposts position from Khorinis. The game world was loaded into one of the available world editor, I found one of the signposts and noted the <code>visual</code> which dictates the model of the in-game object <code>nw_misc_sign_01.3DS</code>. Alternatively, you can find the standard vanilla objects from both games on this website. Next, the world was saved as a <code>ASCII ZEN</code> format. This allows us to write a macro to search for all instances of objects with a specific visual and extract the position vector.</p> One signpost object<pre><code>[% oCMOB:zCVob 47105 317]\npack=int:0\npresetName=string:\nbbox3DWS=rawFloat:7564.8291 127.361191 -80.5309067 7611.52441 377.422913 1.67681122 trafoOSToWSRot=raw:73e1673f9c4ec33b15efd8be4465d7bba0fe7f3f30ea7137e5edd83eecaa353bb7e2673f\ntrafoOSToWSPos=vec3:7588.17627 252.391052 -39.4283791\nvobName=string:\nvisual=string:NW_MISC_SIGN_01.3DS\nshowVisual=bool:1\nvisualCamAlign=enum:0\nvisualAniMode=enum:0\nvisualAniModeStrength=float:0\nvobFarClipZScale=float:1\ncdStatic=bool:1\ncdDyn=bool:1\nstaticVob=bool:1\ndynShadow=enum:0\nzbias=int:0\nisAmbient=bool:0\n[visual zCProgMeshProto 53505 318]\n[]\n[ai % 0 0]\n[]\nfocusName=string:MOBNAME_INCITY02\nhitpoints=int:10\ndamage=int:0\nmoveable=bool:0\ntakeable=bool:0\nfocusOverride=bool:0\nsoundMaterial=enum:0\nvisualDestroyed=string:\nowner=string:\nownerGuild=string:\nisDestroyed=bool:0\n[]\n</code></pre> <p>Tip</p> <p>You can also see that the <code>focusName</code> has a <code>MOBNAME_INCITY02</code> string constant. This constant is defined in the scripts and its content is used as the focus name. <pre><code>const string MOBNAME_INCITY02 = \"To Marketplace\";\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#the-injectable-script","title":"The injectable script","text":"<p>As it is an injectable script, we have to specify the <code>META</code> tag. Lets tell zParseExtender to insert this code into the game parser. <pre><code>META\n{\nParser = Game\n};\n</code></pre> We want to teleport the player and for this we will need the <code>C_Position</code> and <code>C_Vob_Data</code> classes. <pre><code>class C_Position\n{\nvar int X; // X coordinate\nvar int Y; // Y coordinate\nvar int Z; // Z coordinate\n};\nclass C_VOB_DATA\n{\nvar string Name;              // object name\nvar float VisualAlpha;        // object's transparency 0.0 - 1.0\nvar int ShowVisual;           // display the mode\nvar int DrawBBox3D;           // show objects bounding box\nvar int VisualAlphaEnabled;   // enables objects transparency\nvar int PhysicsEnabled;       // enables object's physics\nvar int IgnoredByTraceRay;    // allow any object collisions\nvar int CollDetectionStatic;  // allow collision with static world polygons\nvar int CollDetectionDynamic; // allow collision with dynamic world objects\nvar int CastDynShadow;        // display shadow of the object\nvar int LightColorStatDirty;  // allow static liging of the object\nvar int LightColorDynDirty;   // allow dynamic lighing of the object\nvar int SleepingMode;         // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only)\nvar int DontWriteIntoArchive; // turns of the serialization of this object to the save file \n};\n</code></pre> It turns out there is 54 instances of objects with the desired visual. Let us define <code>const int NUM_OF_SIGNS = 54</code> and a <code>const int MAX_COORDS = 3 * NUM_OF_SIGNS</code> - we will store 3 times 54 integers - for every signpost a <code>x</code>, <code>y</code> and <code>z</code> coordinate. And lastly a <code>const int</code> array containing all the positions. <pre><code>// Number of signs we want to jump to\nconst int NUM_OF_SIGNS = 54;\nconst int MAX_COORDS = 3 * NUM_OF_SIGNS;\nconst int sign_coordinates[MAX_COORDS] = {\n11974,  309,   6815,\n12024,  310,   6778,\n12411,  1668,  -22495,\n19491,  1281,  1669,\n19563,  1281,  1687,\n20294,  2058,  12487,\n20324,  2058,  12419,\n21917,  2900,  -22751,\n2600,   -57,   -4351,\n26695,  2419,  4308,\n26770,  2418,  4319,\n26978,  2937,  6130,\n27015,  2936,  6104,\n27049,  2937,  6159,\n2964,   2142,  14424,\n31383,  3896,  4699,\n31427,  3896,  4640,\n35368,  3870,  -4374,\n35435,  3870,  -4355,\n35437,  3871,  -4399,\n36205,  3333,  -27186,\n37774,  3875,  -501,\n37812,  3874,  -469,\n37849,  3874,  -512,\n38291,  3732,  -6699,\n39276,  3926,  -3357,\n39307,  3924,  -3313,\n39351,  3924,  -3359,\n39435,  4350,  10902,\n39458,  4350,  10827,\n40932,  3861,  -3054,\n42454,  2838,  -19437,\n5297,   387,   -2145,\n5358,   387,   -2184,\n5362,   387,   -2128,\n54006,  1723,  -10316,\n54035,  1723,  -10387,\n551,    -62,   -1820,\n61080,  2132,  -11622,\n61155,  2132,  -11625,\n6408,   392,   3598,\n6432,   393,   3652,\n7000,   387,   -1482,\n73439,  3341,  -11307,\n7588,   252,   -39,\n7590,   252,   -109,\n7642,   253,   -83,\n7713,   387,   -4782,\n7758,   386,   -4775,\n7776,   388,   -4811,\n8154,   1206,  -17022,\n8855,   395,   -2402,\n9704,   393,   5129,\n9738,   392,   5108\n};\n</code></pre> Next define a built in event <code>GameLoop</code> function, to check for a pressed key. If the key <code>U</code> is pressed, the <code>jump_to_sign</code> function is called. <pre><code>// check for pressed U button every frame\nfunc event GameLoop()\n{\n// if U is toggled, run the function\nif (Hlp_KeyToggled(KEY_U))\n{\njump_to_sign();\n};\n};\n</code></pre></p> <p>Let's look at the <code>jump_to_sign</code> function now. This function is called on every <code>U</code> key press and goes through all the signposts and teleports the player to them. At the start of the function we check if the index is not out of bounds and if it is, sets it back to 0 and starts over. <pre><code>    // if we reached the end, start over\nif (tp_index &gt;= NUM_OF_SIGNS)\n{\ntp_index = 0;\n};\n</code></pre> Notice the use of <code>Str_Format</code> function for the formatted output. <pre><code>// give information to the player\nPrint(Str_Format(\"Sign %i/%i\", tp_index+1, NUM_OF_SIGNS));\nvar C_Position pos;  pos  = Vob_GetVobPosition(hero);\nvar C_Vob_Data data; data = Vob_GetVobData(hero);\n</code></pre> Daedalus does not allow array access with variables (only constants and literals). To access the coordinate array we use a selection of parser functions. Firstly we get the game parser ID. Then we can use the <code>Par_GetSymbolValueIntArray</code> to access the <code>sign_coordinates</code> array and assign the coordinates to the <code>pos</code> variable. <pre><code>// get parser ID for the GAME parser\nvar int game_par_id; game_par_id = Par_GetParserID(\"game\");\n// get parser ID of the array\nvar int arr_id; arr_id = Par_GetSymbolID(game_par_id ,\"sign_coordinates\");\n// access the coordinates from above array\npos.x = Par_GetSymbolValueIntArray(game_par_id ,arr_id ,tp_index * 3    ); pos.y = Par_GetSymbolValueIntArray(game_par_id ,arr_id ,tp_index * 3 + 1);\npos.z = Par_GetSymbolValueIntArray(game_par_id ,arr_id ,tp_index * 3 + 2);\n</code></pre> And now comes the big trick. If you try to just change the position the dynamic and static collision is going to stop you at the first wall, tree or a mountain. To disable it, we can use the <code>C_Vob_Data</code> helper class, get players data, and disable both the static a dynamic collision. First we create a backup of the values just so we can restore them back after the teleport. <pre><code>// backup original collision detection\nvar int dyn;   dyn = data.CollDetectionDynamic;\nvar int stat; stat = data.CollDetectionStatic;\n// turn off collision detection \ndata.CollDetectionDynamic = 0;\ndata.CollDetectionStatic  = 0;\n</code></pre> Let us apply the changed data to the player and edit the position. <pre><code>// apply the edited data to player\nVob_SetVobData(hero, data);\n// move the player \nVob_SetVobPosition(hero, pos);\n</code></pre> Restore the collision detection data from the backup we made and set it. <pre><code>// restore collision detection\ndata.CollDetectionDynamic = dyn;\ndata.CollDetectionStatic  = stat;\n// apply the edited data to player\nVob_SetVobData(hero, data);\n</code></pre> Finally, we advance the index to jump to another signpost. <pre><code>// advance the index\ntp_index += 1;\n</code></pre></p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/","title":"AI - functions for working with AI","text":"<p>Functions to work with the new <code>C_Trigger</code> class and NPC's AI queue.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_callscript","title":"AI_CallScript","text":"<p>Adds a <code>funcName</code> function call to the AI queue</p> <pre><code>func void AI_CallScript(var string funcName,\nvar C_NPC slf,\nvar C_NPC oth) {};\n</code></pre> <ul> <li><code>funcName</code> - name of the function to be called</li> <li><code>slf</code> - will be inserted into global <code>self</code> instance</li> <li><code>oth</code> - will be inserted into global <code>other</code> instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_starttriggerscript","title":"AI_startTriggerScript","text":"<p>Creates a trigger script that calls function <code>funcName</code> once every <code>interval</code> in milliseconds</p> <pre><code>func C_Trigger AI_startTriggerScript(var string funcName, var int interval) {};\n</code></pre> <ul> <li><code>funcName</code> - name of the function to be called</li> <li><code>interval</code> - call period in milliseconds</li> <li><code>return</code> - created C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_starttriggerscriptex","title":"AI_startTriggerScriptEx","text":"<p>Extended version call - Creates a trigger script, that calls function <code>funcName</code> once every <code>interval</code> in milliseconds also updates the <code>self</code>, <code>other</code> and <code>victim</code> global instances based on <code>slf</code>, <code>oth</code> and <code>vct</code> parameters respectively</p> <pre><code>func C_Trigger AI_startTriggerScriptEx( var string funcName,\nvar int interval,\nvar C_NPC slf,\nvar C_NPC oth,\nvar C_NPC vct) {};\n</code></pre> <ul> <li><code>funcName</code> - name of the function to be called</li> <li><code>interval</code> - call period in milliseconds</li> <li><code>slf</code> - will be inserted into global <code>self</code> instance</li> <li><code>oth</code> - will be inserted into global <code>other</code> instance</li> <li><code>vct</code> - will be inserted into global <code>victim</code> instance</li> <li><code>return</code> - created C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerbyid","title":"AI_GetTriggerByID","text":"<p>Returns a C_Trigger instance from the array of active triggers by the array index <code>ID</code></p> <pre><code>func C_Trigger AI_GetTriggerByID(var int ID) {};\n</code></pre> <ul> <li><code>ID</code> - array id</li> <li><code>return</code> - active C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggersnum","title":"AI_GetTriggersNum","text":"<p>Returns the number of active C_Trigger scripts</p> <pre><code>func int AI_GetTriggersNum() {};\n</code></pre> <ul> <li><code>return</code> - number of active C_Trigger scripts</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggernpc","title":"AI_GetTriggerNPC","text":"<p>Returns the npc associated with the C_Trigger script based on the ID selfID   = 0; otherID  = 1; victimID = 2;</p> <pre><code>func C_NPC AI_GetTriggerNPC(var C_Trigger trigger, var int npcID) {};\n</code></pre> <ul> <li><code>trigger</code> - C_Trigger script</li> <li><code>npcID</code> - NPC id</li> <li><code>return</code> - active C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerfunc","title":"AI_GetTriggerFunc","text":"<p>Returns the function associated with the specified C_Trigger</p> <pre><code>func func AI_GetTriggerFunc(var C_Trigger trigger) {};\n</code></pre> <ul> <li><code>trigger</code> - C_Trigger script</li> <li><code>return</code> - trigger function</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerfuncname","title":"AI_GetTriggerFuncName","text":"<p>Returns the function name of a function associated with the specified C_Trigger</p> <pre><code>func string AI_GetTriggerFuncName(var C_Trigger trigger) {};\n</code></pre> <ul> <li><code>trigger</code> - C_Trigger script</li> <li><code>return</code> - active C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyfunc","title":"Ai_GetNextTriggerByFunc","text":"<p>Returns the next trigger in the active trigger array based on the trigger function, starting on the <code>startTrigger</code> trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByFunc(var C_Trigger startTrigger, var func function) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>function</code> - function to be matched</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyfuncname","title":"Ai_GetNextTriggerByFuncName","text":"<p>Returns the next trigger in the active trigger array based on the trigger function name, starting on the <code>startTrigger</code> trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByFuncName(var C_Trigger startTrigger, var string functionName) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>functionName</code> - name of a function to be matched</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyself","title":"Ai_GetNextTriggerBySelf","text":"<p>Returns the next trigger in the active trigger array based on the <code>self</code> trigger parameter, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerBySelf(var C_Trigger startTrigger, var C_NPC self) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>self</code> - C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyother","title":"Ai_GetNextTriggerByOther","text":"<p>Returns the next trigger in the active trigger array based on the <code>other</code> trigger parameter, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByOther(var C_Trigger startTrigger, var C_NPC other) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>other</code> - C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyvictim","title":"Ai_GetNextTriggerByVictim","text":"<p>Returns the next trigger in the active trigger array based on the <code>victim</code> trigger parameter, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByVictim( var C_Trigger startTrigger, var C_NPC victim ) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>victim</code> - C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbynpcs","title":"Ai_GetNextTriggerByNPCs","text":"<p>Returns the next trigger in the active trigger array based on all the NPCs set in the trigger script <code>self</code>, <code>other</code> and <code>victim</code>, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func c_trigger Ai_GetNextTriggerByNPCs( var C_Trigger startTrigger,\nvar C_NPC self,\nvar C_NPC other,\nvar C_NPC victim) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>self</code> - self C_NPC instance</li> <li><code>other</code> - other C_NPC instance</li> <li><code>victim</code> - victim C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/","title":"CAST - data type conversion functions","text":"<p>External functions for data type conversion and pointer casting.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertoinstance","title":"Cast_PointerToInstance","text":"<p>Converts memory address (pointer) to an instance</p> <pre><code>func instance Cast_PointerToInstance(var int address) {};\n</code></pre> <ul> <li><code>address</code> - object pointer</li> <li><code>return</code> - instance of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instancetopointer","title":"Cast_InstanceToPointer","text":"<p>Converts instance to a memory address (pointer)</p> <pre><code>func int Cast_InstanceToPointer( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object instance</li> <li><code>return</code> - memory address (pointer) of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertonpc","title":"Cast_PointerToNpc","text":"<p>Casts memory address (pointer) to an NPC</p> <pre><code>func C_NPC Cast_PointerToNpc( var int address) {};\n</code></pre> <ul> <li><code>address</code> - npc pointer</li> <li><code>return</code> - NPC instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertoitem","title":"Cast_PointerToItem","text":"<p>Casts memory address (pointer) to an Item</p> <pre><code>func C_ITEM Cast_PointerToItem( var int address) {};\n</code></pre> <ul> <li><code>address</code> - item pointer</li> <li><code>return</code> - Item instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceisnpc","title":"Cast_InstanceIsNpc","text":"<p>Checks whether object is an NPC</p> <pre><code>func int Cast_InstanceIsNpc( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object to check</li> <li><code>return</code> - <code>TRUE</code> or <code>FALSE</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceisitem","title":"Cast_InstanceIsItem","text":"<p>Checks whether object is an Item</p> <pre><code>func int Cast_InstanceIsItem( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object to check</li> <li><code>return</code> - <code>TRUE</code> or <code>FALSE</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceismob","title":"Cast_InstanceIsMob","text":"<p>Checks whether object is an MOB</p> <pre><code>func int Cast_InstanceIsMob( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object to check</li> <li><code>return</code> - <code>TRUE</code> or <code>FALSE</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getinstanceindex","title":"Cast_GetInstanceIndex","text":"<p>Returns symbolID of the object, returns -1 when not found</p> <pre><code>func int Cast_GetInstanceIndex( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - instance of an object</li> <li><code>return</code> - symbol table index, -1 when not found</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getclassid","title":"Cast_GetClassID","text":"<p>Returns the class identifier of a class by its name</p> <pre><code>func int Cast_GetClassID( var string className ) {};\n</code></pre> <ul> <li><code>className</code> - name of the class</li> <li><code>return</code> - class identifier</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getvobclassid","title":"Cast_GetVobClassID","text":"<p>Returns class identifier of the zCObject vob class</p> <pre><code>func int Cast_GetVobClassID( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - object instance</li> <li><code>return</code> - class zCObject identifier</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_checkvobclassid","title":"Cast_CheckVobClassID","text":"<p>Checks if the classId class is the parent class of the object</p> <pre><code>func int Cast_CheckVobClassID( var int classId, var instance object ) {};\n</code></pre> <ul> <li><code>classId</code> - class identifier, from Cast_GetClassID function</li> <li><code>object</code> - object instance</li> <li><code>return</code> - class zCObject identifier</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/events_vars/","title":"Event functions and variables","text":"<p>On top of external functions, zParserExtender also adds these event functions and constants.</p> <pre><code>/// Every event function with this name is exectued once every frame\nfunc event GameLoop() {};\n/// Every event function with this name is exectued once on game init\nfunc event GameInit() {};\n/// empty instance\nconst instance null;\n/// not a number floating point constant\nconst float NaN;\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/","title":"HLP - help functions","text":"<p>Helper functions generally used for safety checks, to get specific information from the engine or to interface with the configuration <code>.ini</code> files.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_hasfocusvob","title":"Hlp_HasFocusVob","text":"<p>Returns <code>TRUE</code>, if a specified NPC has a Vob in focus</p> <pre><code>func int Hlp_HasFocusVob( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> <li><code>return</code> - <code>TRUE</code> if npc has a focus Vob, <code>FALSE</code> if it does not</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getfocusvob","title":"Hlp_GetFocusVob","text":"<p>Returns NPC's focus Vob</p> <pre><code>func instance Hlp_GetFocusVob( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> <li><code>return</code> - focus vob</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getfocusvobname","title":"Hlp_GetFocusVobName","text":"<p>Returns the name of NPC's focus vob</p> <pre><code>func string Hlp_GetFocusVobName( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> <li><code>return</code> - focus vob name</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getstringlength","title":"Hlp_GetStringLength","text":"<p>Returns the length of a specified string</p> <pre><code>func int Hlp_GetStringLength( var string str ) {};\n</code></pre> <ul> <li><code>return</code> - length of <code>str</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#isnan","title":"IsNAN","text":"<p>Checks whether floating point number is valid</p> <pre><code>func int IsNAN( var float value ) {};\n</code></pre> <ul> <li><code>return</code> - <code>TRUE</code> if <code>value</code> is NaN, <code>FALSE</code> if <code>value</code> is a valid floating point number</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_keytoggled","title":"Hlp_KeyToggled","text":"<p>Checks whether <code>key</code> is toggled</p> <pre><code>func int Hlp_KeyToggled( var int key ) {};\n</code></pre> <ul> <li><code>key</code> - key code</li> <li><code>return</code> - <code>TRUE</code> if key is toggled, <code>FALSE</code> if key is not toggled</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_keypressed","title":"Hlp_KeyPressed","text":"<p>Checks whether <code>key</code> is pressed</p> <pre><code>func int Hlp_KeyPressed( var int key ) {};\n</code></pre> <ul> <li><code>key</code> - key code</li> <li><code>return</code> - <code>TRUE</code> if key is pressed, <code>FALSE</code> if key is not pressed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_logicalkeytoggled","title":"Hlp_LogicalKeyToggled","text":"<p>Checks whether logical <code>key</code> is toggled</p> <pre><code>func int Hlp_LogicalKeyToggled( var int key ) {};\n</code></pre> <ul> <li><code>key</code> - key code</li> <li><code>return</code> - <code>TRUE</code> if key is toggled, <code>FALSE</code> if key is not toggled</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_gameonpause","title":"Hlp_GameOnPause","text":"<p>Checks whether the game is paused</p> <pre><code>func int Hlp_GameOnPause() {};\n</code></pre> <ul> <li><code>return</code> - <code>TRUE</code> if the game is paused, <code>FALSE</code> if the game is not paused</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_messagebox","title":"Hlp_MessageBox","text":"<p>Opens a message box with a specified message</p> <pre><code>func void Hlp_MessageBox( var string message ) {};\n</code></pre> <ul> <li><code>message</code> - message to be printed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_printconsole","title":"Hlp_PrintConsole","text":"<p>Prints a message to the Union debug console</p> <pre><code>func void Hlp_PrintConsole(var string message) {};\n</code></pre> <ul> <li><code>message</code> - message to be printed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_optionisexists","title":"Hlp_OptionIsExists","text":"<p>Checks whether the <code>entry</code> in <code>section</code> in <code>.ini</code> file <code>optName</code> exists</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func int Hlp_OptionIsExists(var string optName, var string section, var string entry) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[GAME]</code></li> <li><code>entry</code> - one setting entry like <code>playLogoVideos</code></li> <li><code>return</code> - <code>TRUE</code> if the option exists, <code>FALSE</code> if the option does not exist</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionint","title":"Hlp_ReadOptionInt","text":"<p>Read an integer value from specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func int Hlp_ReadOptionInt(var string optName, var string section, var string entry, var int default) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[GAME]</code></li> <li><code>entry</code> - one setting entry like <code>playLogoVideos</code></li> <li><code>default</code> - default value - if the value is empty</li> <li><code>return</code> - the option value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionfloat","title":"Hlp_ReadOptionFloat","text":"<p>Read a floating point value from specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func float Hlp_ReadOptionFloat(var string optName, var string section, var string entry, var float default) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>default</code> - default value - if the value is empty</li> <li><code>return</code> - the option value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionstring","title":"Hlp_ReadOptionString","text":"<p>Read a string value from specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func string Hlp_ReadOptionString(var string optName, var string section, var string entry, var string default) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>default</code> - default value - if the value is empty</li> <li><code>return</code> - the option value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionint","title":"Hlp_WriteOptionInt","text":"<p>Writes an integer value to specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func void Hlp_WriteOptionInt(var string optName, var string section, var string entry, var int value) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>value</code> - value to be written</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionfloat","title":"Hlp_WriteOptionFloat","text":"<p>Writes a floating point value to specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func void Hlp_WriteOptionFloat(var string optName, var string section, var string entry, var float value) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>value</code> - value to be written</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionstring","title":"Hlp_WriteOptionString","text":"<p>Writes a string value to specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func void Hlp_WriteOptionString(var string optName, var string section, var string entry, var string value) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>value</code> - value to be written</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getsteampersonalname","title":"Hlp_GetSteamPersonalName","text":"<p>Returns the name of the current Steam user Returns empty string when not run with Steam</p> <pre><code>func string Hlp_GetSteamPersonalName() {};\n</code></pre> <ul> <li><code>return</code> - string containing the Steam username, or an empty string</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/","title":"Log functions","text":"<p>As discussed on Inside Gothic, vanilla Gothic has no way of getting the status of a quest. These functions implement that functionality.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log_gettopicstatus","title":"Log_GetTopicStatus","text":"<p>Returns the status of diary topic</p> <ul> <li><code>-1</code> - Not found</li> <li><code>0</code> - Free</li> <li><code>1</code> - Running</li> <li><code>2</code> - Success</li> <li><code>3</code> - Failure</li> <li><code>4</code> - Obsolete</li> </ul> <pre><code>func int Log_GetTopicStatus(var string topic) {};\n</code></pre> <ul> <li><code>topic</code> - name of the topic</li> <li><code>return</code> - topic status</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log_gettopicsection","title":"Log_GetTopicSection","text":"<p>Returns the topic the diary topic is in</p> <ul> <li><code>-1</code> - Not found</li> <li><code>0</code> - Missions</li> <li><code>1</code> - Notes</li> <li><code>2</code> - All</li> </ul> <pre><code>func int Log_GetTopicSection(var string topic) {};\n</code></pre> <ul> <li><code>topic</code> - name of the topic</li> <li><code>return</code> - topic section</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/","title":"MDL - model functions","text":"<p>Functions to tweak animation and other model related settings.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_getanimationindex","title":"Mdl_GetAnimationIndex","text":"<p>Returns animation's index for specified NPC based on animation's name</p> <pre><code>func int Mdl_GetAnimationIndex( var C_NPC npc, var string ani_name ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_name</code> - name of the animation in uppercase</li> <li><code>return</code> - animation index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_getanimationname","title":"Mdl_GetAnimationName","text":"<p>Returns animation's name for specified NPC based on animation's index</p> <pre><code>func string Mdl_GetAnimationName( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>return</code> - animation name</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_animationisexists","title":"Mdl_AnimationIsExists","text":"<p>Checks whether animation exists</p> <pre><code>func int Mdl_AnimationIsExists( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>return</code> - animation name</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_animationisactive","title":"Mdl_AnimationIsActive","text":"<p>Checks whether animation is active (whether it is currently played)</p> <pre><code>func int Mdl_AnimationIsActive( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>return</code> - <code>TRUE</code> if the animation is playing, <code>FALSE</code> if it is not playing</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setallanimationsfps","title":"Mdl_SetAllAnimationsFPS","text":"<p>Set framerate for all animations</p> <pre><code>func void Mdl_SetAllAnimationsFPS( var C_NPC npc, var float fps ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>fps</code> - framerate</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetallanimationsfps","title":"Mdl_ResetAllAnimationsFPS","text":"<p>Reset framerate for all animations to default value</p> <pre><code>func void Mdl_ResetAllAnimationsFPS( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setanimationfps","title":"Mdl_SetAnimationFPS","text":"<p>Set framerate for animation specified by animation index</p> <pre><code>func void Mdl_SetAnimationFPS( var C_NPC npc, var int ani_index, var float fps ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>fps</code> - framerate</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetanimationfps","title":"Mdl_ResetAnimationFPS","text":"<p>Reset framerate to default for animation specified by animation index</p> <pre><code>func void Mdl_ResetAnimationFPS( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setvisible","title":"Mdl_SetVisible","text":"<p>Set NPCs visibility</p> <pre><code>func void Mdl_SetVisible( var C_NPC npc, var int isVisible ) {};\n</code></pre> <ul> <li><code>npc</code> - specified NPC</li> <li><code>isVisible</code> - <code>TRUE</code> - visible, <code>FALSE</code> - invisible</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_applyoverlaymds_atfirst","title":"Mdl_ApplyOverlayMds_AtFirst","text":"<p>Applies or moves existing overlay to the top of the list</p> <pre><code>func void Mdl_ApplyOverlayMds_AtFirst( var string mdsName ) {};\n</code></pre> <ul> <li><code>mdsName</code> - name of the overlay</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setnpcspeedmultiplier","title":"Mdl_SetNpcSpeedMultiplier","text":"<p>Sets a multiplier for animation speed 1.0 = 100% speed (normal speed)</p> <pre><code>func void Mdl_SetNpcSpeedMultiplier( var C_Npc npc, var float multiplier ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>multiplier</code> - speed of the animation</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetnpcspeedmultiplier","title":"Mdl_ResetNpcSpeedMultiplier","text":"<p>Resets the animation speed of an NPC</p> <pre><code>func void Mdl_ResetNpcSpeedMultiplier( var C_Npc npc ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/","title":"Menu function","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#menu_searchitems","title":"Menu_SearchItems","text":"<p>Find all C_MenuItem object instances by the mask and automatically places them in the current menu instance</p> <pre><code>func void Menu_SearchItems( var string mask ) {};\n</code></pre> <ul> <li><code>mask</code> - regex like mask for searching</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#example","title":"Example","text":"<p>This function is used in the Union Menu API script. In this script the <code>Menu_SearchItems</code> external is used to collect all Union menu scripts that are placed into the Union &amp; Plugins menu that will appear in the game if you use any of the plugins that use this feature.  </p> Usage of Menu_SearchItems external function<pre><code>instance MENU_OPT_UNION(C_MENU_DEF)\n{\nMenu_SearchItems(\"MENUITEM_UNION_AUTO_*\");\nMENU_OPT_UNION_PY = 1200;\nbackpic           = MENU_BACK_PIC;\nitems[0]          = \"UNION_MENUITEM_TITLE\";\nitems[100]        = \"UNION_MENUITEM_BACK\";\ndefaultoutgame    = 0;\ndefaultingame     = 0;\nFlags             = Flags | MENU_SHOW_INFO;\n};\n</code></pre> <p>In this case all instances are of the name <code>MENUITEM_UNION_AUTO_*</code> where <code>*</code> is a wildcard that can be substituted with anything. The plugin will search the scripts and find all instances (in the case of zGamePad it is <code>MenuItem_Union_Auto_zGamePad</code>)</p> <p>This example comes from the <code>zUnionMenu.d</code> injectable API script that is part of the zGamePad plugin, GitHub link.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/","title":"MOB - interactive object functions","text":"<p>Functions to manipulate interactive objects like destroying MOBs, setting lockpick combination and such.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_destroy","title":"Mob_Destroy","text":"<p>Marks oCMOB as destroyed, changes the visual to visualDestroyed (if present).</p> <pre><code>func void Mob_Destroy( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMOB to be destroyed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_removeitem","title":"Mob_RemoveItem","text":"<p>Removes an item from a oCMobContainer</p> <pre><code>func void Mob_RemoveItem( var instance object, var int item ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_removeitems","title":"Mob_RemoveItems","text":"<p>Removes specified number of items from a oCMobContainer</p> <pre><code>func void Mob_RemoveItems( var instance object, var int item, var int cnt ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be removed</li> <li><code>cnt</code> - number of items to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_insertitem","title":"Mob_InsertItem","text":"<p>Inserts an item into a oCMobContainer</p> <pre><code>func void Mob_InsertItem( var instance object, var int item ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be inserted</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_insertitems","title":"Mob_InsertItems","text":"<p>Inserts specified number of items into a oCMobContainer</p> <pre><code>func void Mob_InsertItems( var instance object, var int item, var int cnt ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be inserted</li> <li><code>cnt</code> - number of items to be inserted</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_getlockcombination","title":"Mob_GetLockCombination","text":"<p>Returns a lock combination of a oCMobContainer</p> <pre><code>func string Mob_GetLockCombination( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>return</code> - lock combination</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setlockcombination","title":"Mob_SetLockCombination","text":"<p>Sets a lock combination to a oCMobContainer</p> <pre><code>func void Mob_SetLockCombination( var instance object, var string comb ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>comb</code> - lock combination</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_islocked","title":"Mob_IsLocked","text":"<p>Returns <code>TRUE</code> if the object is locked</p> <pre><code>func int Mob_IsLocked( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>return</code> - <code>TRUE</code> if locked, <code>FALSE</code> if unlocked</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setlocked","title":"Mob_SetLocked","text":"<p>Set the lock status of the object</p> <pre><code>func void Mob_SetLocked( var instance object, var int locked ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>locked</code> - lock or unlock the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_getkeyinstance","title":"Mob_GetKeyInstance","text":"<p>Returns the key instance, that unlocks the object</p> <pre><code>func instance Mob_GetKeyInstance( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>return</code> - the key C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setkeyinstance","title":"Mob_SetKeyInstance","text":"<p>Stets the key instance, that unlocks the object</p> <pre><code>func void Mob_SetKeyInstance( var instance object, var int key ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>key</code> - the key C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/","title":"NPC - character functions","text":"<p>NPC related functions.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_setashero","title":"Npc_SetAsHero","text":"<p>Changes players character to specified <code>npc</code></p> <pre><code>func void Npc_SetAsHero( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC to be set as players character</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventory","title":"Npc_OpenInventory","text":"<p>Opens NPCs main inventory</p> <pre><code>func void Npc_OpenInventory( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventorysteal","title":"Npc_OpenInventorySteal","text":"<p>Opens the steal inventory of <code>npc</code>'s focus NPC</p> <pre><code>func void Npc_OpenInventorySteal( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventorytrade","title":"Npc_OpenInventoryTrade","text":"<p>Start the trading dialogue with specified NPC</p> <pre><code>func void Npc_OpenInventoryTrade( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getlefthanditem","title":"Npc_GetLeftHandItem","text":"<p>Returns an item in NPC's left hand slot</p> <pre><code>func C_Item Npc_GetLeftHandItem( var C_Npc npc ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>return</code> - found C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getrighthanditem","title":"Npc_GetRightHandItem","text":"<p>Returns an item in NPC's right hand slot</p> <pre><code>func C_Item Npc_GetRightHandItem( var C_Npc npc ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>return</code> - found C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getslotitem","title":"Npc_GetSlotItem","text":"<p>Returns an item from a slot with the slotName</p> <pre><code>func C_Item Npc_GetSlotItem( var C_Npc npc, var string slotName ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>slotName</code> - name of the slot</li> <li><code>return</code> - found C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_putinslot","title":"Npc_PutInSlot","text":"<p>Places an instance of the oCVom class (including items and NPCs) object into the slotName of the NPC The copyInInv parameter determines whether a copy of the object should remain in the character's inventory</p> <pre><code>func void Npc_PutInSlot(var C_Npc npc, var string slotName, var instance object, var int copyInInv) {};\n</code></pre> <ul> <li><code>npc</code> - npc to remove the item from</li> <li><code>slotName</code> - name of the slot from which to remove the item</li> <li><code>object</code> - object to be inserted into the slot</li> <li><code>copyInInv</code> - should a copy of the object stay in character inventory</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_removefromslot","title":"Npc_RemoveFromSlot","text":"<p>Removes an object from the slotName of the NPC. The dropIt parameter in Gothic 2 defines, whether object should drop out of the slot. In Gothic 1, this parameter is reserved and must be 0.</p> <pre><code>func void Npc_RemoveFromSlot(var C_Npc npc, var string slotName, var int dropIt) {};\n</code></pre> <ul> <li><code>npc</code> - npc to remove the item from</li> <li><code>slotName</code> - name of the slot from which to remove the item</li> <li><code>dropIt</code> - should the object be dropped</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/","title":"PAR - functions for parser manipulation","text":"<p>Parser functions are used to manipulate the parsers. Retrieve SymbolID, access arrays and such.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getparserid","title":"Par_GetParserID","text":"<p>Returns a parser ID of the parser with a <code>parName</code> name</p> <p>Parser names:</p> <ul> <li><code>\"Game\"</code></li> <li><code>\"SFX\"</code></li> <li><code>\"PFX\"</code></li> <li><code>\"VFX\"</code></li> <li><code>\"Camera\"</code></li> <li><code>\"Menu\"</code></li> <li><code>\"Music\"</code></li> </ul> <pre><code>func int Par_GetParserID(var string parName) {};\n</code></pre> <ul> <li><code>parName</code> - parser name</li> <li><code>return</code> - parser ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolid","title":"Par_GetSymbolID","text":"<p>Returns symbol ID for the symbol specified by its name</p> <pre><code>func int Par_GetSymbolID(var int parId, var string symName) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbollength","title":"Par_GetSymbolLength","text":"<p>Returns symbol length (number of elements)</p> <pre><code>func int Par_GetSymbolLength(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol length</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueint","title":"Par_GetSymbolValueInt","text":"<p>Returns the integer value of specified symbol</p> <pre><code>func int Par_GetSymbolValueInt(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluefloat","title":"Par_GetSymbolValueFloat","text":"<p>Returns the float value of specified symbol</p> <pre><code>func float Par_GetSymbolValueFloat(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluestring","title":"Par_GetSymbolValueString","text":"<p>Returns the string value of specified symbol</p> <pre><code>func string Par_GetSymbolValueString(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueinstance","title":"Par_GetSymbolValueInstance","text":"<p>Returns the instance value of specified symbol</p> <pre><code>func instance Par_GetSymbolValueInstance(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueintarray","title":"Par_GetSymbolValueIntArray","text":"<p>Returns the value of specified integer array at the <code>arrayID</code> index</p> <pre><code>func int Par_GetSymbolValueIntArray(var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>arrayID</code> - array index</li> <li><code>return</code> - value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluefloatarray","title":"Par_GetSymbolValueFloatArray","text":"<p>Returns the value of specified float array at the <code>arrayID</code> index</p> <pre><code>func float Par_GetSymbolValueFloatArray(var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>arrayID</code> - array index</li> <li><code>return</code> - value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluestringarray","title":"Par_GetSymbolValueStringArray","text":"<p>Returns the value of specified string array at the <code>arrayID</code> index</p> <pre><code>func string Par_GetSymbolValueStringArray(var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>arrayID</code> - array index</li> <li><code>return</code> - value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueint","title":"Par_SetSymbolValueInt","text":"<p>Sets a new integer value to specified symbol</p> <pre><code>func void Par_SetSymbolValueInt(var int value, var int parId, var int symId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluefloat","title":"Par_SetSymbolValueFloat","text":"<p>Sets a new float value to specified symbol</p> <pre><code>func void Par_SetSymbolValueFloat(var float value, var int parId, var int symId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluestring","title":"Par_SetSymbolValueString","text":"<p>Sets a new string value to specified symbol</p> <pre><code>func void Par_SetSymbolValueString(var string value, var int parId, var int symId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueinstance","title":"Par_SetSymbolValueInstance","text":"<p>Sets a new instance value to specified symbol</p> <pre><code>func void Par_SetSymbolValueInstance(var instance value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueintarray","title":"Par_SetSymbolValueIntArray","text":"<p>Sets a new integer value to specified integer array symbol</p> <pre><code>func void Par_SetSymbolValueIntArray(var int value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> <li><code>arrayId</code> - array index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluefloatarray","title":"Par_SetSymbolValueFloatArray","text":"<p>Sets a new float value to specified float array symbol</p> <pre><code>func void Par_SetSymbolValueFloatArray(var float value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> <li><code>arrayId</code> - array index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluestringarray","title":"Par_SetSymbolValueStringArray","text":"<p>Sets a new string value to specified string array symbol</p> <pre><code>func void Par_SetSymbolValueStringArray(var string value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> <li><code>arrayId</code> - array index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/","title":"String functions","text":"<p>Functions to manipulate and format strings.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_format","title":"Str_Format","text":"<p>Returns formatted string using format specifiers</p> <p>Format specifiers:</p> <ul> <li><code>%s</code> - inserts a string</li> <li><code>%i</code> - inserts an integer number</li> <li><code>%x</code> - inserts an integer in hexadecimal</li> <li><code>%f</code> - inserts a floating point number</li> <li><code>%b</code> - inserts a logical expression</li> <li><code>%p</code> - inserts a pointer</li> </ul> <pre><code>func string Str_Format( var string format, ... ) {};\n</code></pre> <ul> <li><code>return</code> - formatted string</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#examples","title":"Examples","text":"<p>Very powerful function, can be used to streamline strings used in the scripts as well as optimize them for translations.</p> <p>Define constants containing the string with format specifiers. <pre><code>const string MENU_SAVE = \"Slot %i - press ENTER to save in this slot.\";\nconst string MENU_LOAD = \"Slot %i - press ENTER to load saved game.\";\n</code></pre> Then define two format functions as such: <pre><code>func string GetSaveSlotString (var int number)\n{\nreturn Str_format(MENU_SAVE, number);\n};\n</code></pre> <pre><code>func string GetLoadSlotString (var int number)\n{\nreturn Str_format(MENU_LOAD, number);\n};\n</code></pre></p> <p>Tip</p> <p>Since the whole translatable string is saved in one constant, it is very easy for translators to change the word order. This was not possible to do without code change to the <code>ConcatStrings</code> function calls within the scripts. With this simple change, translators have to translate only 2 strings instead of 30 (15 + 15 slots) and only 2 strings are compiled into the compiled <code>Menu.dat</code> file.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlocalizedstring","title":"Str_GetLocalizedString","text":"<p>Returns a string in the current language, otherwise in English. Arguments MUST be encoded in UTF-8! The result string will be converted to appropriate ANSI string.</p> <pre><code>func string Str_GetLocalizedString( var string russian,\nvar string english,\nvar string german,\nvar string polish ) {};\n</code></pre> <ul> <li><code>russian</code> - Russian string</li> <li><code>english</code> - English string</li> <li><code>german</code> -  German string</li> <li><code>polish</code> -  Polish string</li> <li><code>return</code> - string in the current language</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlocalizedstringex","title":"Str_GetLocalizedStringEx","text":"<p>Returns a string in the current language, otherwise in English. Offers additional languages</p> <pre><code>func string Str_GetLocalizedStringEx(   var string russian,\nvar string english,\nvar string german,\nvar string polish,\nvar string romanian,\nvar string italian,\nvar string czech,\nvar string spanish ) {};\n</code></pre> <ul> <li><code>russian</code> -  Russian string</li> <li><code>english</code> -  English string</li> <li><code>german</code> -   German string</li> <li><code>polish</code> -   Polish string</li> <li><code>romanian</code> - Romanian string</li> <li><code>italian</code> -  Italian string</li> <li><code>czech</code> -    Czech  string</li> <li><code>spanish</code> -  Spanish string</li> <li><code>return</code> - string in the current language</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_utf8_to_ansi","title":"Str_UTF8_to_ANSI","text":"<p>Converts UTF-8 string into an ANSI string with codePage</p> <pre><code>func string Str_UTF8_to_ANSI( var string utf8, var int codePage ) {};\n</code></pre> <ul> <li><code>utf8</code> - string encoded in UTF8</li> <li><code>codePage</code> - codePage id, can be obtained from Str_GetCurrentCP</li> <li><code>return</code> -</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getcurrentcp","title":"Str_GetCurrentCP","text":"<p>Return the code page corresponding to the current language set in the Union System <pre><code>func int Str_GetCurrentCP() {};\n</code></pre></p> <ul> <li><code>return</code> - code page corresponding to the current language</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlength","title":"Str_GetLength","text":"<p>Returns the length of a string</p> <pre><code>func int Str_GetLength( var int str ) {};\n</code></pre> <ul> <li><code>str</code> - string to be measured</li> <li><code>return</code> - length of the string</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/","title":"VOB - functions for object manipulation","text":"<p>VOB functions allow you to manipulate game world objects.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getvobposition","title":"Vob_GetVobPosition","text":"<p>Returns the current position of the object in the world</p> <pre><code>func C_Position Vob_GetVobPosition( var C_Vob vob ) {};\n</code></pre> <ul> <li><code>vob</code> - vob to ge the position of</li> <li><code>return</code> - C_Position instance - position of the VOB</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setvobposition","title":"Vob_SetVobPosition","text":"<p>Sets the current position of the object in the world</p> <pre><code>func void Vob_SetVobPosition( var C_Vob vob, var C_Position pos ) {};\n</code></pre> <ul> <li><code>vob</code> - vob to get the position of</li> <li><code>pos</code> - new position of the vob</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getvobdata","title":"Vob_GetVobData","text":"<p>Returns the universal data of the zCVob object</p> <pre><code>func C_Vob_Data Vob_GetVobData( var C_Vob vob ) {};\n</code></pre> <ul> <li><code>vob</code> - VOB to get the position of</li> <li><code>return</code> - general vob data C_Vob_Data</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setvobdata","title":"Vob_SetVobData","text":"<p>Sets the universal data to a zCVob object</p> <pre><code>func void Vob_SetVobData( var C_Vob vob, var C_Vob_Data data ) {};\n</code></pre> <ul> <li><code>vob</code> - VOB to get the position of</li> <li><code>data</code> - general vob data C_Vob_Data</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getlightdata","title":"Vob_GetLightData","text":"<p>Returns zCVobLight object data</p> <pre><code>func C_Light_Data Vob_GetLightData( var C_Vob vobLight ) {};\n</code></pre> <ul> <li><code>vobLight</code> - vobLight object</li> <li><code>return</code> - C_Light_Data of the light</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setlightdata","title":"Vob_SetLightData","text":"<p>Sets the data of a zCVobLight object</p> <pre><code>func void Vob_SetLightData( var C_Vob vobLight, var C_Light_Data data ) {};\n</code></pre> <ul> <li><code>vobLight</code> - object to apply the light data to</li> <li><code>data</code> - C_Light_Data light data to be set</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_clearlightanilist","title":"Vob_ClearLightAniList","text":"<p>Clears the list of animation colours for the light source</p> <pre><code>func void Vob_ClearLightAniList( var C_Vob vobLight ) {};\n</code></pre> <ul> <li><code>vobLight</code> - light vob</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_addlightanicolor","title":"Vob_AddLightAniColor","text":"<p>Adds a color to the colour list</p> <pre><code>func void Vob_AddLightAniColor( var C_Vob vobLight, var C_Color col ) {};\n</code></pre> <ul> <li><code>vobLight</code> - object to apply the colour to</li> <li><code>col</code> - colour to be applied</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_addlightanicolorrgb","title":"Vob_AddLightAniColorRGB","text":"<p>Adds a color to the colour list</p> <pre><code>func void Vob_AddLightAniColorRGB(  var C_Vob vobLight,\nvar int r,\nvar int g,\nvar int b ) {};\n</code></pre> <ul> <li><code>vobLight</code> - object to apply the colour to</li> <li><code>r</code> - red colour channel</li> <li><code>g</code> - green colour channel</li> <li><code>b</code> - blue colour channel</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobdata","title":"Vob_GetMobData","text":"<p>Returns the data of the oCMOB object</p> <pre><code>func C_Mob_Data Vob_GetMobData( var C_Vob mob ) {};\n</code></pre> <ul> <li><code>mob</code> - oCMOB object</li> <li><code>return</code> - mob data</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobdata","title":"Vob_SetMobData","text":"<p>Sets the data of the oCMOB object</p> <pre><code>func void Vob_SetMobData( var C_Vob mob, var C_Mob_Data data ) {};\n</code></pre> <ul> <li><code>mob</code> - oCMOB object</li> <li><code>data</code> - C_Mob_Data to be set</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobinterdata","title":"Vob_GetMobInterData","text":"<p>Returns the data of the oCMobInter object</p> <pre><code>func MobInter_Data Vob_GetMobInterData( var C_Vob mobInter ) {};\n</code></pre> <ul> <li><code>mobInter</code> - oCMobInter object</li> <li><code>return</code> - MobInter_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobinterdata","title":"Vob_SetMobInterData","text":"<p>Sets the data of the oCMobInter object</p> <pre><code>func void Vob_SetMobInterData( var C_Vob mobInter, var C_MobInter_Data data ) {};\n</code></pre> <ul> <li><code>mobInter</code> - oCMobInter object</li> <li><code>data</code> - MobInter_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobinterdata_1","title":"Vob_GetMobInterData","text":"<p>Returns the data of the oCMobLockable object</p> <pre><code>func C_MobLockable_Data Vob_GetMobInterData( var C_Vob mobLock ) {};\n</code></pre> <ul> <li><code>mobLock</code> - oCMobLockable object</li> <li><code>data</code> - MobInter_Data of the object</li> <li><code>return</code> - C_MobLockable_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobinterdata_1","title":"Vob_SetMobInterData","text":"<p>Sets the data of the oCMobLockable object</p> <pre><code>func void Vob_SetMobInterData( var C_Vob mobLock, var C_MobLockable_Data data ) {};\n</code></pre> <ul> <li><code>mobLock</code> - oCMobLockable object</li> <li><code>data</code> - C_MobLockable_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/","title":"WLD - world manipulation functions","text":"<p>Functions related to the world. </p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_changelevel","title":"Wld_ChangeLevel","text":"<p>Trigger level change.</p> <pre><code>func void Wld_ChangeLevel( var string world, var string waypoint ) {};\n</code></pre> <ul> <li><code>world</code> - name of the world</li> <li><code>waypoint</code> - target waypoint</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_findvob","title":"Wld_FindVob","text":"<p>Return the VOB instance based on its name.</p> <pre><code>func instance Wld_FindVob( var string vobname ) {};\n</code></pre> <ul> <li><code>vobname</code> - name of the vob</li> <li><code>return</code> - zCVob pointer</li> <li><code>return</code> -</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_playeffectvob","title":"Wld_PlayEffectVob","text":"<p>Play a visual effect at specified vob</p> <pre><code>func void Wld_PlayEffectVob(    var string effect,\nvar instance pvob,\nvar int level,\nvar int damage,\nvar int damage_type,\nvar int damage_speed ) {};\n</code></pre> <ul> <li><code>effect</code> - effect name</li> <li><code>pvob</code> - Vob to play the effect at</li> <li><code>level</code> - effect level</li> <li><code>damage</code> - damage amount</li> <li><code>damage_type</code> - damage type</li> <li><code>damage_speed</code> - damage interval</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_playeffectat","title":"Wld_PlayEffectAt","text":"<p>Play a visual effect at specified world coordinates</p> <pre><code>func void Wld_PlayEffectAt( var string effect,\nvar instance coord,\nvar int level,\nvar int damage,\nvar int damage_type,\nvar int damage_speed ) {};\n</code></pre> <ul> <li><code>effect</code> - effect name</li> <li><code>coord</code> - world coordinates to play the effect at</li> <li><code>level</code> - effect level</li> <li><code>damage</code> - damage amount</li> <li><code>damage_type</code> - damage type</li> <li><code>damage_speed</code> - damage interval</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_togglerain","title":"Wld_ToggleRain","text":"<p>Turns on the rain</p> <pre><code>func void Wld_ToggleRain( var float weight, var float time ) {};\n</code></pre> <ul> <li><code>weight</code> - the strength of the rain</li> <li><code>time</code> - rain duration</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_setweathertype","title":"Wld_SetWeatherType","text":"<p>Sets the weather type. Types:</p> <p><code>0</code> - snow <code>1</code> - rain</p> <pre><code>func void Wld_SetWeatherType( var int type ) {};\n</code></pre> <ul> <li><code>type</code> - weather type</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_getweathertype","title":"Wld_GetWeatherType()","text":"<p>Returns the weather type. Types:</p> <p><code>0</code> - snow <code>1</code> - rain</p> <pre><code>func int Wld_GetWeatherType() {};\n</code></pre> <ul> <li><code>return</code> - weather type</li> </ul>"},{"location":"zengin/tools/","title":"Tools","text":"<p>The community has developed many tools to help with the creation of Gothic mods.</p> <p>Note</p> <p>This list is work in progress</p> <p>Daedalus</p> <ul> <li>Daedalus Language Server - a VS Code/VS Codium extension that adds IDE like functionality for Daedalus scripting language</li> <li>Ikarus - A daedalus library for the game Gothic. Exploits the interpreter to allow arbitrary memory access and defines a lot of useful functions for interfacing with the engine. </li> <li>LeGo - A daedalus library for the game Gothic. It contains various packages to support modders.</li> <li>AFSP - Fawkes' &amp; Auronen's script package for Gothic 1 and Gothic 2: Night of the Raven.</li> <li>Ninja - Ninja introduces the possibility of true modular modifications for the video games Gothic and Gothic 2 Night of the Raven.</li> </ul> <p>VDFS tools</p> <ul> <li>GothicVDFS - NiceDE's viewer, extractor and builder for <code>.vdf</code> and <code>.mod</code> volumes</li> <li>VDFS Tool - Gratt's Union VDFS viewer, extractor, builder, optimizer and ZIP compressor for <code>.vdf</code> and <code>.mod</code> volumes</li> </ul> <p>World Editors</p> <ul> <li>Spacer - the original world editor for ZenGin, ships with the MDK</li> <li>Union Gothic World Editor - Saturas' world editor, supports new object classes created with Union</li> <li>Gothic World Editor - World editor for vanilla worlds, works with G1, G2 and G2 NotR worlds</li> </ul>"},{"location":"zengin/tools/dls/","title":"Daedalus Language Server","text":"<p>Daedalus Language Server</p> <p>Todo</p> <p>TODO</p>"},{"location":"zengin/tools/gothic_sourcer/","title":"Gothic Sourcer","text":"<p>Gothic Sourcer can be used to do a lot of things.</p> <p>Todo</p> <p>TODO</p>"},{"location":"zengin/tools/gothic_vdfs/","title":"GothicVDFS","text":"<p>Gothic VDFS is still the most popular VDFS tool. It was created by NicoDE.</p>"},{"location":"zengin/tools/gothic_vdfs/#download","title":"Download","text":"<p>You can download the tool from NicoDE's website - direct link.</p>"},{"location":"zengin/tools/gothic_vdfs/#quick-overview","title":"Quick overview","text":""},{"location":"zengin/tools/vdfs_tool/","title":"VDFS Tool","text":"<p>VDFS Tool is a new program that supports new features introduced to VDFS by the Union team. Like ZIP compression or drag and drop support.</p>"},{"location":"zengin/tools/vdfs_tool/#download","title":"Download","text":"<p>You can download the tool from the post on WoP.ru - VDFS Tool or using the Resource Manager</p>"},{"location":"zengin/tools/vdfs_tool/#quick-overview","title":"Quick overview","text":""},{"location":"zengin/union/","title":"Union","text":"<p>Union is a system to patch and extend Gothic's engine the ZenGin. It allows you to load <code>.dll</code> files - ZenGin extensions created using the Gothic/Union SDK and <code>.patch</code> files - files designed to patch the game's executable. The Union installer also contains the SystemPack a collection of bug fixes and engine edits that improve performance.</p>"},{"location":"zengin/union/#plug-ins","title":"Plug-ins","text":"<p>Union plugins are shipped in the form of a <code>.dll</code> library. This library contains the compiled C++ code with the Union SDK and an embedded <code>.patch</code> file.</p>"},{"location":"zengin/union/#union-sdk--gothic-api","title":"Union SDK &amp; Gothic API","text":"<p>Union software development kit is a collection of tools and the Gothic API that allow you to create Union plugins and alter the engine's behavior.   Gothic API a set of 4 interfaces (each for one different ZenGin version) that allow you to interface with the engine, access the engine objects, change their behavior and introduce new classes and functionality.</p>"},{"location":"zengin/union/#patch-file-format","title":"PATCH file format","text":"<p>The <code>.patch</code> file contains one or more small programs that are designed to change the engine code (game executable). This is usually done to fix bugs. Union plug-ins contain an embedded <code>.patch</code> file and this file usually contains changes to the binary necessary for the proper function of the plug-in.</p>"},{"location":"zengin/union/zgamepad/","title":"zGamePad","text":"<p>zGamePad plugin adds gamepad support for ZenGin games.  </p> <p>Important</p> <p>Visit the excellent original GitHub wiki page.</p> Contacts Author  Gratt GitHub  zGamePad Forum  zGamePad"},{"location":"zengin/union/zgamepad/#gamepad-support","title":"Gamepad support","text":"<ul> <li>All xinput compatible (including emulators)</li> <li>Xbox controller family</li> <li>Dualshock 4</li> <li>Dualsense</li> <li>Nintendo Switch Joy-Cons</li> <li>Nintendo Switch Pro Controller</li> </ul>"},{"location":"zengin/union/zgamepad/#features","title":"Features","text":"<ul> <li>Natural Movements Intuitiveness and smoothness of movement controls is the main goal of this plugin. Touch the world of Gothic with your hands.</li> <li>Interactive hints Interactive hints will help you in mastering the controls. You can always customize their appearance or disable them.</li> <li>Quick access The plugin has two quick access rings - **weapons and items. Use them to always have access to your items.</li> <li>Automatic save naming Sit comfortably. You do not have to reach for your keyboard, because the plugin itself will give a name to your saves.</li> <li>Saves rotation The best alternative to quicksaves for gamepad controls.</li> <li>Vibration response Immerse yourself in the game even more. Vibration will allow you to feel your character and everything that happens in the world.</li> <li>Target locking The plugin will always help you win. Keeping the enemy in focus will allow you to fight much more effectively.</li> <li>Stuck protection Oops! If you get stuck, hold both analogue sticks for a few seconds and the character will reset.</li> </ul>"},{"location":"zengin/union/zgamepad/controls/","title":"Gamepad controls","text":"<p>The zGamePad plugin comes with a default control scheme, but it is possible to create your own. The plugin will search for any file with the <code>.gamepad.overlay</code> extension placed in <code>Gothic/System</code> directory or in any of the loaded <code>.mod</code> and <code>.vdf</code> archives.</p>"},{"location":"zengin/union/zgamepad/controls/#control-file-syntax","title":"Control file syntax","text":"<p>Gamepad controls are set using the <code>.gamepad</code> configuration file. This file encodes the controls for different actions in the game and the hint string in multiple languages.</p> <p>Warning</p> <p>The <code>.gamepad</code> file must be encoded in Unicode or UTF-8 to accommodate the multilingual hint strings.</p>"},{"location":"zengin/union/zgamepad/controls/#regions","title":"Regions","text":"<p>The format supports code blocks specified by the <code>#region</code> and <code>#endregion</code> keywords. These regions do not have any syntactical meaning, they only offer a convenient way to collapse sections of the code in editors with the syntax highlighting capabilities such as Notepad++</p> Regions<pre><code>#region strings\n    // TODO\n#endregion\n\n#region fight scheme\n    // TODO\n#endregion\n</code></pre>"},{"location":"zengin/union/zgamepad/controls/#comments","title":"Comments","text":"<p>Comments are useful for quick information or just to disable some old code that might come in handy later. The <code>.gamepad</code> file syntax supports C++ line comments using two forward slashes <code>//</code>.</p> <p>Warning</p> <p>Comments can only be used at the start of any given line!</p> Comments<pre><code>// this is a comment\nKeyRecord // this is NOT a comment\n</code></pre>"},{"location":"zengin/union/zgamepad/controls/#strings","title":"Strings","text":"<p>Strings are used for interactive hints. They should be defined at the top of the file. To define a string, use the keyword <code>String</code>. Strings have the following format: Multilang string syntax<pre><code>String [id]\n    [langTag] [text]\n    [langTag] [text]\n    [langTag] [text]\n</code></pre></p>"},{"location":"zengin/union/zgamepad/controls/#example","title":"Example","text":"<p><pre><code>String interact\n    Rus \"\u0412\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c\"\n    Eng \"Interact\"\n    Pol \"Interakcja\"\n    Deu \"Interagieren\"\n\nString remove_weapon\n    Rus \"\u0423\u0431\u0440\u0430\u0442\u044c \u043e\u0440\u0443\u0436\u0438\u0435\"\n    Eng \"Remove weapon\"\n    Pol \"Chowanie broni\"\n    Deu \"Waffe entfernen\"\n</code></pre> The string <code>name</code> must be unique and is used to reference the string while defining hints. The language tag matches the language in <code>SystemPack.ini</code>. If the file does not contain the user's language, English will be taken by default. If there is no English, then the first one.</p>"},{"location":"zengin/union/zgamepad/controls/#control-bindings","title":"Control bindings","text":"<p>A binding is a description of an event that includes emulation object and conditions. Hints are part of the binding. The general structure of the bind starts with the keyword <code>KeyRecord</code> and has the following format: Control binding<pre><code>KeyRecord [modifier]\n    Id          [key name]\n    Combination [gamepad keys]\n    Emulation   [engine logical and absolute keys]\n    Condition   [engine logical, absolute keys or logical functions]\n    Help        [name of the hint string]\n</code></pre></p> <ul> <li><code>Id</code> - unique identifier used by other users to override this control binding</li> <li><code>[modifier]</code> - can be empty or take the value of <code>Toggled</code> If the value is empty, the control binding will work as long as the player holds down the specified button or button combination.       If the value is <code>Toggled</code>, the control binding will work only when the player toggles the button or button combination. (One press to start sneaking, another press to stop sneaking)</li> <li><code>Combination</code> - these are the gamepad buttons that the player must press or hold to activate the control binding.</li> <li><code>Emulation</code> - specify which buttons will be emulated. You can specify absolute buttons, or that are defined in the game settings (logical).</li> <li><code>Condition</code> - specify the condition under which the control binding can be activated. To invert condition, use the operator <code>!</code> before the operand (!Cond_IsOverlayTop, !JOY_B)</li> <li> <p><code>Help</code> - name of the text string with a hint which will be displayed when the Conditions are met.</p> </li> <li> <p><code>[gamepad keys]</code> - Gamepad key list</p> </li> <li><code>[engine logical keys]</code> - Engine logical key list</li> <li><code>[engine absolute keys]</code> - Engine absolute key list</li> <li><code>[logical functions]</code> - Logical function list</li> </ul> <p>Tip</p> <p>All operators are optional! This means that if a binding should only show a hint, it doesn't have to contain Combination.</p>"},{"location":"zengin/union/zgamepad/controls/#example_1","title":"Example","text":"Control binding examples<pre><code>KeyRecord\n    Id          StopUsingPicklock\n    Combination JOY_B\n    Emulation   KEY_DOWN\n    Condition   Cond_InterfaceIsOpen, Cond_UsesPicklock, !JOY_B\n\nKeyRecord Toggled\n    Id          ReturnToHumanForm\n    Combination JOY_A\n    Emulation   KEY_RETURN\n    Condition   Cond_InTransformation\n    Help        end_transform\n\nKeyRecord\n    Id          QuickRingSelectSlot\n    Combination JOY_RSTICK_FULL\n    Condition   !Cond_InventoryIsOpen, Cond_IsOverlayTop\n    Help        focus_item\n</code></pre>"},{"location":"zengin/union/zgamepad/controls/#controls-override","title":"Controls override","text":"<p>If you want to change or remove bindings from another controls file, use the <code>KeyDisable</code> keyword.   Default controls file</p> <p>Controls override syntax<pre><code>KeyDisable [fileName].[Id]\n</code></pre> Where <code>fileName</code> is the name of the controls file without extension and <code>id</code> is a key of the binding.</p>"},{"location":"zengin/union/zgamepad/controls/#example_2","title":"Example","text":"Controls override example<pre><code>// remove key from the main controls file\nKeyDisable Controls.ArrowDown\n\n// create new key based on the same buttons\nKeyRecord Toggled\n    Id          ArrowDownNew\n    Combination JOY_DOWN\n    Emulation   GAME_DOWN\n</code></pre>"},{"location":"zengin/union/zgamepad/keys_engine_absolute/","title":"Engine absolute keys","text":"<p>Absolute keys are the physical keys on your keyboard. <pre><code>MOUSE_DX\nMOUSE_DY\nMOUSE_UP\nMOUSE_DOWN\nMOUSE_LEFT\nMOUSE_RIGHT\nMOUSE_WHEELUP\nMOUSE_WHEELDOWN\nMOUSE_BUTTONLEFT\nMOUSE_BUTTONRIGHT\nMOUSE_BUTTONMID\nMOUSE_XBUTTON1\nMOUSE_XBUTTON2\nMOUSE_XBUTTON3\nMOUSE_XBUTTON4\nMOUSE_XBUTTON5\nKEY_ESCAPE\nKEY_1\nKEY_2\nKEY_3\nKEY_4\nKEY_5\nKEY_6\nKEY_7\nKEY_8\nKEY_9\nKEY_0\nKEY_MINUS\nKEY_EQUALS\nKEY_BACK\nKEY_TAB\nKEY_Q\nKEY_W\nKEY_E\nKEY_R\nKEY_T\nKEY_Y\nKEY_U\nKEY_I\nKEY_O\nKEY_P\nKEY_LBRACKET\nKEY_RBRACKET\nKEY_RETURN\nKEY_LCONTROL\nKEY_A\nKEY_S\nKEY_D\nKEY_F\nKEY_G\nKEY_H\nKEY_J\nKEY_K\nKEY_L\nKEY_SEMICOLON\nKEY_APOSTROPHE\nKEY_GRAVE\nKEY_LSHIFT\nKEY_BACKSLASH\nKEY_Z\nKEY_X\nKEY_C\nKEY_V\nKEY_B\nKEY_N\nKEY_M\nKEY_COMMA\nKEY_PERIOD\nKEY_SLASH\nKEY_RSHIFT\nKEY_MULTIPLY\nKEY_LMENU\nKEY_SPACE\nKEY_CAPITAL\nKEY_F1\nKEY_F2\nKEY_F3\nKEY_F4\nKEY_F5\nKEY_F6\nKEY_F7\nKEY_F8\nKEY_F9\nKEY_F10\nKEY_NUMLOCK\nKEY_SCROLL\nKEY_NUMPAD7\nKEY_NUMPAD8\nKEY_NUMPAD9\nKEY_SUBTRACT\nKEY_NUMPAD4\nKEY_NUMPAD5\nKEY_NUMPAD6\nKEY_ADD\nKEY_NUMPAD1\nKEY_NUMPAD2\nKEY_NUMPAD3\nKEY_NUMPAD0\nKEY_DECIMAL\nKEY_OEM_102\nKEY_F11\nKEY_F12\nKEY_F13\nKEY_F14\nKEY_F15\nKEY_KANA\nKEY_ABNT_C1\nKEY_CONVERT\nKEY_NOCONVERT\nKEY_YEN\nKEY_ABNT_C2\nKEY_NUMPADEQUALS\nKEY_PREVTRACK\nKEY_AT\nKEY_COLON\nKEY_UNDERLINE\nKEY_KANJI\nKEY_STOP\nKEY_AX\nKEY_UNLABELED\nKEY_NEXTTRACK\nKEY_NUMPADENTER\nKEY_RCONTROL\nKEY_MUTE\nKEY_CALCULATOR\nKEY_PLAYPAUSE\nKEY_MEDIASTOP\nKEY_VOLUMEDOWN\nKEY_VOLUMEUP\nKEY_WEBHOME\nKEY_NUMPADCOMMA\nKEY_DIVIDE\nKEY_SYSRQ\nKEY_RMENU\nKEY_PAUSE\nKEY_HOME\nKEY_UP\nKEY_PRIOR\nKEY_LEFT\nKEY_RIGHT\nKEY_END\nKEY_DOWN\nKEY_NEXT\nKEY_INSERT\nKEY_DELETE\nKEY_LWIN\nKEY_RWIN\nKEY_APPS\nKEY_POWER\nKEY_SLEEP\nKEY_WAKE\nKEY_WEBSEARCH\nKEY_WEBFAVORITES\nKEY_WEBREFRESH\nKEY_WEBSTOP\nKEY_WEBFORWARD\nKEY_WEBBACK\nKEY_MYCOMPUTER\nKEY_MAIL\nKEY_MEDIASELECT\nKEY_BACKSPACE\nKEY_NUMPADSTAR\nKEY_LALT\nKEY_CAPSLOCK\nKEY_NUMPADMINUS\nKEY_NUMPADPLUS\nKEY_NUMPADPERIOD\nKEY_NUMPADSLASH\nKEY_RALT\nKEY_UPARROW\nKEY_PGUP\nKEY_LEFTARROW\nKEY_RIGHTARROW\nKEY_DOWNARROW\nKEY_PGDN\n</code></pre></p>"},{"location":"zengin/union/zgamepad/keys_engine_logical/","title":"Engine logical keys","text":"<p>Logical keys are the keys you set in keyboard settings in the game menu. These can fill multiple roles in different situations and the gamepad controls can be set to emulate these logical keys. <pre><code>GAME_LEFT\nGAME_RIGHT\nGAME_UP\nGAME_DOWN\nGAME_ACTION\nGAME_SLOW\nGAME_ACTION2\nGAME_WEAPON\nGAME_SMOVE\nGAME_SMOVE2\nGAME_SHIFT\nGAME_END\nGAME_INVENTORY\nGAME_LOOK\nGAME_SNEAK\nGAME_STRAFELEFT\nGAME_STRAFERIGHT\nGAME_SCREEN_STATUS\nGAME_SCREEN_LOG\nGAME_SCREEN_MAP\nGAME_LOOK_FP\nGAME_LOCK_TARGET\nGAME_PARADE\nGAME_ACTIONLEFT\nGAME_ACTIONRIGHT\nGAME_LAME_POTION\nGAME_LAME_HEAL\n</code></pre></p>"},{"location":"zengin/union/zgamepad/keys_gamepad/","title":"Gamepad keys","text":"<p>In order to set gamepad keys, you have to know the key codes as they are listed below. <pre><code>JOY_UP\nJOY_DOWN\nJOY_LEFT\nJOY_RIGHT\nJOY_MENU\nJOY_VIEW\nJOY_LSTICK\nJOY_RSTICK\nJOY_LB\nJOY_RB\nJOY_A\nJOY_B\nJOY_X\nJOY_Y\nJOY_LSTICK_LOWUP\nJOY_LSTICK_UP\nJOY_LSTICK_DOWN\nJOY_LSTICK_LEFT\nJOY_LSTICK_RIGHT\nJOY_RT\nJOY_LT\nJOY_DPAD\nJOY_UPDOWN\nJOY_LEFTRIGHT\nJOY_LSTICK_FULL\nJOY_RSTICK_FULL\n</code></pre></p>"},{"location":"zengin/union/zgamepad/logical_functions/","title":"Logical function names","text":"<p>Conditions for when to show or allow the control binding to work are specified using these logic functions. They describe different useful states of the game or user interface, allowing the user to set when will a certain control work.  <pre><code>Cond_FightMode        - player is in the fight mode\nCond_FightModeMelee   - player is in the melee fight mode\nCond_FightModeRange   - player is in the ranged fight mode\nCond_FightModeMagic   - player is in the magical fight mode\nCond_CanShoot         - player is in the aim mode and can shoot now\nCond_CanSneaking      - player is sneaking now\nCond_Diving           - player is diving now\nCond_HasFocusVob      - player has a focus vob\nCond_HasFocusNpc      - player has a focus npc\nCond_OnChooseWeapon   - weapon selection is active\nCond_InventoryIsOpen  - inventory is open\nCond_InTransformation - player is transformed\nCond_VideoIsOpen      - video is playing\nCond_CanLockTarget    - player in the fight mode now and can lock the focus vob\nCond_G1               - this engine is a Gothic 1 (or sequel)\nCond_G2               - this engine is a Gothic 2 NoTR (or classic)\nCond_IsDialogTop      - dialog window is open on the top\nCond_IsDocumentTop    - document object is open on the top\nCond_IsOverlayTop     - gamepad overlay object is open on the top\nCond_IsMenuTop        - game menu is open on the top\nCond_OnSpellBook      - magic selection ring is active\nCond_IsPlayerTalking  - player is talking to someone\nCond_InterfaceIsOpen  - open any interface element\nCond_HasLeftContainer - the left container is open (chest, plunder, trader)\nCond_UsesPicklock     - player is picking a lock now\nCond_IsOnTrade        - player is trading\nCond_IsOverlayTop     - gamepad overlay object is open on the top\nCond_IsMenuTop        - game menu is open on the top\n</code></pre></p>"},{"location":"pl/","title":"Witamy na stronie Gothic Modding Community","text":"<p>Ta strona GitHub jest zaprojektowana w celu zawarcia zbioru artyku\u0142\u00f3w, poradnik\u00f3w oraz innej dokumentacji o Gothicu utrzymywanych przez spo\u0142eczno\u015b\u0107.</p> <p>Dwie pierwsze cz\u0119\u015bci gier Gothic korzystaj\u0105 z silnika o nazwie ZenGin, stworzonego przez Piranha Bytes oraz Szalonych Naukowc\u00f3w. Je\u017celi chcesz wiedzie\u0107 wi\u0119cej o historii tworzenia, to jest masa informacji na Gothic Archive.</p> <p>Zawarto\u015b\u0107 strony nie jest przeznaczona, aby by\u0107 uznan\u0105 za \u015bwi\u0119te s\u0142owa moddingu. Jeste\u015bmy tylko modderami dziel\u0105cymi si\u0119 do\u015bwiadczeniami, wiedz\u0105 oraz naszym ulubionym tokiem pracy.</p> <p>Nie kr\u0119puj si\u0119, aby otworzy\u0107 pro\u015bb\u0119 o po\u0142\u0105czenie (ang. pull request) z twoim artyku\u0142em, lub z propozycj\u0105 zmian. Po wi\u0119cej informacji jak to zrobi\u0107 zobacz, Jak Si\u0119 Udzieli\u0107.</p> <p>Mo\u017cesz otworzy\u0107 pro\u015bb\u0119 o po\u0142\u0105czenie wzgl\u0119dem tego repozytorium.</p>"},{"location":"pl/contribute/","title":"Jak si\u0119 udzieli\u0107","text":"<p>Gothic Modding Community jest projektem nap\u0119dzanym przed spo\u0142eczno\u015b\u0107. Zach\u0119camy osoby do wnoszenia swojego wk\u0142adu.</p> <p>Ta strona jest budowana przy pomocy statycznego generatora stron MkDocs oraz sk\u00f3rki Material for MkDocs, wraz z wieloma innymi wtyczkami do MkDocs.</p> <p>Zale\u017cnie od skali i typu kontrybucji, trzeba spe\u0142ni\u0107 inne wymagania wst\u0119pne.</p>"},{"location":"pl/contribute/#zg\u0142oszenia","title":"Zg\u0142oszenia","text":"<p>Po angielsku mo\u017cna zg\u0142osi\u0107 problem lub inny komentarz o funkcjonowaniu strony poprzez otworzenie problemu (ang. issue) na serwisie GitHub albo do\u0142\u0105cz do nas na platformie Discord.</p>"},{"location":"pl/contribute/#wk\u0142ad-bezpo\u015bredni","title":"Wk\u0142ad bezpo\u015bredni","text":"<p>Wk\u0142ad bezpo\u015bredni wykonuje si\u0119 poprzez stworzenie kopii tego repozytorium (ang. fork) oraz stworzenie pro\u015bby o po\u0142\u0105czenie (ang. pull request PR) na serwisie GitHub wraz ze zmianami do zatwierdzenia.</p> <p>Nie zmarnuj czasu</p> <p>Prosz\u0119 si\u0119 upewni\u0107, \u017ce tre\u015b\u0107, jaka zostanie dodana, nie wyst\u0119puje ju\u017c na wersji dev strony. Mo\u017cna skorzysta\u0107 z funkcjonalno\u015bci wyszukiwania, \u017ceby przefiltrowa\u0107 GMC r\u00f3\u017cnymi s\u0142owami kluczowymi i tre\u015bciami.</p> <p>Jak edytowa\u0107 pliki \u017ar\u00f3d\u0142owe?</p> <p>Pliki \u017ar\u00f3d\u0142owe artyku\u0142\u00f3w s\u0105 pisane wykorzystuj\u0105c format plik\u00f3w Markdown <code>.md</code> (Markdown cheatsheet). Poza tym ta strona wykorzystuje wtyczk\u0119 Python Markdown Extensions, kt\u00f3ra rozszerza sk\u0142adni\u0119 o dodatkowe zasady pozwalaj\u0105ce na wstawienie wzmianek jak ta, kt\u00f3r\u0105 w\u0142a\u015bnie czytasz.</p>"},{"location":"pl/contribute/#mniejsze-zmiany","title":"Mniejsze zmiany","text":"<p>Mniejsze zmiany, jak poprawianie b\u0142\u0119d\u00f3w ortograficzny, gramatycznych, czy usuwanie/dodawanie s\u0142\u00f3w do akapit\u00f3w w jednym pliku, mog\u0105 by\u0107 zrobione szybko poprzez klikni\u0119cie przycisku  w prawym g\u00f3rnym rogu artyku\u0142u. Otworzy to interfejs edytowania pliku w serwisie GitHub, kt\u00f3re po zapisaniu zmian, automatycznie utworzy kopi\u0119 (ang. fork) oraz ga\u0142\u0105\u017a (ang. brach) z \u0142atk\u0105, a nast\u0119pnie otworzy pro\u015bb\u0119 o po\u0142\u0105czenie (ang. pull request) wzgl\u0119dem ga\u0142\u0119zi <code>dev</code>.</p> <p>Poprawna ga\u0142\u0105\u017a dla pro\u015bby o po\u0142\u0105czenie</p> <p>Upewnij si\u0119, \u017ce pro\u015bba o po\u0142\u0105czenie (ang. pull request) jest skierowana do ga\u0142\u0119zi <code>dev</code> albo specjalnej ga\u0142\u0119zi <code>pre-merge</code>, a nie do ga\u0142\u0119zi <code>main</code>.</p>"},{"location":"pl/contribute/#wi\u0119ksze-zmiany","title":"Wi\u0119ksze zmiany","text":"<p>Bardziej z\u0142o\u017cone zmiany takie jak, edycja wielu plik\u00f3w naraz, dodawanie nowych artyku\u0142\u00f3w, obrazk\u00f3w, czy innych plik\u00f3w, albo zmiana konfiguracji strony jest \u0142atwiej zrobi\u0107 poprzez u\u017cycie zewn\u0119trznych narz\u0119dzi na lokalnym PC. Wi\u0119kszo\u015b\u0107 z tych operacji mo\u017cna zrobi\u0107 poprzez interfejs serwisu GitHub, ale jest to raczej uci\u0105\u017cliwe oraz trudniej zauwa\u017cy\u0107 problemy wynikaj\u0105ce z procesu zmian, poniewa\u017c nie s\u0105 one widoczne w przegl\u0105darce w ich ostatecznej formie.</p> <p>Troch\u0119 przygotowa\u0144 jest potrzebnych przed rozpocz\u0119ciem prac nad plikami, poniewa\u017c do dzia\u0142ania MkDocs wymaga zainstalowanego w systemie Pythona. GitHub dzia\u0142a nad systemem kontroli wersji git, wi\u0119c jego instalacja jest te\u017c wymagana. Podstawowa znajomo\u015b\u0107 obs\u0142ugi Terminala/Konsoli polece\u0144/Powershell jest pomocna.</p>"},{"location":"pl/contribute/#przygotowanie-systemu-wideo","title":"Przygotowanie Systemu (wideo)","text":"<p>Po pierwsze, trzeba zainstalowa\u0107 Python. Mo\u017cna pod\u0105\u017ca\u0107 wed\u0142ug tego poradnika krok po kroku dla Windowsa albo macOS jak zainstalowa\u0107 Python.</p> <p>Wideo jest z 2017?!</p> <p>Proces instalacji Pythona nie zmieni\u0142 si\u0119 od tamtego czasu. Jednak\u017ce prosz\u0119 instalowa\u0107 najnowsz\u0105 wersj\u0119 Python 3.</p> <p>Aby m\u00f3c pracowa\u0107 zdalnie z GitHub, mo\u017cna zainstalowa\u0107 najnowsz\u0105 wersj\u0119 git, pod\u0105\u017caj\u0105c wed\u0142ug tego poradnika.</p> <p>Je\u017celi planujesz tylko edytowa\u0107 zawarto\u015b\u0107 artyku\u0142\u00f3w Markdown, mo\u017cesz po prostu zainstalowa\u0107 najnowsz\u0105 wersj\u0119 Visual Studio Code, \u017ceby mie\u0107 interfejs graficzny do zarz\u0105dzania git oraz podgl\u0105d Markdown, albo pracuj z dowolnym znanym edytorem tekstu i omi\u0144 konfiguracj\u0119 \u015brodowiska.</p> <p>Je\u017celi planujesz bardziej z\u0142o\u017cone programowanie w Python, mo\u017cesz pod\u0105\u017cy\u0107 wed\u0142ug tego poradnika krok po kroku dla Windowsa lub macOS jak skonfigurowa\u0107 \u015brodowisko developerskie z Visual Studio Code (VS Code).</p>"},{"location":"pl/contribute/#przygotowanie-systemu-tekst","title":"Przygotowanie Systemu (tekst)","text":"<p>\u017beby przygotowa\u0107 system do uruchomienia projektu lokalnie, pod\u0105\u017caj wed\u0142ug tych instrukcji.</p> <ol> <li> <p>Zainstaluj najnowsz\u0105 wersj\u0119 Pythona.     Upewnij si\u0119, \u017ceby zaznaczy\u0107 opcj\u0119 \"Add Python to PATH\" podczas instalacji.</p> </li> <li> <p>Otw\u00f3rz okno Terminala/Konsoli polece\u0144/PowerShell.</p> </li> <li> <p>Sprawd\u017a, \u017ce instalacja Pythona by\u0142a pomy\u015blna, korzystaj\u0105c z tego polecenia (mo\u017cliwa jest potrzeba restartu okna konsoli):</p> <pre><code>python --version\n</code></pre> </li> <li> <p>Zainstaluj najnowsz\u0105 wersj\u0119 git, pod\u0105\u017caj\u0105c wed\u0142ug tego poradnika.</p> </li> <li> <p>Sprawd\u017a, \u017ce instalacja git by\u0142a pomy\u015blna, korzystaj\u0105c z tego polecenia (mo\u017cliwa jest potrzeba restartu okna konsoli):</p> <pre><code>git --version\n</code></pre> </li> <li> <p>(opcjonalne) Zainstaluj najnowsz\u0105 wersj\u0119 Visual Studio Code dla interfejsu graficznego do zarz\u0105dzania git i podgl\u0105dem Markdown.</p> </li> </ol>"},{"location":"pl/contribute/#praca-lokalna","title":"Praca lokalna","text":"<p>Aby m\u00f3c pracowa\u0107 lokalnie:</p> <ol> <li>Stw\u00f3rz kopi\u0119 (ang. fork) na serwisie GitHub.</li> <li>Na lokalnym PC nawiguj do folderu, w kt\u00f3rym chcesz sklonowa\u0107 kopi\u0119 repozytorium, oraz otw\u00f3rz okno konsoli wewn\u0105trz niego.</li> <li> <p>Sklonuj kopi\u0119 repozytorium, korzystaj\u0105c z tego polecenia:</p> <pre><code>git clone https://github.com/user-name/forked-repository-name.git &lt;DIR-PATH&gt;\n</code></pre> <p>Zamiast <code>https://github.com/user-name/forked-repository-name.git</code> skorzystaj z w\u0142asnego linku, kt\u00f3ry jest widoczny po klikni\u0119ciu zielonego przycisku <code>&lt;&gt; Code</code> i wybraniu zak\u0142adki <code>HTTPS</code>.    </p> <p>Zamie\u0144 <code>&lt;DIR-PATH&gt;</code> ze \u015bcie\u017ck\u0105 do folderu, do kt\u00f3rego ma by\u0107 sklonowane repozytorium albo <code>.</code> je\u017celi ju\u017c jeste\u015b wewn\u0105trz folderu gdzie pliki projektu maj\u0105 si\u0119 znajdowa\u0107.</p> <p>To automatycznie utworzy zdalne repozytorium <code>origin</code> skierowane wzgl\u0119dem twojej kopii.</p> </li> <li> <p>Dodaj zdalne repozytorium <code>upstream</code> korzystaj\u0105c z tego polecenia:</p> <pre><code>git remote add upstream https://github.com/Gothic-Modding-Community/gmc.git\n</code></pre> </li> <li> <p>(opcjonalne) Stw\u00f3rz wirtualne \u015brodowisko i aktywuj je.</p> <p>Je\u017celi pracujesz przy kilku projektach Python, warto stworzy\u0107 wirtualne \u015brodowisko (ang. Virtual Environment) dla ka\u017cdego z tych projekt\u00f3w, \u017ceby ka\u017cdy m\u00f3g\u0142 korzysta\u0107 z w\u0142asnego folderu bibliotek z zainstalowanymi modu\u0142ami/wtyczkami.</p> <pre><code>python -m venv venv\n</code></pre> <p>To utworzy folder <code>venv</code> wewn\u0105trz obecnie wybranego folderu w oknie konsoli. Prosz\u0119, zostaw t\u0119 nazw\u0119, poniewa\u017c jest dodana do pliku <code>.gitignore</code> projektu.</p> <p>Zale\u017cnie od systemu, skorzystaj z jednego z tych polece\u0144 do aktywacji wirtualnego \u015brodowiska.</p> <p>Linux / macOS<pre><code>source venv/bin/activate\n</code></pre> Windows Powershell<pre><code>venv\\Scripts\\activate.ps1\n</code></pre> Windows Konsola Polece\u0144 (cmd)<pre><code>venv\\Scripts\\activate.bat\n</code></pre></p> <p>Po aktywacji indykator <code>(venv)</code> b\u0119dzie wy\u015bwietlany przy nazwie folderu w oknie polece\u0144.</p> <p>Nie zamykaj okna polece\u0144</p> <p>Wirtualne \u015brodowisko musi by\u0107 ponownie aktywowane, przy ka\u017cdym otwarciu okna polece\u0144.</p> </li> <li> <p>Zainstaluj MkDocs wraz z wtyczkami korzystaj\u0105c z tego polecenia:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>To zainstaluje wszystkie zale\u017cno\u015bci.</p> </li> <li> <p>Pobierz (ang. fetch) stan historii git z repozytorium <code>upstream</code> korzystaj\u0105c z tego polecenia:</p> <pre><code>git fetch upstream\n</code></pre> </li> <li> <p>Otw\u00f3rz (ang. checkout) lokaln\u0105 ga\u0142\u0105\u017a opieraj\u0105c\u0105 si\u0119 o ga\u0142\u0105\u017a <code>dev</code> repozytorium <code>upstream</code> korzystaj\u0105c z tego polecenia:</p> <pre><code>git checkout -b name-of-branch --track upstream/dev\n</code></pre> <p>W miejscu <code>name-of-branch</code> podaj kr\u00f3tk\u0105 nazw\u0119 po angielsku. Odpowiedni\u0105 nazw\u0105 ga\u0142\u0119zi jest albo nazwa funkcjonalno\u015bci, albo kr\u00f3tki opis wprowadzonych zmian np. <code>3ds-articles</code>, <code>fix-typos-for-contribution</code>. Nie musz\u0105 by\u0107 zbyt skomplikowane, do 4 s\u0142\u00f3w wystarczy.</p> </li> <li> <p>Uruchom serwer ze zbudowan\u0105 stron\u0105 projektu, korzystaj\u0105c z tego polecenia:</p> <pre><code>mkdocs serve\n</code></pre> <p>Odwied\u017a lokaln\u0105 stron\u0119 pod tym adresem <code>http://127.0.0.1:8000/gmc/</code>. Po ka\u017cdej zmianie w plikach projektu strona automatycznie si\u0119 przebuduje i po chwili przegl\u0105darka automatycznie si\u0119 od\u015bwie\u017cy.</p> <p>Serwer mo\u017ce by\u0107 zamkni\u0119ty poprzez skorzystanie ze skr\u00f3tu klawiszowego <code>Control-C</code> w trakcie gdy okno polece\u0144 jest aktywne.</p> </li> <li> <p>Je\u017celi uko\u0144czysz fragment swojej pracy, dodaj pliki i wstaw wpis do historii gita (ang. commit) korzystaj\u0105c z tego polecenia:</p> <pre><code>git add .\ngit commit -m \"add 3 articles about ZenGin\"\n</code></pre> <p>Jak wida\u0107 wiadomo\u015b\u0107 (ang. message) / nazwa do wpisu historii r\u00f3wnie\u017c powinna by\u0107 w j\u0119zyku angielskim. Odpowiedni\u0105 wiadomo\u015bci\u0105 jest zdanie opisuj\u0105ce zmiany.</p> </li> <li> <p>Po sko\u0144czeniu wszystkich prac wy\u015blij (ang. push) swoj\u0105 ga\u0142\u0105\u017a do zdalnego repozytorium <code>origin</code>, korzystaj\u0105c z tego polecenia:</p> <pre><code>git push origin name-of-branch\n</code></pre> </li> <li> <p>Stw\u00f3rz pro\u015bb\u0119 o po\u0142\u0105czenie (ang. pull request) wzgl\u0119dem odpowiedniej ga\u0142\u0119zi.</p> <p>Po wys\u0142aniu lokalnej ga\u0142\u0119zi do zdalnego repozytorium <code>origin</code> w oknie polece\u0144 b\u0119dzie dost\u0119pne \u0142\u0105cze, kt\u00f3re otworzy stron\u0119 tworzenia pro\u015bby o po\u0142\u0105czenie. Upewnij si\u0119, \u017ce jest skierowana wzgl\u0119dem ga\u0142\u0119zi <code>dev</code> oraz, \u017ce posiada wszystkie wprowadzone zmiany.</p> </li> <li> <p>Kolejna kontrybucja:</p> <p>Przed kolejn\u0105 kontrybucj\u0105, zawsze skorzystaj z tego polecenia: <pre><code>git fetch upstream </code></pre> \u017ceby mie\u0107 pewno\u015b\u0107, \u017ce posiadasz najnowsz\u0105 histori\u0119 zmian z repozytorium <code>upstream</code>. Nast\u0119pnie pod\u0105\u017caj ponownie od 8. podpunktu i zawsze tw\u00f3rz now\u0105 ga\u0142\u0105\u017a przed wprowadzeniem zmian.</p> <pre><code>git status\n</code></pre> <p>Tym poleceniem mo\u017cesz sprawdzi\u0107, czy nie masz \u017cadnych zmian w strukturze projektu wzgl\u0119dem repozytorium <code>upstream</code>.</p> </li> </ol>"},{"location":"pl/contribute/#preferencje-budowy-strony","title":"Preferencje budowy strony","text":"<p>Podczas pracy z projektem mo\u017cna ustawi\u0107 r\u00f3\u017cne zmienne \u015brodowiskowe, \u017ceby przystosowa\u0107 konfiguracj\u0119 do w\u0142asnych preferencji:</p> <ul> <li><code>GMC_DEFAULT_LANG</code> - to dwuznakowy identyfikator j\u0119zyka (musi by\u0107 obecny w pliku <code>mkdocs.yml</code>), ustawia domy\u015blny j\u0119zyk strony</li> <li><code>GMC_ONLY_DEFAULT_LANG</code> - warto\u015b\u0107 <code>True</code> albo <code>False</code>, aktywuje budowanie strony wy\u0142\u0105cznie w domy\u015blnym j\u0119zyku </li> <li><code>GMC_ENABLE_ON_PUBLISH</code> - warto\u015b\u0107 <code>True</code> albo <code>False</code>, aktywuje wszystkie finalne procesy, jak dodanie daty ostatniej aktualizacji, minimalizacja zasob\u00f3w itp. </li> </ul> <p>Dla otwartego okna polece\u0144 mo\u017cna tymczasowo je ustawi\u0107:</p> Linux<pre><code>export GMC_DEFAULT_LANG=en export GMC_ONLY_DEFAULT_LANG=True; mkdocs serve\n</code></pre> Windows Powershell<pre><code>$env:GMC_DEFAULT_LANG=\"en\"\n$env:GMC_ONLY_DEFAULT_LANG=\"True\"\nmkdocs serve\n</code></pre> Windows Konsola Polece\u0144 (cmd)<pre><code>set GMC_DEFAULT_LANG=en\nset GMC_ONLY_DEFAULT_LANG=True\nmkdocs serve\n</code></pre>"},{"location":"pl/contribute/#wydajno\u015b\u0107-budowy-strony","title":"Wydajno\u015b\u0107 budowy strony","text":"<p>Aby przy\u015bpieszy\u0107 proces budowy strony podczas pracy, upewnij si\u0119, \u017ce tylko 1 j\u0119zyk jest budowany i rozwa\u017c u\u017cycie opcji <code>--dirtyreload</code>:</p> <pre><code>mkdocs serve --dirtyreload\n</code></pre> <p>To sprawi, \u017ce tylko zmienione pliki <code>.md</code> b\u0119d\u0105 na nowo budowane. Jednak\u017ce, zmiany plik\u00f3w szablonowych (ang. template) w folderze <code>overrides</code> nie b\u0119d\u0105 widoczne, poniewa\u017c takie zmiany wymagaj\u0105 pe\u0142nej przebudowy.</p>"},{"location":"pl/contribute/#prze\u015blij-plik","title":"Prze\u015blij plik","text":"<p>Je\u017celi praca z git albo Markdown jest nieprzyst\u0119pna lub niemo\u017cliwa to mo\u017cesz przes\u0142a\u0107 plik w formacie Google Docs na serwer Discord GMC, sformatujemy go i dodamy tre\u015b\u0107 do strony.</p> <p>Tylko nowa zawarto\u015b\u0107 po angielsku</p> <p>Ta opcja jest ograniczona tylko dla nowej tre\u015bci w j\u0119zyku angielskim. Nie mo\u017cemy wykorzysta\u0107 tego sposobu dla t\u0142umacze\u0144. Dla t\u0142umacze\u0144 wy\u015blij przet\u0142umaczony plik <code>.md</code> poprzez zg\u0142oszenie, je\u017celi nie chcesz pracowa\u0107 bezpo\u015brednio z git, ani doda\u0107 pliku poprzez interfejs GitHub.</p>"},{"location":"pl/contribute/#translations","title":"T\u0142umaczenia","text":"<p>\u017beby dostarczy\u0107 wsparcie dla wielu j\u0119zyk\u00f3w, nasza strona korzysta ze wtyczki MkDocs i18n.</p>"},{"location":"pl/contribute/#dodaj-wsparcie-dla-nowego-j\u0119zyka","title":"Dodaj wsparcie dla nowego j\u0119zyka","text":"<p>\u017beby wspiera\u0107 nowy j\u0119zyk, musi by\u0107 dodany:</p> <p>Wci\u0119cia maj\u0105 znaczenie</p> <p>Musisz zachowa\u0107 poprawn\u0105 ilo\u015b\u0107 wci\u0119\u0107, czyli odst\u0119p\u00f3w mi\u0119dzy wpisami.</p> <ol> <li> <p>W konfiguracji <code>mkdocs.yml</code>, w tym przyk\u0142adzie dodajemy j\u0119zyk <code>xx</code>:</p> <pre><code>plugins:\n- i18n:\n# ...\nlanguages:\nen:\nname: en - English\nbuild: true\nxx:\nname: xx - Language Name\nbuild: true\n</code></pre> </li> <li> <p>W pliku <code>overrides/main.html</code>, \u017ceby doda\u0107 tekst og\u0142oszenia dla zawarto\u015bci nieprzet\u0142umaczonej:</p> <pre><code>{%\n    set announcement = {\n        \"en\": \"This page has not yet been translated into LANGUAGE, therefore it is displayed in English.\",\n        \"xx\": \"yyy\",\n    }\n%}\n{%\n    set call_to_action = {\n        \"en\": \"Support us and translate!\",\n        \"xx\": \"yyy\",\n    }\n%}\n</code></pre> </li> <li> <p>Odwied\u017a oficjaln\u0105 stron\u0119 sk\u00f3rki.     Upewnij si\u0119, \u017ce t\u0142umaczenie sk\u00f3rki jest tam kompletne. Je\u017celi nie jest, pod\u0105\u017caj wed\u0142ug poradnika kontrybucji sk\u00f3rki i wr\u00f3\u0107 tutaj, nie trzeba czeka\u0107 na zmiany w sk\u00f3rce.</p> </li> </ol>"},{"location":"pl/contribute/#dodaj-przet\u0142umaczone-strony","title":"Dodaj przet\u0142umaczone strony","text":"<p>Ka\u017cdy plik <code>.md</code> w folderze <code>docs</code> mo\u017ce mie\u0107 przet\u0142umaczon\u0105 wersj\u0119. \u017beby doda\u0107 t\u0142umaczenie strony dla danego j\u0119zyka, stw\u00f3rz kopi\u0119 strony z dodan\u0105 ko\u0144c\u00f3wk\u0105 tego j\u0119zyka.  Na przyk\u0142ad <code>index.md</code> b\u0119dzie <code>index.xx.md</code> dla j\u0119zyka <code>xx</code> bazuj\u0105c na ustawieniach z pliku <code>mkdocs.yml</code>.</p> <p>Ka\u017cdy nieprzet\u0142umaczony artyku\u0142 posiada przycisk  w g\u00f3rnym prawym rogu obok tytu\u0142u. Pozwala na szybkie dodanie t\u0142umaczenia poprzez interfejs serwisu GitHub bez potrzeby konfiguracji plik\u00f3w lokalnie.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/","title":"Ikarus","text":"<p>Ikarus jest bibliotek\u0105 Daedalusa - j\u0119zyka skryptowego Gothica. Wykorzystuje interpreter, aby umo\u017cliwi\u0107 dowolny dost\u0119p do pami\u0119ci i definiuje mn\u00f3stwo przydatnych funkcji do pracy z silnikiem.</p> Kontakt Autor  Sektenspinner i wsp\u00f3\u0142tw\u00f3rcy GitHub  Ikarus Forum  Ikarus <p>Note</p> <p>Ikarus jest hostowany na GitHubie i posiada wbudowan\u0105 dokumentacje. Jej t\u0142umaczenie jest w planach.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/","title":"Dost\u0119p do plik\u00f3w konfiguracyjnych","text":"<p>Ta cz\u0119\u015b\u0107 Ikarusa umo\u017cliwia dost\u0119p do <code>Gothic.ini</code> i pliku konfiguracyjnego za\u0142adowanej modyfikacji.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#inicjalizacja","title":"Inicjalizacja","text":"<p>Najlepszym sposobem na zainicjowanie Ikarusa jest wywo\u0142anie <code>MEM_InitAll()</code> w funkcji <code>Init_Global()</code>. </p> <p>Warning</p> <p>Je\u017celi chcesz u\u017cywa\u0107 Ikarusa z Gothiciem 1, najlepiej b\u0119dzie, je\u015bli zdefiniujesz w\u0142asn\u0105 funkcj\u0119 <code>Init_Global()</code> i wywo\u0142asz j\u0105 w ka\u017cdej funkcji inicjuj\u0105cej \u015bwiat.</p> <pre><code>func void MEM_InitAll () {};\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#implementacja","title":"Implementacja","text":"<p> Ikarus.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#funkcje-odczytu","title":"Funkcje odczytu","text":""},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_getgothopt","title":"MEM_GetGothOpt","text":"<p>Przeszukuje <code>Gothic.ini</code> w poszukiwaniu opcji <pre><code>func string MEM_GetGothOpt(var string sectionname, var string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - nazwa przeszukiwanej sekcji</li> <li><code>optionname</code> - nazwa szukanej opcji</li> <li><code>return</code> - warto\u015b\u0107 opcji w postaci \u0142a\u0144cucha znak\u00f3w, albo pust\u0105 zmienn\u0105, gdy opcja nie istnieje w danej sekcji</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_getmodopt","title":"MEM_GetModOpt","text":"<p>Przeszukuje ini za\u0142adowanej modyfikacji w poszukiwaniu opcji. <pre><code>func void MEM_GetModOpt(var string sectionname, var string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - nazwa przeszukiwanej sekcji</li> <li><code>optionname</code> - nazwa szukanej opcji</li> <li><code>return</code> - warto\u015b\u0107 opcji w postaci \u0142a\u0144cucha znak\u00f3w, albo pust\u0105 zmienn\u0105, gdy opcja nie istnieje w danej sekcji</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_gothoptsectionexists","title":"MEM_GothOptSectionExists","text":"<p>Sprawdza, czy dana sekcja istnieje w <code>Gothic.ini</code> <pre><code>func int MEM_GothOptSectionExists(var string sectionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - nazwa szukanej sekcji</li> <li><code>return</code> - <code>TRUE</code> je\u015bli sekcja istnieje, inaczej <code>FALSE</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_modoptsectionexists","title":"MEM_ModOptSectionExists","text":"<p>Sprawdza, czy dana sekcja istnieje w ini za\u0142adowanej modyfikacji. <pre><code>func int MEM_ModOptSectionExists(var string sectionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - nazwa szukanej sekcji</li> <li><code>return</code> - <code>TRUE</code> je\u015bli sekcja istnieje, inaczej <code>FALSE</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_gothoptexists","title":"MEM_GothOptExists","text":"<p>Sprawdza, czy dana opcja istnieje w <code>Gothic.ini</code> <pre><code>func int MEM_GothOptExists(var string sectionname,\nvar string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - nazwa przeszukiwanej sekcji</li> <li><code>optionname</code> - nazwa szukanej opcji</li> <li><code>return</code> - <code>TRUE</code> je\u015bli sekcja istnieje, inaczej <code>FALSE</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_modoptexists","title":"MEM_ModOptExists","text":"<p>Sprawdza, czy dana opcja istnieje w ini za\u0142adowanej modyfikacji. <pre><code>func int MEM_ModOptExists(var string sectionname, var string optionname) {};\n</code></pre></p> <ul> <li><code>sectionname</code> - nazwa przeszukiwanej sekcji</li> <li><code>optionname</code> - nazwa szukanej opcji</li> <li><code>return</code> - <code>TRUE</code> je\u015bli sekcja istnieje, inaczej <code>FALSE</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#funkcje-zapisu","title":"Funkcje zapisu","text":"<p>Warning</p> <p>Plik konfiguracyjny modyfikacji nigdy nie jest zapisywany na dysku, dlatego nie ma oddzielnej funkcji do jego zapisu.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_setgothopt","title":"MEM_SetGothOpt","text":"<p>Opcja <code>option</code> w sekcji <code>section</code> jest ustawiana na <code>value</code>. Je\u015bli sekcja i/lub opcja nie istnieje, zostanie utworzona. <pre><code>func void MEM_SetGothOpt(var string section, var string option, var string value) {};\n</code></pre></p> <ul> <li><code>section</code> - sekcja, w kt\u00f3rej znajduje si\u0119 opcja</li> <li><code>option</code> - opcja do zapisania/nadpisania</li> <li><code>value</code> - warto\u015b\u0107, na jak\u0105 ustawiana jest opcja</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_applygothopt","title":"MEM_ApplyGothOpt","text":"<p>Stosuje zmiany i zapisuje plik ini na dysku. <pre><code>func void MEM_ApplyGothOpt() {};\n</code></pre></p> <p>Tip</p> <p>Je\u015bli wprowadzasz nowe opcje, najlepiej kierowa\u0107 si\u0119 paroma zasadami. Dobr\u0105 praktyk\u0105 jest nazywanie swoich opcji tak, aby inni mogli je zrozumie\u0107 i umieszczanie ich w sekcji o takiej samej nazwie jak tw\u00f3j mod. Nie umieszczaj opcji swojej modyfikacji w sekcji <code>[GAME]</code> lub <code>[PERFORMANCE]</code>.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#funkcje-klawiszy","title":"Funkcje klawiszy","text":"<p><code>Gothic.ini</code> zawiera przypisanie klawiszy fizycznych (np. \"W\") do klawiszy logicznych (np. \"keyUp\").</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_getkey","title":"MEM_GetKey","text":"<p>Zwraca podstawowy klawisz przypisany do klawisza logicznego. <pre><code>func int MEM_GetKey (var string name) {};\n</code></pre></p> <ul> <li><code>name</code> - nazwa klawisza logicznego</li> <li><code>return</code> - klawisz przypisany do klawisza logicznego</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_getsecondarykey","title":"MEM_GetSecondaryKey","text":"<p>Zwraca zapasowy klawisz przypisany do klawisza logicznego. <pre><code>func int MEM_GetSecondaryKey(var string name) {};\n</code></pre></p> <ul> <li><code>name</code> - nazwa klawisza logicznego</li> <li><code>return</code> - klawisz przypisany do klawisza logicznego</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_setkeys","title":"MEM_SetKeys","text":"<p>Ustawia klawisze klawiatury dla klawisza logicznego. <pre><code>func void MEM_SetKeys(var string name, var int primary, var int secondary) {};\n</code></pre></p> <ul> <li><code>name</code> - nazwa klawisza logicznego</li> <li><code>primary</code> - podstawowy klawisz do przypisania, mo\u017cna go pobra\u0107 z pliku Ikarus_Const_G1/G2.</li> <li><code>secondary</code> - zapasowy klawisz do przypisania, mo\u017cna go pobra\u0107 z pliku Ikarus_Const_G1/G2.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_setkey","title":"MEM_SetKey","text":"<p>Ustawia podstawowy klawisz klawiatury dla klawisza logicznego. <pre><code>func void MEM_SetKey(var string name, var int key) {};\n</code></pre></p> <ul> <li><code>name</code> - nazwa klawisza logicznego</li> <li><code>key</code> - podstawowy klawisz do przypisania, mo\u017cna go pobra\u0107 z pliku Ikarus_Const_G1/G2.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/ini_access/#mem_setsecondarykey","title":"MEM_SetSecondaryKey","text":"<p>Ustawia zapasowy klawisz klawiatury dla klawisza logicznego. <pre><code>func void MEM_SetSecondaryKey(var string name, var int key) {};\n</code></pre></p> <ul> <li><code>name</code> - name of the logical key</li> <li><code>key</code> - zapasowy klawisz do przypisania, mo\u017cna go pobra\u0107 z pliku Ikarus_Const_G1/G2.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/","title":"LeGo","text":"<p>LeGo (LehonaGottfried) to pakiet skryptowy zbudowany na bazie Ikarusa.</p> Kontakt Autor  Lehona, Gottfried i wsp\u00f3\u0142tw\u00f3rcy GitHub  LeGo Forum  LeGo <p>Note</p> <p>Kod LeGo jest hostowany na GitHubie, a sam pakiet skryptowy ma w\u0142asn\u0105 strone z dokumentacj\u0105. </p>"},{"location":"pl/zengin/scripts/extenders/lego/bars/","title":"Bars - paski","text":"<p>Ten pakiet bardzo u\u0142atwia dodawanie nowych pask\u00f3w, dla wy\u015bwietlania np. wytrzyma\u0142o\u015bci.</p>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>PermMem</li> <li>View</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_Bars</code>. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Bars);\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#implementacja","title":"Implementacja","text":"<p> Bars.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#funkcje","title":"Funkcje","text":"<p>Note</p> <p>Je\u015bli prototyp <code>GothicBar</code> jest wybrany jako typ pocz\u0105tkowy (<code>GothicBar@</code> jako konstruktor), paski u\u017cytkownika s\u0105 wizualnie nie do odr\u00f3\u017cnienia od tych u\u017cywanych w Gothicu.</p>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_create","title":"Bar_Create","text":"<p>Tworzy nowy pasek z instancji konstruktora. <pre><code>func int Bar_Create(var int inst) {};\n</code></pre></p> <ul> <li><code>inst</code> - instancja konstruktora klasy <code>Bar</code></li> <li><code>return</code> - handler do nowego paska </li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_delete","title":"Bar_Delete","text":"<p>Usuwa pasek z ekranu i pami\u0119ci.  <pre><code>func void Bar_Delete(var int bar) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_setmax","title":"Bar_SetMax","text":"<p>Zmienia maksymalna warto\u015b\u0107 paska, ale nie aktualizuje jego d\u0142ugo\u015bci (tylko <code>Bar_SetPercent</code>, <code>Bar_SetPromille</code> i <code>Bar_SetValue</code> to robi\u0105) <pre><code>func void Bar_SetMax(var int bar, var int max) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>max</code> - nowa maksymalna warto\u015b\u0107</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_setvalue","title":"Bar_SetValue","text":"<p>Ustawia warto\u015b\u0107 paska. <pre><code>func void Bar_SetValue(var int bar, var int val) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>val</code> - nowa warto\u015b\u0107 paska</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_setpercent","title":"Bar_SetPercent","text":"<p>Ustawia warto\u015b\u0107 paska, ale w procentach (0..100). <pre><code>func void Bar_SetPercent(var int bar, var int perc) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>perc</code> - nowa warto\u015b\u0107 paska w procentach</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_setpromille","title":"Bar_SetPromille","text":"<p>Ustawia warto\u015b\u0107 paska, ale w promilach (0..1000). <pre><code>func void Bar_SetPromille(var int bar, var int pro) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>pro</code> - nowa warto\u015b\u0107 paska w promilach</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_hide","title":"Bar_Hide","text":"<p>Ukrywa pasek, ale go nie usuwa. <pre><code>func void Bar_Hide(var int bar) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_show","title":"Bar_Show","text":"<p>Wy\u015bwietla pasek ponownie po u\u017cyciu <code>Bar_Hide</code>.  <pre><code>func void Bar_Show(var int bar) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_moveto","title":"Bar_MoveTo","text":"<p>Przenosi pasek do danej pozycji wirtualnej.  <pre><code>func void Bar_MoveTo(var int bar, var int x, var int y) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>x</code> - nowa pozycja w osi x</li> <li><code>y</code> - nowa pozycja w osi y</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_movetopxl","title":"Bar_MoveToPxl","text":"<p>Przenosi pasek do danej pozycji wyra\u017conej w pikselach. <pre><code>func void Bar_MoveToPxl(var int bar, var int x, var int y) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>x</code> - nowa pozycja w osi x</li> <li><code>y</code> - nowa pozycja w osi y</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_setalpha","title":"Bar_SetAlpha","text":"<p>Ustawia przezroczysto\u015b\u0107 paska. <pre><code>func void Bar_SetAlpha(var int bar, var int alpha) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>alpha</code> - warto\u015b\u0107 przezroczysto\u015bci (0..255) </li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_setbartexture","title":"Bar_SetBarTexture","text":"<p>Ustawia tekstur\u0119 warto\u015bci paska. <pre><code>func void Bar_SetBarTexture(var int bar, var string barTex) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>barTex</code> - nowa tekstura</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_setbacktexture","title":"Bar_SetBackTexture","text":"<p>Ustawia tekstur\u0119 t\u0142a paska. <pre><code>func void Bar_SetBackTexture(var int bar, var string backTex) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>backTex</code> - nowa tekstura</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_resize","title":"Bar_Resize","text":"<p>Zmie\u0144 rozmiar istniej\u0105cego paska. <pre><code>func void Bar_Resize(var int bar, var int width, var int height) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>width</code> - nowa szeroko\u015b\u0107</li> <li><code>height</code> - nowa wysoko\u015b\u0107</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#bar_resizepxl","title":"Bar_ResizePxl","text":"<p>Zmie\u0144 rozmiar istniej\u0105cego paska (w pikselach). <pre><code>func void Bar_ResizePxl(var int bar, var int x, var int y) {};\n</code></pre></p> <ul> <li><code>bar</code> - handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>x</code> - nowa szeroko\u015b\u0107</li> <li><code>y</code> - nowa wysoko\u015b\u0107</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#przyk\u0142ady","title":"Przyk\u0142ady","text":"<p>Note</p> <p>Ten pakiet zak\u0142ada podstawowe zrozumienie modu\u0142u PermMem. </p>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#wy\u015bwietlenie-prostego-paska","title":"Wy\u015bwietlenie prostego paska","text":"<p>Na pocz\u0105tku tworzymy pasek, kt\u00f3ry nie robi absolutnie nic. Powinien wy\u015bwietla\u0107 si\u0119 na dole ekranu jako zape\u0142niony w po\u0142owie. <pre><code>func void Example_1()\n{\nvar int bar; bar = Bar_Create(GothicBar@); // Tworzy nowy pasek\nBar_SetPercent(bar, 50);                   // Ustawia jego warto\u015b\u0107 na 50%\n};\n</code></pre> To tyle. Bez \u017cadnych ustawie\u0144? I czym jest ten <code>GothicBar@</code>? Sp\u00f3jrzmy na bardziej rozbudowany przyk\u0142ad.</p>"},{"location":"pl/zengin/scripts/extenders/lego/bars/#dedykowany-pasek-do\u015bwiadczenia","title":"Dedykowany pasek do\u015bwiadczenia","text":"<p>Pakiet Bars implementuje klas\u0119 <code>Bar</code>. Kt\u00f3ra wygl\u0105da tak: <pre><code>class Bar\n{\nvar int x;          // Pozycja na ekranie w osi X (\u015brodka paska)\nvar int y;          // Pozycja na ekranie w osi Y (\u015brodka paska)\nvar int barTop;     // Pasek odst\u0119pu t\u0142a - g\u00f3ra/d\u00f3\u0142\nvar int barLeft;    // Pasek odst\u0119pu t\u0142a - lewo/prawo\nvar int width;      // Szeroko\u015b\u0107\nvar int height;     // Wysoko\u015b\u0107\nvar string backTex; // Tekstura t\u0142a\nvar string barTex;  // Tekstura warto\u015bci paska\nvar int value;      // Pocz\u0105tkowa warto\u015b\u0107\nvar int valueMax;   // Maksymalna warto\u015b\u0107\n};\n</code></pre> Prototyp <code>GothicBar</code> jest paskiem, kt\u00f3ry na\u015bladuje standardowy pasek u\u017cywany w grze. <pre><code>prototype GothicBar(Bar)\n{\nx = Print_Screen[PS_X] / 2;\ny = Print_Screen[PS_Y] - 20;\nbarTop = 3;\nbarLeft = 7;\nwidth = 180;\nheight = 20;\nbackTex = \"Bar_Back.tga\";\nbarTex = \"Bar_Misc.tga\";\nvalue = 100;\nvalueMax = 100;\n};\n</code></pre> O wiele \u0142atwiej jest skonfigurowa\u0107 now\u0105 instancj\u0119 przy u\u017cyciu tego prototypu. <code>GothicBar</code> bez zmian mo\u017cna znale\u017a\u0107 jako instancj\u0119 <code>GothicBar@</code>, kt\u00f3r\u0105 u\u017cyli\u015bmy do stworzenia paska w powy\u017cszym przyk\u0142adzie. GothicBar znajduje si\u0119 na \u015brodku ekranu i wygl\u0105da tak samo, jak pasek wy\u015bwietlany podczas nurkowania,  ale zr\u00f3bmy pasek, kt\u00f3ry znajduje si\u0119 w lewym g\u00f3rnym rogu obrazu i wy\u015bwietla punkty do\u015bwiadczenia. Stw\u00f3rz now\u0105 instancj\u0119 z pomoc\u0105 <code>GothicBar</code> i zmie\u0144 tylko pozycj\u0119. Oczywi\u015bcie dodaj te\u017c p\u0119tl\u0119 za pomoc\u0105 pakietu FrameFunctions. <pre><code>// Instancja stworzona z pomoc\u0105 prototypu GothicBar \ninstance Bar_1(GothicBar)\n{\nx = 100;\ny = 20;\n};\nfunc void Example_1()\n{\n// Example_1 mo\u017ce by\u0107 wywo\u0142any np. w Init_Global\nFF_ApplyOnce(Loop_1);\n};\nfunc void Loop_1()\n{\n// Example_1 uruchamia t\u0119 p\u0119tl\u0119.\n// Tutaj pasek powinien by\u0107 stworzony raz\n// a potem sparowany z punktami do\u015bwiadczenia:\nvar int MyBar;\nif(!Hlp_IsValidHandle(MyBar))\n{\nMyBar = Bar_Create(Bar_1); // Our Bar_1\n};\n// Reszta jest chyba oczywista:\nBar_SetMax(MyBar, hero.exp_next);\nBar_SetValue(MyBar, hero.exp);\n};\n</code></pre></p> <p>Note</p> <p>Jest to t\u0142umaczenie artyku\u0142u napisanego oryginalnie przez Gottfrieda i Lehone i umieszczonego w oficjalnej dokumentacji pakietu LeGo.</p>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/","title":"Console Commands - polecenia konsoli","text":"<p>Ten Pakiet pozwala na tworzenie nowych polece\u0144 konsloli dost\u0119pnej po naci\u015bni\u0119ciu klawisza F2 w trybie marvin.</p>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>PermMem</li> <li>HookEngine</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_ConsoleCommands</code>. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_ConsoleCommands);\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#implementacja","title":"Implementacja","text":"<p> ConsoleCommands.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#cc_register","title":"CC_Register","text":"<p>Rejestruje nowe polecenie konsoli. <pre><code>func void CC_Register(var func f, var string cmdPrefix, var string description) {};\n</code></pre></p> <ul> <li><code>f</code> - Ta funkcja jest wykonywana po wprowadzeniu polecenia <code>cmdPrefix</code> w konsoli. Sygnatura funkcji to <code>func string f(var string p0)</code>. Przekazany string to wszystko, co zosta\u0142o okre\u015blone w konsoli po faktycznym poleceniu. Zwracana warto\u015b\u0107 jest nast\u0119pnie wy\u015bwietlana w konsoli.</li> <li><code>cmdPrefix</code> - Jest to polecenie, kt\u00f3re mo\u017cna wprowadzi\u0107 w konsoli.</li> <li><code>description</code> - Ten tekst pojawia si\u0119 obok polecenia (w zSpy), gdy u\u017cywasz polecenia <code>help</code> w konsoli.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#cc_remove","title":"CC_Remove","text":"<p>Usuwa funkcje z konsoli komend. <pre><code>func void CC_Remove(var func f) {};\n</code></pre></p> <ul> <li><code>f</code>- Ta funkcja zostanie usuni\u0119ta, a powi\u0105zane z ni\u0105 polecenie przestanie dzia\u0142a\u0107.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#cc_active","title":"CC_Active","text":"<p>Sprawdza dana funkcja jest ju\u017c cz\u0119\u015bci\u0105 polecenia konsoli. <pre><code>func int CC_Active(var func f) {};\n</code></pre></p> <ul> <li><code>f</code> - sprawdzana funkcja</li> <li><code>return</code> - <code>TRUE</code> je\u015bli istnieje odpowiednia funkcja, <code>FALSE</code> w ka\u017cdym innym przypadku.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#przyk\u0142ady","title":"Przyk\u0142ady","text":""},{"location":"pl/zengin/scripts/extenders/lego/console_commands/#proste-polecenie-konsoli","title":"Proste polecenie konsoli","text":"<p>Jako prosty przyk\u0142ad stw\u00f3rzmy polecenie version, kt\u00f3re wy\u015bwietli nam wersj\u0119 modyfikacji.  Po pierwsze, deklarujemy sta\u0142\u0105 zmienn\u0105 <code>string</code> do przechowywania informacji o wersji. <pre><code>const string Mod_Version = \"Wersja modyfikacji - 0.1alpha\";\n</code></pre> Nast\u0119pnie tworzymy now\u0105 funkcje.</p> <p>Note</p> <p>Zwr\u00f3\u0107 uwag\u0119 na poprawn\u0105 sygnatur\u0119 funkcji. Je\u015bli nie b\u0119dzie b\u0142\u0119dna, polecenie spowoduje awari\u0119 gry.</p> <p><pre><code>// Ta funkcja jest wywo\u0142ywana przez nasze nowe polecenie\nfunc string CC_ModVersion (var string param)\n{\nreturn Mod_Version;\n};\n</code></pre> Nast\u0119pnie musimy zarejestrowa\u0107 polecenie. Dla wygody stworzy\u0142em now\u0105 funkcj\u0119 <code>RegisterConsoleFunctions</code>, kt\u00f3ra inicjuje wszystkie polecenia konsoli. Funkcja jest naprawd\u0119 prosta. <pre><code>func void RegisterConsoleFunctions()\n{\nCC_Register (CC_ModVersion, \"wersja_moda\", \"Wersja mojej modyfikacji.\");\n};\n</code></pre> Na koniec musimy wywo\u0142a\u0107 t\u0105 funkcje w <code>INIT_GLOBAL</code>. <pre><code>func void INIT_GLOBAL()\n{\nGame_InitGerman(); //tylko w G2\n// Inicjalizacja Ikarusa\nMEM_InitAll();\n// Inicjalizacja LeGo\nLeGo_Init(LeGo_ConsoleCommands);\n// Tutaj rejstrujemy nasze polecenia\nRegisterConsoleFunctions();\n// Reszta kodu\n};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/","title":"Gamestate - stan gry","text":"<p>Pakiet Gamestate pozwala sprawdzi\u0107 stan gry (rozpocz\u0119cie gry, \u0142adowanie gry lub zmiana poziomu).</p>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>EventHandler</li> <li>Saves</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_Gamestate</code>. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Gamestate);\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#implementacja","title":"Implementacja","text":"<p> Gamestate.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#gamestate_addlistener","title":"Gamestate_AddListener","text":"<p>Dodaje listener/handler zmiany stanu gry. <pre><code>func void Gamestate_AddListener(var func listener) {};\n</code></pre></p> <ul> <li><code>listener</code> - Ta funkcja zostanie wywo\u0142ana przy zmianie stanu gry. Bie\u017c\u0105cy stan gry jest przekazywany jako parametr.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#gamestate_removelistener","title":"Gamestate_RemoveListener","text":"<p>Usuwa listener zmiany stanu gry. <pre><code>func void Gamestate_RemoveListener(var func listener) {};\n</code></pre></p> <ul> <li><code>listener</code> - listener do usuni\u0119cia.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#przyk\u0142ady","title":"Przyk\u0142ady","text":"<p>Istniej\u0105 teraz dwie mo\u017cliwo\u015bci: albo zrobisz wszystko bezpo\u015brednio w Init-Global, albo u\u017cyjesz EventHandlera.</p>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#init_global","title":"Init_Global","text":"<pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame) {\nMEM_Info(\"Nowa gra rozpocz\u0119ta.\");\n}\nelse if(Gamestate == Gamestate_Loaded)\n{\nMEM_Info(\"\u0141adowanie gry.\");\n}\nelse if(Gamestate == Gamestate_WorldChange)\n{\nMEM_Info(\"Zmiana \u015bwiata.\");\n}\nelse\n{\nMEM_Info(\"Brak zmiany stanu gry\");\n};\n};\n</code></pre> <p>Mo\u017ce to by\u0107 przydatne podczas pracy z PermMem, gdzie obiekty PermMem nie musz\u0105 by\u0107 odtwarzane po za\u0142adowaniu gry.</p> <p>Mo\u017cesz te\u017c wymy\u015bli\u0107 co\u015b takiego: <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame)\n{\nFF_Apply(MyLoop);\nFF_Apply(My2ndLoop);\n};\n};\n</code></pre> Da\u0142oby to taki sam efekt jak: <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nFF_ApplyOnce(MyLoop);\nFF_ApplyOnce(My2ndLoop);\n};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/gamestate/#event-handler","title":"Event Handler","text":"<p>Ten przyk\u0142ad nie wymaga wi\u0119kszych wyja\u015bnie\u0144. <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nGamestate_AddListener(MyGamestateListener);\n};\nfunc void MyGamestateListener(var int state)\n{\nif(state == Gamestate_NewGame)\n{\nMEM_Info(\"Nowa gra rozpocz\u0119ta.\");\n}\nelse if(state == Gamestate_Loaded)\n{\nMEM_Info(\"\u0141adowanie gry.\");\n}\nelse if(state == Gamestate_WorldChange)\n{\nMEM_Info(\"Zmiana \u015bwiata.\");\n}\nelse\n{\nMEM_Info(\"Brak zmiany stanu gry.\");\n};\n};\n</code></pre> Daje taki sam efekt jak przyk\u0142ad z <code>Init_Global</code> ale dla niekt\u00f3rych mo\u017ce lepiej wygl\u0105da\u0107.</p> <p>Note</p> <p>Jest to t\u0142umaczenie artyku\u0142u napisanego oryginalnie przez Gottfrieda i Lehone i umieszczonego w oficjalnej dokumentacji pakietu LeGo.</p>"},{"location":"pl/zengin/scripts/extenders/lego/item_helper/","title":"ItemHelper - pomocnik do przedmiot\u00f3w","text":"<p>Ten pakiet jest bardzo prosty - pobiera wska\u017anik <code>oCItem</code> z instancji <code>C_Item</code> wa\u017cnej dla bie\u017c\u0105cego \u015bwiata i sesji.</p> <p>Warning</p> <p>Upewnij si\u0119, \u017ce ka\u017cdy \u015bwiat ma waypoint o nazwie <code>TOT</code> (po niemiecku \u201emartwy\u201d). Ikarus i LeGo potrzebuj\u0105 tego punktu nawigacyjnego, aby odradza\u0107 pomocniczych NPC. Jest to szczeg\u00f3lnie wa\u017cne w Gothicu 1, poniewa\u017c jego \u015bwiaty nie maj\u0105 waypointu <code>TOT</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/item_helper/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<p>Brak</p>"},{"location":"pl/zengin/scripts/extenders/lego/item_helper/#inicjalizacja","title":"Inicjalizacja","text":"<p>Brak</p>"},{"location":"pl/zengin/scripts/extenders/lego/item_helper/#implementacja","title":"Implementacja","text":"<p> ItemHelper.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/item_helper/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/item_helper/#itm_getptr","title":"ITM_GetPtr","text":"<pre><code>func int ITM_GetPtr(var int instance) {};\n</code></pre> <ul> <li><code>instance</code> - instancja <code>C_Item</code>, z kt\u00f3rej ma zosta\u0107 pobrany wska\u017anik</li> <li><code>return</code>- wska\u017anik <code>oCItem</code> instancji <code>C_Item</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/","title":"Misc - r\u00f3\u017cne","text":"<p>Pakiet Misc wprowadza r\u00f3\u017cne funkcje pomocnicze, kt\u00f3re nie pasowa\u0142y do \u017cadnego innego pakietu.</p>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<p>Brak</p>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#inicjalizacja","title":"Inicjalizacja","text":"<p>Brak</p>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#implementation","title":"Implementation","text":"<p> Misc.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/misc/#atan2f","title":"atan2f","text":"<p>Oblicza arcus tangens k\u0105ta mi\u0119dzy pocz\u0105tkiem a punktem (x, y). <pre><code>func float atan2f(var int x, var int y) {};\n</code></pre></p> <ul> <li><code>x</code> -  wsp\u00f3\u0142rz\u0119dna x</li> <li><code>y</code> -  wsp\u00f3\u0142rz\u0119dna y</li> <li><code>return</code> - arcus tangens w radianach jako Ikarusowy <code>float</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#sin","title":"sin","text":"<p>Oblicza sinus k\u0105ta podanego w radianach. <pre><code>func float sin (var float angle) {};\n</code></pre></p> <ul> <li><code>angle</code> - k\u0105t w radianach jak Ikarusowy <code>float</code></li> <li><code>return</code> - sinus k\u0105ta</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#cos","title":"cos","text":"<p>Oblicza cosinus k\u0105ta podanego w radianach. <pre><code>func float cos (var float angle) {};\n</code></pre></p> <ul> <li><code>angle</code> - k\u0105t w radianach jak Ikarusowy <code>float</code></li> <li><code>return</code> - cosinus k\u0105ta</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#tan","title":"tan","text":"<p>Oblicza tangens k\u0105ta podanego w radianach. <pre><code>func float tan (var float angle) {};\n</code></pre></p> <ul> <li><code>angle</code> - k\u0105t w radianach jak Ikarusowy <code>float</code></li> <li><code>return</code> - tangens k\u0105ta</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#asin","title":"asin","text":"<p>Oblicza arcus sinus <pre><code>func float asin (var float sine) {};\n</code></pre></p> <ul> <li><code>sine</code> - sinus k\u0105ta</li> <li><code>return</code> - arcus sinus k\u0105ta</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#acos","title":"acos","text":"<p>Oblicza arcus cosinus <pre><code>func float acos (var float cosine) {};\n</code></pre></p> <ul> <li><code>cosine</code> - cosinus k\u0105ta</li> <li><code>return</code> - arcus cosinus k\u0105ta</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#distance2d","title":"distance2D","text":"<p>Oblicza odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami na p\u0142aszczy\u017anie dwuwymiarowej <pre><code>func int distance2D(var int x1, var int x2, var int y1, var int y2) {};\n</code></pre></p> <ul> <li><code>x1</code> - wsp\u00f3\u0142rz\u0119dna x pierwszego punktu</li> <li><code>x2</code> - wsp\u00f3\u0142rz\u0119dna x drugiego punktu</li> <li><code>y1</code> - wsp\u00f3\u0142rz\u0119dna y pierwszego punktu</li> <li><code>y2</code> - wsp\u00f3\u0142rz\u0119dna y drugiego punktu</li> <li><code>return</code> - odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/misc/#distance2df","title":"distance2Df","text":"<p>Oblicza odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami na p\u0142aszczy\u017anie dwuwymiarowej, jako Ikarusowy <code>float</code> <pre><code>func float distance2Df(var float x1, var float x2, var float y1, var float y2) {};\n</code></pre></p> <ul> <li><code>x1</code> - wsp\u00f3\u0142rz\u0119dna x pierwszego punktu</li> <li><code>x2</code> - wsp\u00f3\u0142rz\u0119dna x drugiego punktu</li> <li><code>y1</code> - wsp\u00f3\u0142rz\u0119dna y pierwszego punktu</li> <li><code>y2</code> - wsp\u00f3\u0142rz\u0119dna y drugiego punktu</li> <li><code>return</code> - odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami, jako Ikarusowy <code>float</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/talents/","title":"Talents - talenty","text":"<p>Ten pakiet robi dwie rzeczy:</p> <ol> <li>Zapisuje dowoln\u0105 liczb\u0119 warto\u015bci dla okre\u015blonego NPC (efektywne rozszerzenie tablicy AIVar).</li> <li>Pozwala zidentyfikowa\u0107 NPC za pomoc\u0105 unikalnego ID.</li> </ol> <p>Pakiet <code>Talents</code> u\u017cywa jednego wolnego AIVara, domy\u015blnie jest to AIVar z mumerem 89, kt\u00f3ry mo\u017cna dostosowa\u0107 w <code>Userconst.d</code> <code>AIV_TALENT</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>PermMem</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_PermMem</code>. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_PermMem);\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#implementacja","title":"Implementacja","text":"<p> Talents.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/talents/#npc_getid","title":"NPC_GetID","text":"<p>Zwraca unikalne ID dla podanego NPC.</p> <pre><code>func int NPC_GetID(var c_npc slf) {};\n</code></pre> <ul> <li><code>slf</code> - NPC</li> <li><code>return</code> - ID </li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#npc_findbyid","title":"NPC_FindByID","text":"<p>Znajduje wska\u017anik NPC o podanym ID. <pre><code>func int NPC_FindByID(var int ID) {};\n</code></pre></p> <ul> <li><code>ID</code> - ID zwr\u00f3cone przez <code>NPC_GetID</code></li> <li><code>return</code> - wska\u017anik NPC</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#tal_createtalent","title":"TAL_CreateTalent","text":"<p>Tworzy talent, w kt\u00f3rym mo\u017cesz p\u00f3\u017aniej zapisa\u0107 warto\u015b\u0107 dla ka\u017cdego NPC (tak jak w AIVarze). <pre><code>func int TAL_CreateTalent() {};\n</code></pre></p> <ul> <li><code>return</code> - warto\u015b\u0107, kt\u00f3ra jest p\u00f3\u017aniej wykorzystywana jako ID talentu</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#tal_setvalue","title":"TAL_SetValue","text":"<p>Ustawia now\u0105 warto\u015b\u0107 dla okre\u015blonego talentu. <pre><code>func void TAL_SetValue(var c_npc npc, var int talent, var int value) {};\n</code></pre></p> <ul> <li><code>npc</code> - NPC dla kt\u00f3rego ustawiana jest warto\u015b\u0107</li> <li><code>talent</code> - ID talentu</li> <li><code>value</code> - ustawiana warto\u015b\u0107</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/talents/#tal_getvalue","title":"TAL_GetValue","text":"<p>Zwraca warto\u015b\u0107 talentu dla okre\u015blonego NPC. <pre><code>func int TAL_GetValue(var c_npc npc, var int talent) {};\n</code></pre></p> <ul> <li><code>npc</code> - NPC, kt\u00f3rego warto\u015b\u0107 talentu jest zwracana</li> <li><code>talent</code> - ID talentu</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/","title":"Trialog","text":"<p>Ten pakiet pozwala na tworzenie rozm\u00f3w z dowoln\u0105 liczb\u0105 NPC i sterowanie kamer\u0105 podczas dialogu.</p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>AI_Function</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_Trialoge</code>. <pre><code>func void LeGo_Init(var int flags) {};\nLeGo_Init(LeGo_Trialoge);\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#implementacja","title":"Implementacja","text":"<p> Trialoge.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#equipweapon","title":"EquipWeapon","text":"<p>Funkcja Sektenspinnera. (wzi\u0119ta z forum) <pre><code>func void EquipWeapon(var c_npc slf, var int ItemInstance) {};\n</code></pre></p> <ul> <li><code>slf</code> - NPC kt\u00f3ry wyposa\u017ca bro\u0144</li> <li><code>ItemInstance</code> - instancja broni do wyposa\u017cenia</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#npc_getarmor","title":"Npc_GetArmor","text":"<p>Zwraca wyposa\u017cony NPC pancerz. <pre><code>func int Npc_GetArmor(var c_npc slf) {};\n</code></pre></p> <ul> <li><code>slf</code> - NPC kt\u00f3rego pancerz jest zwracany</li> <li><code>return</code> - instanacja pancerza</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#npc_getmeleeweapon","title":"Npc_GetMeleeWeapon","text":"<p>Zwraca wyposa\u017con\u0105 przez NPC bro\u0144 r\u0119czn\u0105/bia\u0142\u0105. <pre><code>func int Npc_GetMeleeWeapon(var c_npc slf) {};\n</code></pre></p> <ul> <li><code>slf</code> - NPC kt\u00f3rego bro\u0144 jest zwracana</li> <li><code>return</code> - instanacja broni</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#diacam_update","title":"DiaCAM_Update","text":"<p>Funkcja Sektenspinnera. Aktualizuje kamer\u0119 dialogow\u0105. (U\u017cywana wewn\u0119trznie) <pre><code>func void DiaCAM_Update() {};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#diacam_disable","title":"DiaCAM_Disable","text":"<p>Ca\u0142kowicie wy\u0142\u0105cza kamery dialogowe. <pre><code>func void DiaCAM_Disable() {};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#diacam_enable","title":"DiaCAM_Enable","text":"<p>Resetuje kamery dialogowe do ustawie\u0144 domy\u015blnych. <pre><code>func void DiaCAM_Enable() {};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#tria_wait","title":"TRIA_Wait","text":"<p>Sprawia, \u017ce <code>self</code> i <code>other</code> czekaj\u0105 na siebie, np. dla synchronizacji po u\u017cyciu <code>AI_GotoWP</code>. <pre><code>func void TRIA_Wait() {};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#tria_invite","title":"TRIA_Invite","text":"<p>Zaprasza NPC do rozmowy. Nale\u017cy wywo\u0142a\u0107 przed <code>TRIA_Start</code>. <pre><code>func void TRIA_Invite(c_npc slf) {};\n</code></pre></p> <ul> <li><code>slf</code> - Zapraszany NPC</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#tria_start","title":"TRIA_Start","text":"<p>Rozpoczyna trialog. Wcze\u015bniej wszyscy NPC powinni zosta\u0107 zaproszeni przez <code>TRI_Invite</code>. <pre><code>func void TRIA_Start() {};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#tria_barrier","title":"TRIA_Barrier","text":"<p>Robi to samo co <code>TRIA_Wait</code>, ale dotyczy wszystkich uczestnicz\u0105cych NPC. <pre><code>func void TRIA_Barrier() {};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#tria_next","title":"TRIA_Next","text":"<p>Ustawia podanego npc na <code>self</code>. <pre><code>func void TRIA_Next(c_npc n0) {};\n</code></pre></p> <ul> <li><code>n0</code> - NPC ustawiany na <code>self</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#tria_cam","title":"TRIA_Cam","text":"<p>Rozpoczyna zdefiniowany wcze\u015bniej ruch kamery. <pre><code>func void TRIA_Cam(string evt) {};\n</code></pre></p> <ul> <li><code>evt</code> - nazwa ruchu kamery w Spacerze. Je\u015bli <code>\"\"</code> zostanie przekazane, ruch kamery zostanie przerwany</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#tria_finish","title":"TRIA_Finish","text":"<p>Ko\u0144czy trwaj\u0105cy trialog. Musi by\u0107 zawsze wywo\u0142ywana na ko\u0144cu, w przeciwnym razie dalsze trialogi nie b\u0119d\u0105 mog\u0142y zosta\u0107 rozpocz\u0119te. <pre><code>func void TRIA_Finish() {};\n</code></pre></p>"},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#przyk\u0142ady","title":"Przyk\u0142ady","text":""},{"location":"pl/zengin/scripts/extenders/lego/trialoge/#prosty-trialog","title":"Prosty trialog","text":"<p>Poni\u017csza rozmowa zosta\u0142a zrealizowana za pomoc\u0105 tego pakietu:</p> <ol> <li>Arto:    Przykro mi, bohaterze, ale nie mo\u017cesz t\u0119dy przej\u015b\u0107</li> <li>Hero:    Czemu nie?</li> <li>Horka:   Miasto zosta\u0142o zamkni\u0119te.</li> <li>Hero:    Mam ze sob\u0105 troch\u0119 z\u0142ota, mo\u017cemy si\u0119 dogada\u0107?</li> <li>Squelto: Nie. Nie jeste\u015bmy otwarci na przekupstwo.</li> <li>Hero:    Na pewno?</li> <li>Arto:    Musz\u0119 ci\u0119 teraz poprosi\u0107 o odej\u015bcie.</li> <li>Hero:    Dobraa... <pre><code>instance TRIA_Test (C_INFO)\n{\nnpc         = PAL_100_Friend;\nnr          = 10;\ncondition   = TRIA_Test_condition;\ninformation = TRIA_Test_info;\nimportant   = FALSE;\npermanent   = 1;\ndescription = \"TRIALOGTEST\";\n};\nfunc int TRIA_Test_condition()\n{\nreturn TRUE;\n};\nfunc void TRIA_Test_info()\n{\nvar c_npc Arto; Arto       = Hlp_GetNpc(PAL_100_Friend); // Jest w\u0142a\u015bcicielem dialogu\nvar c_npc Horka; Horka     = Hlp_GetNpc(PAL_101_Horka);\nvar c_npc Squelto; Squelto = Hlp_GetNpc(PAL_102_Squelto);\nTRIA_Invite(Horka);   // Zaprasza Hork\u0119 do tego dialogu\nTRIA_Invite(Squelto); // Zaprasza Squelto do tego dialogu\nTRIA_Start();         // Rozpoczyna rozmowe\n// Bohater i Arto(w\u0142a\u015bciciel) nie musz\u0105/nie mog\u0105 by\u0107 zaproszeni.\n// Bohater rozmawia teraz z Arto (self = Arto, other = Bohater)\nTRIA_Next(Arto);\nDIAG_Reset();\nAI_Output (self, other, \"TRIA_TEST_00\"); //Przykro mi, bohaterze, ale nie mo\u017cesz t\u0119dy przej\u015b\u0107\n// Bohater rozmawia teraz z Hork\u0105 (self = Horka, other = Bohater)\nTRIA_Next(Horka);\nAI_Output (other, self, \"TRIA_TEST_01\"); //Czemu nie?\nAI_GotoNpc(self, other);\nAI_TurnToNpc(other, self);\nAI_Output (self, other, \"TRIA_TEST_02\"); //Miasto zosta\u0142o zamkni\u0119te.\n// Bohater rozgl\u0105da si\u0119 konspiracyjnie podczas nast\u0119pnego zdania\nDIAG(\"Nervous\", 1, 2);\nAI_Output (other, self, \"TRIA_TEST_03\"); //Mam ze sob\u0105 troch\u0119 z\u0142ota, mo\u017cemy si\u0119 dogada\u0107?\n// Bohater powinien porusza\u0107 si\u0119 ju\u017c normalnie \nDIAG_Reset();\n// Rozpoczyna ruch kamery\nTRIA_Cam(\"CAMERASTART\");\n// Bohater rozmawia teraz z Squelto (self = Squelto, other = Bohater)\nTRIA_Next(Squelto);\nAI_TurnToNpc(other, self);\nDIAG(\"No\", 0, 1);\nAI_Output (self, other, \"TRIA_TEST_04\"); //Nie. Nie jeste\u015bmy otwarci na przekupstwo.\n// Bohater z powrotem rozmawia z Arto (self = Arto, other = Hero)\nTRIA_Next(Arto);\n// Bohater powinien teraz wypowiada\u0107 si\u0119 pytaj\u0105co\nDIAG(\"NotSure\", 0, 1);\nAI_Output (other, self, \"TRIA_TEST_05\"); //Na pewno?\nAI_TurnToNpc(other, self);\n// Koniec ruchu kamery\nTRIA_Cam(\"\");\n// Arto powinien agresywnie zareagowa\u0107\nDIAG(\"Angry\", 0, 4);\nAI_Output (self, other, \"TRIA_TEST_06\"); //Musz\u0119 ci\u0119 teraz poprosi\u0107 o odej\u015bcie.\n// Bohater powinien znowu porusza\u0107 si\u0119 normalnie \nDIAG_Reset();\nAI_Output (other, self, \"TRIA_TEST_07\"); //Dobraa...\nTRIA_Finish(); // Koniec\n};\n</code></pre></li> </ol> <p>Note</p> <p>Dodatkowo w tej rozmowie u\u017cywane s\u0105 gesty dialogowe (funkcje <code>DIAG</code> i <code>DIAG_Reset</code>).</p>"},{"location":"cs/","title":"V\u00edtejte na str\u00e1nce Gothic Modding Community","text":"<p>Tato Github str\u00e1nka obsahuje komunitou vytvo\u0159en\u00e9 a udr\u017eovan\u00e9 \u010dl\u00e1nky, n\u00e1vody a dokumentaci o v\u0161em, co se t\u00fdk\u00e1 her Gothic.</p> <p>Prvn\u00ed dv\u011b hry s\u00e9rie Gothic b\u011b\u017e\u00ed na enginu, kter\u00fd se jmenuje ZenGin, vyvinut\u00e9m studiem Piranha Bytes a skupinou program\u00e1tor\u016f Mad Scientists. Pokud se chcete o historii v\u00fdvoje dozv\u011bd\u011bt v\u00edce, hromadu informac\u00ed m\u016f\u017eete naj\u00edt na str\u00e1nce Gothic Archive.</p> <p>Obsah t\u00e9to str\u00e1nky by nem\u011bl b\u00fdt br\u00e1n jako jedin\u00fd validn\u00ed zp\u016fsob moddingu. Jsme pouze nad\u0161enci, kte\u0159\u00ed sd\u00edl\u00ed sv\u00e9 zku\u0161enosti, znalosti a na\u0161e nejobl\u00edben\u011bj\u0161\u00ed postupy.</p> <p>Nev\u00e1hejte otev\u0159\u00edt pull request s va\u0161\u00edm \u010dl\u00e1nkem nebo n\u00e1vrhy na zm\u011bny.</p> <p>Pull request m\u016f\u017eete otev\u0159\u00edt v tomto repozit\u00e1\u0159i.</p>"}]}