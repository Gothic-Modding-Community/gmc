{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Gothic Modding Community page This GitHub page is designed to contain community maintained set of articles, tutorials and documentation for everything Gothic. First two Gothic games use engine called ZenGin, developed by Piranha Bytes and Mad Scientists. If you want to know more about the history of the development, there is a heap of information on the Gothic Archive . The content here is not meant to be taken as the holy word of modding. We are just modders sharing our experiences, knowledge and our favorite work flows. Feel free to open a pull request with your article or propose changes. You can open a pull request in this repository","title":"Welcome to Gothic Modding Community page"},{"location":"#welcome-to-gothic-modding-community-page","text":"This GitHub page is designed to contain community maintained set of articles, tutorials and documentation for everything Gothic. First two Gothic games use engine called ZenGin, developed by Piranha Bytes and Mad Scientists. If you want to know more about the history of the development, there is a heap of information on the Gothic Archive . The content here is not meant to be taken as the holy word of modding. We are just modders sharing our experiences, knowledge and our favorite work flows. Feel free to open a pull request with your article or propose changes. You can open a pull request in this repository","title":"Welcome to Gothic Modding Community page"},{"location":"notready/","text":"Warning Sorry, this page is not ready yet!","title":"Notready"},{"location":"contribute/","text":"How to contribute The Gothic Modding Community is a community-driven project. We encourage people to contribute. This site is built with a Static Site Generator MkDocs and the Material for MkDocs theme together with multiple other MkDocs plugins. Prerequisites for contribution differ based on the scale and type of the contribution. Feedback You can either open an issue via GitHub or join us on Discord. Direct contribution Direct contribution is made via creating a copy of this repository (a fork) and creating a pull request (PR) on GitHub with changes for approval. Don't waste time Please make sure that the content you are contributing does not already exist on the dev page . You can use the search tool to filter GMC for different keywords and contents. How to edit the source files? The source files for the articles are written using the Markdown .md file format ( Markdown cheatsheet ). Other than that, this site also uses Python Markdown Extensions which add more syntax rules like indented admonitions . Minor changes Minor changes like fixing typos, grammatical errors or removing/adding words to paragraphs in a single file can be done quickly with the pen button in the upper right corner of each article. This will open up a GitHub editing interface which will create a fork with a patch branch after modifying the file and guide the user to open up the pull request. Select the correct branch for the pull request Make sure that the pull request is directed towards the dev or a special pre-merge branch and not the main branch. Major changes More elaborate changes like editing multiple files at once, adding new articles, images, other miscellaneous files or changing the configuration of the page are easier to make via external tools on your local PC. While most of these operations can be done with the GitHub interface, it is rather cumbersome, and it may be harder to spot issues during the process as changes are not immediately visible in the browser. Some preparation is needed before working on the files as MkDocs requires an installation of Python on the system to run. GitHub works on top of git so an installation of git is also required. A basic familiarity with Terminal/Command Prompt/Powershell command line interfaces is helpful. System setup (video) Firstly, you should install Python. You can follow this step-by-step tutorial for Windows or macOS on how to install Python. This video is from 2017?! The process of installing Python hasn't changed since that point. However, please install the latest version of Python 3. To work remotely with GitHub, you can install the latest version of git on your system following this tutorial . If you are planning to do some elaborate Python programming, you can follow this step-by-step tutorial for Windows or macOS on how to set up an environment with Visual Studio Code. If you just plan on editing the content of the articles with Markdown, you can simply install the latest version of Visual Studio Code for GUI git management and Markdown preview or work with any other familiar text editor and omit the environment setup. System setup (text) To prepare your system to run the project follow those instructions: Install the latest Python version. Make sure to select the \"Add Python to PATH\" option during the installation process. Open up a Terminal/Command Prompt (cmd)/Powershell window. Check that Python was properly installed with this command (might need a terminal restart): 1 python --version Install the latest version of git following this tutorial . Check that git was properly installed with this command (might need a terminal restart): 1 git --version (optional) Install the latest version of Visual Studio Code for GUI git management and Markdown preview. Working locally In order to work locally: Create a fork on GitHub. Navigate to a directory where you want to clone your forked repository and open a Terminal window inside. Clone the forked repository, using this command: 1 git clone https://github.com/user-name/forked-repository-name.git DIR-PATH Replace the DIR-PATH with a directory name or . if you're inside the directory you want the project files to be in. Instead of https://github.com/user-name/forked-repository-name.git you ought to click on the green <> Code button and select the HTTPS tab. (optional) Create a Virtual Environment and activate it. If you work on multiple Python projects, it might be worthwhile to create a Virtual Environment for each project to have separate library directories with installed modules/plugins. 1 python -m venv venv This will create a venv directory inside the current Terminal directory. Please keep that name as it's added to the .gitignore project file. Depending on the system, use one of these commands to activate the virtual environment. Linux 1 2 # Linux / macOS source venv/bin/activate Windows 1 2 3 4 # Windows Command Prompt (cmd) venv \\ Scripts \\ activate . bat # Windows Powershell venv \\ Scripts \\ activate . ps1 After activation there will be a (venv) indicator near the Terminal prompt. Don't close the Terminal The virtual environment must be activated each time a new Terminal window is opened. Install MkDocs with plugins using this command: 1 pip install -r requirements.txt This will install all dependencies. Add the remote upstream repository and fetch the history using these commands: 1 2 git remote add upstream https://github.com/auronen/gmc.git git fetch upstream Checkout the upstream dev branch using this command: 1 git checkout --track upstream/dev Checkout the new branch based on the upstream dev branch: 1 git checkout -b name-of-branch An appropriate name for a branch is either a feature name or short description of what it changes - for example 3ds-articles , fix-typos-for-contribution . They do not have to be elaborate, up-to 4 words suffices. Start a server with MkDocs using this command: 1 mkdocs serve Visit the local site with this url http://127.0.0.1:8000/gmc/ . Any time you make change to any file, the website will rebuild itself and your browser will auto-refresh. The server may be closed using the Control-C shortcut while in the terminal/console. When you are satisfied with a part of work, add and commit the files using these commands: 1 2 git add . git commit -m \"add 3 articles about ZenGin\" An appropriate commit message should be a sentence describing the changes. When you are finished with the work, push the branch to origin and create the pull request using this command: 1 git push origin name-of-branch Create the pull request to the appropriate branch. Submit a file If working with git or Markdown is not viable or possible for you, you can submit files in a Google Docs format on the GMC Discord server and we will format and upload it to the page.","title":"How to contribute"},{"location":"contribute/#how-to-contribute","text":"The Gothic Modding Community is a community-driven project. We encourage people to contribute. This site is built with a Static Site Generator MkDocs and the Material for MkDocs theme together with multiple other MkDocs plugins. Prerequisites for contribution differ based on the scale and type of the contribution.","title":"How to contribute"},{"location":"contribute/#feedback","text":"You can either open an issue via GitHub or join us on Discord.","title":"Feedback"},{"location":"contribute/#direct-contribution","text":"Direct contribution is made via creating a copy of this repository (a fork) and creating a pull request (PR) on GitHub with changes for approval. Don't waste time Please make sure that the content you are contributing does not already exist on the dev page . You can use the search tool to filter GMC for different keywords and contents. How to edit the source files? The source files for the articles are written using the Markdown .md file format ( Markdown cheatsheet ). Other than that, this site also uses Python Markdown Extensions which add more syntax rules like indented admonitions .","title":"Direct contribution"},{"location":"contribute/#minor-changes","text":"Minor changes like fixing typos, grammatical errors or removing/adding words to paragraphs in a single file can be done quickly with the pen button in the upper right corner of each article. This will open up a GitHub editing interface which will create a fork with a patch branch after modifying the file and guide the user to open up the pull request. Select the correct branch for the pull request Make sure that the pull request is directed towards the dev or a special pre-merge branch and not the main branch.","title":"Minor changes"},{"location":"contribute/#major-changes","text":"More elaborate changes like editing multiple files at once, adding new articles, images, other miscellaneous files or changing the configuration of the page are easier to make via external tools on your local PC. While most of these operations can be done with the GitHub interface, it is rather cumbersome, and it may be harder to spot issues during the process as changes are not immediately visible in the browser. Some preparation is needed before working on the files as MkDocs requires an installation of Python on the system to run. GitHub works on top of git so an installation of git is also required. A basic familiarity with Terminal/Command Prompt/Powershell command line interfaces is helpful.","title":"Major changes"},{"location":"contribute/#system-setup-video","text":"Firstly, you should install Python. You can follow this step-by-step tutorial for Windows or macOS on how to install Python. This video is from 2017?! The process of installing Python hasn't changed since that point. However, please install the latest version of Python 3. To work remotely with GitHub, you can install the latest version of git on your system following this tutorial . If you are planning to do some elaborate Python programming, you can follow this step-by-step tutorial for Windows or macOS on how to set up an environment with Visual Studio Code. If you just plan on editing the content of the articles with Markdown, you can simply install the latest version of Visual Studio Code for GUI git management and Markdown preview or work with any other familiar text editor and omit the environment setup.","title":"System setup (video)"},{"location":"contribute/#system-setup-text","text":"To prepare your system to run the project follow those instructions: Install the latest Python version. Make sure to select the \"Add Python to PATH\" option during the installation process. Open up a Terminal/Command Prompt (cmd)/Powershell window. Check that Python was properly installed with this command (might need a terminal restart): 1 python --version Install the latest version of git following this tutorial . Check that git was properly installed with this command (might need a terminal restart): 1 git --version (optional) Install the latest version of Visual Studio Code for GUI git management and Markdown preview.","title":"System setup (text)"},{"location":"contribute/#working-locally","text":"In order to work locally: Create a fork on GitHub. Navigate to a directory where you want to clone your forked repository and open a Terminal window inside. Clone the forked repository, using this command: 1 git clone https://github.com/user-name/forked-repository-name.git DIR-PATH Replace the DIR-PATH with a directory name or . if you're inside the directory you want the project files to be in. Instead of https://github.com/user-name/forked-repository-name.git you ought to click on the green <> Code button and select the HTTPS tab. (optional) Create a Virtual Environment and activate it. If you work on multiple Python projects, it might be worthwhile to create a Virtual Environment for each project to have separate library directories with installed modules/plugins. 1 python -m venv venv This will create a venv directory inside the current Terminal directory. Please keep that name as it's added to the .gitignore project file. Depending on the system, use one of these commands to activate the virtual environment. Linux 1 2 # Linux / macOS source venv/bin/activate Windows 1 2 3 4 # Windows Command Prompt (cmd) venv \\ Scripts \\ activate . bat # Windows Powershell venv \\ Scripts \\ activate . ps1 After activation there will be a (venv) indicator near the Terminal prompt. Don't close the Terminal The virtual environment must be activated each time a new Terminal window is opened. Install MkDocs with plugins using this command: 1 pip install -r requirements.txt This will install all dependencies. Add the remote upstream repository and fetch the history using these commands: 1 2 git remote add upstream https://github.com/auronen/gmc.git git fetch upstream Checkout the upstream dev branch using this command: 1 git checkout --track upstream/dev Checkout the new branch based on the upstream dev branch: 1 git checkout -b name-of-branch An appropriate name for a branch is either a feature name or short description of what it changes - for example 3ds-articles , fix-typos-for-contribution . They do not have to be elaborate, up-to 4 words suffices. Start a server with MkDocs using this command: 1 mkdocs serve Visit the local site with this url http://127.0.0.1:8000/gmc/ . Any time you make change to any file, the website will rebuild itself and your browser will auto-refresh. The server may be closed using the Control-C shortcut while in the terminal/console. When you are satisfied with a part of work, add and commit the files using these commands: 1 2 git add . git commit -m \"add 3 articles about ZenGin\" An appropriate commit message should be a sentence describing the changes. When you are finished with the work, push the branch to origin and create the pull request using this command: 1 git push origin name-of-branch Create the pull request to the appropriate branch.","title":"Working locally"},{"location":"contribute/#submit-a-file","text":"If working with git or Markdown is not viable or possible for you, you can submit files in a Google Docs format on the GMC Discord server and we will format and upload it to the page.","title":"Submit a file"},{"location":"genome/","text":"Genome engine Genome engine is new engine by Piranha Bytes created for the game Gothic 3 and later used for the Risen and ELEX series of games.","title":"Genome engine"},{"location":"genome/#genome-engine","text":"Genome engine is new engine by Piranha Bytes created for the game Gothic 3 and later used for the Risen and ELEX series of games.","title":"Genome engine"},{"location":"genome/object_persistence/","text":"Object persistence Please note the following warning about Risen 2, 3 and ELEX 1 and 2 The following information only applies to Gothic 3 (2006) and Risen (2009). While newer Genome engine games share the same overall concepts, they have significant implementation differences that warrant their own section. The engine is, due to the nature of the games themselves, required to store and load a vast amount of different types of data from the user's hard-drive. In order to streamline this parsing and/or serialization process, Genome implements an object persistence system using its own built-in runtime type information (RTTI) system. Any class derived from bCObjectBase may declare its own member properties in such a way that when the object is then written into a file using the bCAccessorPropertyObject class, its associated properties will be automatically serialized into the stream by using special preprocessor macros. When the object is read back from the file, the class will be automatically initialized using the stored members. Additionally, classes may overload the Read and Write ( OnRead and OnWrite in Risen 1) virtual methods that allow the class to save additional data required during parsing such as paths to other necessary files. As this system is quite flexible, it is used to store most of the game's data, from meshes, animations and textures to level and quest data. This is quite different from ZenGin, as its object persistence system is only used for worlds, saves, output units and parts of compiled meshes. File format Files 1 2 3 4 struct bCIOStream { char data []; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct eCArchiveFile { char8_t magic [ 8 ]; // \"GENOMFLE\" uint16_t version ; // 0001 uint32_t offset ; char data []; uint32_t magic ; // DEADBEEF uint8_t version ; // 01 uint32_t count ; for ( Count ) { uint16_t length ; char8_t string [ length ]; // (ASCII) } }; bCAccessorPropertyObject 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 bCAccessorPropertyObject :: Read { uint16_t version ; // 0x0001 bool hasPropertyObject ; if ( hasPropertyObject ) { bCPropertyObjectSingleton :: ReadObject { uint16_t version ; // 0x0001 bool isPersistable ; // 0x01 (GETrue) bCString className ; bCPropertyObjectFactory :: ReadObject { uint16_t version ; // 0x0001 bool isRoot ; // 0x00 (GEFalse) uint16_t classVersion ; bTPropertyObject <% , %>:: Read { bCPropertyObjectBase :: Read { uint16_t version ; // 0x00C9 (201) } uint32_t size ; } bTPropertyObject <% , %>:: ReadData { bCPropertyObjectBase :: ReadData { uint16_t version ; // 0x00C9 (201) uint32_t count ; for ( count ) { bCString name ; bCString type ; uint16_t version ; // 0x001E (30) uint32_t size ; uint8_t value [ size ]; } } %:: Read { // ClassName::OnRead/OnWrite() // uint16_t ClassVersion; ... } } } } } } eCProcessibleElement Gothic 3 Risen 1 2 3 4 5 6 7 8 eCProcessibleElement :: Load { uint32_t magic ; // 0xD0DEFADE bCAccessorPropertyObject :: Read { // Look above for bCAccessorPropertyObject definition } } 1 2 3 4 5 6 7 eCProcessibleElement :: Load { bCAccessorPropertyObject :: Read { // Look above for bCAccessorPropertyObject definition } } Implementation A practical example Let's propose that we have a class which is declared like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class gCMyClass : public bCObjectRefBase { public : gCMyClass () {} virtual ~ gCMyClass () {} virtual bEResult Write ( bCOStream & ); // OnWrite for Risen virtual bEResult Read ( bCIStream & ); // OnRead for Risen private : DECLARE_PROPERTY ( myInt , int ); int someData ; }; The hypothetical class then implements these virtual functions: 1 2 3 4 5 6 7 8 9 10 11 bEResult gCMyClass::Write ( bCOStream & file ) { file << someData ; return bEResult_Ok ; } bEResult gCMyClass::Read ( bCIStream & file ) { file >> someData ; return bEResult_Ok ; } We then initialize the class in the following way: 1 2 3 gCMyClass object ; object . myInt = 1 ; object . someData = 1 ; If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII stream, the result would look like this: 1","title":"Object persistence"},{"location":"genome/object_persistence/#object-persistence","text":"Please note the following warning about Risen 2, 3 and ELEX 1 and 2 The following information only applies to Gothic 3 (2006) and Risen (2009). While newer Genome engine games share the same overall concepts, they have significant implementation differences that warrant their own section. The engine is, due to the nature of the games themselves, required to store and load a vast amount of different types of data from the user's hard-drive. In order to streamline this parsing and/or serialization process, Genome implements an object persistence system using its own built-in runtime type information (RTTI) system. Any class derived from bCObjectBase may declare its own member properties in such a way that when the object is then written into a file using the bCAccessorPropertyObject class, its associated properties will be automatically serialized into the stream by using special preprocessor macros. When the object is read back from the file, the class will be automatically initialized using the stored members. Additionally, classes may overload the Read and Write ( OnRead and OnWrite in Risen 1) virtual methods that allow the class to save additional data required during parsing such as paths to other necessary files. As this system is quite flexible, it is used to store most of the game's data, from meshes, animations and textures to level and quest data. This is quite different from ZenGin, as its object persistence system is only used for worlds, saves, output units and parts of compiled meshes.","title":"Object persistence"},{"location":"genome/object_persistence/#file-format","text":"","title":"File format"},{"location":"genome/object_persistence/#files","text":"1 2 3 4 struct bCIOStream { char data []; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct eCArchiveFile { char8_t magic [ 8 ]; // \"GENOMFLE\" uint16_t version ; // 0001 uint32_t offset ; char data []; uint32_t magic ; // DEADBEEF uint8_t version ; // 01 uint32_t count ; for ( Count ) { uint16_t length ; char8_t string [ length ]; // (ASCII) } };","title":"Files"},{"location":"genome/object_persistence/#bcaccessorpropertyobject","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 bCAccessorPropertyObject :: Read { uint16_t version ; // 0x0001 bool hasPropertyObject ; if ( hasPropertyObject ) { bCPropertyObjectSingleton :: ReadObject { uint16_t version ; // 0x0001 bool isPersistable ; // 0x01 (GETrue) bCString className ; bCPropertyObjectFactory :: ReadObject { uint16_t version ; // 0x0001 bool isRoot ; // 0x00 (GEFalse) uint16_t classVersion ; bTPropertyObject <% , %>:: Read { bCPropertyObjectBase :: Read { uint16_t version ; // 0x00C9 (201) } uint32_t size ; } bTPropertyObject <% , %>:: ReadData { bCPropertyObjectBase :: ReadData { uint16_t version ; // 0x00C9 (201) uint32_t count ; for ( count ) { bCString name ; bCString type ; uint16_t version ; // 0x001E (30) uint32_t size ; uint8_t value [ size ]; } } %:: Read { // ClassName::OnRead/OnWrite() // uint16_t ClassVersion; ... } } } } } }","title":"bCAccessorPropertyObject"},{"location":"genome/object_persistence/#ecprocessibleelement","text":"Gothic 3 Risen 1 2 3 4 5 6 7 8 eCProcessibleElement :: Load { uint32_t magic ; // 0xD0DEFADE bCAccessorPropertyObject :: Read { // Look above for bCAccessorPropertyObject definition } } 1 2 3 4 5 6 7 eCProcessibleElement :: Load { bCAccessorPropertyObject :: Read { // Look above for bCAccessorPropertyObject definition } }","title":"eCProcessibleElement"},{"location":"genome/object_persistence/#implementation","text":"","title":"Implementation"},{"location":"genome/object_persistence/#a-practical-example","text":"Let's propose that we have a class which is declared like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class gCMyClass : public bCObjectRefBase { public : gCMyClass () {} virtual ~ gCMyClass () {} virtual bEResult Write ( bCOStream & ); // OnWrite for Risen virtual bEResult Read ( bCIStream & ); // OnRead for Risen private : DECLARE_PROPERTY ( myInt , int ); int someData ; }; The hypothetical class then implements these virtual functions: 1 2 3 4 5 6 7 8 9 10 11 bEResult gCMyClass::Write ( bCOStream & file ) { file << someData ; return bEResult_Ok ; } bEResult gCMyClass::Read ( bCIStream & file ) { file >> someData ; return bEResult_Ok ; } We then initialize the class in the following way: 1 2 3 gCMyClass object ; object . myInt = 1 ; object . someData = 1 ; If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII stream, the result would look like this: 1","title":"A practical example"},{"location":"genome/tools/","text":"Tools Piranha Bytes did not release a modkit for their Genome engine, but the modding community has released a wide range of tools to work with the game's files and the engine itself. Info This page is under construction, for now, only handful of links are present. Gothic 3 SDK Georgeto, inspired by NiceDE's Risen SDK, has created an SDK for Gothic 3. It can be used to manipulate the engine in the similar way Union is able to manipulate ZenGin. GitHub repository","title":"Tools"},{"location":"genome/tools/#tools","text":"Piranha Bytes did not release a modkit for their Genome engine, but the modding community has released a wide range of tools to work with the game's files and the engine itself. Info This page is under construction, for now, only handful of links are present.","title":"Tools"},{"location":"genome/tools/#gothic-3-sdk","text":"Georgeto, inspired by NiceDE's Risen SDK, has created an SDK for Gothic 3. It can be used to manipulate the engine in the similar way Union is able to manipulate ZenGin. GitHub repository","title":"Gothic 3 SDK"},{"location":"zengin/","text":"ZenGin The game engine ZenGin is used by Gothic 1 and 2. This section contains the documentation of the various aspects of ZenGin modding.","title":"ZenGin"},{"location":"zengin/#zengin","text":"The game engine ZenGin is used by Gothic 1 and 2. This section contains the documentation of the various aspects of ZenGin modding.","title":"ZenGin"},{"location":"zengin/meshes/","text":"Meshes Everything about 3D models in ZenGin.","title":"Meshes"},{"location":"zengin/meshes/#meshes","text":"Everything about 3D models in ZenGin.","title":"Meshes"},{"location":"zengin/music/","text":"Music How to get your custom music.","title":"Music"},{"location":"zengin/music/#music","text":"How to get your custom music.","title":"Music"},{"location":"zengin/sound/","text":"Sound Sound effects and dialogues are sound files playing during the game. This is Gothic VDFS. It is a tool that allows you to pack and unpack files in .VDF and .MOD format. Let us start with unpacking \"Sound\" file: In the \"(Viewer)\" tab, in the \"Filename\", go to your Gothic or Gothic II/Data folder and choose \"Sound.VDF\". Create a folder on your desktop or any other easily accessible place on your computer. Name it however you want. Go to \"Root path\" and choose the folder you just created. Press \"Extract volume\" if you want to unpack all sound files. The chosen file should be unpacking right now. Here are the files we just extracted: It can oftentimes be tricky to find the sound you are looking for, but we will leave that for later. Let's just see how can we change a sound file in the game now. Get yourself any short sound file. In order for the sound to work in the game, it needs to be in mono .wav format. A lot of programs let you convert a file such as Audacity, so do just that; Rename your converted file into \"INV_CHANGE.WAV\" and replace it in SFX folder you just extracted; Go back to Gothic VDFS, go to (Builder) tab; In \"Filename\" you choose how do you want your file to be called and its location. I recommend creating separate folder and putting it there. You can also name the file however you want, as long as it has higher time stamp (more on that later) than original Sounds file. To create it as .VDF file, choose \"All file\" in the \"Save file as\" and call it \"Sounds.VDF\"; In \"Root path\" go to and choose \"_WORK\" folder; In the field just below \"Comment\", add a * character and then click on the + next to it; Press \"Build\", and if you did everything right, the folder is being packed back into .VDF file; That's how a successful process looks like: Now get the file you just created, and put it in your Gothic/Data folder replacing the old one. The file we just replaced changes the sound in main menu and the inventory. If you can hear it, congratulations, you did it!","title":"Sound"},{"location":"zengin/sound/#sound","text":"Sound effects and dialogues are sound files playing during the game. This is Gothic VDFS. It is a tool that allows you to pack and unpack files in .VDF and .MOD format. Let us start with unpacking \"Sound\" file: In the \"(Viewer)\" tab, in the \"Filename\", go to your Gothic or Gothic II/Data folder and choose \"Sound.VDF\". Create a folder on your desktop or any other easily accessible place on your computer. Name it however you want. Go to \"Root path\" and choose the folder you just created. Press \"Extract volume\" if you want to unpack all sound files. The chosen file should be unpacking right now. Here are the files we just extracted: It can oftentimes be tricky to find the sound you are looking for, but we will leave that for later. Let's just see how can we change a sound file in the game now. Get yourself any short sound file. In order for the sound to work in the game, it needs to be in mono .wav format. A lot of programs let you convert a file such as Audacity, so do just that; Rename your converted file into \"INV_CHANGE.WAV\" and replace it in SFX folder you just extracted; Go back to Gothic VDFS, go to (Builder) tab; In \"Filename\" you choose how do you want your file to be called and its location. I recommend creating separate folder and putting it there. You can also name the file however you want, as long as it has higher time stamp (more on that later) than original Sounds file. To create it as .VDF file, choose \"All file\" in the \"Save file as\" and call it \"Sounds.VDF\"; In \"Root path\" go to and choose \"_WORK\" folder; In the field just below \"Comment\", add a * character and then click on the + next to it; Press \"Build\", and if you did everything right, the folder is being packed back into .VDF file; That's how a successful process looks like: Now get the file you just created, and put it in your Gothic/Data folder replacing the old one. The file we just replaced changes the sound in main menu and the inventory. If you can hear it, congratulations, you did it!","title":"Sound"},{"location":"zengin/textures/","text":"Textures Textures are pictures that get projected onto a 3D models and on a 2D user interface in the game. We will discuss how to work with textures in this section.","title":"Textures"},{"location":"zengin/textures/#textures","text":"Textures are pictures that get projected onto a 3D models and on a 2D user interface in the game. We will discuss how to work with textures in this section.","title":"Textures"},{"location":"zengin/video/","text":"Video To get a video cutscene, intro or outro into the game, the video needs to be in a proper format - BINK video format .bik . Editing the video The video you recorded and want to use has to be edited. My go-to editor for this is kdenlive . It works very well, it is free and open source, and it supports BINK video as an input, which is great if you want to include subtitles in the video. My version of kdenlive does not know how to export video straight to .bik so I just export my video to .mp4 and then convert it with RAD Video Tools. RAD Video Tools RAD Video Tools is a tool for converting other video formats to BINK .bik that Gothic can use. Warning Gothic 1 bink implementation has some problems as you have to set the audio compression to 104 and above in RAD tools to get video to work in Gothic 1. NicoDE's comment: Add 100 to the audio compression level when encoding videos, e.g. 104 for level 4 with old sound format (should be mentioned in the RAD Video Tools documentation) for G1 without updated Miles libraries. Note Newest Union (1.0m at the time of writing) has a new patch for BINK video playback. The issue with sound should be fixed.","title":"Video"},{"location":"zengin/video/#video","text":"To get a video cutscene, intro or outro into the game, the video needs to be in a proper format - BINK video format .bik .","title":"Video"},{"location":"zengin/video/#editing-the-video","text":"The video you recorded and want to use has to be edited. My go-to editor for this is kdenlive . It works very well, it is free and open source, and it supports BINK video as an input, which is great if you want to include subtitles in the video. My version of kdenlive does not know how to export video straight to .bik so I just export my video to .mp4 and then convert it with RAD Video Tools.","title":"Editing the video"},{"location":"zengin/video/#rad-video-tools","text":"RAD Video Tools is a tool for converting other video formats to BINK .bik that Gothic can use. Warning Gothic 1 bink implementation has some problems as you have to set the audio compression to 104 and above in RAD tools to get video to work in Gothic 1. NicoDE's comment: Add 100 to the audio compression level when encoding videos, e.g. 104 for level 4 with old sound format (should be mentioned in the RAD Video Tools documentation) for G1 without updated Miles libraries. Note Newest Union (1.0m at the time of writing) has a new patch for BINK video playback. The issue with sound should be fixed.","title":"RAD Video Tools"},{"location":"zengin/worlds/","text":"Worlds Worlds, saved as .ZEN files in ZenGin, are archives that contain the world mesh (model), BSP tree and the information of all objects in the world. Spacer is used to create these .ZEN files. There are other world editors.","title":"Worlds"},{"location":"zengin/worlds/#worlds","text":"Worlds, saved as .ZEN files in ZenGin, are archives that contain the world mesh (model), BSP tree and the information of all objects in the world. Spacer is used to create these .ZEN files. There are other world editors.","title":"Worlds"},{"location":"zengin/anims/","text":"Animation Animations in ZenGin Animations are (apart from maybe advanced programming work using Ikarus or Union) one of the most advanced modding techniques, since you not only must understand the way they work, but also know how to write the animation script and understand the whole scheme selection system, naming convention and of course know how to animate (that is my biggest problem :D). To get a new animation into ZenGin (the Gothic engine) is not difficult per se, I would describe it as tedious. Luckily, there are tools to help us to achieve our goal - get a new animation to be used by the engine, and in effect, to be used and seen in the game. To describe the whole process, I constructed this small tutorial, to help other people to get animations working and to spare them many hours of searching the excellent forum posts, that describe parts of the process. __ Excluding advanced programming work with Ikarus or Union, animations are arguably the most advanced modding discipline of ZenGin engine. Its difficulty stems for the fact that you not only have to understand the general concept, but also learn how to write the animation scripts and understand the whole scheme selection system, including naming conventions and, most important for last - actually know how to animate. Adding new animations into ZenGin is more tedious than actually difficult. There are tool to help with this endeavor - to get a new animation implemented in the engine, and seeing its effects in game. Following tutorial has been constructed to help others to get their animations working without having to scour old forum posts for hours. Prerequisites - Tools & Materials Gothic Mod Development Kit (MDK) Gothic 1 MDK - link Gothic 2 MDK - link Blender Kerrax's Import Export plugin - follow the installation instructions to install the plugin, make sure to set up the texture paths too Tool for decompiling animations GothicSourcer , or use phoenix or write your own using ZenLib The workflow This is the basic step-by-step workflow on how to get the animation into the game. Load the actor (character or object) into your 3D software Create your animation Export the animation as an .asc file Write the MDS file Run the game to compile your animations Test your animations in-game using a Daedalus script or a console command Sounds simple enough, except there is a lot missing. Even though the steps start with loading the actor into blender, understanding the system of animations to get high quality assets into your mod is more important. Animation \"types\" There are two main types of animations - skeletal and morphmesh animations. Character body animations are skeletal, and we animate the skeleton and the entire model (skin) moves around it. Morph mesh animation is, on the other hand, used for facial animations such as eating, blinking or talking and for animated meshes like wave water ferns or fish in Khorinis' harbor. This guide focuses on skeletal animations. There are few different ones, all of which will have their own demonstration in the future. Categories are: Standalone animation - waving, bowing, eating MOBSI animations - bed, alchemy table, anvil Item animations - sweeping the floor with a broomstick, using the horn, playing the lute Mandatory animations - running, walking, sneaking Combined/interpolated animations - picking stuff up, aiming with a bow/crossbow All of these animations are defined in an MDS file which will be talked about in the next sections.","title":"Animation"},{"location":"zengin/anims/#animation","text":"","title":"Animation"},{"location":"zengin/anims/#animations-in-zengin","text":"Animations are (apart from maybe advanced programming work using Ikarus or Union) one of the most advanced modding techniques, since you not only must understand the way they work, but also know how to write the animation script and understand the whole scheme selection system, naming convention and of course know how to animate (that is my biggest problem :D). To get a new animation into ZenGin (the Gothic engine) is not difficult per se, I would describe it as tedious. Luckily, there are tools to help us to achieve our goal - get a new animation to be used by the engine, and in effect, to be used and seen in the game. To describe the whole process, I constructed this small tutorial, to help other people to get animations working and to spare them many hours of searching the excellent forum posts, that describe parts of the process. __ Excluding advanced programming work with Ikarus or Union, animations are arguably the most advanced modding discipline of ZenGin engine. Its difficulty stems for the fact that you not only have to understand the general concept, but also learn how to write the animation scripts and understand the whole scheme selection system, including naming conventions and, most important for last - actually know how to animate. Adding new animations into ZenGin is more tedious than actually difficult. There are tool to help with this endeavor - to get a new animation implemented in the engine, and seeing its effects in game. Following tutorial has been constructed to help others to get their animations working without having to scour old forum posts for hours.","title":"Animations in ZenGin"},{"location":"zengin/anims/#prerequisites-tools-materials","text":"Gothic Mod Development Kit (MDK) Gothic 1 MDK - link Gothic 2 MDK - link Blender Kerrax's Import Export plugin - follow the installation instructions to install the plugin, make sure to set up the texture paths too Tool for decompiling animations GothicSourcer , or use phoenix or write your own using ZenLib","title":"Prerequisites - Tools &amp; Materials"},{"location":"zengin/anims/#the-workflow","text":"This is the basic step-by-step workflow on how to get the animation into the game. Load the actor (character or object) into your 3D software Create your animation Export the animation as an .asc file Write the MDS file Run the game to compile your animations Test your animations in-game using a Daedalus script or a console command Sounds simple enough, except there is a lot missing. Even though the steps start with loading the actor into blender, understanding the system of animations to get high quality assets into your mod is more important.","title":"The workflow"},{"location":"zengin/anims/#animation-types","text":"There are two main types of animations - skeletal and morphmesh animations. Character body animations are skeletal, and we animate the skeleton and the entire model (skin) moves around it. Morph mesh animation is, on the other hand, used for facial animations such as eating, blinking or talking and for animated meshes like wave water ferns or fish in Khorinis' harbor. This guide focuses on skeletal animations. There are few different ones, all of which will have their own demonstration in the future. Categories are: Standalone animation - waving, bowing, eating MOBSI animations - bed, alchemy table, anvil Item animations - sweeping the floor with a broomstick, using the horn, playing the lute Mandatory animations - running, walking, sneaking Combined/interpolated animations - picking stuff up, aiming with a bow/crossbow All of these animations are defined in an MDS file which will be talked about in the next sections.","title":"Animation \"types\""},{"location":"zengin/anims/events/","text":"Animation event blocks We often need to perform some other actions together with our animation, such as playing a sound effect, inserting item into NPC's hand or changing an item instance into a different one, like turning a raw steel into hot raw steel. Example: 1 2 3 4 5 ani ( \"s_RunL\" 1 \"s_RunL\" 0.0 0.1 M . \"Hum_RunLoop_M01.asc\" F 12 31 ) { * eventSFXGrnd ( 12 \"Run\" ) * eventSFXGrnd ( 21 \"Run\" ) } The example shows the animation and its event block. We place these events into a block surrounded by curly brackets. There are many events to choose from to choose from. Here are some examples: Sound effects 1 2 * eventSFXGrnd ( 12 \"Run\" ) * eventSFX ( 10 \"Swim\" ) Particle effects 1 2 3 * eventPFX ( 12 \"ZMODELLANDDUST\" \"Bip01\" ) * eventPFX ( 35 1 \"BUBBLES\" \"BIP01 HEAD\" ATTACH ) * eventPFXStop ( 45 1 ) Morph mesh animations \u26a0 Heads are animated using morph meshes and whilst this feature is almost never used in the original game, Chronicles of Myrtana uses it plenty. I intend to dedicate separate section to morphMesh animation in the future. 1 * eventMMStartAni ( 14 \"T_HURT\" ) Event tags 1 2 3 4 5 6 7 8 9 10 11 * eventTag ( 5 \"DEF_FIGHTMODE\" \"\" ) * eventTag ( 0 \"DEF_HIT_LIMB\" \"ZS_RIGHTHAND\" ) * eventTag ( 0 \"DEF_OPT_FRAME\" \"6\" ) * eventTag ( 0 \"DEF_HIT_END\" \"29\" ) * eventTag ( 0 \"DEF_WINDOW\" \"18 35\" ) * eventTa ( 4 \"DEF_INSERT_ITEM\" \"ZS_LEFTHAND\" ) * eventTa ( 4 \"DEF_CREATE_ITEM\" \"ZS_RIGHTHAND\" \"ItMw_1H_Sledgehammer_01\" ) * eventTa ( 9 \"DEF_EXCHANGE_ITEM\" \"ZS_LEFTHAND\" \"ItMiSwordbladehot\" ) * eventTa ( 4 \"DEF_REMOVE_ITEM\" )","title":"EventBlocks"},{"location":"zengin/anims/events/#animation-event-blocks","text":"We often need to perform some other actions together with our animation, such as playing a sound effect, inserting item into NPC's hand or changing an item instance into a different one, like turning a raw steel into hot raw steel. Example: 1 2 3 4 5 ani ( \"s_RunL\" 1 \"s_RunL\" 0.0 0.1 M . \"Hum_RunLoop_M01.asc\" F 12 31 ) { * eventSFXGrnd ( 12 \"Run\" ) * eventSFXGrnd ( 21 \"Run\" ) } The example shows the animation and its event block. We place these events into a block surrounded by curly brackets. There are many events to choose from to choose from. Here are some examples: Sound effects 1 2 * eventSFXGrnd ( 12 \"Run\" ) * eventSFX ( 10 \"Swim\" ) Particle effects 1 2 3 * eventPFX ( 12 \"ZMODELLANDDUST\" \"Bip01\" ) * eventPFX ( 35 1 \"BUBBLES\" \"BIP01 HEAD\" ATTACH ) * eventPFXStop ( 45 1 ) Morph mesh animations \u26a0 Heads are animated using morph meshes and whilst this feature is almost never used in the original game, Chronicles of Myrtana uses it plenty. I intend to dedicate separate section to morphMesh animation in the future. 1 * eventMMStartAni ( 14 \"T_HURT\" ) Event tags 1 2 3 4 5 6 7 8 9 10 11 * eventTag ( 5 \"DEF_FIGHTMODE\" \"\" ) * eventTag ( 0 \"DEF_HIT_LIMB\" \"ZS_RIGHTHAND\" ) * eventTag ( 0 \"DEF_OPT_FRAME\" \"6\" ) * eventTag ( 0 \"DEF_HIT_END\" \"29\" ) * eventTag ( 0 \"DEF_WINDOW\" \"18 35\" ) * eventTa ( 4 \"DEF_INSERT_ITEM\" \"ZS_LEFTHAND\" ) * eventTa ( 4 \"DEF_CREATE_ITEM\" \"ZS_RIGHTHAND\" \"ItMw_1H_Sledgehammer_01\" ) * eventTa ( 9 \"DEF_EXCHANGE_ITEM\" \"ZS_LEFTHAND\" \"ItMiSwordbladehot\" ) * eventTa ( 4 \"DEF_REMOVE_ITEM\" )","title":"Animation event blocks"},{"location":"zengin/anims/mds/","text":"MDS - model animation script Tip The MDS syntax is very simple and scripts can be edited in any text editor. It is, however, easier to work in an editor with a proper syntax highlighting. Daedalus Language Server 's dev branch already merged the MDS grammar for syntax highlighting, we can expect it in the next release. Model animation script is a file describing what skeleton should be used, what body meshes work with this set of animations and how should the animations be named, how fast they run, what animation is supposed to start after the current one is finished and much more. These files are located in Gothic\\_work\\DATA\\Anims\\ directory. Whilst the code seems long and terrifying, it is in fact rather simple, and this guide will try to explain it whole. Don't forget to use the search If you search this file for t_Yes , you will get an example of the first type of animation - \"standalone\" To play the animation in game you use this console command play ani t_yes . Syntax and keywords Let us get a quick look at the naming convention to get a basic idea what is going on before we start. The first letter indicates a type of animation (transition - t_ - or state - s_ ). Then depending on the animation type we have: Transition animation 1 t_Run_2_Sneak Transition animation from the run animation to the sneak animation. 1 t_BSANVIL_Stand_2_S0 Transition animation for the blacksmith's anvil from standing to state 0. State animation 1 s_Run State animation for the looping animation. 1 s_BSANVIL_S0 State animation for the blacksmith's anvil and its first state. ani This is the main command you will be using while defining new animations. Example: 1 ani ( \"t_Yes\" 2 \"\" 0.1 0.1 M . \"Hum_Yes_M01.asc\" F 1 44 ) Syntax: 1 ani ( ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ASC_NAME ANI_DIR START_FRAME END_FRAME ) ani - is a keyword, we are defining new animation Let's describe all the parameters ANI_NAME - animation name, we use it in Daedalus as animation identifier There is a naming convention, that is recommended and sometimes required to be used. prefix t_ - transition animations prefix s_ - state animations - they usually run in a loop prefix c_ - animations used for animation combining/interpolation LAYER - layer number for multi-layer animations NEXT_ANI - name of the next animations BLEND_IN - time in seconds describing animation blending at the start If we set it to 0.5, it takes 0.5 seconds for this animation to take full effect. At 0.0 s the previous animation has full effect on the bones of the skeleton, at 0.1 s it is influenced by 20% by this animation and at 0.5s it is completely influenced by this animation and the previous one has no effect. BLEND_OUT - time in seconds describing animation blending at the end FLAGS - flags, that describe animation behavior M - specifies a movement animation, the animation of the model translates into a changed position in the game world R - the same as M but for rotation E - this flag makes this animation run only, if the animation in the same layer are finished, this is used in the movement animations. The animation s_walk (walking loop animation) runs, when the player is walking,when he stops the transition animation to standing state is played t_walk_2_stand . This animation uses the E flag to wait for the walk cycle animation to finish, to smoothly transition into the standing state. F - the engine ignores height coordinate - doesn't keep the model \"glued\" to the ground (falling/flying animation) I - specifies idle animation - breathing, standing with a drawn weapon and moving the weapon ASC_NAME - name of the source file exported from Blender ANI_DIR - direction of the animation F - forward R - reverse START_FRAME - on what frame from the source file the animation starts END_FRAME - on what frame from the source file the animation ends aniAlias Generally considered as one of the most useful commands, aniAlias is used to create an alias (hard link for UNIX users) for an already defined animation. Example: 1 aniAlias ( \"t_Sneak_2_Run\" 1 \"s_Run\" 0.0 0.1 M . \"t_Run_2_Sneak\" R ) Syntax: 1 aniAlias ( ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ALIAS_NAME ANI_DIR ) ANI_NAME - name of the new animation LAYER - layer the animation is on NEXT_ANI - name of the next animations BLEND_IN - time in seconds describing animation blending at the start BLEND_OUT - time in seconds describing animation blending at the end FLAGS - flags, that describe animation behavior ALIAS_NAME - name of the animation we want to use as a source for the alias ANI_DIR - direction of the animation If we look for the animation in the example we can see that there is a related one just one line above 1 2 ani ( \"t_Run_2_Sneak\" 1 \"s_Sneak\" 0.1 0.0 M . \"Hum_Sneak_M01.asc\" F 0 10 ) aniAlias ( \"t_Sneak_2_Run\" 1 \"s_Run\" 0.0 0.1 M . \"t_Run_2_Sneak\" R ) In this example we are defining t_Sneak_2_Run animation and we are specifying that the animation after this one is finished will be s_Run and that it is being made by reversing animation t_Run_2_Sneak by specifying the R flag. aniBlend AniBlend is used to define animations that are a result of blending of two animations. This animation is not animated by hand, but it is dynamically generated by the engine during run-time. Example 1 aniBlend ( \"t_RunR_2_Run\" \"s_Run\" 0.2 0.2 ) Syntax: 1 aniBlend ( ANI_NAME NEXT_ANI BLEND_IN BLEND_OUT ) ANI_NAME - name of the new animation NEXT_ANI - name of the next animations BLEND_IN - time in seconds describing animation blending at the start BLEND_OUT - time in seconds describing animation blending at the end aniSync Not used in the game. aniBatch Not used in the game. Animation state machine More complex animations such as MOBSI animations form a state machine - an animation set. MDS script for the big chest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Model ( \"CHESTBIG_OCCRATELARGE\" ) { meshAndTree ( \"CHESTBIG_OCCRATELARGE.asc\" ) aniEnum { // Closed chest ani ( \"s_S0\" 1 \"s_S0\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" F 20 20 ) // Opening the chest ani ( \"t_S0_2_S1\" 1 \"s_S1\" 0.0 0.0 M . \"CHESTBIG_USE.ASC\" F 50 79 ) { * eventSFX ( 50 \"chest_try\" ) * eventSFX ( 55 \"chest_open\" ) } // Opened chest ani ( \"s_S1\" 1 \"s_S1\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" F 80 80 ) // Closing the chest ani ( \"t_S1_2_S0\" 1 \"s_S0\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" R 50 79 ) { * eventSFX ( 78 \"chest_close\" ) } // Pick lock broken ani ( \"t_S0_Try\" 1 \"s_S0\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" F 96 124 ) { * eventSFX ( 100 \"chest_try\" ) * eventSFX ( 115 \"Hammer\" ) } } } stateDiagram-v2 s_S0 : Closed chest t_S0_2_S1 : Opening the chest s_S1 : Opened chest t_S1_2_S0 : Closing the chest t_S0_Try : Pick lock broken [*] --> s_S0 s_S0 --> s_S0 s_S0 --> t_S0_2_S1 t_S0_2_S1 --> s_S1 s_S1 --> s_S1 s_S1 --> t_S1_2_S0 t_S1_2_S0 --> s_S0 s_S0 --> t_S0_Try t_S0_Try --> s_S0","title":"MDS - ModelScript"},{"location":"zengin/anims/mds/#mds-model-animation-script","text":"Tip The MDS syntax is very simple and scripts can be edited in any text editor. It is, however, easier to work in an editor with a proper syntax highlighting. Daedalus Language Server 's dev branch already merged the MDS grammar for syntax highlighting, we can expect it in the next release. Model animation script is a file describing what skeleton should be used, what body meshes work with this set of animations and how should the animations be named, how fast they run, what animation is supposed to start after the current one is finished and much more. These files are located in Gothic\\_work\\DATA\\Anims\\ directory. Whilst the code seems long and terrifying, it is in fact rather simple, and this guide will try to explain it whole. Don't forget to use the search If you search this file for t_Yes , you will get an example of the first type of animation - \"standalone\" To play the animation in game you use this console command play ani t_yes .","title":"MDS - model animation script"},{"location":"zengin/anims/mds/#syntax-and-keywords","text":"Let us get a quick look at the naming convention to get a basic idea what is going on before we start. The first letter indicates a type of animation (transition - t_ - or state - s_ ). Then depending on the animation type we have: Transition animation 1 t_Run_2_Sneak Transition animation from the run animation to the sneak animation. 1 t_BSANVIL_Stand_2_S0 Transition animation for the blacksmith's anvil from standing to state 0. State animation 1 s_Run State animation for the looping animation. 1 s_BSANVIL_S0 State animation for the blacksmith's anvil and its first state.","title":"Syntax and keywords"},{"location":"zengin/anims/mds/#ani","text":"This is the main command you will be using while defining new animations. Example: 1 ani ( \"t_Yes\" 2 \"\" 0.1 0.1 M . \"Hum_Yes_M01.asc\" F 1 44 ) Syntax: 1 ani ( ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ASC_NAME ANI_DIR START_FRAME END_FRAME ) ani - is a keyword, we are defining new animation Let's describe all the parameters ANI_NAME - animation name, we use it in Daedalus as animation identifier There is a naming convention, that is recommended and sometimes required to be used. prefix t_ - transition animations prefix s_ - state animations - they usually run in a loop prefix c_ - animations used for animation combining/interpolation LAYER - layer number for multi-layer animations NEXT_ANI - name of the next animations BLEND_IN - time in seconds describing animation blending at the start If we set it to 0.5, it takes 0.5 seconds for this animation to take full effect. At 0.0 s the previous animation has full effect on the bones of the skeleton, at 0.1 s it is influenced by 20% by this animation and at 0.5s it is completely influenced by this animation and the previous one has no effect. BLEND_OUT - time in seconds describing animation blending at the end FLAGS - flags, that describe animation behavior M - specifies a movement animation, the animation of the model translates into a changed position in the game world R - the same as M but for rotation E - this flag makes this animation run only, if the animation in the same layer are finished, this is used in the movement animations. The animation s_walk (walking loop animation) runs, when the player is walking,when he stops the transition animation to standing state is played t_walk_2_stand . This animation uses the E flag to wait for the walk cycle animation to finish, to smoothly transition into the standing state. F - the engine ignores height coordinate - doesn't keep the model \"glued\" to the ground (falling/flying animation) I - specifies idle animation - breathing, standing with a drawn weapon and moving the weapon ASC_NAME - name of the source file exported from Blender ANI_DIR - direction of the animation F - forward R - reverse START_FRAME - on what frame from the source file the animation starts END_FRAME - on what frame from the source file the animation ends","title":"ani"},{"location":"zengin/anims/mds/#anialias","text":"Generally considered as one of the most useful commands, aniAlias is used to create an alias (hard link for UNIX users) for an already defined animation. Example: 1 aniAlias ( \"t_Sneak_2_Run\" 1 \"s_Run\" 0.0 0.1 M . \"t_Run_2_Sneak\" R ) Syntax: 1 aniAlias ( ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ALIAS_NAME ANI_DIR ) ANI_NAME - name of the new animation LAYER - layer the animation is on NEXT_ANI - name of the next animations BLEND_IN - time in seconds describing animation blending at the start BLEND_OUT - time in seconds describing animation blending at the end FLAGS - flags, that describe animation behavior ALIAS_NAME - name of the animation we want to use as a source for the alias ANI_DIR - direction of the animation If we look for the animation in the example we can see that there is a related one just one line above 1 2 ani ( \"t_Run_2_Sneak\" 1 \"s_Sneak\" 0.1 0.0 M . \"Hum_Sneak_M01.asc\" F 0 10 ) aniAlias ( \"t_Sneak_2_Run\" 1 \"s_Run\" 0.0 0.1 M . \"t_Run_2_Sneak\" R ) In this example we are defining t_Sneak_2_Run animation and we are specifying that the animation after this one is finished will be s_Run and that it is being made by reversing animation t_Run_2_Sneak by specifying the R flag.","title":"aniAlias"},{"location":"zengin/anims/mds/#aniblend","text":"AniBlend is used to define animations that are a result of blending of two animations. This animation is not animated by hand, but it is dynamically generated by the engine during run-time. Example 1 aniBlend ( \"t_RunR_2_Run\" \"s_Run\" 0.2 0.2 ) Syntax: 1 aniBlend ( ANI_NAME NEXT_ANI BLEND_IN BLEND_OUT ) ANI_NAME - name of the new animation NEXT_ANI - name of the next animations BLEND_IN - time in seconds describing animation blending at the start BLEND_OUT - time in seconds describing animation blending at the end","title":"aniBlend"},{"location":"zengin/anims/mds/#anisync","text":"Not used in the game.","title":"aniSync"},{"location":"zengin/anims/mds/#anibatch","text":"Not used in the game.","title":"aniBatch"},{"location":"zengin/anims/mds/#animation-state-machine","text":"More complex animations such as MOBSI animations form a state machine - an animation set. MDS script for the big chest 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Model ( \"CHESTBIG_OCCRATELARGE\" ) { meshAndTree ( \"CHESTBIG_OCCRATELARGE.asc\" ) aniEnum { // Closed chest ani ( \"s_S0\" 1 \"s_S0\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" F 20 20 ) // Opening the chest ani ( \"t_S0_2_S1\" 1 \"s_S1\" 0.0 0.0 M . \"CHESTBIG_USE.ASC\" F 50 79 ) { * eventSFX ( 50 \"chest_try\" ) * eventSFX ( 55 \"chest_open\" ) } // Opened chest ani ( \"s_S1\" 1 \"s_S1\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" F 80 80 ) // Closing the chest ani ( \"t_S1_2_S0\" 1 \"s_S0\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" R 50 79 ) { * eventSFX ( 78 \"chest_close\" ) } // Pick lock broken ani ( \"t_S0_Try\" 1 \"s_S0\" 0.0 0.0 M . \"CHESTBIG_USE.asc\" F 96 124 ) { * eventSFX ( 100 \"chest_try\" ) * eventSFX ( 115 \"Hammer\" ) } } } stateDiagram-v2 s_S0 : Closed chest t_S0_2_S1 : Opening the chest s_S1 : Opened chest t_S1_2_S0 : Closing the chest t_S0_Try : Pick lock broken [*] --> s_S0 s_S0 --> s_S0 s_S0 --> t_S0_2_S1 t_S0_2_S1 --> s_S1 s_S1 --> s_S1 s_S1 --> t_S1_2_S0 t_S1_2_S0 --> s_S0 s_S0 --> t_S0_Try t_S0_Try --> s_S0","title":"Animation state machine"},{"location":"zengin/anims/standalone_ani/","text":"Acknowledgment This tutorial would not be possible without the ZenGin documentation available in the mod-kit. Further credits also go to Mark56 who helped me understand animations in the first place, Fawkes and his request for me to do some animations for his excellent mod - Replay Mod, and last but not least Flosha from the Phoenix team who was the one for whom I offered to write this tutorial to help with the development of the Phoenix project . Standalone animation Let us start with the easiest animation - a very simple gesturing animation. Info You can find some of the videos that are mentioned in the text below in this play-list . Firstly we have to have the animation source files ready. Best way to decompile them is using Gothic Sourcer . In GothicSourcer you choose Tools > Decompiler models > Dynamic (MDS or MSB) and choose an MDS file of your choice - Humans.mds in our case and then click the decompile button. Animating Open Blender, File > Import > Kerrax ASCII model (.asc) , navigate to the folder with your decompiled animation files and select HUM_BODY_NAKED0.ASC . This file contains the skeleton and skin model for human NPCs. What bone hierarchy is this model using? If you open the .mds file, you can see a command meshAndTree that specifies what model contains the skeleton. And there lies our answer: 1 2 3 Model ( \"HuS\" ) { meshAndTree ( \"Hum_Body_Naked0.ASC\" DONT_USE_MESH ) A windows pops up and you can read some interesting information about the model you are about to import. We are interested in the fact that Completely replace current scene is ticked, we want to use Armature modifier , and we also want to Try to connect bones and Use sample meshes from folder . You should provide a path to a directory with the sample meshes - these are meshes for items, that usually go into slot bones. Lastly, the space transformation scale should be set to 0.01 . This is because ZenGin works with centimeter units and one unit in Blender is a meter. Click import and wait for the magic to happen. This video shows a freshly imported model with all default meshes. Note If we now want to play (or edit) existing animation, we can now load it on top of this. Just as before File > Import > Kerrax ASCII model (.asc) and select different animation file (or armor file), for example Hum_SmokeHerb_Layer_M01.asc for an animation file. Gothic characters are modular and you can change their heads on the fly, even during gameplay as seen in this amazing video from my dear friend and colleague Fawkes - Head changing . Let's add a head so that we can see how the whole body will behave while we are animating. File > Import > Kerrax ASCII model (.asc) , navigate to your head model. You will have to decompile it like we did with the body itself. We will import HUM_HEAD_PONY.ASC . Please make sure to select the target bone for importing Bip01 Head , this will attach the head to the proper bone, just like the engine does it. Now we have everything ready to start animating. The video shows the DopeSheet a nice way to edit keyframes. DopeSheet Blender's dope sheet can be used to copy entire sets of keyframes. It is useful if we want to create a looping animation. We can import an animation into Blender as a base. Tip If you don't know the name of the animation, just go into the game and make your character perform the animation you want. While in MARVIN mode, you can press G and the animation information together with other info will be displayed right on the screen In this video we can see that the idle standing animation is s_run . We want to make an animation that is going to start from this idle animation, so we will import it into blender. We find it by looking into the .mds file, look for s_run name and get the name of the file. 1 ani ( \"s_Run\" 1 \"s_Run\" 0.1 0.1 MI \"Hum_RunAmbient_M01.asc\" F 1 50 ) As we can see, we have to import the Hum_RunAmbient_M01.asc file. Next goes the first trick. Since we want our animation to end exactly, as it started - ether because we want the hero to continue his standing animation, or we want to make a looping animation, we somehow have to copy the pose. We use the DopeSheet screen, to delete all keyframes and then copy the keyframe set from keyframe number 0 and drag it somewhere to the end of the timeline. Once the animation is done, we have to export it into an asc format again, File > Export > Kerrax ASCII model (.asc) and then save it to _work\\data\\Anims\\asc\\ so the engine can see it and convert it. There are many options here that we will explore later, but we have tick Export animation and pick bones that we want to export - this is useful for animations that are played on different layers (dialogue gestures, scratching head, scratching a shoulder,...). Animation script Now that we have exported the animation, we now have to define it in Humans.mds . Open the file, scroll to the end and define a new animation. Attention All ani code has to be between the curly brackets, this means you have to insert it before the last two closing curly brackets } } . Example: 1 ani ( \"t_backpain\" 1 \"\" 0.0 0.0 M . \"Hum_back.ASC\" F 0 121 ) Save the Humans.mds file and try it in game. Nothing happens! The reason is that the mds has been already compiled, and we have to recompile it. The easiest is to go to Anims\\_compiled and delete HUMANS.MSB . Run the game and try to play the animation again ( play ani t_backpain in MARVIN console) and now everything should work. Amazing, now you have your first animation in the game. And you can use it to do some fun stuff, like in dialogues using the AI_PlayAni function. Example dialogue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 instance DIA_Xardas_Back ( C_INFO ) { npc = NONE_100_Xardas ; nr = 11 ; condition = DIA_Xardas_Back_Condition ; information = DIA_Xardas_Back_Info ; permanent = TRUE ; description = \"What's wrong?\" ; }; func int DIA_Xardas_Back_Condition () { return TRUE ; }; func void DIA_Xardas_Back_Info () { AI_Output ( self , hero , \"DIA_Xardas_MOB_14_00\" ); // My back hurts so much. // This is our animation!!!!! AI_PlayAni ( self , \"T_BACKPAIN\" ); AI_Output ( self , hero , \"DIA_Xardas_MOB_14_01\" ); // How do YOU feel? AI_Output ( hero , self , \"DIA_Xardas_MOB_14_02\" ); // My back is fine. AI_StopProcessInfos ( self ); };","title":"Standalone animation"},{"location":"zengin/anims/standalone_ani/#standalone-animation","text":"Let us start with the easiest animation - a very simple gesturing animation. Info You can find some of the videos that are mentioned in the text below in this play-list . Firstly we have to have the animation source files ready. Best way to decompile them is using Gothic Sourcer . In GothicSourcer you choose Tools > Decompiler models > Dynamic (MDS or MSB) and choose an MDS file of your choice - Humans.mds in our case and then click the decompile button.","title":"Standalone animation"},{"location":"zengin/anims/standalone_ani/#animating","text":"Open Blender, File > Import > Kerrax ASCII model (.asc) , navigate to the folder with your decompiled animation files and select HUM_BODY_NAKED0.ASC . This file contains the skeleton and skin model for human NPCs. What bone hierarchy is this model using? If you open the .mds file, you can see a command meshAndTree that specifies what model contains the skeleton. And there lies our answer: 1 2 3 Model ( \"HuS\" ) { meshAndTree ( \"Hum_Body_Naked0.ASC\" DONT_USE_MESH ) A windows pops up and you can read some interesting information about the model you are about to import. We are interested in the fact that Completely replace current scene is ticked, we want to use Armature modifier , and we also want to Try to connect bones and Use sample meshes from folder . You should provide a path to a directory with the sample meshes - these are meshes for items, that usually go into slot bones. Lastly, the space transformation scale should be set to 0.01 . This is because ZenGin works with centimeter units and one unit in Blender is a meter. Click import and wait for the magic to happen. This video shows a freshly imported model with all default meshes. Note If we now want to play (or edit) existing animation, we can now load it on top of this. Just as before File > Import > Kerrax ASCII model (.asc) and select different animation file (or armor file), for example Hum_SmokeHerb_Layer_M01.asc for an animation file. Gothic characters are modular and you can change their heads on the fly, even during gameplay as seen in this amazing video from my dear friend and colleague Fawkes - Head changing . Let's add a head so that we can see how the whole body will behave while we are animating. File > Import > Kerrax ASCII model (.asc) , navigate to your head model. You will have to decompile it like we did with the body itself. We will import HUM_HEAD_PONY.ASC . Please make sure to select the target bone for importing Bip01 Head , this will attach the head to the proper bone, just like the engine does it. Now we have everything ready to start animating. The video shows the DopeSheet a nice way to edit keyframes. DopeSheet Blender's dope sheet can be used to copy entire sets of keyframes. It is useful if we want to create a looping animation. We can import an animation into Blender as a base. Tip If you don't know the name of the animation, just go into the game and make your character perform the animation you want. While in MARVIN mode, you can press G and the animation information together with other info will be displayed right on the screen In this video we can see that the idle standing animation is s_run . We want to make an animation that is going to start from this idle animation, so we will import it into blender. We find it by looking into the .mds file, look for s_run name and get the name of the file. 1 ani ( \"s_Run\" 1 \"s_Run\" 0.1 0.1 MI \"Hum_RunAmbient_M01.asc\" F 1 50 ) As we can see, we have to import the Hum_RunAmbient_M01.asc file. Next goes the first trick. Since we want our animation to end exactly, as it started - ether because we want the hero to continue his standing animation, or we want to make a looping animation, we somehow have to copy the pose. We use the DopeSheet screen, to delete all keyframes and then copy the keyframe set from keyframe number 0 and drag it somewhere to the end of the timeline. Once the animation is done, we have to export it into an asc format again, File > Export > Kerrax ASCII model (.asc) and then save it to _work\\data\\Anims\\asc\\ so the engine can see it and convert it. There are many options here that we will explore later, but we have tick Export animation and pick bones that we want to export - this is useful for animations that are played on different layers (dialogue gestures, scratching head, scratching a shoulder,...).","title":"Animating"},{"location":"zengin/anims/standalone_ani/#animation-script","text":"Now that we have exported the animation, we now have to define it in Humans.mds . Open the file, scroll to the end and define a new animation. Attention All ani code has to be between the curly brackets, this means you have to insert it before the last two closing curly brackets } } . Example: 1 ani ( \"t_backpain\" 1 \"\" 0.0 0.0 M . \"Hum_back.ASC\" F 0 121 ) Save the Humans.mds file and try it in game. Nothing happens! The reason is that the mds has been already compiled, and we have to recompile it. The easiest is to go to Anims\\_compiled and delete HUMANS.MSB . Run the game and try to play the animation again ( play ani t_backpain in MARVIN console) and now everything should work. Amazing, now you have your first animation in the game. And you can use it to do some fun stuff, like in dialogues using the AI_PlayAni function.","title":"Animation script"},{"location":"zengin/anims/standalone_ani/#example-dialogue","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 instance DIA_Xardas_Back ( C_INFO ) { npc = NONE_100_Xardas ; nr = 11 ; condition = DIA_Xardas_Back_Condition ; information = DIA_Xardas_Back_Info ; permanent = TRUE ; description = \"What's wrong?\" ; }; func int DIA_Xardas_Back_Condition () { return TRUE ; }; func void DIA_Xardas_Back_Info () { AI_Output ( self , hero , \"DIA_Xardas_MOB_14_00\" ); // My back hurts so much. // This is our animation!!!!! AI_PlayAni ( self , \"T_BACKPAIN\" ); AI_Output ( self , hero , \"DIA_Xardas_MOB_14_01\" ); // How do YOU feel? AI_Output ( hero , self , \"DIA_Xardas_MOB_14_02\" ); // My back is fine. AI_StopProcessInfos ( self ); };","title":"Example dialogue"},{"location":"zengin/general_info/directory_structure/","text":"ZenGin directory structure Modding is all about changing the game files. To achieve that, we have to know the directory (folder) structure of a Gothic game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 $Templates$ \u2502 \u251c\u2500\u2500 modvdf \u2502 \u2514\u2500\u2500 plugins \u251c\u2500\u2500 Miles \u251c\u2500\u2500 Saves \u251c\u2500\u2500 System \u2502 \u2514\u2500\u2500 Autorun \u2514\u2500\u2500 _work \u2514\u2500\u2500 DATA \u251c\u2500\u2500 Anims \u2502 \u2514\u2500\u2500 _Compiled \u251c\u2500\u2500 Meshes \u2502 \u2514\u2500\u2500 _Compiled \u251c\u2500\u2500 Music \u251c\u2500\u2500 Presets \u251c\u2500\u2500 Scripts \u2502 \u251c\u2500\u2500 _compiled \u2502 \u2514\u2500\u2500 content \u2502 \u2514\u2500\u2500 CUTSCENE \u251c\u2500\u2500 Sound \u251c\u2500\u2500 Textures \u251c\u2500\u2500 Video \u2514\u2500\u2500 Worlds Data Data directory contains .vdf volumes of the game. These contain anims.vdf - animations, speech.vdf - dubbing, worlds.vdf - world ZEN files. Saves Contains saved games. System The system directory contains the game executable, GothicStarter.exe , GothicStarter_mod.exe , configuration .ini files, mod .ini files and mod icons and description .rtf files. system/Autorun is a Union specific directory, it serves as a default search directory for Daedalus injection scripts with zParserExtender and Union plugins. _work/DATA This is where the magic happens: Anims - contains animations and animated models. _compiled - contains compiled animations. Meshes - contains meshes source and compiled files. _compiled - contains compiled meshes. Music - contains music files. Presets - contains basic presets. Scripts _compiled - contains compiled scripts - .dat files. Content - contains scripts that make up the content of the game. System - contains scripts that make up the menu. Sound - contains sound effects .wav or .ogg format (Union only). Video - contains videos in .bik format.","title":"Directory structure"},{"location":"zengin/general_info/directory_structure/#zengin-directory-structure","text":"Modding is all about changing the game files. To achieve that, we have to know the directory (folder) structure of a Gothic game. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u251c\u2500\u2500 Data \u2502 \u251c\u2500\u2500 $Templates$ \u2502 \u251c\u2500\u2500 modvdf \u2502 \u2514\u2500\u2500 plugins \u251c\u2500\u2500 Miles \u251c\u2500\u2500 Saves \u251c\u2500\u2500 System \u2502 \u2514\u2500\u2500 Autorun \u2514\u2500\u2500 _work \u2514\u2500\u2500 DATA \u251c\u2500\u2500 Anims \u2502 \u2514\u2500\u2500 _Compiled \u251c\u2500\u2500 Meshes \u2502 \u2514\u2500\u2500 _Compiled \u251c\u2500\u2500 Music \u251c\u2500\u2500 Presets \u251c\u2500\u2500 Scripts \u2502 \u251c\u2500\u2500 _compiled \u2502 \u2514\u2500\u2500 content \u2502 \u2514\u2500\u2500 CUTSCENE \u251c\u2500\u2500 Sound \u251c\u2500\u2500 Textures \u251c\u2500\u2500 Video \u2514\u2500\u2500 Worlds","title":"ZenGin directory structure"},{"location":"zengin/general_info/directory_structure/#data","text":"Data directory contains .vdf volumes of the game. These contain anims.vdf - animations, speech.vdf - dubbing, worlds.vdf - world ZEN files.","title":"Data"},{"location":"zengin/general_info/directory_structure/#saves","text":"Contains saved games.","title":"Saves"},{"location":"zengin/general_info/directory_structure/#system","text":"The system directory contains the game executable, GothicStarter.exe , GothicStarter_mod.exe , configuration .ini files, mod .ini files and mod icons and description .rtf files. system/Autorun is a Union specific directory, it serves as a default search directory for Daedalus injection scripts with zParserExtender and Union plugins.","title":"System"},{"location":"zengin/general_info/directory_structure/#_workdata","text":"This is where the magic happens: Anims - contains animations and animated models. _compiled - contains compiled animations. Meshes - contains meshes source and compiled files. _compiled - contains compiled meshes. Music - contains music files. Presets - contains basic presets. Scripts _compiled - contains compiled scripts - .dat files. Content - contains scripts that make up the content of the game. System - contains scripts that make up the menu. Sound - contains sound effects .wav or .ogg format (Union only). Video - contains videos in .bik format.","title":"_work/DATA"},{"location":"zengin/general_info/object_persistence/","text":"Object persistence In order to simplify the process of loading and saving data of various types to and from the user's hard-drive, ZenGin implements a simple object persistence system using the zCArchiver class and its derivatives that allow the individual engine classes to implement a routine specifying which data should be saved or loaded from disk and in which manner. An object that is derived from the zCObject class may overload the Archive and Unarchive virtual methods. The class may then call on an interface provided by the zCArchiver class within these methods which allows it to directly read from or write to a stream using several modes. Those are ASCII and BinSafe by default. There are, however, more options, as is explained below. Archive format In order to better understand how this process works, it would be best to look at an example of a .ZEN file containing an instance of an oCWorld object. Header When you open up a ZenGin archive, you will see the following at the start of the file: 1 2 3 4 5 6 7 8 9 10 ZenGin Archive ver 1 zCArchiverGeneric ASCII saveGame 0 date 7.1.2001 23:9:19 user roeske END objects 2594 END Let's look at each of these properties and what they mean: ZenGin Archive This simply specifies that the following data is an zCArchiver archive. ver 1 Version specification. Can be either 0 or 1 . Both Gothic 1 and 2 are already on version 1, although version 0 archives can also be occasionally found. zCArchiverGeneric Specifies which derived zCArchiver class should be used to read this archive. Accepted values are zCArchiverGeneric for ASCII and Binary archives, and zCArchiverBinSafe for BinSafe archives. More info below. This property might not be present in older archives. ASCII This is the most important part of the header as it specifies in which format should the data be stored. There are 4 different modes: ASCII - The simplest one. It stores data in human-readable ASCII notation (not unlike JSON for example). This is usually used when saving data during development and/or testing, while the final version of said data will most likely be stored as BIN_SAFE. ASCII_PROPS - Same as ASCII except with more additional data that the developer can specify for visual clarity. In practice, it is not used anywhere and mostly serves only to prettify debug info (try typing ZWORLD VOBPROPS in the console and look in zSpy ;) ). BINARY - Binary representation of the class instance, which mostly copies the data 1:1 into/from the stream. In practice, this format is only used to store savefiles (.SAV). BIN_SAFE - BinSafe, short for Binary Safe, is an extended version of Binary which stores type information along with the data itself. This is meant to make error checking for invalid data easier. There are other changes which are explained below. Most, if not all world files (.ZEN), are stored in this format. saveGame 0 Specifies if this archive is a savefile. This property might not be present in older archives. date 7.1.2001 23:9:19 The date at which this archive was created. user roeske The user which created the archive. This property might not be present in older archives. END Tells the parses that this is the end of the header. We may additionally find a property called csum in version 0 archives which stores the checksum of the whole archive. This property is, however, unused and equals 00000000 by default. In order to correctly read the archive's header across varying engine versions, one should not count on the properties always being in the same order or even being there at all. If the archive utilizes zCArchiverGeneric then this header will also be followed by a short section specifying the number of object instances in this archive. This value will be used to initialize the objectList, which is an array of pointers where the addresses of loaded objects will be stored for later referencing. This property would be directly part of the main header in older versions. 1 objects 2594 END If the archive is created using zCArchiverBinSafe , this data will be stored in the following binary structure: 1 2 3 4 struct BinSafeArchiveHeader { uint32_t version ; // Always equals 2 uint32_t objectCount; // Serves the same function as \"objects n\" uint32_t chunkPos; // Offset to chunk hash table}; }; Contents Looking further into the archive, we see what appears to be a nested structure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [% oCWorld:zCWorld 64513 0] [VobTree % 0 0] childs0=int:1 [% zCVobLevelCompo:zCVob 12289 1] pack=int:0 presetName=string: bbox3DWS=rawFloat:-71919.9609 -13091.8232 -59900 108999.992 20014.0352 67399.9922 trafoOSToWSRot=raw:0000803f0000000000000000000000000000803f0000000000000000000000000000803f trafoOSToWSPos=vec3:0 0 0 vobName=string:LEVEL-VOB visual=string:SURFACE.3DS showVisual=bool:0 visualCamAlign=enum:0 cdStatic=bool:1 cdDyn=bool:0 staticVob=bool:0 dynShadow=enum:0 [visual zCMesh 0 2] [] [ai % 0 0] [] [] ... We primarily differentiate between chunks and properties within ZenGin archives: Chunks A chunk is a structure that groups properties together. For most of the time, a chunk represents a class instance. This is, however, not always true as classes may arbitrarily create chunks as is needed. For example, the sample above contains a chunk called VobTree , which does not represent a class instance, but only serves to make the reading of the archive easier. While in ASCII mode, the start of a chunk is represented using square brackets. [% oCWorld:zCWorld 64513 0] There are 4 pieces of data separated by spaces inside the start of each chunk, which are: Object name - The name of the chunk to use while reading. If the chunk has no name, then it will be simply equal to % . Class name - The name of the class which this chunk represents. Class names are stored with their full inheritance hierarchy (e.g. oCMobLadder:oCMobInter:oCMOB:zCVob ). In case the chunk is not an object, but an arbitrary chunk, then this field will be equal to % ( % can also mean that this chunk is a nullptr). In some cases you may encounter the symbol \u00a7 instead. This means that the object already exists and that the parser should look for it in the objectList using the object index. Using this mechanism, a single instance can be referenced multiple times without worrying about duplicity. Class version - Used to ensure that the data being read is compatible with the current game/engine version, so that there are no mismatches in the data pattern. This value is different for every class and varies between game versions. Object index - An index into the objectList under which this object will be stored. If the class name is equal to \u00a7 , then this value will be used to retrieve an existing instance from the objectList. If this is a Binary archive, the same data will be stored in the following binary structure: 1 2 3 4 5 6 7 8 struct BinaryObjectHeader { uint32_t objectSize ; // Size of the whole object in bytes uint16_t classVersion ; uint32_t objectIndex ; char objectName []; // Null-terminated string char className []; // Null-terminated string }; Oddly enough, if the archive is BinSafe, then the data will be encoded the same way as in ASCII mode, except that it will be stored as a type-checked property. 1 2 3 4 5 6 struct BinSafeObjectHeader { uint32_t type ; // 0x1 = TYPE_STRING uint16_t length ; // Length of the text char text []; // [% oCWorld:zCWorld 64513 0] }; In ASCII mode [] represents the end of the current chunk. Properties We find properties inside the chunks which are key-value pairs that classes use to store the actual data. Each property stores its name, type and value. In ASCII mode the format for this is name=type:value . For example: visual=string:SURFACE.3DS By default, zCArchiver allows to store properties of the following types: Int - A regular 32-bit integer. In ASCII mode, int gets stored as name=int:1 , while in Binary mode, it's just the raw value stored as 4 bytes. Byte - A 8-bit integer. ASCII mode doesn't differentiate between Int and Byte, so this will be stored as name=int:1 regardless. Binary mode stores only the single byte. Word - A 16-bit integer. ASCII mode doesn't differentiate between Int and Word, so this will be stored as name=int:1 regardless. Binary mode stores only the 2 bytes. Float - A standard IEEE 754 32-bit floating point number. In ASCII mode the format is name=float:1.0 , while in Binary mode the float gets stored raw as 4 bytes. Bool - Stores a single-byte boolean value. In ASCII mode its name=bool:1 and in Binary mode it's a single byte. String - An ASCII encoded string. While in ASCII mode, strings are stored as name=string:value . In Binary mode, strings are NULL terminated. Vec3 - A three component vector, mainly used to store positional data. The ASCII mode format is name=vec3:1.0 1.0 1.0 . In Binary mode the three components of the vector are stored in series, which equals to a total size of 12 bytes. Color - A 32-bit color value stored as BGRA. In ASCII mode the color is stored as name=color:255 255 255 255 while in Binary mode it's just 4 raw bytes. Raw - Raw binary data. In order to maintain readability, in ASCII mode this gets stored as a hex encoded string such as name=raw:63D15B07 . In Binary mode, only the data itself is stored, without any other info. Be aware that due to this you must know the size of the data beforehand. RawFloat - An array of floats, mainly used to store bounding boxes. In ASCII mode, the floats are stored as name=rawFloat:1.0 1.0 1.0 1.0 1.0 1.0 . In Binary mode the floats are stored in series as raw bytes. Same as with Raw , you must know the size of the array beforehand. Enum - An enum value. In ASCII mode, it gets stored as name=enum:1 . In Binary mode, it behaves the same as Int . As you might have noticed, binary mode doesn't perform any kind of checks on if it's reading the right property or even data of the correct type. This is why BinSafe mode exists, as it stores the property type in along with the data itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 enum TYPE { TYPE_STRING = 0x1 , TYPE_INTEGER = 0x2 , TYPE_FLOAT = 0x3 , TYPE_BYTE = 0x4 , TYPE_WORD = 0x5 , TYPE_BOOL = 0x6 , TYPE_VEC3 = 0x7 , TYPE_COLOR = 0x8 , TYPE_RAW = 0x9 , TYPE_RAWFLOAT = 0x10 , TYPE_ENUM = 0x11 TYPE_HASH = 0x12 , }; struct BinSafeProperty { TYPE type ; union { struct { uint16_t stringLength ; char stringValue []; } uint32_t integerOrHashOrEnumValue ; float floatValue ; uint8_t byteOrBoolValue ; zVEC3 vec3Value ; zCOLOR colorValue ; struct { uint16_t rawLength ; char rawValue []; } struct { uint16_t rawFloatLength ; float rawFloatValue []; } }; }; Looking at the enumeration of types, you might notice that BinSafe mode has an additional property type called Hash. BinSafe archives include a hash table which is stored in the following manner: 1 2 3 4 5 6 7 8 9 10 11 struct BinSafeHashTable { uint32_t chunkCount ; for ( chunkCount ) { uint16_t stringLength ; uint16_t linearValue ; uint32_t hashValue ; char text [ stringLength ]; } }; Instead of storing the raw value, properties may save a hash instead, which is then used to look up the corresponding value from the hash table. Implementation As mentioned in the opening paragraph, classes may use the described functionality by overloading the Archive and Unarchive virtual methods, which pass an instance of zCArchiver by reference. When the class instance is then serialized and/or parsed, these methods are called and perform the desired serialization/parsing work. The class uses methods provided by the zCArchiver instance within these routines. These methods return/accept a value of a specific type (e.g. ReadInt/WriteInt), while they do the actual reading/writing work behind the scenes based on the current mode (ASCII/Binary/BinSafe). The programmer writing the class then does not care whether the final archive will be saved as ASCII, Binary or BinSafe, as they only use the zCArchiver Read* and Write* methods. A practical example Let's propose that we have a class which is declared like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class zCMyClass : public zCObject { public : zCMyClass () {} virtual ~ zCMyClass () {} virtual void Archive ( zCArchiver & ); virtual void Unarchive ( zCArchiver & ); int myInt ; zCMyClass * myObject ; zCMyClass * secondPointerToMyObject ; }; The hypothetical class then implements these virtual functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void zCMyClass::Archive ( zCArchiver & archiver ) { archiver . WriteInt ( \"myInt\" , myInt ); archiver . WriteObject ( \"myObject\" , myObject ); archiver . WriteChunkStart ( \"myChunk\" , 0 ); archiver . WriteObject ( \"secondPointerToMyObject\" , secondPointerToMyObject ); archiver . WriteChunkEnd (); } void zCMyClass::Unarchive ( zCArchiver & archiver ) { archiver . ReadInt ( \"myInt\" , myInt ); myObject = dynamic_cast < zCMyClass *> ( archiver . ReadObject ( \"myObject\" )); archiver . ReadChunkStart ( \"myChunk\" ); secondPointerToMyObject = dynamic_cast < zCMyClass *> ( archiver . ReadObject ( \"secondPointerToMyObject\" )); archiver . ReadChunkEnd (); } We then initialize the class in the following way: 1 2 3 4 5 6 7 8 zCMyClass object ; object . myInt = 12121212 ; object . myObject = new zCMyClass (); object . myObject -> myInt = 34343434 ; object . secondPointerToMyObject = object . myObject ; If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII archive, the result would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ZenGin Archive ver 1 zCArchiverGeneric ASCII saveGame 0 date 3.7.2022 0:0:0 user GMC END objects 2 END [% zCMyClass 0 0] myInt=int:12121212 [myObject zCMyClass 0 1] myInt=int:34343434 [myObject % 0 0] [] [myChunk % 0 0] [secondPointerToMyObject % 0 0] [] [] [] [myChunk % 0 0] [secondPointerToMyObject \u00a7 0 1] [] [] [] Notice how secondPointerToMyObject doesn't have any contents. The character \u00a7 tells the parser that this object already exists in the objectList, and that instead of creating a new instance, it should return an existing instance which is stored under index 1 in the objectList. This allows an instance to be referenced from multiple places, without the need to worry about duplicity. If we used Binary or BinSafe mode, we would see a big blob of binary data instead. This would, of course, store the exact same data, although in a slightly less human-readable format. Final thoughts We hope this helps you better understand the inner workings of ZenGin. If you want to see how Piranha Bytes went about implementing a much more advanced version of this system for their next engine, check out Genome's object persistence system .","title":"Object persistence"},{"location":"zengin/general_info/object_persistence/#object-persistence","text":"In order to simplify the process of loading and saving data of various types to and from the user's hard-drive, ZenGin implements a simple object persistence system using the zCArchiver class and its derivatives that allow the individual engine classes to implement a routine specifying which data should be saved or loaded from disk and in which manner. An object that is derived from the zCObject class may overload the Archive and Unarchive virtual methods. The class may then call on an interface provided by the zCArchiver class within these methods which allows it to directly read from or write to a stream using several modes. Those are ASCII and BinSafe by default. There are, however, more options, as is explained below.","title":"Object persistence"},{"location":"zengin/general_info/object_persistence/#archive-format","text":"In order to better understand how this process works, it would be best to look at an example of a .ZEN file containing an instance of an oCWorld object.","title":"Archive format"},{"location":"zengin/general_info/object_persistence/#header","text":"When you open up a ZenGin archive, you will see the following at the start of the file: 1 2 3 4 5 6 7 8 9 10 ZenGin Archive ver 1 zCArchiverGeneric ASCII saveGame 0 date 7.1.2001 23:9:19 user roeske END objects 2594 END Let's look at each of these properties and what they mean: ZenGin Archive This simply specifies that the following data is an zCArchiver archive. ver 1 Version specification. Can be either 0 or 1 . Both Gothic 1 and 2 are already on version 1, although version 0 archives can also be occasionally found. zCArchiverGeneric Specifies which derived zCArchiver class should be used to read this archive. Accepted values are zCArchiverGeneric for ASCII and Binary archives, and zCArchiverBinSafe for BinSafe archives. More info below. This property might not be present in older archives. ASCII This is the most important part of the header as it specifies in which format should the data be stored. There are 4 different modes: ASCII - The simplest one. It stores data in human-readable ASCII notation (not unlike JSON for example). This is usually used when saving data during development and/or testing, while the final version of said data will most likely be stored as BIN_SAFE. ASCII_PROPS - Same as ASCII except with more additional data that the developer can specify for visual clarity. In practice, it is not used anywhere and mostly serves only to prettify debug info (try typing ZWORLD VOBPROPS in the console and look in zSpy ;) ). BINARY - Binary representation of the class instance, which mostly copies the data 1:1 into/from the stream. In practice, this format is only used to store savefiles (.SAV). BIN_SAFE - BinSafe, short for Binary Safe, is an extended version of Binary which stores type information along with the data itself. This is meant to make error checking for invalid data easier. There are other changes which are explained below. Most, if not all world files (.ZEN), are stored in this format. saveGame 0 Specifies if this archive is a savefile. This property might not be present in older archives. date 7.1.2001 23:9:19 The date at which this archive was created. user roeske The user which created the archive. This property might not be present in older archives. END Tells the parses that this is the end of the header. We may additionally find a property called csum in version 0 archives which stores the checksum of the whole archive. This property is, however, unused and equals 00000000 by default. In order to correctly read the archive's header across varying engine versions, one should not count on the properties always being in the same order or even being there at all. If the archive utilizes zCArchiverGeneric then this header will also be followed by a short section specifying the number of object instances in this archive. This value will be used to initialize the objectList, which is an array of pointers where the addresses of loaded objects will be stored for later referencing. This property would be directly part of the main header in older versions. 1 objects 2594 END If the archive is created using zCArchiverBinSafe , this data will be stored in the following binary structure: 1 2 3 4 struct BinSafeArchiveHeader { uint32_t version ; // Always equals 2 uint32_t objectCount; // Serves the same function as \"objects n\" uint32_t chunkPos; // Offset to chunk hash table}; };","title":"Header"},{"location":"zengin/general_info/object_persistence/#contents","text":"Looking further into the archive, we see what appears to be a nested structure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [% oCWorld:zCWorld 64513 0] [VobTree % 0 0] childs0=int:1 [% zCVobLevelCompo:zCVob 12289 1] pack=int:0 presetName=string: bbox3DWS=rawFloat:-71919.9609 -13091.8232 -59900 108999.992 20014.0352 67399.9922 trafoOSToWSRot=raw:0000803f0000000000000000000000000000803f0000000000000000000000000000803f trafoOSToWSPos=vec3:0 0 0 vobName=string:LEVEL-VOB visual=string:SURFACE.3DS showVisual=bool:0 visualCamAlign=enum:0 cdStatic=bool:1 cdDyn=bool:0 staticVob=bool:0 dynShadow=enum:0 [visual zCMesh 0 2] [] [ai % 0 0] [] [] ... We primarily differentiate between chunks and properties within ZenGin archives:","title":"Contents"},{"location":"zengin/general_info/object_persistence/#chunks","text":"A chunk is a structure that groups properties together. For most of the time, a chunk represents a class instance. This is, however, not always true as classes may arbitrarily create chunks as is needed. For example, the sample above contains a chunk called VobTree , which does not represent a class instance, but only serves to make the reading of the archive easier. While in ASCII mode, the start of a chunk is represented using square brackets. [% oCWorld:zCWorld 64513 0] There are 4 pieces of data separated by spaces inside the start of each chunk, which are: Object name - The name of the chunk to use while reading. If the chunk has no name, then it will be simply equal to % . Class name - The name of the class which this chunk represents. Class names are stored with their full inheritance hierarchy (e.g. oCMobLadder:oCMobInter:oCMOB:zCVob ). In case the chunk is not an object, but an arbitrary chunk, then this field will be equal to % ( % can also mean that this chunk is a nullptr). In some cases you may encounter the symbol \u00a7 instead. This means that the object already exists and that the parser should look for it in the objectList using the object index. Using this mechanism, a single instance can be referenced multiple times without worrying about duplicity. Class version - Used to ensure that the data being read is compatible with the current game/engine version, so that there are no mismatches in the data pattern. This value is different for every class and varies between game versions. Object index - An index into the objectList under which this object will be stored. If the class name is equal to \u00a7 , then this value will be used to retrieve an existing instance from the objectList. If this is a Binary archive, the same data will be stored in the following binary structure: 1 2 3 4 5 6 7 8 struct BinaryObjectHeader { uint32_t objectSize ; // Size of the whole object in bytes uint16_t classVersion ; uint32_t objectIndex ; char objectName []; // Null-terminated string char className []; // Null-terminated string }; Oddly enough, if the archive is BinSafe, then the data will be encoded the same way as in ASCII mode, except that it will be stored as a type-checked property. 1 2 3 4 5 6 struct BinSafeObjectHeader { uint32_t type ; // 0x1 = TYPE_STRING uint16_t length ; // Length of the text char text []; // [% oCWorld:zCWorld 64513 0] }; In ASCII mode [] represents the end of the current chunk.","title":"Chunks"},{"location":"zengin/general_info/object_persistence/#properties","text":"We find properties inside the chunks which are key-value pairs that classes use to store the actual data. Each property stores its name, type and value. In ASCII mode the format for this is name=type:value . For example: visual=string:SURFACE.3DS By default, zCArchiver allows to store properties of the following types: Int - A regular 32-bit integer. In ASCII mode, int gets stored as name=int:1 , while in Binary mode, it's just the raw value stored as 4 bytes. Byte - A 8-bit integer. ASCII mode doesn't differentiate between Int and Byte, so this will be stored as name=int:1 regardless. Binary mode stores only the single byte. Word - A 16-bit integer. ASCII mode doesn't differentiate between Int and Word, so this will be stored as name=int:1 regardless. Binary mode stores only the 2 bytes. Float - A standard IEEE 754 32-bit floating point number. In ASCII mode the format is name=float:1.0 , while in Binary mode the float gets stored raw as 4 bytes. Bool - Stores a single-byte boolean value. In ASCII mode its name=bool:1 and in Binary mode it's a single byte. String - An ASCII encoded string. While in ASCII mode, strings are stored as name=string:value . In Binary mode, strings are NULL terminated. Vec3 - A three component vector, mainly used to store positional data. The ASCII mode format is name=vec3:1.0 1.0 1.0 . In Binary mode the three components of the vector are stored in series, which equals to a total size of 12 bytes. Color - A 32-bit color value stored as BGRA. In ASCII mode the color is stored as name=color:255 255 255 255 while in Binary mode it's just 4 raw bytes. Raw - Raw binary data. In order to maintain readability, in ASCII mode this gets stored as a hex encoded string such as name=raw:63D15B07 . In Binary mode, only the data itself is stored, without any other info. Be aware that due to this you must know the size of the data beforehand. RawFloat - An array of floats, mainly used to store bounding boxes. In ASCII mode, the floats are stored as name=rawFloat:1.0 1.0 1.0 1.0 1.0 1.0 . In Binary mode the floats are stored in series as raw bytes. Same as with Raw , you must know the size of the array beforehand. Enum - An enum value. In ASCII mode, it gets stored as name=enum:1 . In Binary mode, it behaves the same as Int . As you might have noticed, binary mode doesn't perform any kind of checks on if it's reading the right property or even data of the correct type. This is why BinSafe mode exists, as it stores the property type in along with the data itself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 enum TYPE { TYPE_STRING = 0x1 , TYPE_INTEGER = 0x2 , TYPE_FLOAT = 0x3 , TYPE_BYTE = 0x4 , TYPE_WORD = 0x5 , TYPE_BOOL = 0x6 , TYPE_VEC3 = 0x7 , TYPE_COLOR = 0x8 , TYPE_RAW = 0x9 , TYPE_RAWFLOAT = 0x10 , TYPE_ENUM = 0x11 TYPE_HASH = 0x12 , }; struct BinSafeProperty { TYPE type ; union { struct { uint16_t stringLength ; char stringValue []; } uint32_t integerOrHashOrEnumValue ; float floatValue ; uint8_t byteOrBoolValue ; zVEC3 vec3Value ; zCOLOR colorValue ; struct { uint16_t rawLength ; char rawValue []; } struct { uint16_t rawFloatLength ; float rawFloatValue []; } }; }; Looking at the enumeration of types, you might notice that BinSafe mode has an additional property type called Hash. BinSafe archives include a hash table which is stored in the following manner: 1 2 3 4 5 6 7 8 9 10 11 struct BinSafeHashTable { uint32_t chunkCount ; for ( chunkCount ) { uint16_t stringLength ; uint16_t linearValue ; uint32_t hashValue ; char text [ stringLength ]; } }; Instead of storing the raw value, properties may save a hash instead, which is then used to look up the corresponding value from the hash table.","title":"Properties"},{"location":"zengin/general_info/object_persistence/#implementation","text":"As mentioned in the opening paragraph, classes may use the described functionality by overloading the Archive and Unarchive virtual methods, which pass an instance of zCArchiver by reference. When the class instance is then serialized and/or parsed, these methods are called and perform the desired serialization/parsing work. The class uses methods provided by the zCArchiver instance within these routines. These methods return/accept a value of a specific type (e.g. ReadInt/WriteInt), while they do the actual reading/writing work behind the scenes based on the current mode (ASCII/Binary/BinSafe). The programmer writing the class then does not care whether the final archive will be saved as ASCII, Binary or BinSafe, as they only use the zCArchiver Read* and Write* methods.","title":"Implementation"},{"location":"zengin/general_info/object_persistence/#a-practical-example","text":"Let's propose that we have a class which is declared like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class zCMyClass : public zCObject { public : zCMyClass () {} virtual ~ zCMyClass () {} virtual void Archive ( zCArchiver & ); virtual void Unarchive ( zCArchiver & ); int myInt ; zCMyClass * myObject ; zCMyClass * secondPointerToMyObject ; }; The hypothetical class then implements these virtual functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void zCMyClass::Archive ( zCArchiver & archiver ) { archiver . WriteInt ( \"myInt\" , myInt ); archiver . WriteObject ( \"myObject\" , myObject ); archiver . WriteChunkStart ( \"myChunk\" , 0 ); archiver . WriteObject ( \"secondPointerToMyObject\" , secondPointerToMyObject ); archiver . WriteChunkEnd (); } void zCMyClass::Unarchive ( zCArchiver & archiver ) { archiver . ReadInt ( \"myInt\" , myInt ); myObject = dynamic_cast < zCMyClass *> ( archiver . ReadObject ( \"myObject\" )); archiver . ReadChunkStart ( \"myChunk\" ); secondPointerToMyObject = dynamic_cast < zCMyClass *> ( archiver . ReadObject ( \"secondPointerToMyObject\" )); archiver . ReadChunkEnd (); } We then initialize the class in the following way: 1 2 3 4 5 6 7 8 zCMyClass object ; object . myInt = 12121212 ; object . myObject = new zCMyClass (); object . myObject -> myInt = 34343434 ; object . secondPointerToMyObject = object . myObject ; If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII archive, the result would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ZenGin Archive ver 1 zCArchiverGeneric ASCII saveGame 0 date 3.7.2022 0:0:0 user GMC END objects 2 END [% zCMyClass 0 0] myInt=int:12121212 [myObject zCMyClass 0 1] myInt=int:34343434 [myObject % 0 0] [] [myChunk % 0 0] [secondPointerToMyObject % 0 0] [] [] [] [myChunk % 0 0] [secondPointerToMyObject \u00a7 0 1] [] [] [] Notice how secondPointerToMyObject doesn't have any contents. The character \u00a7 tells the parser that this object already exists in the objectList, and that instead of creating a new instance, it should return an existing instance which is stored under index 1 in the objectList. This allows an instance to be referenced from multiple places, without the need to worry about duplicity. If we used Binary or BinSafe mode, we would see a big blob of binary data instead. This would, of course, store the exact same data, although in a slightly less human-readable format.","title":"A practical example"},{"location":"zengin/general_info/object_persistence/#final-thoughts","text":"We hope this helps you better understand the inner workings of ZenGin. If you want to see how Piranha Bytes went about implementing a much more advanced version of this system for their next engine, check out Genome's object persistence system .","title":"Final thoughts"},{"location":"zengin/general_info/vdfs/","text":"VDFS VDFS is the virtual file system used by ZenGin to distribute and store many, but not all, game assets. Tools The community created variety of different modding tools for work with VDFS volumes over the times, such as: GothicVDFS Viewing Extracting Building .mod and .vdf archives VDFS Tool Viewing Extracting Building Optimizing Compressing .mod and .vdf archives","title":"VDFS - virtual file system"},{"location":"zengin/general_info/vdfs/#vdfs","text":"VDFS is the virtual file system used by ZenGin to distribute and store many, but not all, game assets.","title":"VDFS"},{"location":"zengin/general_info/vdfs/#tools","text":"The community created variety of different modding tools for work with VDFS volumes over the times, such as: GothicVDFS Viewing Extracting Building .mod and .vdf archives VDFS Tool Viewing Extracting Building Optimizing Compressing .mod and .vdf archives","title":"Tools"},{"location":"zengin/scripts/","text":"Scripts ZenGin uses its own scripting language called Daedalus. It is similar to C programming language, so if you know some C programming, it will be quite easy to get started. The Scripts directory is where the scripts live. You will be able to find Daedalus script files - .d extension and .src files, that list all files to be compiled. Daedalus scripts can be edited in any text editor. To get useful features like syntax highlighting you can use community developed tools like Gothic Sourcer Daedalus VS Code extension","title":"Scripts"},{"location":"zengin/scripts/#scripts","text":"ZenGin uses its own scripting language called Daedalus. It is similar to C programming language, so if you know some C programming, it will be quite easy to get started. The Scripts directory is where the scripts live. You will be able to find Daedalus script files - .d extension and .src files, that list all files to be compiled. Daedalus scripts can be edited in any text editor. To get useful features like syntax highlighting you can use community developed tools like Gothic Sourcer Daedalus VS Code extension","title":"Scripts"},{"location":"zengin/scripts/classes/c_info/","text":"C_INFO Daedalus class Acknowledgment Heavily inspired by the amazing documentation site Gothic library The C_INFO class is used to define dialogues in the game. Class definition Class definition as it is defined in Scripts/Content/_intern/Classes.d script file. C_Info Daedalus class 1 2 3 4 5 6 7 8 9 10 11 class C_Info { var int npc ; // npc instance has the dialogue var int nr ; // number of the dialogue (for sorting) var int important ; // should the npc start the dialogue automatically var func condition ; // condition function var func information ; // function called on selecting the dialogue var string description ; // text in the dialogue box var int trade ; // should the dialogue show the trade window var int permanent ; // should the dialogue be permanent or only one time deal }; Class members Variable Type Description npc int npc instance to have the dialogue nr int dialogue order number important int npc addresses player automatically condition func condition function whether the dialogue is shown or not information func function called on dialogue selection - contains the dialogue lines and other logic description string text shown in the dialogue box trade int is it a trade dialogue permanent int does the dialogue stay after being played once Class member overview Description of the class member variables. npc Sets what NPC will have this dialogue instance. Set an NPC instance. 1 2 3 4 5 instance Info_Diego_Gamestart ( C_INFO ) { npc = PC_Thief ; // NPC instance for Diego // ... }; nr The nr member variables determines the order of shown dialogues. Dialogues are ordered in the ascending order - instances with higher nr are below instances with lower nr . 1 2 3 4 5 6 instance Info_Diego_Gamestart ( C_INFO ) { // ... nr = 1 ; // ... }; Note This is why the end dialogues usually have nr = 999; this is the highest number out of any dialogues therefore will always show up at the bottom. (999 is not the highest number the nr can store, it is just considered the highest number, as there will hardly be 998 dialogue instances for a single character) important The important member variable determines whether the NPC will automatically address the player or not. important = TRUE - the NPC will address the player important = FALSE - the player has to talk to the NPC When important is set to TRUE , the description is not needed since the dialogue is never shown in the dialogue box. Info If there are multiple important dialogues that satisfy their condition function, they will be played in the order specified by nr . Tip important variable is of the type integer, and it is initialized by the engine to the value of 0 . If you do not want your dialogue to be important, you can omit the important member variable since it will be initialized to 0 by the engine. condition Condition function with signature func int f() . If the function returns TRUE the dialogue is displayed, if it returns FALSE it is not displayed. The function name does not have to follow a particular naming convention but a naming convention is used throughout all the Gothic scripts: {DialogueName}_Condition . Conditioned dialogue Unconditioned dialogue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 instance Info_Diego_Gamestart ( C_INFO ) { // ... condition = Info_Diego_Gamestart_Condition ; // ... }; func int Info_Diego_Gamestart_Condition () { if ( Kapitel < 2 ) // Show only when chapter is less than 2 { return TRUE ; }; return FALSE ; // Not needed, but added for readability }; 1 2 3 4 5 6 7 8 9 10 11 instance Info_Diego_EXIT_Gamestart ( C_INFO ) { // ... condition = Info_Diego_EXIT_Gamestart_Condition ; // ... }; func int Info_Diego_EXIT_Gamestart_Condition () { return TRUE ; // or return 1; }; Tip It is not necessary to return FALSE from dialogue conditions, but in other cases it can very rarely cause subtle bugs. It is thus good practice to always return some value, even if that is FALSE . information The information function contains the function name (without double quotes \"\" as func is a type in Daedalus) that is called when the dialogue option is selected. It contains the lines NPCs will say, items that will be transferred, quests related logic and much more. The function name does not have to follow a particular naming convention, but a naming convention is used throughout all the Gothic scripts: {DialogueName}_Info . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 instance Info_Diego_Gamestart ( C_INFO ) { npc = PC_Thief ; nr = 1 ; condition = Info_Diego_Gamestart_Condition ; information = Info_Diego_Gamestart_Info ; permanent = FALSE ; important = TRUE ; }; func int Info_Diego_Gamestart_Condition () { if ( Kapitel < 2 ) { return TRUE ; }; return FALSE ; }; func void Info_Diego_Gamestart_Info () { AI_Output ( self , hero , \"Info_Diego_Gamestart_11_00\" ); //I'm Diego. AI_Output ( hero , self , \"Info_Diego_Gamestart_15_01\" ); //I'm... AI_Output ( self , hero , \"Info_Diego_Gamestart_11_02\" ); //I'm not interested in who you are. You've just arrived. I look after the new arrivals. That's all for now. AI_Output ( self , hero , \"Info_Diego_Gamestart_11_03\" ); //If you plan to stay alive for a while, you should talk to me. But of course I won't keep you from choosing your own destruction. Well, what do you think? B_Kapitelwechsel ( 1 ); // Show the chapter 1 screen }; description Specify a string that will be shown in the dialogue window. 1 2 3 4 5 instance DIA_XARDAS_GMC ( C_INFO ) { // ... description = \"Hello, is this the GMC site?\" ; }; trade If trade is set to TRUE the trading interface will be launched after the content information function is finished. Fisk's trade dialogue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 instance Stt_311_Fisk_Trade ( C_INFO ) { npc = Stt_311_Fisk ; nr = 800 ; condition = Stt_311_Fisk_Trade_Condition ; information = Stt_311_Fisk_Trade_Info ; permanent = TRUE ; description = \"Show me your goods.\" ; trade = TRUE ; }; func int Stt_311_Fisk_Trade_Condition () { return TRUE ; }; func void Stt_311_Fisk_Trade_Info () { AI_Output ( other , self , \"Stt_311_Fisk_Trade_15_00\" ); //Show me your goods. }; Trivia Trade manager has been added to ZenGin not that long before the release of Gothic 1 (as discussed and discovered on Phoenix the Game Discord server with the acquisition of Gothic version 0.94k ). In version 0.94 the trade manager worked quite differently and used a special (nowadays unused) Daedalus class C_ItemReact . permanent Dialogues with permanent = TRUE do not disappear after the dialogue is played. This is used for dialogues where you ask for directions or flavor dialogues for unnamed NPCs. Bug Frequently used external function Npc_KnowsInfo which returns true if the dialogue instance has been played has had a bug in the implementation for a long time. This bug made it impossible to use this function with dialogue instances with permanent = TRUE as it would always return FALSE . This has been fixed in Union 1.0m . zParserExtender zParserExtender implements some Quality of Life features for dialogues. More information can be found in Dialogue constants article AF Script Packet Enhanced Info Manager (implemented using Ikarus and LeGo) adds tonne of customisation and additional features to dialogues. More information can be found in the AFSP Enhanced Information Manager article","title":"C_INFO"},{"location":"zengin/scripts/classes/c_info/#c_info-daedalus-class","text":"Acknowledgment Heavily inspired by the amazing documentation site Gothic library The C_INFO class is used to define dialogues in the game.","title":"C_INFO Daedalus class"},{"location":"zengin/scripts/classes/c_info/#class-definition","text":"Class definition as it is defined in Scripts/Content/_intern/Classes.d script file. C_Info Daedalus class 1 2 3 4 5 6 7 8 9 10 11 class C_Info { var int npc ; // npc instance has the dialogue var int nr ; // number of the dialogue (for sorting) var int important ; // should the npc start the dialogue automatically var func condition ; // condition function var func information ; // function called on selecting the dialogue var string description ; // text in the dialogue box var int trade ; // should the dialogue show the trade window var int permanent ; // should the dialogue be permanent or only one time deal };","title":"Class definition"},{"location":"zengin/scripts/classes/c_info/#class-members","text":"Variable Type Description npc int npc instance to have the dialogue nr int dialogue order number important int npc addresses player automatically condition func condition function whether the dialogue is shown or not information func function called on dialogue selection - contains the dialogue lines and other logic description string text shown in the dialogue box trade int is it a trade dialogue permanent int does the dialogue stay after being played once","title":"Class members"},{"location":"zengin/scripts/classes/c_info/#class-member-overview","text":"Description of the class member variables.","title":"Class member overview"},{"location":"zengin/scripts/classes/c_info/#npc","text":"Sets what NPC will have this dialogue instance. Set an NPC instance. 1 2 3 4 5 instance Info_Diego_Gamestart ( C_INFO ) { npc = PC_Thief ; // NPC instance for Diego // ... };","title":"npc"},{"location":"zengin/scripts/classes/c_info/#nr","text":"The nr member variables determines the order of shown dialogues. Dialogues are ordered in the ascending order - instances with higher nr are below instances with lower nr . 1 2 3 4 5 6 instance Info_Diego_Gamestart ( C_INFO ) { // ... nr = 1 ; // ... }; Note This is why the end dialogues usually have nr = 999; this is the highest number out of any dialogues therefore will always show up at the bottom. (999 is not the highest number the nr can store, it is just considered the highest number, as there will hardly be 998 dialogue instances for a single character)","title":"nr"},{"location":"zengin/scripts/classes/c_info/#important","text":"The important member variable determines whether the NPC will automatically address the player or not. important = TRUE - the NPC will address the player important = FALSE - the player has to talk to the NPC When important is set to TRUE , the description is not needed since the dialogue is never shown in the dialogue box. Info If there are multiple important dialogues that satisfy their condition function, they will be played in the order specified by nr . Tip important variable is of the type integer, and it is initialized by the engine to the value of 0 . If you do not want your dialogue to be important, you can omit the important member variable since it will be initialized to 0 by the engine.","title":"important"},{"location":"zengin/scripts/classes/c_info/#condition","text":"Condition function with signature func int f() . If the function returns TRUE the dialogue is displayed, if it returns FALSE it is not displayed. The function name does not have to follow a particular naming convention but a naming convention is used throughout all the Gothic scripts: {DialogueName}_Condition . Conditioned dialogue Unconditioned dialogue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 instance Info_Diego_Gamestart ( C_INFO ) { // ... condition = Info_Diego_Gamestart_Condition ; // ... }; func int Info_Diego_Gamestart_Condition () { if ( Kapitel < 2 ) // Show only when chapter is less than 2 { return TRUE ; }; return FALSE ; // Not needed, but added for readability }; 1 2 3 4 5 6 7 8 9 10 11 instance Info_Diego_EXIT_Gamestart ( C_INFO ) { // ... condition = Info_Diego_EXIT_Gamestart_Condition ; // ... }; func int Info_Diego_EXIT_Gamestart_Condition () { return TRUE ; // or return 1; }; Tip It is not necessary to return FALSE from dialogue conditions, but in other cases it can very rarely cause subtle bugs. It is thus good practice to always return some value, even if that is FALSE .","title":"condition"},{"location":"zengin/scripts/classes/c_info/#information","text":"The information function contains the function name (without double quotes \"\" as func is a type in Daedalus) that is called when the dialogue option is selected. It contains the lines NPCs will say, items that will be transferred, quests related logic and much more. The function name does not have to follow a particular naming convention, but a naming convention is used throughout all the Gothic scripts: {DialogueName}_Info . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 instance Info_Diego_Gamestart ( C_INFO ) { npc = PC_Thief ; nr = 1 ; condition = Info_Diego_Gamestart_Condition ; information = Info_Diego_Gamestart_Info ; permanent = FALSE ; important = TRUE ; }; func int Info_Diego_Gamestart_Condition () { if ( Kapitel < 2 ) { return TRUE ; }; return FALSE ; }; func void Info_Diego_Gamestart_Info () { AI_Output ( self , hero , \"Info_Diego_Gamestart_11_00\" ); //I'm Diego. AI_Output ( hero , self , \"Info_Diego_Gamestart_15_01\" ); //I'm... AI_Output ( self , hero , \"Info_Diego_Gamestart_11_02\" ); //I'm not interested in who you are. You've just arrived. I look after the new arrivals. That's all for now. AI_Output ( self , hero , \"Info_Diego_Gamestart_11_03\" ); //If you plan to stay alive for a while, you should talk to me. But of course I won't keep you from choosing your own destruction. Well, what do you think? B_Kapitelwechsel ( 1 ); // Show the chapter 1 screen };","title":"information"},{"location":"zengin/scripts/classes/c_info/#description","text":"Specify a string that will be shown in the dialogue window. 1 2 3 4 5 instance DIA_XARDAS_GMC ( C_INFO ) { // ... description = \"Hello, is this the GMC site?\" ; };","title":"description"},{"location":"zengin/scripts/classes/c_info/#trade","text":"If trade is set to TRUE the trading interface will be launched after the content information function is finished. Fisk's trade dialogue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 instance Stt_311_Fisk_Trade ( C_INFO ) { npc = Stt_311_Fisk ; nr = 800 ; condition = Stt_311_Fisk_Trade_Condition ; information = Stt_311_Fisk_Trade_Info ; permanent = TRUE ; description = \"Show me your goods.\" ; trade = TRUE ; }; func int Stt_311_Fisk_Trade_Condition () { return TRUE ; }; func void Stt_311_Fisk_Trade_Info () { AI_Output ( other , self , \"Stt_311_Fisk_Trade_15_00\" ); //Show me your goods. }; Trivia Trade manager has been added to ZenGin not that long before the release of Gothic 1 (as discussed and discovered on Phoenix the Game Discord server with the acquisition of Gothic version 0.94k ). In version 0.94 the trade manager worked quite differently and used a special (nowadays unused) Daedalus class C_ItemReact .","title":"trade"},{"location":"zengin/scripts/classes/c_info/#permanent","text":"Dialogues with permanent = TRUE do not disappear after the dialogue is played. This is used for dialogues where you ask for directions or flavor dialogues for unnamed NPCs. Bug Frequently used external function Npc_KnowsInfo which returns true if the dialogue instance has been played has had a bug in the implementation for a long time. This bug made it impossible to use this function with dialogue instances with permanent = TRUE as it would always return FALSE . This has been fixed in Union 1.0m .","title":"permanent"},{"location":"zengin/scripts/classes/c_info/#zparserextender","text":"zParserExtender implements some Quality of Life features for dialogues. More information can be found in Dialogue constants article","title":"zParserExtender"},{"location":"zengin/scripts/classes/c_info/#af-script-packet","text":"Enhanced Info Manager (implemented using Ikarus and LeGo) adds tonne of customisation and additional features to dialogues. More information can be found in the AFSP Enhanced Information Manager article","title":"AF Script Packet"},{"location":"zengin/scripts/classes/c_item/","text":"C_ITEM Daedalus class Acknowledgment Heavily inspired by the amazing documentation site Gothic library The C_ITEM class is used to define new items in the game. Class definition Class definition as it is defined in Scripts/Content/_intern/Classes.d script file. C_Item Daedalus class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class C_Item { // For all Items var int id ; // ID of the item var string name ; // Name of the item var string nameID ; // Name ID var int hp ; // Current health of the item var int hp_max ; // Maximum health of the item var int mainflag ; // Item category flag var int flags ; // Item type flag var int weight ; // Weight of the item var int value ; // Value of the item // For weapons var int damageType ; // Damage type var int damageTotal ; // Total amount of damage var int damage [ DAM_INDEX_MAX ]; // Array of damage types // For armours var int wear ; // Flag to specify where to wear an item var int protection [ PROT_INDEX_MAX ]; // Protection array of different damage types // For food var int nutrition ; // The amount of HP healed // Ben\u00f6tigte Attribute zum Benutzen des Items var int cond_atr [ 3 ]; // Array of NPC attributes needed to equip the item var int cond_value [ 3 ]; // Array of values corresponding to the cond_atr arry // Attributes to be changed on equip var int change_atr [ 3 ]; // Array of attributes that will be changed on equip var int change_value [ 3 ]; // Array of values of the attributes defined in change_atr // Parser functions var func magic ; var func on_equip ; // Called on equpping an item var func on_unequip ; // Called on unequipping an item var func on_state [ 4 ]; var func owner ; // Owner of the item: instance name var int ownerGuild ; // Owner of the item: guild var int disguiseGuild ; // NPC guild set when equipping an item // 3DS model file var string visual ; // Item model file // NPC mesh change, when equipping an item var string visual_change ; // .asc file var string effect ; // Effect instance var int visual_skin ; // Texture variation var string scemeName ; // Animation sceme name var int material ; // Material of the object var int munition ; // Ammo instance var int spell ; // ID if the spell that this item does var int range ; // Range of the weapon var int mag_circle ; // Circle of magic needed to use this item var string description ; // The name of the item shown in the preview box var string text [ ITM_TEXT_MAX ]; // Array of string describing the item (left side) var int count [ ITM_TEXT_MAX ]; // Array of integers (the right side) // Parameters for displaying items in the inventory var int inv_zbias // How far away is the item from the screen var int inv_rotx // X-axis rotation var int inv_roty // Y-axis rotation var int inv_rotz // Z-axis rotation var int inv_animate // Should the item rotate in the inventory }; It has many member variables but not all of them are used for every item. It is not necessary to define every one of these variables for every item as it was discussed on InsideGothic . Class members A selection of the most important class members. change_atr & change_value change_atr stores the attributes that will be changed by the amount specified in change_value . NPCs have these attributes: 1 2 3 4 5 6 7 8 9 const int ATR_HITPOINTS = 0 ; // Hit points const int ATR_HITPOINTS_MAX = 1 ; // Max hitpoints const int ATR_MANA = 2 ; // Mana const int ATR_MANA_MAX = 3 ; // Max mana const int ATR_STRENGTH = 4 ; // Strength const int ATR_DEXTERITY = 5 ; // Dexterity const int ATR_REGENERATEHP = 6 ; // HP regeneration per second const int ATR_REGENERATEMANA = 7 ; // Mana regeneration per second This can be used on all equipable items to change the attributes. As an example we can create a sword that has a 10 point dexterity bonus. 1 2 3 4 5 6 7 instance ItMw_testSword ( C_Item ) { // some code change_atr [ 0 ] = ATR_DEXTERITY ; change_value [ 0 ] = 10 ; // some code }; Warning Do not change ATR_HITPOINTS , ATR_MANA , ATR_HITPOINTS_MAX or ATR_MANA_MAX as it will result in unwanted behaviour with max health or max mana. You can change ATR_HITPOINTS_MAX and ATR_MANA_MAX attributes in on_equip and on_unequip cond_atr & cond_value cond_atr stores the attributes that will be checked as a requirement to equip an item, the amount specified in cond_value . The next example sword is equipable only if the NPC has at least 5 strength. If the requirements are not met G_CanNotUse() is called. 1 2 3 4 5 6 7 instance ItMw_testSword ( C_Item ) { // some code cond_atr [ 2 ] = ATR_STRENGTH ; cond_value [ 2 ] = 5 ; // some code }; Try injecting the code below zParserExtender to test it in game right away. It is compatible with G2NotR. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 instance ItMw_testSword ( C_Item ) { name = TXT_Spells [ 10 ]; // demonstrates the usage of direct constr array access mainflag = ITEM_KAT_NF ; flags = ITEM_SWD ; material = MAT_METAL ; value = 10 ; damageTotal = 10 ; damagetype = DAM_EDGE ; range = 100 ; cond_atr [ 2 ] = ATR_STRENGTH ; cond_value [ 2 ] = 5 ; change_atr [ 0 ] = ATR_DEXTERITY ; change_value [ 0 ] = 10 ; visual = \"ItMw_010_1h_Sword_short_01.3DS\" ; description = name ; TEXT [ 2 ] = NAME_Damage ; COUNT [ 2 ] = damageTotal ; TEXT [ 3 ] = NAME_Str_needed ; COUNT [ 3 ] = cond_value [ 2 ]; TEXT [ 4 ] = NAME_OneHanded ; TEXT [ 5 ] = NAME_Value ; COUNT [ 5 ] = value ; }; To insert it into the game use insert ItMw_testSword in console. text & count arrays These two arrays are used to put information into the item information box. The maximum number of lines is 6. This is defined in the engine, but for script side class definition is declared in the scripts too. 1 const int ITM_TEXT_MAX = 6 ; This example shows an item with all elements of TEXT and COUNT array filled. Note Please notice the last COUNT element. It did not take the value we entered, but shows 10 which is the value of the item. This behaviour can be changed with Ikarus or Union. You can find the code below 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 instance ItMw_testSword ( C_Item ) { name = TXT_Spells [ 10 ]; mainflag = ITEM_KAT_NF ; flags = ITEM_SWD ; material = MAT_METAL ; value = 10 ; damageTotal = 10 ; damagetype = DAM_EDGE ; range = 100 ; cond_atr [ 2 ] = ATR_STRENGTH ; cond_value [ 2 ] = 5 ; change_atr [ 0 ] = ATR_DEXTERITY ; change_value [ 0 ] = 10 ; visual = \"ItMw_010_1h_Sword_short_01.3DS\" ; description = name ; TEXT [ 0 ] = \"Line 0\" ; COUNT [ 0 ] = 0 ; TEXT [ 1 ] = \"Line 1\" ; COUNT [ 1 ] = 1 ; TEXT [ 2 ] = \"Line 2\" ; COUNT [ 2 ] = 2 ; TEXT [ 3 ] = \"Line 3\" ; COUNT [ 3 ] = 3 ; TEXT [ 4 ] = \"Line 4\" ; COUNT [ 4 ] = 34 ; TEXT [ 5 ] = \"Line 5\" ; COUNT [ 5 ] = 35 ; }; description & name description - determines the name of the item in the inventory name - determines the focus name of the item in the world In the scripts you often find that the description is assigned the value of name . 1 2 3 4 5 6 7 instance ItMw_testSword ( C_Item ) { name = \"New amazing sword\" ; // ... description = name ; // description now has the same value as ' // ...name' // ... }; This is used in the case where you want to show the name of the item on focus too. There is a second way used in the scripts though with, for example,magic scrolls - the focus name in the world is \"Scroll\" and in inventory the scroll carries the name of the spell. This is how it is done: 1 2 3 4 5 6 7 instance ItSc_InstantFireball ( C_Item ) { name = NAME_Spruchrolle ; // const string = \"Scroll\" // ... description = NAME_SPL_InstantFireball ; // const string = \"Fireball\" // ... }; hp & hp_max Both of these parameters are unused. Trivia In alpha ZenGin versions the player was able to destroy objects. This feature was abandoned during the course of the development. This video shows the reconstruction of this feature.","title":"C_ITEM"},{"location":"zengin/scripts/classes/c_item/#c_item-daedalus-class","text":"Acknowledgment Heavily inspired by the amazing documentation site Gothic library The C_ITEM class is used to define new items in the game.","title":"C_ITEM Daedalus class"},{"location":"zengin/scripts/classes/c_item/#class-definition","text":"Class definition as it is defined in Scripts/Content/_intern/Classes.d script file. C_Item Daedalus class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class C_Item { // For all Items var int id ; // ID of the item var string name ; // Name of the item var string nameID ; // Name ID var int hp ; // Current health of the item var int hp_max ; // Maximum health of the item var int mainflag ; // Item category flag var int flags ; // Item type flag var int weight ; // Weight of the item var int value ; // Value of the item // For weapons var int damageType ; // Damage type var int damageTotal ; // Total amount of damage var int damage [ DAM_INDEX_MAX ]; // Array of damage types // For armours var int wear ; // Flag to specify where to wear an item var int protection [ PROT_INDEX_MAX ]; // Protection array of different damage types // For food var int nutrition ; // The amount of HP healed // Ben\u00f6tigte Attribute zum Benutzen des Items var int cond_atr [ 3 ]; // Array of NPC attributes needed to equip the item var int cond_value [ 3 ]; // Array of values corresponding to the cond_atr arry // Attributes to be changed on equip var int change_atr [ 3 ]; // Array of attributes that will be changed on equip var int change_value [ 3 ]; // Array of values of the attributes defined in change_atr // Parser functions var func magic ; var func on_equip ; // Called on equpping an item var func on_unequip ; // Called on unequipping an item var func on_state [ 4 ]; var func owner ; // Owner of the item: instance name var int ownerGuild ; // Owner of the item: guild var int disguiseGuild ; // NPC guild set when equipping an item // 3DS model file var string visual ; // Item model file // NPC mesh change, when equipping an item var string visual_change ; // .asc file var string effect ; // Effect instance var int visual_skin ; // Texture variation var string scemeName ; // Animation sceme name var int material ; // Material of the object var int munition ; // Ammo instance var int spell ; // ID if the spell that this item does var int range ; // Range of the weapon var int mag_circle ; // Circle of magic needed to use this item var string description ; // The name of the item shown in the preview box var string text [ ITM_TEXT_MAX ]; // Array of string describing the item (left side) var int count [ ITM_TEXT_MAX ]; // Array of integers (the right side) // Parameters for displaying items in the inventory var int inv_zbias // How far away is the item from the screen var int inv_rotx // X-axis rotation var int inv_roty // Y-axis rotation var int inv_rotz // Z-axis rotation var int inv_animate // Should the item rotate in the inventory }; It has many member variables but not all of them are used for every item. It is not necessary to define every one of these variables for every item as it was discussed on InsideGothic .","title":"Class definition"},{"location":"zengin/scripts/classes/c_item/#class-members","text":"A selection of the most important class members.","title":"Class members"},{"location":"zengin/scripts/classes/c_item/#change_atr-change_value","text":"change_atr stores the attributes that will be changed by the amount specified in change_value . NPCs have these attributes: 1 2 3 4 5 6 7 8 9 const int ATR_HITPOINTS = 0 ; // Hit points const int ATR_HITPOINTS_MAX = 1 ; // Max hitpoints const int ATR_MANA = 2 ; // Mana const int ATR_MANA_MAX = 3 ; // Max mana const int ATR_STRENGTH = 4 ; // Strength const int ATR_DEXTERITY = 5 ; // Dexterity const int ATR_REGENERATEHP = 6 ; // HP regeneration per second const int ATR_REGENERATEMANA = 7 ; // Mana regeneration per second This can be used on all equipable items to change the attributes. As an example we can create a sword that has a 10 point dexterity bonus. 1 2 3 4 5 6 7 instance ItMw_testSword ( C_Item ) { // some code change_atr [ 0 ] = ATR_DEXTERITY ; change_value [ 0 ] = 10 ; // some code }; Warning Do not change ATR_HITPOINTS , ATR_MANA , ATR_HITPOINTS_MAX or ATR_MANA_MAX as it will result in unwanted behaviour with max health or max mana. You can change ATR_HITPOINTS_MAX and ATR_MANA_MAX attributes in on_equip and on_unequip","title":"change_atr &amp; change_value"},{"location":"zengin/scripts/classes/c_item/#cond_atr-cond_value","text":"cond_atr stores the attributes that will be checked as a requirement to equip an item, the amount specified in cond_value . The next example sword is equipable only if the NPC has at least 5 strength. If the requirements are not met G_CanNotUse() is called. 1 2 3 4 5 6 7 instance ItMw_testSword ( C_Item ) { // some code cond_atr [ 2 ] = ATR_STRENGTH ; cond_value [ 2 ] = 5 ; // some code }; Try injecting the code below zParserExtender to test it in game right away. It is compatible with G2NotR. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 instance ItMw_testSword ( C_Item ) { name = TXT_Spells [ 10 ]; // demonstrates the usage of direct constr array access mainflag = ITEM_KAT_NF ; flags = ITEM_SWD ; material = MAT_METAL ; value = 10 ; damageTotal = 10 ; damagetype = DAM_EDGE ; range = 100 ; cond_atr [ 2 ] = ATR_STRENGTH ; cond_value [ 2 ] = 5 ; change_atr [ 0 ] = ATR_DEXTERITY ; change_value [ 0 ] = 10 ; visual = \"ItMw_010_1h_Sword_short_01.3DS\" ; description = name ; TEXT [ 2 ] = NAME_Damage ; COUNT [ 2 ] = damageTotal ; TEXT [ 3 ] = NAME_Str_needed ; COUNT [ 3 ] = cond_value [ 2 ]; TEXT [ 4 ] = NAME_OneHanded ; TEXT [ 5 ] = NAME_Value ; COUNT [ 5 ] = value ; }; To insert it into the game use insert ItMw_testSword in console.","title":"cond_atr &amp; cond_value"},{"location":"zengin/scripts/classes/c_item/#text-count-arrays","text":"These two arrays are used to put information into the item information box. The maximum number of lines is 6. This is defined in the engine, but for script side class definition is declared in the scripts too. 1 const int ITM_TEXT_MAX = 6 ; This example shows an item with all elements of TEXT and COUNT array filled. Note Please notice the last COUNT element. It did not take the value we entered, but shows 10 which is the value of the item. This behaviour can be changed with Ikarus or Union. You can find the code below 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 instance ItMw_testSword ( C_Item ) { name = TXT_Spells [ 10 ]; mainflag = ITEM_KAT_NF ; flags = ITEM_SWD ; material = MAT_METAL ; value = 10 ; damageTotal = 10 ; damagetype = DAM_EDGE ; range = 100 ; cond_atr [ 2 ] = ATR_STRENGTH ; cond_value [ 2 ] = 5 ; change_atr [ 0 ] = ATR_DEXTERITY ; change_value [ 0 ] = 10 ; visual = \"ItMw_010_1h_Sword_short_01.3DS\" ; description = name ; TEXT [ 0 ] = \"Line 0\" ; COUNT [ 0 ] = 0 ; TEXT [ 1 ] = \"Line 1\" ; COUNT [ 1 ] = 1 ; TEXT [ 2 ] = \"Line 2\" ; COUNT [ 2 ] = 2 ; TEXT [ 3 ] = \"Line 3\" ; COUNT [ 3 ] = 3 ; TEXT [ 4 ] = \"Line 4\" ; COUNT [ 4 ] = 34 ; TEXT [ 5 ] = \"Line 5\" ; COUNT [ 5 ] = 35 ; };","title":"text &amp; count arrays"},{"location":"zengin/scripts/classes/c_item/#description-name","text":"description - determines the name of the item in the inventory name - determines the focus name of the item in the world In the scripts you often find that the description is assigned the value of name . 1 2 3 4 5 6 7 instance ItMw_testSword ( C_Item ) { name = \"New amazing sword\" ; // ... description = name ; // description now has the same value as ' // ...name' // ... }; This is used in the case where you want to show the name of the item on focus too. There is a second way used in the scripts though with, for example,magic scrolls - the focus name in the world is \"Scroll\" and in inventory the scroll carries the name of the spell. This is how it is done: 1 2 3 4 5 6 7 instance ItSc_InstantFireball ( C_Item ) { name = NAME_Spruchrolle ; // const string = \"Scroll\" // ... description = NAME_SPL_InstantFireball ; // const string = \"Fireball\" // ... };","title":"description &amp; name"},{"location":"zengin/scripts/classes/c_item/#hp-hp_max","text":"Both of these parameters are unused. Trivia In alpha ZenGin versions the player was able to destroy objects. This feature was abandoned during the course of the development. This video shows the reconstruction of this feature.","title":"hp &amp; hp_max"},{"location":"zengin/scripts/classes/c_svm/","text":"C_SVM Daedalus class Acknowledgment Heavily inspired by the amazing documentation site Gothic library The C_SVM class is used to define sound dialogues (smalltalk, reactions) that are defined for every C_NPC.voice . Class definition C_SVM class is the only class with variable number of members. The C_SVM definition in the scripts dictates the content of the class. Every Gothic game has a different number of SVM entries. As an interesting information (more than anything else) we include a table with the numbers of voice lines and voices below. Game voice lines voices Gothic 1 136 17 Gothic Sequel 110 17 (30 planned) Gothic 2 202 19 Gothic 2 Addon 235 19 Chronicles of Myrtana 1346 73 Returning New Balance 495 19 Rules The number of instances is defined by a constant integer with a specified name read by the engine. 1 const int SVM_MODULES = 18 ; Info The value SVM_MODULES = 18 means 18 SVMs will be parsed by the engine and because the first one, SVM_0 , is empty, the final number of voices is 18 - 1 = 17. Instances of the C_SVM class must have the name SVM_XXX . 1 2 3 4 instance svm_1 ( c_svm ) { // ... }; The first instance svm_0 is always empty, it is used internally by the engine. 1 instance svm_0 ( c_svm ) {}; Usage in the scripts While some defined SVMs are used automatically by the engine - the 20 smalltalk lines for example, others are used in the scripts. To instruct the engine to run a specific SVM, external function AI_OutputSVM is used. In the original scripts it is wrapped in a script function B_Say . To reference the SVM, you use the $ symbol followed by the name of the member variable in the C_SVM class definition. 1 2 3 4 5 6 // some code { PrintScreen ( \"Not enough skill points!\" , - 1 , - 1 , \"FONT_OLD_20_WHITE.TGA\" , 1 ); B_Say ( self , other , \"$NOLEARNNOPOINTS\" ); }; // some code Here the $NOLEARNNOPOINTS references the var string NoLearnNoPoints in SVM.D . The voice is then chosen automatically by the engine. 1 2 3 4 5 6 7 8 9 10 11 12 class C_SVM { //... // Teacher comments var string NoLearnNoPoints ; // NPC teacher doesn't teach - not enough learning points! var string NoLearnOverMax ; // NPC teacher doesn't teach - cannot teach above 100 points! var string NoLearnYouAlreadyKnow ; // You have to know something to become a master! var string NoLearnYoureBetter ; // You are better than the teacher! //... };","title":"C_SVM"},{"location":"zengin/scripts/classes/c_svm/#c_svm-daedalus-class","text":"Acknowledgment Heavily inspired by the amazing documentation site Gothic library The C_SVM class is used to define sound dialogues (smalltalk, reactions) that are defined for every C_NPC.voice .","title":"C_SVM Daedalus class"},{"location":"zengin/scripts/classes/c_svm/#class-definition","text":"C_SVM class is the only class with variable number of members. The C_SVM definition in the scripts dictates the content of the class. Every Gothic game has a different number of SVM entries. As an interesting information (more than anything else) we include a table with the numbers of voice lines and voices below. Game voice lines voices Gothic 1 136 17 Gothic Sequel 110 17 (30 planned) Gothic 2 202 19 Gothic 2 Addon 235 19 Chronicles of Myrtana 1346 73 Returning New Balance 495 19","title":"Class definition"},{"location":"zengin/scripts/classes/c_svm/#rules","text":"The number of instances is defined by a constant integer with a specified name read by the engine. 1 const int SVM_MODULES = 18 ; Info The value SVM_MODULES = 18 means 18 SVMs will be parsed by the engine and because the first one, SVM_0 , is empty, the final number of voices is 18 - 1 = 17. Instances of the C_SVM class must have the name SVM_XXX . 1 2 3 4 instance svm_1 ( c_svm ) { // ... }; The first instance svm_0 is always empty, it is used internally by the engine. 1 instance svm_0 ( c_svm ) {};","title":"Rules"},{"location":"zengin/scripts/classes/c_svm/#usage-in-the-scripts","text":"While some defined SVMs are used automatically by the engine - the 20 smalltalk lines for example, others are used in the scripts. To instruct the engine to run a specific SVM, external function AI_OutputSVM is used. In the original scripts it is wrapped in a script function B_Say . To reference the SVM, you use the $ symbol followed by the name of the member variable in the C_SVM class definition. 1 2 3 4 5 6 // some code { PrintScreen ( \"Not enough skill points!\" , - 1 , - 1 , \"FONT_OLD_20_WHITE.TGA\" , 1 ); B_Say ( self , other , \"$NOLEARNNOPOINTS\" ); }; // some code Here the $NOLEARNNOPOINTS references the var string NoLearnNoPoints in SVM.D . The voice is then chosen automatically by the engine. 1 2 3 4 5 6 7 8 9 10 11 12 class C_SVM { //... // Teacher comments var string NoLearnNoPoints ; // NPC teacher doesn't teach - not enough learning points! var string NoLearnOverMax ; // NPC teacher doesn't teach - cannot teach above 100 points! var string NoLearnYouAlreadyKnow ; // You have to know something to become a master! var string NoLearnYoureBetter ; // You are better than the teacher! //... };","title":"Usage in the scripts"},{"location":"zengin/scripts/extenders/","text":"Daedalus extenders The default scripting language Daedalus can be quite limiting. Over the years the community created quite a few extenders to, well, extend the functionality. Before Union came along, the standard to interface with the engine was the script library Ikarus and a collection of packages LeGo built on top of that. Not so recently, an additional script packet was made (and is actively being worked on) AF Script Packet that offers even more functionality and is built on tom of Ikarus & LeGo. With the adoption of Union and plugins the Union system can use a new extender emerged called zParserExtender . Other Union plugins can, of course, implement their own external functions.","title":"Daedalus extenders"},{"location":"zengin/scripts/extenders/#daedalus-extenders","text":"The default scripting language Daedalus can be quite limiting. Over the years the community created quite a few extenders to, well, extend the functionality. Before Union came along, the standard to interface with the engine was the script library Ikarus and a collection of packages LeGo built on top of that. Not so recently, an additional script packet was made (and is actively being worked on) AF Script Packet that offers even more functionality and is built on tom of Ikarus & LeGo. With the adoption of Union and plugins the Union system can use a new extender emerged called zParserExtender . Other Union plugins can, of course, implement their own external functions.","title":"Daedalus extenders"},{"location":"zengin/scripts/extenders/ikarus/","text":"Ikarus Ikarus is a daedalus library for Gothic. It exploits the interpreter to allow arbitrary memory access and defines tonne of useful functions for interfacing with the engine. Contacts Author Sektenspinner & contributors GitHub Ikarus Forum Ikarus Note Ikarus is hosted on GitHub and the documentation is built in . The translation is planned.","title":"Ikarus"},{"location":"zengin/scripts/extenders/ikarus/#ikarus","text":"Ikarus is a daedalus library for Gothic. It exploits the interpreter to allow arbitrary memory access and defines tonne of useful functions for interfacing with the engine. Contacts Author Sektenspinner & contributors GitHub Ikarus Forum Ikarus Note Ikarus is hosted on GitHub and the documentation is built in . The translation is planned.","title":"Ikarus"},{"location":"zengin/scripts/extenders/afsp/","text":"AF Script Packet A uronen & F awkes' script packet is a script package built on top of Ikarus and LeGo . It implements many features and there is also a Union version which is in its infancy stage. Note AFSP's documentation is lacking (@Auronen: \"My fault\"). The authors will host the documentation on GMC. Contacts Authors Fawkes & Auronen GitHub AFSP Forum AFSP","title":"AF Script Packet"},{"location":"zengin/scripts/extenders/afsp/#af-script-packet","text":"A uronen & F awkes' script packet is a script package built on top of Ikarus and LeGo . It implements many features and there is also a Union version which is in its infancy stage. Note AFSP's documentation is lacking (@Auronen: \"My fault\"). The authors will host the documentation on GMC. Contacts Authors Fawkes & Auronen GitHub AFSP Forum AFSP","title":"AF Script Packet"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/","text":"Enhanced Information Manager Warning This is a quick paste-in of and old version of AFSP's documentation and the information should be taken with a grain of salt. It may not be up-to-date since AFSP is being developed all the time and this is only a demo page. Enhanced Information Manager allows you to more precisely control the Information Manager (dialogue manager). Change color, font and much more! This package \"scans\" the dialogue string for modifiers and alters the string based on the modifiers you specify. Initialization To use this feature you have to: Add _headers_G[1/2]_EnhancedInfoManager.src or _headers_G[1/2]_All.src to your Gothic.src after Ikarus and LeGo initialization. Call G12_EnhancedInfoManager_Init(); from your INIT_GLOBAL() function in Startup.d Change colour Set font color for a dialogue choice. 1 h@[hex color value] Set font color for highlighted dialogue choice. 1 hs@[hex color value] Example 1 description = \"h@2a85a3 hs@2ea9d1 This dialogue is blue.\" ; Change font Set font itself for a dialogue choice. 1 f@[font name] Set font itself for highlighted dialogue choice. 1 fs@[font name] Example 1 description = \"f@font_old_20_white.tga fs@font_old_10_white.tga This dialogue has a different font, when selected.\" ; Change text alignment Align text left. 1 al@ Align text center. 1 ac@ Align text right. 1 ar@ Example 1 2 3 description = \"al@ This dialogue has LEFT alignment.\" ; description = \"ac@ This dialogue has CENTER alignment.\" ; description = \"ar@ This dialogue has RIGHT alignment.\" ; Disable dialogue Player cannot highlight (and select) this dialogue. 1 d@ Text input field Input field allows you to turn a dialogue choice into an input text field. 1 a@ Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 INSTANCE DIA_Xardas_Password ( C_Info ) { npc = NONE_100_Xardas ; nr = 1 ; condition = DIA_Xardas_Password_Condition ; information = DIA_Xardas_Password_Info ; permanent = FALSE ; description = \"a@ What is the password to get to the Mages of Water?\" ; }; FUNC INT DIA_Xardas_Password_Condition () { return TRUE ; }; FUNC VOID DIA_Xardas_Password_Info () { if ( Hlp_StrCmp ( InfoManagerAnswer , \"TETRIANDOCH\" )) { PrintScreen ( \"Yes that is correct!\" , - 1 , - 1 , \"font_old_10_white.tga\" , 3 ); } else { PrintScreen ( \"No that is wrong!\" , - 1 , - 1 , \"font_old_10_white.tga\" , 3 ); }; }; Dialogue numbers This feature shows a dialogue number next to the dialogue line (visual for Dialogue keyboard controls ). To turn this on you just set InfoManagerNumKeysNumbers variable to true. (in your INIT_GLOBAL() function). 1 InfoManagerNumKeysNumbers = TRUE ; Dialogue keyboard controls Note This has also been fixed in Union and we noticed a strange behavior with different keyboard layouts. This feature changes the way number keys affect dialogue selection. The first dialogue is no longer 0 and you highlight the dialogue option by pressing appropriate number. 1 InfoManagerNumKeysControls = TRUE ; Spinners This is by far the most flashy feature of EIM as it allows you to use left/right arrow keys on a dialogue option to increase/decease numerical value. This can be used in many ways. This feature is a bit more complex: 1. Set up a standard dialogue Notice Notice we are using \" dummy \" as a description, since it is going to get updated. If something goes wrong the \" dummy \" string shows up and you can clearly tell something went wrong. 1 2 3 4 5 6 7 8 INSTANCE PC_Pan_Cook_Meat ( C_Info ) { nr = 1 ; condition = PC_Pan_Cook_Meat_Condition ; information = PC_Pan_Cook_Meat_Info ; permanent = TRUE ; description = \"dummy\" ; //Description is updated in PC_Pan_Cook_Meat_Condition }; Most of the magic takes place in the condition function (apart from the code behind the scenes, of course). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 var int selectedMeat ; // global variable for this spinner value FUNC INT PC_Pan_Cook_Meat_Condition () { if ( PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN ) { var string lastSpinnerID ; var int total ; total = NPC_HasItems ( self , ItFoMuttonRaw ); if ( selectedMeat == 0 ) { selectedMeat = 1 ; }; //Default initial value //Check currently selected spinned ID --> is it this one? if ( Hlp_StrCmp ( InfoManagerSpinnerID , \"CookMeat\" )) { //Setup spinner if spinner ID has changed if ( ! Hlp_StrCmp ( InfoManagerSpinnerID , lastSpinnerID )) { //Restore previous value InfoManagerSpinnerValue = selectedMeat ; }; //Page Up/Down quantity InfoManagerSpinnerPageSize = 5 ; //Min/Max value (Home/End keys) InfoManagerSpinnerValueMin = 1 ; InfoManagerSpinnerValueMax = total ; //Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT selectedMeat = InfoManagerSpinnerValue ; }; lastSpinnerID = InfoManagerSpinnerID ; //Remember last active spinner ID var string newDescription ; //Spinner ID 'CookMeat' newDescription = \"s@CookMeat Cook some meat: \" ; newDescription = ConcatStrings ( newDescription , IntToString ( selectedMeat )); newDescription = ConcatStrings ( newDescription , \" / \" ); newDescription = ConcatStrings ( newDescription , IntToString ( total )); //Update description PC_Pan_Cook_Meat . description = newDescription ; return TRUE ; }; return FALSE ; }; We can use the spinner value stored in selectedMeat variable here in the info function to create the meat (or do other stuff with it). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 FUNC VOID PC_Pan_Cook_Meat_Info () { //If we don't have any meat ... don't cook any :) if ( ! NPC_HasItems ( self , ItFoMuttonRaw )) { return ; }; //This should not happen - but you never know! if ( selectedMeat < 1 ) { return ; }; //This should not happen either! but just in case if ( selectedMeat > ( NPC_HasItems ( self , ItFoMuttonRaw ))) { selectedMeat = NPC_HasItems ( self , ItFoMuttonRaw ); }; NPC_RemoveInvItems ( self , ItFoMuttonRaw , selectedMeat ); CreateInvItems ( self , ItFoMutton , selectedMeat ); //Reset value for next time selectedMeat = 1 ; }; Spinners: Full code example Spinner example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 INSTANCE PC_Pan_Cook_Meat ( C_Info ) { nr = 1 ; condition = PC_Pan_Cook_Meat_Condition ; information = PC_Pan_Cook_Meat_Info ; permanent = TRUE ; description = \"dummy\" ; //Description is updated in PC_Pan_Cook_Meat_Condition }; var int selectedMeat ; FUNC INT PC_Pan_Cook_Meat_Condition () { if ( PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN ) { var string lastSpinnerID ; var int total ; total = NPC_HasItems ( self , ItFoMuttonRaw ); if ( selectedMeat == 0 ) { selectedMeat = 1 ; }; //Default initial value //Check currently selected spinned ID --> is it this one? if ( Hlp_StrCmp ( InfoManagerSpinnerID , \"CookMeat\" )) { //Setup spinner if spinner ID has changed if ( ! Hlp_StrCmp ( InfoManagerSpinnerID , lastSpinnerID )) { //Restore previous value InfoManagerSpinnerValue = selectedMeat ; }; //Page Up/Down quantity InfoManagerSpinnerPageSize = 5 ; //Min/Max value (Home/End keys) InfoManagerSpinnerValueMin = 1 ; InfoManagerSpinnerValueMax = total ; //Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT selectedMeat = InfoManagerSpinnerValue ; }; lastSpinnerID = InfoManagerSpinnerID ; //Remember last active spinner ID var string newDescription ; //Spinner ID 'CookMeat' newDescription = \"s@CookMeat Cook some meat: \" ; newDescription = ConcatStrings ( newDescription , IntToString ( selectedMeat )); newDescription = ConcatStrings ( newDescription , \" / \" ); newDescription = ConcatStrings ( newDescription , IntToString ( total )); //Update description PC_Pan_Cook_Meat . description = newDescription ; return TRUE ; }; return FALSE ; }; FUNC VOID PC_Pan_Cook_Meat_Info () { //If we don't have any meat ... don't cook any :) if ( ! NPC_HasItems ( self , ItFoMuttonRaw )) { return ; }; //This should not happen - but you never know! if ( selectedMeat < 1 ) { return ; }; //This should not happen either! but just in case if ( selectedMeat > ( NPC_HasItems ( self , ItFoMuttonRaw ))) { selectedMeat = NPC_HasItems ( self , ItFoMuttonRaw ); }; NPC_RemoveInvItems ( self , ItFoMuttonRaw , selectedMeat ); CreateInvItems ( self , ItFoMutton , selectedMeat ); //Reset value for next time InfoManagerSpinnerValue = 1 ; }; INSTANCE PC_Pan_Cook_Meat_Exit ( C_Info ) { nr = 999 ; condition = PC_Pan_Cook_Meat_Exit_Condition ; information = PC_Pan_Cook_Meat_Exit_Info ; permanent = TRUE ; description = \"End\" ; }; FUNC INT PC_Pan_Cook_Meat_Exit_Condition () { if ( PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN ) { return TRUE ; }; return FALSE ; }; FUNC VOID PC_Pan_Cook_Meat_Exit_Info () { if ( PLAYER_MOBSI_PRODUCTION != MOBSI_DIALOG_NONE ) { PLAYER_MOBSI_PRODUCTION = MOBSI_DIALOG_NONE ; hero . aivar [ AIV_INVINCIBLE ] = FALSE ; AI_StopProcessInfos ( hero ); }; };","title":"Enhanced Info Manager"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#enhanced-information-manager","text":"Warning This is a quick paste-in of and old version of AFSP's documentation and the information should be taken with a grain of salt. It may not be up-to-date since AFSP is being developed all the time and this is only a demo page. Enhanced Information Manager allows you to more precisely control the Information Manager (dialogue manager). Change color, font and much more! This package \"scans\" the dialogue string for modifiers and alters the string based on the modifiers you specify.","title":"Enhanced Information Manager"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#initialization","text":"To use this feature you have to: Add _headers_G[1/2]_EnhancedInfoManager.src or _headers_G[1/2]_All.src to your Gothic.src after Ikarus and LeGo initialization. Call G12_EnhancedInfoManager_Init(); from your INIT_GLOBAL() function in Startup.d","title":"Initialization"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-colour","text":"Set font color for a dialogue choice. 1 h@[hex color value] Set font color for highlighted dialogue choice. 1 hs@[hex color value] Example 1 description = \"h@2a85a3 hs@2ea9d1 This dialogue is blue.\" ;","title":"Change colour"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-font","text":"Set font itself for a dialogue choice. 1 f@[font name] Set font itself for highlighted dialogue choice. 1 fs@[font name] Example 1 description = \"f@font_old_20_white.tga fs@font_old_10_white.tga This dialogue has a different font, when selected.\" ;","title":"Change font"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-text-alignment","text":"Align text left. 1 al@ Align text center. 1 ac@ Align text right. 1 ar@ Example 1 2 3 description = \"al@ This dialogue has LEFT alignment.\" ; description = \"ac@ This dialogue has CENTER alignment.\" ; description = \"ar@ This dialogue has RIGHT alignment.\" ;","title":"Change text alignment"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#disable-dialogue","text":"Player cannot highlight (and select) this dialogue. 1 d@","title":"Disable dialogue"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#text-input-field","text":"Input field allows you to turn a dialogue choice into an input text field. 1 a@ Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 INSTANCE DIA_Xardas_Password ( C_Info ) { npc = NONE_100_Xardas ; nr = 1 ; condition = DIA_Xardas_Password_Condition ; information = DIA_Xardas_Password_Info ; permanent = FALSE ; description = \"a@ What is the password to get to the Mages of Water?\" ; }; FUNC INT DIA_Xardas_Password_Condition () { return TRUE ; }; FUNC VOID DIA_Xardas_Password_Info () { if ( Hlp_StrCmp ( InfoManagerAnswer , \"TETRIANDOCH\" )) { PrintScreen ( \"Yes that is correct!\" , - 1 , - 1 , \"font_old_10_white.tga\" , 3 ); } else { PrintScreen ( \"No that is wrong!\" , - 1 , - 1 , \"font_old_10_white.tga\" , 3 ); }; };","title":"Text input field"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#dialogue-numbers","text":"This feature shows a dialogue number next to the dialogue line (visual for Dialogue keyboard controls ). To turn this on you just set InfoManagerNumKeysNumbers variable to true. (in your INIT_GLOBAL() function). 1 InfoManagerNumKeysNumbers = TRUE ;","title":"Dialogue numbers"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#dialogue-keyboard-controls","text":"Note This has also been fixed in Union and we noticed a strange behavior with different keyboard layouts. This feature changes the way number keys affect dialogue selection. The first dialogue is no longer 0 and you highlight the dialogue option by pressing appropriate number. 1 InfoManagerNumKeysControls = TRUE ;","title":"Dialogue keyboard controls"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#spinners","text":"This is by far the most flashy feature of EIM as it allows you to use left/right arrow keys on a dialogue option to increase/decease numerical value. This can be used in many ways. This feature is a bit more complex: 1. Set up a standard dialogue Notice Notice we are using \" dummy \" as a description, since it is going to get updated. If something goes wrong the \" dummy \" string shows up and you can clearly tell something went wrong. 1 2 3 4 5 6 7 8 INSTANCE PC_Pan_Cook_Meat ( C_Info ) { nr = 1 ; condition = PC_Pan_Cook_Meat_Condition ; information = PC_Pan_Cook_Meat_Info ; permanent = TRUE ; description = \"dummy\" ; //Description is updated in PC_Pan_Cook_Meat_Condition }; Most of the magic takes place in the condition function (apart from the code behind the scenes, of course). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 var int selectedMeat ; // global variable for this spinner value FUNC INT PC_Pan_Cook_Meat_Condition () { if ( PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN ) { var string lastSpinnerID ; var int total ; total = NPC_HasItems ( self , ItFoMuttonRaw ); if ( selectedMeat == 0 ) { selectedMeat = 1 ; }; //Default initial value //Check currently selected spinned ID --> is it this one? if ( Hlp_StrCmp ( InfoManagerSpinnerID , \"CookMeat\" )) { //Setup spinner if spinner ID has changed if ( ! Hlp_StrCmp ( InfoManagerSpinnerID , lastSpinnerID )) { //Restore previous value InfoManagerSpinnerValue = selectedMeat ; }; //Page Up/Down quantity InfoManagerSpinnerPageSize = 5 ; //Min/Max value (Home/End keys) InfoManagerSpinnerValueMin = 1 ; InfoManagerSpinnerValueMax = total ; //Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT selectedMeat = InfoManagerSpinnerValue ; }; lastSpinnerID = InfoManagerSpinnerID ; //Remember last active spinner ID var string newDescription ; //Spinner ID 'CookMeat' newDescription = \"s@CookMeat Cook some meat: \" ; newDescription = ConcatStrings ( newDescription , IntToString ( selectedMeat )); newDescription = ConcatStrings ( newDescription , \" / \" ); newDescription = ConcatStrings ( newDescription , IntToString ( total )); //Update description PC_Pan_Cook_Meat . description = newDescription ; return TRUE ; }; return FALSE ; }; We can use the spinner value stored in selectedMeat variable here in the info function to create the meat (or do other stuff with it). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 FUNC VOID PC_Pan_Cook_Meat_Info () { //If we don't have any meat ... don't cook any :) if ( ! NPC_HasItems ( self , ItFoMuttonRaw )) { return ; }; //This should not happen - but you never know! if ( selectedMeat < 1 ) { return ; }; //This should not happen either! but just in case if ( selectedMeat > ( NPC_HasItems ( self , ItFoMuttonRaw ))) { selectedMeat = NPC_HasItems ( self , ItFoMuttonRaw ); }; NPC_RemoveInvItems ( self , ItFoMuttonRaw , selectedMeat ); CreateInvItems ( self , ItFoMutton , selectedMeat ); //Reset value for next time selectedMeat = 1 ; };","title":"Spinners"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#spinners-full-code-example","text":"Spinner example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 INSTANCE PC_Pan_Cook_Meat ( C_Info ) { nr = 1 ; condition = PC_Pan_Cook_Meat_Condition ; information = PC_Pan_Cook_Meat_Info ; permanent = TRUE ; description = \"dummy\" ; //Description is updated in PC_Pan_Cook_Meat_Condition }; var int selectedMeat ; FUNC INT PC_Pan_Cook_Meat_Condition () { if ( PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN ) { var string lastSpinnerID ; var int total ; total = NPC_HasItems ( self , ItFoMuttonRaw ); if ( selectedMeat == 0 ) { selectedMeat = 1 ; }; //Default initial value //Check currently selected spinned ID --> is it this one? if ( Hlp_StrCmp ( InfoManagerSpinnerID , \"CookMeat\" )) { //Setup spinner if spinner ID has changed if ( ! Hlp_StrCmp ( InfoManagerSpinnerID , lastSpinnerID )) { //Restore previous value InfoManagerSpinnerValue = selectedMeat ; }; //Page Up/Down quantity InfoManagerSpinnerPageSize = 5 ; //Min/Max value (Home/End keys) InfoManagerSpinnerValueMin = 1 ; InfoManagerSpinnerValueMax = total ; //Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT selectedMeat = InfoManagerSpinnerValue ; }; lastSpinnerID = InfoManagerSpinnerID ; //Remember last active spinner ID var string newDescription ; //Spinner ID 'CookMeat' newDescription = \"s@CookMeat Cook some meat: \" ; newDescription = ConcatStrings ( newDescription , IntToString ( selectedMeat )); newDescription = ConcatStrings ( newDescription , \" / \" ); newDescription = ConcatStrings ( newDescription , IntToString ( total )); //Update description PC_Pan_Cook_Meat . description = newDescription ; return TRUE ; }; return FALSE ; }; FUNC VOID PC_Pan_Cook_Meat_Info () { //If we don't have any meat ... don't cook any :) if ( ! NPC_HasItems ( self , ItFoMuttonRaw )) { return ; }; //This should not happen - but you never know! if ( selectedMeat < 1 ) { return ; }; //This should not happen either! but just in case if ( selectedMeat > ( NPC_HasItems ( self , ItFoMuttonRaw ))) { selectedMeat = NPC_HasItems ( self , ItFoMuttonRaw ); }; NPC_RemoveInvItems ( self , ItFoMuttonRaw , selectedMeat ); CreateInvItems ( self , ItFoMutton , selectedMeat ); //Reset value for next time InfoManagerSpinnerValue = 1 ; }; INSTANCE PC_Pan_Cook_Meat_Exit ( C_Info ) { nr = 999 ; condition = PC_Pan_Cook_Meat_Exit_Condition ; information = PC_Pan_Cook_Meat_Exit_Info ; permanent = TRUE ; description = \"End\" ; }; FUNC INT PC_Pan_Cook_Meat_Exit_Condition () { if ( PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN ) { return TRUE ; }; return FALSE ; }; FUNC VOID PC_Pan_Cook_Meat_Exit_Info () { if ( PLAYER_MOBSI_PRODUCTION != MOBSI_DIALOG_NONE ) { PLAYER_MOBSI_PRODUCTION = MOBSI_DIALOG_NONE ; hero . aivar [ AIV_INVINCIBLE ] = FALSE ; AI_StopProcessInfos ( hero ); }; };","title":"Spinners: Full code example"},{"location":"zengin/scripts/extenders/lego/","text":"LeGo LeGo ( Le hona Go ttfried) is a script packet built on top of Ikarus . Contacts Author Lehona, Gottfried & contributors GitHub LeGo Forum LeGo Note The code for LeGo is hosted on GitHub and LeGo has its very own documentation page .","title":"LeGo"},{"location":"zengin/scripts/extenders/lego/#lego","text":"LeGo ( Le hona Go ttfried) is a script packet built on top of Ikarus . Contacts Author Lehona, Gottfried & contributors GitHub LeGo Forum LeGo Note The code for LeGo is hosted on GitHub and LeGo has its very own documentation page .","title":"LeGo"},{"location":"zengin/scripts/extenders/lego/bars/","text":"Bars This package makes it very easy to add new bars, for e.g. stamina. Dependencies PermMem View Initialization Initialize with LeGo_Bars flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_Bars ); Implementation Bars.d on GitHub Functions Note If the GothicBar@ prototype is selected as the initial type, the user's own bars are visually indistinguishable from those used in Gothic. Bar_Create Creates a new bar from a constructor instance. 1 func int Bar_Create ( var int bar ) {}; bar - constructor instance of 'Bar' class return - handle to the new bar Bar_Delete Deletes a bar from the screen and from memory. 1 func void Bar_Delete ( var int handle ) {}; handle - handle returned from Bar_Create Bar_SetMax Changes a bar's maximum value but does not update its bar length (only Bar_SetPercent , Bar_SetPromille and Bar_SetValue ) 1 func void Bar_SetMax ( var int handle , var int max ) {}; handle - handle returned from Bar_Create max - the new maximum value Bar_SetValue Sets the value of the bar. 1 func void Bar_SetValue ( var int handle , var int value ) {}; handle - handle returned from Bar_Create value - new value of the bar Bar_SetPercent Sets the value of the bar but as a percentage (0..100). 1 func void Bar_SetPercent ( var int handle , var int percent ) {}; handle - handle returned from Bar_Create percent - new value of the bar in percent Bar_SetPromille Sets the value of the bar but per mille (0..1000). 1 func void Bar_SetPromille ( var int handle , var int promille ) {}; handle - handle returned from Bar_Create promille - new value of the bar in per mille Bar_Hide Hides a bar. It will not be deleted. 1 func void Bar_Hide ( var int handle ) {}; handle - handle returned from Bar_Create Bar_Show Displays a bar again after using Bar_Hide . 1 func void Bar_Show ( var int handle ) {}; handle - handle returned from Bar_Create Bar_MoveTo Move the bar to virtual position. 1 func void Bar_MoveTo ( var int handle , var int x , var int y ) {}; handle - handle returned from Bar_Create x - new horizontal position y - new vertical position Bar_SetAlpha Sets the opacity of the bar. 1 func void Bar_SetAlpha ( var int handle , var int alpha ) {}; handle - handle returned from Bar_Create alpha - transparency value (0..255) Bar_SetBarTexture Sets the foreground texture of the bar. 1 func void Bar_SetBarTexture ( var int handle , var string texture ) {}; handle - handle returned from Bar_Create texture - the new foreground texture Bar_SetBackTexture Sets the background texture of the bar. 1 func void Bar_SetBackTexture ( var int handle , var string texture ) {}; handle - handle returned from Bar_Create texture - The new background texture Examples Note The bars assume a certain basic understanding of the PermMem module. Display a simple bar First we just create a bar that does nothing. It should only be half full (or empty?) on the screen. 1 2 3 4 5 func void Example_1 () { var int bar ; bar = Bar_Create ( GothicBar@ ); // Create a new bar Bar_SetPercent ( bar , 50 ); // And set the value to 50% }; Finished. Without any settings? And what is GothicBar ? Let's take a look at a more elaborate example. A dedicated experience bar Bars implement the Bar class. It looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Bar { var int x ; // X position on screen (middle of bar) var int y ; // Y position on screen (middle of bar) var int barTop ; // Spacing bar - background top/bottom var int barLeft ; // Spacing bar - background left/right var int width ; // Width var int height ; // Height var string backTex ; // background texture var string barTex ; // Actual bar texture var int value ; // Start value var int valueMax ; // Maximum value }; The GothicBar prototype is a bar that mimics the standard Gothic status bar. 1 2 3 4 5 6 7 8 9 10 11 12 13 prototype GothicBar ( Bar ) { x = Print_Screen [ PS_X ] / 2 ; y = Print_Screen [ PS_Y ] - 20 ; barTop = 3 ; barLeft = 7 ; width = 180 ; height = 20 ; backTex = \"Bar_Back.tga\" ; barTex = \"Bar_Misc.tga\" ; value = 100 ; valueMax = 100 ; }; It is much easier to set up a new instance using this prototype. Standard vanilla status bar can be easily created using the GothicBar instance, as seen in the example below. GothicBar is located in the middle of the screen and looks exactly like the Gothic Underwater Bar. But let us make a bar that hangs in the top left of the picture and displays the experience points. Derive again GothicBar and only change the position. Of course add a loop using the FrameFunctions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Instance created from instance Bar_1 ( GothicBar ) { x = 100 ; y = 20 ; }; func void Example_1 () { // Example_1 could e.g. be called in Init_Global FF_ApplyOnce ( Loop_1 ); }; func void Loop_1 () { // Example_1 gets this loop running. // Here the bar should be constructed once // and then adapted to the EXP of the hero: var int MyBar ; if ( ! Hlp_IsValidHandle ( MyBar )) { MyBar = Bar_Create ( Bar_1 ); // Our Bar_1 }; // The rest is probably self-explanatory: Bar_SetMax ( MyBar , hero . exp_next ); Bar_SetValue ( MyBar , hero . exp ); }; Note This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website","title":"Bars"},{"location":"zengin/scripts/extenders/lego/bars/#bars","text":"This package makes it very easy to add new bars, for e.g. stamina.","title":"Bars"},{"location":"zengin/scripts/extenders/lego/bars/#dependencies","text":"PermMem View","title":"Dependencies"},{"location":"zengin/scripts/extenders/lego/bars/#initialization","text":"Initialize with LeGo_Bars flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_Bars );","title":"Initialization"},{"location":"zengin/scripts/extenders/lego/bars/#implementation","text":"Bars.d on GitHub","title":"Implementation"},{"location":"zengin/scripts/extenders/lego/bars/#functions","text":"Note If the GothicBar@ prototype is selected as the initial type, the user's own bars are visually indistinguishable from those used in Gothic.","title":"Functions"},{"location":"zengin/scripts/extenders/lego/bars/#bar_create","text":"Creates a new bar from a constructor instance. 1 func int Bar_Create ( var int bar ) {}; bar - constructor instance of 'Bar' class return - handle to the new bar","title":"Bar_Create"},{"location":"zengin/scripts/extenders/lego/bars/#bar_delete","text":"Deletes a bar from the screen and from memory. 1 func void Bar_Delete ( var int handle ) {}; handle - handle returned from Bar_Create","title":"Bar_Delete"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setmax","text":"Changes a bar's maximum value but does not update its bar length (only Bar_SetPercent , Bar_SetPromille and Bar_SetValue ) 1 func void Bar_SetMax ( var int handle , var int max ) {}; handle - handle returned from Bar_Create max - the new maximum value","title":"Bar_SetMax"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setvalue","text":"Sets the value of the bar. 1 func void Bar_SetValue ( var int handle , var int value ) {}; handle - handle returned from Bar_Create value - new value of the bar","title":"Bar_SetValue"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setpercent","text":"Sets the value of the bar but as a percentage (0..100). 1 func void Bar_SetPercent ( var int handle , var int percent ) {}; handle - handle returned from Bar_Create percent - new value of the bar in percent","title":"Bar_SetPercent"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setpromille","text":"Sets the value of the bar but per mille (0..1000). 1 func void Bar_SetPromille ( var int handle , var int promille ) {}; handle - handle returned from Bar_Create promille - new value of the bar in per mille","title":"Bar_SetPromille"},{"location":"zengin/scripts/extenders/lego/bars/#bar_hide","text":"Hides a bar. It will not be deleted. 1 func void Bar_Hide ( var int handle ) {}; handle - handle returned from Bar_Create","title":"Bar_Hide"},{"location":"zengin/scripts/extenders/lego/bars/#bar_show","text":"Displays a bar again after using Bar_Hide . 1 func void Bar_Show ( var int handle ) {}; handle - handle returned from Bar_Create","title":"Bar_Show"},{"location":"zengin/scripts/extenders/lego/bars/#bar_moveto","text":"Move the bar to virtual position. 1 func void Bar_MoveTo ( var int handle , var int x , var int y ) {}; handle - handle returned from Bar_Create x - new horizontal position y - new vertical position","title":"Bar_MoveTo"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setalpha","text":"Sets the opacity of the bar. 1 func void Bar_SetAlpha ( var int handle , var int alpha ) {}; handle - handle returned from Bar_Create alpha - transparency value (0..255)","title":"Bar_SetAlpha"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setbartexture","text":"Sets the foreground texture of the bar. 1 func void Bar_SetBarTexture ( var int handle , var string texture ) {}; handle - handle returned from Bar_Create texture - the new foreground texture","title":"Bar_SetBarTexture"},{"location":"zengin/scripts/extenders/lego/bars/#bar_setbacktexture","text":"Sets the background texture of the bar. 1 func void Bar_SetBackTexture ( var int handle , var string texture ) {}; handle - handle returned from Bar_Create texture - The new background texture","title":"Bar_SetBackTexture"},{"location":"zengin/scripts/extenders/lego/bars/#examples","text":"Note The bars assume a certain basic understanding of the PermMem module.","title":"Examples"},{"location":"zengin/scripts/extenders/lego/bars/#display-a-simple-bar","text":"First we just create a bar that does nothing. It should only be half full (or empty?) on the screen. 1 2 3 4 5 func void Example_1 () { var int bar ; bar = Bar_Create ( GothicBar@ ); // Create a new bar Bar_SetPercent ( bar , 50 ); // And set the value to 50% }; Finished. Without any settings? And what is GothicBar ? Let's take a look at a more elaborate example.","title":"Display a simple bar"},{"location":"zengin/scripts/extenders/lego/bars/#a-dedicated-experience-bar","text":"Bars implement the Bar class. It looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Bar { var int x ; // X position on screen (middle of bar) var int y ; // Y position on screen (middle of bar) var int barTop ; // Spacing bar - background top/bottom var int barLeft ; // Spacing bar - background left/right var int width ; // Width var int height ; // Height var string backTex ; // background texture var string barTex ; // Actual bar texture var int value ; // Start value var int valueMax ; // Maximum value }; The GothicBar prototype is a bar that mimics the standard Gothic status bar. 1 2 3 4 5 6 7 8 9 10 11 12 13 prototype GothicBar ( Bar ) { x = Print_Screen [ PS_X ] / 2 ; y = Print_Screen [ PS_Y ] - 20 ; barTop = 3 ; barLeft = 7 ; width = 180 ; height = 20 ; backTex = \"Bar_Back.tga\" ; barTex = \"Bar_Misc.tga\" ; value = 100 ; valueMax = 100 ; }; It is much easier to set up a new instance using this prototype. Standard vanilla status bar can be easily created using the GothicBar instance, as seen in the example below. GothicBar is located in the middle of the screen and looks exactly like the Gothic Underwater Bar. But let us make a bar that hangs in the top left of the picture and displays the experience points. Derive again GothicBar and only change the position. Of course add a loop using the FrameFunctions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Instance created from instance Bar_1 ( GothicBar ) { x = 100 ; y = 20 ; }; func void Example_1 () { // Example_1 could e.g. be called in Init_Global FF_ApplyOnce ( Loop_1 ); }; func void Loop_1 () { // Example_1 gets this loop running. // Here the bar should be constructed once // and then adapted to the EXP of the hero: var int MyBar ; if ( ! Hlp_IsValidHandle ( MyBar )) { MyBar = Bar_Create ( Bar_1 ); // Our Bar_1 }; // The rest is probably self-explanatory: Bar_SetMax ( MyBar , hero . exp_next ); Bar_SetValue ( MyBar , hero . exp ); }; Note This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website","title":"A dedicated experience bar"},{"location":"zengin/scripts/extenders/lego/console_commands/","text":"Console Commands This package allows you to create new console commands. Dependencies PermMem HookEngine Initialization Initialize with LeGo_ConsoleCommands flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_ConsoleCommands ); Implementation ConsoleCommands.d on GitHub Functions CC_Register Registers a new console command. 1 func void CC_Register ( var func f , var string cmdPrefix , var string description ) {}; f - This function is executed when the cmdPrefix command is entered in the console. The function signature is func string f(var string p0) . The string passed is everything that was specified in the console after the actual command. The return value is then displayed in the console. cmdPrefix - This is a command that can be entered in the console. description - This text appears next to the command (in zSpy) when you use the help command in the console. CC_Remove Removes a function from the console commands. 1 func void CC_Remove ( var func f ) {}; f - This function will be removed, i.e. the associated command will no longer work. CC_Active Checks whether the function passed is already part of a console command. 1 func int CC_Active ( var func f ) {}; f - function being checked return - TRUE if there is a corresponding function, FALSE otherwise. Examples Basic command example As a basic example - let us create a version command that prints a version of our modification. Firstly, we declare a constant string variable to hold the version string to be shown. 1 const string Mod_Version = \"My mod version 0.1alpha\" ; Next we create the command function. Note Notice the correct function signature. If you do not adhere to the correct function signature, the command will crash the game. 1 2 3 4 5 // This function is called by our console func string CC_ModVersion ( var string param ) { return Mod_Version ; }; We then have to register the functions. For convenience, I created a new RegisterConsoleFunctions function to initialize all console commands. The function is really simple. 1 2 3 4 func void RegisterConsoleFunctions () { CC_Register ( CC_ModVersion , \"mod_version\" , \"Version of my amazing mod.\" ); }; Lastly, we have to call this function from INIT_GLOBAL function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func void INIT_GLOBAL () { // will be called for every world (from INIT_<LevelName>) Game_InitGerman (); // Ikarus initialization MEM_InitAll (); // LeGo initialization LeGo_Init ( LeGo_ConsoleCommands ); // Here we register all of our commands RegisterConsoleFunctions (); // the rest of the code };","title":"ConsoleCommands"},{"location":"zengin/scripts/extenders/lego/console_commands/#console-commands","text":"This package allows you to create new console commands.","title":"Console Commands"},{"location":"zengin/scripts/extenders/lego/console_commands/#dependencies","text":"PermMem HookEngine","title":"Dependencies"},{"location":"zengin/scripts/extenders/lego/console_commands/#initialization","text":"Initialize with LeGo_ConsoleCommands flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_ConsoleCommands );","title":"Initialization"},{"location":"zengin/scripts/extenders/lego/console_commands/#implementation","text":"ConsoleCommands.d on GitHub","title":"Implementation"},{"location":"zengin/scripts/extenders/lego/console_commands/#functions","text":"","title":"Functions"},{"location":"zengin/scripts/extenders/lego/console_commands/#cc_register","text":"Registers a new console command. 1 func void CC_Register ( var func f , var string cmdPrefix , var string description ) {}; f - This function is executed when the cmdPrefix command is entered in the console. The function signature is func string f(var string p0) . The string passed is everything that was specified in the console after the actual command. The return value is then displayed in the console. cmdPrefix - This is a command that can be entered in the console. description - This text appears next to the command (in zSpy) when you use the help command in the console.","title":"CC_Register"},{"location":"zengin/scripts/extenders/lego/console_commands/#cc_remove","text":"Removes a function from the console commands. 1 func void CC_Remove ( var func f ) {}; f - This function will be removed, i.e. the associated command will no longer work.","title":"CC_Remove"},{"location":"zengin/scripts/extenders/lego/console_commands/#cc_active","text":"Checks whether the function passed is already part of a console command. 1 func int CC_Active ( var func f ) {}; f - function being checked return - TRUE if there is a corresponding function, FALSE otherwise.","title":"CC_Active"},{"location":"zengin/scripts/extenders/lego/console_commands/#examples","text":"","title":"Examples"},{"location":"zengin/scripts/extenders/lego/console_commands/#basic-command-example","text":"As a basic example - let us create a version command that prints a version of our modification. Firstly, we declare a constant string variable to hold the version string to be shown. 1 const string Mod_Version = \"My mod version 0.1alpha\" ; Next we create the command function. Note Notice the correct function signature. If you do not adhere to the correct function signature, the command will crash the game. 1 2 3 4 5 // This function is called by our console func string CC_ModVersion ( var string param ) { return Mod_Version ; }; We then have to register the functions. For convenience, I created a new RegisterConsoleFunctions function to initialize all console commands. The function is really simple. 1 2 3 4 func void RegisterConsoleFunctions () { CC_Register ( CC_ModVersion , \"mod_version\" , \"Version of my amazing mod.\" ); }; Lastly, we have to call this function from INIT_GLOBAL function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func void INIT_GLOBAL () { // will be called for every world (from INIT_<LevelName>) Game_InitGerman (); // Ikarus initialization MEM_InitAll (); // LeGo initialization LeGo_Init ( LeGo_ConsoleCommands ); // Here we register all of our commands RegisterConsoleFunctions (); // the rest of the code };","title":"Basic command example"},{"location":"zengin/scripts/extenders/lego/item_helper/","text":"ItemHelper This package is very simple - it retrieves a oCItem pointer from an C_Item instance valid for the current world and session. Warning Make sure every world has waypoint with name TOT (\"dead\" in German). Ikarus & LeGo need this waypoint to spawn helper NPCs. This is especially important in Gothic 1 since G1 vanilla worlds do not have the TOT waypoint. Dependencies No dependencies Initialization No initialization Implementation ItemHelper.d on GitHub Functions ITM_GetPtr 1 func int ITM_GetPtr ( var int instance ) {}; instance - C_Item instance to get the pointer of return - oCItem pointer of the C_Item instance","title":"ItemHelper"},{"location":"zengin/scripts/extenders/lego/item_helper/#itemhelper","text":"This package is very simple - it retrieves a oCItem pointer from an C_Item instance valid for the current world and session. Warning Make sure every world has waypoint with name TOT (\"dead\" in German). Ikarus & LeGo need this waypoint to spawn helper NPCs. This is especially important in Gothic 1 since G1 vanilla worlds do not have the TOT waypoint.","title":"ItemHelper"},{"location":"zengin/scripts/extenders/lego/item_helper/#dependencies","text":"No dependencies","title":"Dependencies"},{"location":"zengin/scripts/extenders/lego/item_helper/#initialization","text":"No initialization","title":"Initialization"},{"location":"zengin/scripts/extenders/lego/item_helper/#implementation","text":"ItemHelper.d on GitHub","title":"Implementation"},{"location":"zengin/scripts/extenders/lego/item_helper/#functions","text":"","title":"Functions"},{"location":"zengin/scripts/extenders/lego/item_helper/#itm_getptr","text":"1 func int ITM_GetPtr ( var int instance ) {}; instance - C_Item instance to get the pointer of return - oCItem pointer of the C_Item instance","title":"ITM_GetPtr"},{"location":"zengin/scripts/extenders/lego/misc/","text":"Misc The Misc package introduces various helper functions that did not fit into any other package. Dependencies No dependencies Initialization No initialization Implementation Misc.d on GitHub Functions atan2f Calculates the arcus tangent of an angle between the origin and (x, y) point 1 func float atan2f ( var int x , var int y ) {}; x - x-coordinate y - y-coordinate return - arcus tangent in radians as Ikarus float sin Calculates the sine of an angle given in radians. 1 func float sin ( var float angle ) {}; angle - the angle in radians as a Ikarus float return - sine of the angle cos Calculates the cosine of an angle given in radians. 1 func float cos ( var float angle ) {}; angle - the angle in radians as a Ikarus float return - cosine of the angle tan Calculates the tangent of an angle given in radians. 1 func float tan ( var float angle ) {}; angle - the angle in radians as a Ikarus float return - tangent of the angle asin Calculates the arcus sine 1 func float asin ( var float sine ) {}; sine - the sine of an angle return - arcus sine of the angle acos Calculates the arcus cosine 1 func float acos ( var float cosine ) {}; sine - the cosine of an angle return - arcus cosine of the angle distance2D Calculates the distance between two points on a two-dimensional plane 1 func int distance2D ( var int x1 , var int x2 , var int y1 , var int y2 ) {}; x1 - X-coordinate of the first point x2 - X-coordinate of the second point y1 - Y-coordinate of the first point y2 - Y-coordinate of the second point return - the distance between the two points distance2Df Calculates the distance between two points on a two-dimensional plane as Ikarus floats 1 func float distance2Df ( var float x1 , var float x2 , var float y1 , var float y2 ) {}; x1 - X-coordinate of the first point x2 - X-coordinate of the second point y1 - Y-coordinate of the first point y2 - Y-coordinate of the second point return - the distance between the two points as Ikarus float","title":"Misc"},{"location":"zengin/scripts/extenders/lego/misc/#misc","text":"The Misc package introduces various helper functions that did not fit into any other package.","title":"Misc"},{"location":"zengin/scripts/extenders/lego/misc/#dependencies","text":"No dependencies","title":"Dependencies"},{"location":"zengin/scripts/extenders/lego/misc/#initialization","text":"No initialization","title":"Initialization"},{"location":"zengin/scripts/extenders/lego/misc/#implementation","text":"Misc.d on GitHub","title":"Implementation"},{"location":"zengin/scripts/extenders/lego/misc/#functions","text":"","title":"Functions"},{"location":"zengin/scripts/extenders/lego/misc/#atan2f","text":"Calculates the arcus tangent of an angle between the origin and (x, y) point 1 func float atan2f ( var int x , var int y ) {}; x - x-coordinate y - y-coordinate return - arcus tangent in radians as Ikarus float","title":"atan2f"},{"location":"zengin/scripts/extenders/lego/misc/#sin","text":"Calculates the sine of an angle given in radians. 1 func float sin ( var float angle ) {}; angle - the angle in radians as a Ikarus float return - sine of the angle","title":"sin"},{"location":"zengin/scripts/extenders/lego/misc/#cos","text":"Calculates the cosine of an angle given in radians. 1 func float cos ( var float angle ) {}; angle - the angle in radians as a Ikarus float return - cosine of the angle","title":"cos"},{"location":"zengin/scripts/extenders/lego/misc/#tan","text":"Calculates the tangent of an angle given in radians. 1 func float tan ( var float angle ) {}; angle - the angle in radians as a Ikarus float return - tangent of the angle","title":"tan"},{"location":"zengin/scripts/extenders/lego/misc/#asin","text":"Calculates the arcus sine 1 func float asin ( var float sine ) {}; sine - the sine of an angle return - arcus sine of the angle","title":"asin"},{"location":"zengin/scripts/extenders/lego/misc/#acos","text":"Calculates the arcus cosine 1 func float acos ( var float cosine ) {}; sine - the cosine of an angle return - arcus cosine of the angle","title":"acos"},{"location":"zengin/scripts/extenders/lego/misc/#distance2d","text":"Calculates the distance between two points on a two-dimensional plane 1 func int distance2D ( var int x1 , var int x2 , var int y1 , var int y2 ) {}; x1 - X-coordinate of the first point x2 - X-coordinate of the second point y1 - Y-coordinate of the first point y2 - Y-coordinate of the second point return - the distance between the two points","title":"distance2D"},{"location":"zengin/scripts/extenders/lego/misc/#distance2df","text":"Calculates the distance between two points on a two-dimensional plane as Ikarus floats 1 func float distance2Df ( var float x1 , var float x2 , var float y1 , var float y2 ) {}; x1 - X-coordinate of the first point x2 - X-coordinate of the second point y1 - Y-coordinate of the first point y2 - Y-coordinate of the second point return - the distance between the two points as Ikarus float","title":"distance2Df"},{"location":"zengin/scripts/extenders/lego/talents/","text":"Talents The Talents package does two things: save any number of values for a specific NPC (effectively AIVar array extension). identify NPC by unique ID. Talents package uses one free AIVar variables, the default is AIVar with the index 89 that can be customized in Userconst.d the AIV_TALENT constant . Dependencies PermMem Initialization Initialize with LeGo_PermMem flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_PermMem ); Implementation Talents.d on GitHub Functions NPC_GetID Returns unique ID specific for provided NPC. 1 func int NPC_GetID ( var c_npc slf ) {}; slf NPC return NPCs unique ID NPC_FindByID Finds the NPC pointer of an NPC with the given ID. 1 func int NPC_FindByID ( var int ID ) {}; ID - NPC ID return - NPC pointer NPC_FindByID Finds the NPC pointer of an NPC with the given ID. 1 func int NPC_FindByID ( var int ID ) {}; ID NPC ID return NPC pointer TAL_CreateTalent Creates a talent into which you can later save a value for every NPC (just like AI_Var). 1 func int TAL_CreateTalent () {}; return - Value that can be later used as a talent index TAL_SetValue Sets a new value to the specified talent. 1 func void TAL_SetValue ( var c_npc npc , var int talent , var int value ) {}; npc - Set the talent value for this NPC talent - Talent ID value - Value to be set TAL_GetValue Returns the value of a saved talent for specified NPC. 1 func int TAL_GetValue ( var c_npc npc , var int talent ) {}; npc - Get the talent value from this NPC talent - Talent ID","title":"Talents"},{"location":"zengin/scripts/extenders/lego/talents/#talents","text":"The Talents package does two things: save any number of values for a specific NPC (effectively AIVar array extension). identify NPC by unique ID. Talents package uses one free AIVar variables, the default is AIVar with the index 89 that can be customized in Userconst.d the AIV_TALENT constant .","title":"Talents"},{"location":"zengin/scripts/extenders/lego/talents/#dependencies","text":"PermMem","title":"Dependencies"},{"location":"zengin/scripts/extenders/lego/talents/#initialization","text":"Initialize with LeGo_PermMem flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_PermMem );","title":"Initialization"},{"location":"zengin/scripts/extenders/lego/talents/#implementation","text":"Talents.d on GitHub","title":"Implementation"},{"location":"zengin/scripts/extenders/lego/talents/#functions","text":"","title":"Functions"},{"location":"zengin/scripts/extenders/lego/talents/#npc_getid","text":"Returns unique ID specific for provided NPC. 1 func int NPC_GetID ( var c_npc slf ) {}; slf NPC return NPCs unique ID","title":"NPC_GetID"},{"location":"zengin/scripts/extenders/lego/talents/#npc_findbyid","text":"Finds the NPC pointer of an NPC with the given ID. 1 func int NPC_FindByID ( var int ID ) {}; ID - NPC ID return - NPC pointer","title":"NPC_FindByID"},{"location":"zengin/scripts/extenders/lego/talents/#npc_findbyid_1","text":"Finds the NPC pointer of an NPC with the given ID. 1 func int NPC_FindByID ( var int ID ) {}; ID NPC ID return NPC pointer","title":"NPC_FindByID"},{"location":"zengin/scripts/extenders/lego/talents/#tal_createtalent","text":"Creates a talent into which you can later save a value for every NPC (just like AI_Var). 1 func int TAL_CreateTalent () {}; return - Value that can be later used as a talent index","title":"TAL_CreateTalent"},{"location":"zengin/scripts/extenders/lego/talents/#tal_setvalue","text":"Sets a new value to the specified talent. 1 func void TAL_SetValue ( var c_npc npc , var int talent , var int value ) {}; npc - Set the talent value for this NPC talent - Talent ID value - Value to be set","title":"TAL_SetValue"},{"location":"zengin/scripts/extenders/lego/talents/#tal_getvalue","text":"Returns the value of a saved talent for specified NPC. 1 func int TAL_GetValue ( var c_npc npc , var int talent ) {}; npc - Get the talent value from this NPC talent - Talent ID","title":"TAL_GetValue"},{"location":"zengin/scripts/extenders/lego/trialoge/","text":"Trialoge This package allows you to create conversations with any number of NPCs and control the camera during the dialog. Dependencies AI_Function Initialization Initialize with LeGo_Trialoge flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_Trialoge ); Implementation Trialoge.d on GitHub Functions EquipWeapon Sektenspinner's function. (Taken from the forum.) 1 func void EquipWeapon ( var c_npc slf , var int ItemInstance ) {}; slf - NPC to have a weapon equipped ItemInstance - weapon instance to be equipped Npc_GetArmor Returns NPC's equipped armor. 1 func int Npc_GetArmor ( var c_npc slf ) {}; slf - NPC to get the armour from return - armor instance Npc_GetMeleeWeapon Returns NPC's equipped melee weapon. 1 func int Npc_GetMeleeWeapon ( var c_npc slf ) {}; slf - NPC to get the weapon from DiaCAM_Update Sektenspinner's function. Updates the dialogue camera. (Used internally.) 1 func void DiaCAM_Update () {}; DiaCAM_Disable Completely disable the dialogue cameras. 1 func void DiaCAM_Disable () {}; DiaCAM_Enable Resets the dialogue cameras to the default settings. 1 func void DiaCAM_Enable () {}; TRIA_Wait Makes self and other wait for each other, e.g. for AI_GotoW P actions for synchronization. 1 func void TRIA_Wait () {}; TRIA_Invite Invites an NPC into a conversation. Must be called before TRIA_Start . 1 func void TRIA_Invite ( c_npc slf ) {}; slf - The invited NPC TRIA_Start Starts trialogues. Before that, all NPC's should be invited by TRI_Invite . 1 func void TRIA_Start () {}; TRIA_Barrier Similar to TRIA_Wait but applies to all participating NPCs. 1 func void TRIA_Barrier () {}; TRIA_Next Sets the called npc to self . 1 func void TRIA_Next ( c_npc n0 ) {}; n0 - can be addressed with self TRIA_Cam Starts a tracking shot. 1 func void TRIA_Cam ( string evt ) {}; evt - the name of the tracking shot in Spacer. If \"\" is passed, the running trace shot will be aborted TRIA_Finish Ends an ongoing trialogue. Must always be called at the end, otherwise no further trialogues can be started. 1 func void TRIA_Finish () {}; Examples A Simple Trialogue The following conversation is resolved via the trialogues: Arto: Sorry hero, but you can't pass here Hero: Why not? Horka: The city has been closed. Hero: I have some gold with me, can we trade? Squelto: No. We are not open to bribery. Hero: Sure? Arto: I have to ask you to leave now Hero: Well... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 instance TRIA_Test ( C_INFO ) { npc = PAL_100_Friend ; nr = 10 ; condition = TRIA_Test_condition ; information = TRIA_Test_info ; important = FALSE ; permanent = 1 ; description = \"TRIALOGTEST\" ; }; func int TRIA_Test_condition () { return TRUE ; }; func void TRIA_Test_info () { var c_npc Arto ; Arto = Hlp_GetNpc ( PAL_100_Friend ); // He is the owner of dialogue var c_npc Horka ; Horka = Hlp_GetNpc ( PAL_101_Horka ); var c_npc Squelto ; Squelto = Hlp_GetNpc ( PAL_102_Squelto ); TRIA_Invite ( Horka ); // Invite Horka into this dialogue TRIA_Invite ( Squelto ); // Invite Squelto into this dialog TRIA_Start (); // Start the conversation // The hero and Arto do not have to/may not be invited. They are in dialogue anyway. // Hero now talks to Arto (self = Arto, other = Hero) TRIA_Next ( Arto ); DIAG_Reset (); AI_Output ( self , other , \"TRIA_TEST_00\" ); //Sorry hero, but you can't pass here // Hero now talks to Horka (self = Horka, other = Hero) TRIA_Next ( Horka ); AI_Output ( other , self , \"TRIA_TEST_01\" ); //Why not? AI_GotoNpc ( self , other ); AI_TurnToNpc ( other , self ); AI_Output ( self , other , \"TRIA_TEST_02\" ); //The city has been closed. // Held looks around conspiratorially during the next sentence DIAG ( \"Nervous\" , 1 , 2 ); AI_Output ( other , self , \"TRIA_TEST_03\" ); //I have some gold with me, can we trade? // Hero should now move normally again DIAG_Reset (); // Start tracking shot TRIA_Cam ( \"CAMERASTART\" ); // Hero now talks to Squelto (self = Squelto, other = Hero) TRIA_Next ( Squelto ); AI_TurnToNpc ( other , self ); DIAG ( \"No\" , 0 , 1 ); AI_Output ( self , other , \"TRIA_TEST_04\" ); //No. We are not open to bribery. // Hero talks to Arto again (self = Arto, other = Hero) TRIA_Next ( Arto ); // Hero should now articulate questioningly DIAG ( \"NotSure\" , 0 , 1 ); AI_Output ( other , self , \"TRIA_TEST_05\" ); //Sure? AI_TurnToNpc ( other , self ); // tracking shot end TRIA_Cam ( \"\" ); // Arto should react angrily DIAG ( \"Angry\" , 0 , 4 ); AI_Output ( self , other , \"TRIA_TEST_06\" ); //I have to ask you to leave now // Hero should now move normally again DIAG_Reset (); AI_Output ( other , self , \"TRIA_TEST_07\" ); //Well... TRIA_Finish (); // End }; Note In addition, here are still dialog gestures used (the page will be added later).","title":"Trialoge"},{"location":"zengin/scripts/extenders/lego/trialoge/#trialoge","text":"This package allows you to create conversations with any number of NPCs and control the camera during the dialog.","title":"Trialoge"},{"location":"zengin/scripts/extenders/lego/trialoge/#dependencies","text":"AI_Function","title":"Dependencies"},{"location":"zengin/scripts/extenders/lego/trialoge/#initialization","text":"Initialize with LeGo_Trialoge flag. 1 2 func void LeGo_Init ( var int flags ) {}; LeGo_Init ( LeGo_Trialoge );","title":"Initialization"},{"location":"zengin/scripts/extenders/lego/trialoge/#implementation","text":"Trialoge.d on GitHub","title":"Implementation"},{"location":"zengin/scripts/extenders/lego/trialoge/#functions","text":"","title":"Functions"},{"location":"zengin/scripts/extenders/lego/trialoge/#equipweapon","text":"Sektenspinner's function. (Taken from the forum.) 1 func void EquipWeapon ( var c_npc slf , var int ItemInstance ) {}; slf - NPC to have a weapon equipped ItemInstance - weapon instance to be equipped","title":"EquipWeapon"},{"location":"zengin/scripts/extenders/lego/trialoge/#npc_getarmor","text":"Returns NPC's equipped armor. 1 func int Npc_GetArmor ( var c_npc slf ) {}; slf - NPC to get the armour from return - armor instance","title":"Npc_GetArmor"},{"location":"zengin/scripts/extenders/lego/trialoge/#npc_getmeleeweapon","text":"Returns NPC's equipped melee weapon. 1 func int Npc_GetMeleeWeapon ( var c_npc slf ) {}; slf - NPC to get the weapon from","title":"Npc_GetMeleeWeapon"},{"location":"zengin/scripts/extenders/lego/trialoge/#diacam_update","text":"Sektenspinner's function. Updates the dialogue camera. (Used internally.) 1 func void DiaCAM_Update () {};","title":"DiaCAM_Update"},{"location":"zengin/scripts/extenders/lego/trialoge/#diacam_disable","text":"Completely disable the dialogue cameras. 1 func void DiaCAM_Disable () {};","title":"DiaCAM_Disable"},{"location":"zengin/scripts/extenders/lego/trialoge/#diacam_enable","text":"Resets the dialogue cameras to the default settings. 1 func void DiaCAM_Enable () {};","title":"DiaCAM_Enable"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_wait","text":"Makes self and other wait for each other, e.g. for AI_GotoW P actions for synchronization. 1 func void TRIA_Wait () {};","title":"TRIA_Wait"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_invite","text":"Invites an NPC into a conversation. Must be called before TRIA_Start . 1 func void TRIA_Invite ( c_npc slf ) {}; slf - The invited NPC","title":"TRIA_Invite"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_start","text":"Starts trialogues. Before that, all NPC's should be invited by TRI_Invite . 1 func void TRIA_Start () {};","title":"TRIA_Start"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_barrier","text":"Similar to TRIA_Wait but applies to all participating NPCs. 1 func void TRIA_Barrier () {};","title":"TRIA_Barrier"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_next","text":"Sets the called npc to self . 1 func void TRIA_Next ( c_npc n0 ) {}; n0 - can be addressed with self","title":"TRIA_Next"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_cam","text":"Starts a tracking shot. 1 func void TRIA_Cam ( string evt ) {}; evt - the name of the tracking shot in Spacer. If \"\" is passed, the running trace shot will be aborted","title":"TRIA_Cam"},{"location":"zengin/scripts/extenders/lego/trialoge/#tria_finish","text":"Ends an ongoing trialogue. Must always be called at the end, otherwise no further trialogues can be started. 1 func void TRIA_Finish () {};","title":"TRIA_Finish"},{"location":"zengin/scripts/extenders/lego/trialoge/#examples","text":"","title":"Examples"},{"location":"zengin/scripts/extenders/lego/trialoge/#a-simple-trialogue","text":"The following conversation is resolved via the trialogues: Arto: Sorry hero, but you can't pass here Hero: Why not? Horka: The city has been closed. Hero: I have some gold with me, can we trade? Squelto: No. We are not open to bribery. Hero: Sure? Arto: I have to ask you to leave now Hero: Well... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 instance TRIA_Test ( C_INFO ) { npc = PAL_100_Friend ; nr = 10 ; condition = TRIA_Test_condition ; information = TRIA_Test_info ; important = FALSE ; permanent = 1 ; description = \"TRIALOGTEST\" ; }; func int TRIA_Test_condition () { return TRUE ; }; func void TRIA_Test_info () { var c_npc Arto ; Arto = Hlp_GetNpc ( PAL_100_Friend ); // He is the owner of dialogue var c_npc Horka ; Horka = Hlp_GetNpc ( PAL_101_Horka ); var c_npc Squelto ; Squelto = Hlp_GetNpc ( PAL_102_Squelto ); TRIA_Invite ( Horka ); // Invite Horka into this dialogue TRIA_Invite ( Squelto ); // Invite Squelto into this dialog TRIA_Start (); // Start the conversation // The hero and Arto do not have to/may not be invited. They are in dialogue anyway. // Hero now talks to Arto (self = Arto, other = Hero) TRIA_Next ( Arto ); DIAG_Reset (); AI_Output ( self , other , \"TRIA_TEST_00\" ); //Sorry hero, but you can't pass here // Hero now talks to Horka (self = Horka, other = Hero) TRIA_Next ( Horka ); AI_Output ( other , self , \"TRIA_TEST_01\" ); //Why not? AI_GotoNpc ( self , other ); AI_TurnToNpc ( other , self ); AI_Output ( self , other , \"TRIA_TEST_02\" ); //The city has been closed. // Held looks around conspiratorially during the next sentence DIAG ( \"Nervous\" , 1 , 2 ); AI_Output ( other , self , \"TRIA_TEST_03\" ); //I have some gold with me, can we trade? // Hero should now move normally again DIAG_Reset (); // Start tracking shot TRIA_Cam ( \"CAMERASTART\" ); // Hero now talks to Squelto (self = Squelto, other = Hero) TRIA_Next ( Squelto ); AI_TurnToNpc ( other , self ); DIAG ( \"No\" , 0 , 1 ); AI_Output ( self , other , \"TRIA_TEST_04\" ); //No. We are not open to bribery. // Hero talks to Arto again (self = Arto, other = Hero) TRIA_Next ( Arto ); // Hero should now articulate questioningly DIAG ( \"NotSure\" , 0 , 1 ); AI_Output ( other , self , \"TRIA_TEST_05\" ); //Sure? AI_TurnToNpc ( other , self ); // tracking shot end TRIA_Cam ( \"\" ); // Arto should react angrily DIAG ( \"Angry\" , 0 , 4 ); AI_Output ( self , other , \"TRIA_TEST_06\" ); //I have to ask you to leave now // Hero should now move normally again DIAG_Reset (); AI_Output ( other , self , \"TRIA_TEST_07\" ); //Well... TRIA_Finish (); // End }; Note In addition, here are still dialog gestures used (the page will be added later).","title":"A Simple Trialogue"},{"location":"zengin/scripts/extenders/zparserextender/","text":"zParserExtender zParserExtender extends ZenGins parser and adds many useful features. It significantly extends the functionality of scripts with added functionality and new external functions. It also enhances script compilation, allowing to compile OU files directly with the game and allowing for runtime script injection. Since the Union version 1.0m zParserExtender is fully integrated in Union itself. Note This is mostly a translation of the original release post Contacts Author Gratt GitHub zParserExtender Forum zParserExtender","title":"zParserExtender"},{"location":"zengin/scripts/extenders/zparserextender/#zparserextender","text":"zParserExtender extends ZenGins parser and adds many useful features. It significantly extends the functionality of scripts with added functionality and new external functions. It also enhances script compilation, allowing to compile OU files directly with the game and allowing for runtime script injection. Since the Union version 1.0m zParserExtender is fully integrated in Union itself. Note This is mostly a translation of the original release post Contacts Author Gratt GitHub zParserExtender Forum zParserExtender","title":"zParserExtender"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/","text":"Trigger functions and the C_Trigger class zParserExtender also implements cyclical functions called triggers - not to be confused with triggers in ZEN files, similar to a part of the functionality implemented in LeGo AI_Functions . These functions are called independently after a specified period of time. These triggers can also store user information. Up to 16 int variables can be stored in each trigger as well as self , other and victim instances. Class definition To define a trigger, the C_Trigger class is used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// Union zPraserExtender Trigger class class C_Trigger { var int Delay ; // defines the frequency (in miliseconds) at which the function will be called. var int Enabled ; // determines if the trigger is active. If the value is equal to zero, the trigger is destroyed. var int AIVariables [ 16 ]; // user data, which can be set independently when creating trigger (yes, you can write there absolutely everything you want). // Hidden variable members /* - Func - The function that the trigger will call. - Self - The NPC that will be placed in `self` when the function is called. - Other - An NPC that will be placed in `other` when the function is called. - Victim - The NPC that will be placed in `victim` when the function is called. */ }; Creating instances There are two external functions that are used to create C_Trigger instance. 1 2 3 4 5 6 7 8 9 10 // function returns a trigger with no NPC (self, other or victim) bound to it func C_Trigger AI_StartTriggerScript ( var string funcName , var int delay ) {}; // function is extended, if certain participants need to be assigned to it func C_Trigger AI_StartTriggerScriptEx ( var string funcName , var int delay , var C_Npc slf , var C_Npc oth , var C_Npc vct ) {}; Both of these functions return an instance of C_Trigger instance. You can of course configure the instance after its creation. You can, for example, fill in the AIVariables with relevant data. The trigger function has the required signature if 'func int f()'. It must return a value indicating the state of the loop. If the function returns LOOP_END the trigger will be stopped and the instance deleted. If LOOP_CONTINUE is returned, the function will be called again after Delay ms have passed. Poison example 1 2 3 4 5 6 7 8 9 // Implement a trigger to simulate the effect of poison debuff: // Let's create a trigger on function `c_loop` with a call interval of 1 second. // When the function is called, the instance hero will be placed in self (although it can be any other NPC if desired). // The rest of the instances are left null (not used). var C_Trigger trigger ; trigger = AI_StartTriggerScriptEx ( \"c_loop\" , 1000 , hero , null , null ); trigger . AIVariables [ 0 ] = 15 ; // how many times the function should be called trigger . AIVariables [ 1 ] = 5 ; // how much damage to deal each iteration The trigger function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func int c_loop () { // Create a loop end check, if the number of // available iterations has reached 0. If it did // we stop the trigger by returning the LOOP_END value. if ( SelfTrigger . AIVariables [ 0 ] <= 0 ) { return Loop_end ; }; SelfTrigger . Delay -= 20 ; // Accelerate loop each call by 20 ms SelfTrigger . AIVariables [ 0 ] -= 1 ; // Reduce number of remaining repeats self . Attribute [ ATR_HITPOINTS ] -= SelfTrigger . AIVariables [ 1 ]; // Take health from self return LOOP_CONTINUE ; }; Trigger scope Triggers can be divided into two types: Global trigger ( AI_StartTriggerScript ) trigger created using this function works in all worlds. A trigger is considered global by default if neither self nor other nor victim has been provided for it. Local trigger ( AI_StartTriggerScriptEx) trigger created with this function only works in the world in which it was created. A trigger is considered local if it has been presented with at least one NPC in self , other or victim (not null). If you want to create a trigger without linking it to any NPC, it is recommended to simply pass hero as self to the trigger. Saving The plugin creates a new save archive to save the information of the triggers that does not conflict with any of the built-in save files. Searching To search for a specific trigger, for example by NPC, the trigger external functions can be used. 1 2 3 4 5 6 7 8 9 // This way you can disable all triggers running on the `hero` instance var C_Trigger trigget = FirstTrigger ; var C_Trigger trigget_saved ; while ( ! Hlp_IsNULL ( trigget )) { trigget_saved = trigger ; trigger = AI_GetNextTriggerBySelf ( hero ); trigget_saved . Enabled = false ; };","title":"C_Trigger class"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#trigger-functions-and-the-c_trigger-class","text":"zParserExtender also implements cyclical functions called triggers - not to be confused with triggers in ZEN files, similar to a part of the functionality implemented in LeGo AI_Functions . These functions are called independently after a specified period of time. These triggers can also store user information. Up to 16 int variables can be stored in each trigger as well as self , other and victim instances.","title":"Trigger functions and the C_Trigger class"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#class-definition","text":"To define a trigger, the C_Trigger class is used: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /// Union zPraserExtender Trigger class class C_Trigger { var int Delay ; // defines the frequency (in miliseconds) at which the function will be called. var int Enabled ; // determines if the trigger is active. If the value is equal to zero, the trigger is destroyed. var int AIVariables [ 16 ]; // user data, which can be set independently when creating trigger (yes, you can write there absolutely everything you want). // Hidden variable members /* - Func - The function that the trigger will call. - Self - The NPC that will be placed in `self` when the function is called. - Other - An NPC that will be placed in `other` when the function is called. - Victim - The NPC that will be placed in `victim` when the function is called. */ };","title":"Class definition"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#creating-instances","text":"There are two external functions that are used to create C_Trigger instance. 1 2 3 4 5 6 7 8 9 10 // function returns a trigger with no NPC (self, other or victim) bound to it func C_Trigger AI_StartTriggerScript ( var string funcName , var int delay ) {}; // function is extended, if certain participants need to be assigned to it func C_Trigger AI_StartTriggerScriptEx ( var string funcName , var int delay , var C_Npc slf , var C_Npc oth , var C_Npc vct ) {}; Both of these functions return an instance of C_Trigger instance. You can of course configure the instance after its creation. You can, for example, fill in the AIVariables with relevant data. The trigger function has the required signature if 'func int f()'. It must return a value indicating the state of the loop. If the function returns LOOP_END the trigger will be stopped and the instance deleted. If LOOP_CONTINUE is returned, the function will be called again after Delay ms have passed.","title":"Creating instances"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#poison-example","text":"1 2 3 4 5 6 7 8 9 // Implement a trigger to simulate the effect of poison debuff: // Let's create a trigger on function `c_loop` with a call interval of 1 second. // When the function is called, the instance hero will be placed in self (although it can be any other NPC if desired). // The rest of the instances are left null (not used). var C_Trigger trigger ; trigger = AI_StartTriggerScriptEx ( \"c_loop\" , 1000 , hero , null , null ); trigger . AIVariables [ 0 ] = 15 ; // how many times the function should be called trigger . AIVariables [ 1 ] = 5 ; // how much damage to deal each iteration The trigger function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func int c_loop () { // Create a loop end check, if the number of // available iterations has reached 0. If it did // we stop the trigger by returning the LOOP_END value. if ( SelfTrigger . AIVariables [ 0 ] <= 0 ) { return Loop_end ; }; SelfTrigger . Delay -= 20 ; // Accelerate loop each call by 20 ms SelfTrigger . AIVariables [ 0 ] -= 1 ; // Reduce number of remaining repeats self . Attribute [ ATR_HITPOINTS ] -= SelfTrigger . AIVariables [ 1 ]; // Take health from self return LOOP_CONTINUE ; };","title":"Poison example"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#trigger-scope","text":"Triggers can be divided into two types: Global trigger ( AI_StartTriggerScript ) trigger created using this function works in all worlds. A trigger is considered global by default if neither self nor other nor victim has been provided for it. Local trigger ( AI_StartTriggerScriptEx) trigger created with this function only works in the world in which it was created. A trigger is considered local if it has been presented with at least one NPC in self , other or victim (not null). If you want to create a trigger without linking it to any NPC, it is recommended to simply pass hero as self to the trigger.","title":"Trigger scope"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#saving","text":"The plugin creates a new save archive to save the information of the triggers that does not conflict with any of the built-in save files.","title":"Saving"},{"location":"zengin/scripts/extenders/zparserextender/c_trigger/#searching","text":"To search for a specific trigger, for example by NPC, the trigger external functions can be used. 1 2 3 4 5 6 7 8 9 // This way you can disable all triggers running on the `hero` instance var C_Trigger trigget = FirstTrigger ; var C_Trigger trigget_saved ; while ( ! Hlp_IsNULL ( trigget )) { trigget_saved = trigger ; trigger = AI_GetNextTriggerBySelf ( hero ); trigget_saved . Enabled = false ; };","title":"Searching"},{"location":"zengin/scripts/extenders/zparserextender/dialogues/","text":"Dialogue constants To simplify dialogues, you can define up to 2 auxiliary variables or constants. Values corresponding to the current C_Info instance will be dynamically written there. DIA_CurrentInstance 1 var int DIA_CurrentInstance Contains the ID of the current C_Info instance. Can greatly simplify code or make it more reusable. Should be defined in scripts. Example usage 1 2 3 Info_ClearChoices ( DIA_CurrentInstance ); Info_AddChoice ( DIA_CurrentInstance , /*text*/ , /*func*/ ); Npc_KnowsInfo ( hero , DIA_CurrentInstance ); // In this case DIA_CurrentInstance contains the last C_Info instance?? Create a wrapper function based on this variable 1 2 3 4 func int C_HeroKnowsCurrentInfo () { return Npc_KnowsInfo ( hero , DIA_CurrentInstance ); }; DIA_CurrentName 1 var string DIA_CurrentName ; Contains the name of the current instance of C_Info . Can be useful for debugging purposes. Should be defined in scripts. Usage scenarios: 1 2 3 Hlp_PrintConsole ( DIA_CurrentName ); Hlp_PrintConsole ( Str_Format ( \"%s[%s]\" , DIA_CurrentName , self . name ); Hlp_StrCmp ( DIA_CurrentName , \"DIA_DiegoOw_Teach\" );","title":"Dialogue constants"},{"location":"zengin/scripts/extenders/zparserextender/dialogues/#dialogue-constants","text":"To simplify dialogues, you can define up to 2 auxiliary variables or constants. Values corresponding to the current C_Info instance will be dynamically written there.","title":"Dialogue constants"},{"location":"zengin/scripts/extenders/zparserextender/dialogues/#dia_currentinstance","text":"1 var int DIA_CurrentInstance Contains the ID of the current C_Info instance. Can greatly simplify code or make it more reusable. Should be defined in scripts. Example usage 1 2 3 Info_ClearChoices ( DIA_CurrentInstance ); Info_AddChoice ( DIA_CurrentInstance , /*text*/ , /*func*/ ); Npc_KnowsInfo ( hero , DIA_CurrentInstance ); // In this case DIA_CurrentInstance contains the last C_Info instance?? Create a wrapper function based on this variable 1 2 3 4 func int C_HeroKnowsCurrentInfo () { return Npc_KnowsInfo ( hero , DIA_CurrentInstance ); };","title":"DIA_CurrentInstance"},{"location":"zengin/scripts/extenders/zparserextender/dialogues/#dia_currentname","text":"1 var string DIA_CurrentName ; Contains the name of the current instance of C_Info . Can be useful for debugging purposes. Should be defined in scripts. Usage scenarios: 1 2 3 Hlp_PrintConsole ( DIA_CurrentName ); Hlp_PrintConsole ( Str_Format ( \"%s[%s]\" , DIA_CurrentName , self . name ); Hlp_StrCmp ( DIA_CurrentName , \"DIA_DiegoOw_Teach\" );","title":"DIA_CurrentName"},{"location":"zengin/scripts/extenders/zparserextender/events/","text":"Event functions Event functions are functions sharing the same name. It can be defined multiple times but only once per file. Such functions are useful for implementing callback type functions. Every time an event is called, all instances of the same name will be called. The event is func with a return type event . Events are defined globally, meaning they ignore namespace they are in. To call an event from a script, use the external function Hlp_DoEvent(var string funcName) . 1 2 3 4 5 6 7 8 9 10 11 12 func void GiveXP () { Hlp_DoEvent ( \"OnGiveXP\" ); }; func event OnGiveXP () { // TODO // This function can be defined in many files to do different things // more appropriate for that file's context and all of them will be // called, when function GiveXP (above) is called. }; Plugin implements two of these event functions func event GameInit() - called when entering the main menu on game start func event GameLoop() - called every frame when a world is loaded Define these in any file in your scripts, they will be automatically called","title":"Event functions"},{"location":"zengin/scripts/extenders/zparserextender/events/#event-functions","text":"Event functions are functions sharing the same name. It can be defined multiple times but only once per file. Such functions are useful for implementing callback type functions. Every time an event is called, all instances of the same name will be called. The event is func with a return type event . Events are defined globally, meaning they ignore namespace they are in. To call an event from a script, use the external function Hlp_DoEvent(var string funcName) . 1 2 3 4 5 6 7 8 9 10 11 12 func void GiveXP () { Hlp_DoEvent ( \"OnGiveXP\" ); }; func event OnGiveXP () { // TODO // This function can be defined in many files to do different things // more appropriate for that file's context and all of them will be // called, when function GiveXP (above) is called. }; Plugin implements two of these event functions func event GameInit() - called when entering the main menu on game start func event GameLoop() - called every frame when a world is loaded Define these in any file in your scripts, they will be automatically called","title":"Event functions"},{"location":"zengin/scripts/extenders/zparserextender/extern/","text":"Extern binding The extern binding allows you to secure your code against overriding or undefined symbol. Keyword extern before declaration means that if object of the same name exists, source object should be used. If not, a new one will be created. 1 2 3 4 extern instance PC_Hero ( C_Npc ) { // TODO };","title":"Extern binding"},{"location":"zengin/scripts/extenders/zparserextender/extern/#extern-binding","text":"The extern binding allows you to secure your code against overriding or undefined symbol. Keyword extern before declaration means that if object of the same name exists, source object should be used. If not, a new one will be created. 1 2 3 4 extern instance PC_Hero ( C_Npc ) { // TODO };","title":"Extern binding"},{"location":"zengin/scripts/extenders/zparserextender/externals/","text":"External functions External functions are Daedalus functions (defined in the engine itself) used to interface with the engine. zParseExtender adds a rather huge amount of new functions that help scripters to interface with the engine in more ways than what was possible before without script extenders such as Ikarus and LeGo. CAST data type conversion functions External functions for data type conversion and pointer casting. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func instance Cast_PointerToInstance ( var int address ) {}; func int Cast_InstanceToPointer ( var instance object ) {}; func C_NPC Cast_PointerToNpc ( var int address ) {}; func C_ITEM Cast_PointerToItem ( var int address ) {}; func int Cast_InstanceIsNpc ( var instance object ) {}; func int Cast_InstanceIsItem ( var instance object ) {}; func int Cast_InstanceIsMob ( var instance object ) {}; func int Cast_GetInstanceIndex ( var instance object ) {}; /// Returns the class identifier of a class by its name /// /// @param className name of the class /// @return class identifier func int Cast_GetClassID ( var string className ) {}; /// Returns class identifier of the zCObject vob class /// /// @param object object instance /// @return class zCObject identifier func int Cast_GetVobClassID ( var instance object ) {}; /// Checks if the classId class is the parent class of the object /// /// @param classId class identifier, from Cast_GetClassID function /// @param object object instance /// @return class zCObject identifier func int Cast_CheckVobClassID ( var int classId , var instance object ) {}; HLP help functions Helper functions used for safety checks or to get specific information from the engine. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func int Hlp_HasFocusVob ( var C_NPC npc ) {}; func instance Hlp_GetFocusVob ( var C_NPC npc ) {}; func string Hlp_GetFocusVobName ( var C_NPC npc ) {}; func int Hlp_GetStringLength ( var string str ) {}; func int IsNAN ( var float value ) {}; func int Hlp_KeyToggled ( var int key ) {}; func int Hlp_KeyPressed ( var int key ) {}; func int Hlp_LogicalKeyToggled ( var int key ) {}; func int Hlp_GameOnPause () {}; func void Hlp_MessageBox ( var string message ) {}; func void Hlp_PrintConsole ( var string message ) {}; func int Hlp_ReadOptionInt ( var string optName , var string section , var string entry , var int default ) {}; func float Hlp_ReadOptionFloat ( var string optName , var string section , var string entry , var float default ) {}; func string Hlp_ReadOptionString ( var string optName , var string section , var string entry , var string default ) {}; func int Hlp_OptionIsExists ( var string optName , var string section , var string entry ) {}; func void Hlp_WriteOptionInt ( var string optName , var string section , var string entry , var int value ) {}; func void Hlp_WriteOptionFloat ( var string optName , var string section , var string entry , var float value ) {}; func void Hlp_WriteOptionString ( var string optName , var string section , var string entry , var string value ) {}; WLD world manipulation functions Functions related to the world. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func void Wld_ChangeLevel ( var string world , var string waypoint ) {}; func instance Wld_FindVob ( var string vobname ) {}; func void Wld_PlayEffectVob ( var string effect , var instance pvob , var int level , var int damage , var int damage_type , var int damage_speed ) {}; func void Wld_PlayEffectAt ( var string effect , var instance coord , var int level , var int damage , var int damage_type , var int damage_speed ) {}; func void Wld_ToggleRain ( var float weight , var flaot time ) {}; func void Wld_SetWeatherType ( var int type ) {}; func int Wld_GetWeatherType () {}; MDL model functions Functions to tweak animation and other model related settings. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func int Mdl_GetAnimationIndex ( var C_NPC npc , var string ani_name ) {}; func string Mdl_GetAnimationName ( var C_NPC npc , var int ani_index ) {}; func int Mdl_AnimationIsExists ( var C_NPC npc , var int ani_index ) {}; func int Mdl_AnimationIsActive ( var C_NPC npc , var int ani_index ) {}; func float Mdl_SetAllAnimationsFPS ( var C_NPC npc , var float fps ) {}; func float Mdl_ResetAllAnimationsFPS ( var C_NPC npc ) {}; func float Mdl_SetAnimationFPS ( var C_NPC npc , var int idx , var float fps ) {}; func float Mdl_ResetAnimationFPS ( var C_NPC npc , var int ani_index ) {}; func void Mdl_SetVisible ( var C_NPC npc , var int isVisible ) {}; /// Applies or moves existing overlay to the top of the list /// /// @param mdsName name of the overlay func void Mdl_ApplyOverlayMds_AtFirst ( var string mdsName ) {}; /// Sets a multipler for animation speed /// 1.0 = 100% speed (normal speed) /// /// @param npc npc to be affected /// @param multiplier speed of the animation func void Mdl_SetNpcSpeedMultiplier ( var C_Npc npc , var float multiplier ) {}; /// Resets the animation speed of an NPC /// /// @param npc npc to be affected func void Mdl_ResetNpcSpeedMultiplier ( var C_Npc npc ) {}; NPC character functions NPC related functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func void Npc_SetAsHero ( var C_NPC npc ) {}; func void Npc_OpenInventory ( var C_NPC npc ) {}; func void Npc_OpenInventorySteal ( var C_NPC npc ) {}; func void Npc_OpenInventoryTrade ( var C_NPC npc ) {}; /// Returns an item in NPC's left hand slot /// /// @param npc npc to be affected func C_Item Npc_GetLeftHandItem ( var C_Npc npc ) {}; /// Returns an item in NPC's right hand slot /// /// @param npc npc to be affected func C_Item Npc_GetRightHandItem ( var C_Npc npc ) {}; /// Returns an item from a slot with the slotName /// /// @param npc npc to be affected /// @param slotName name of the slot func C_Item Npc_GetSlotItem ( var C_Npc npc , var string slotName ) {}; /// Places an instance of the oCVom class (including items and NPCs) object into the slotName of the NPC /// The copyInInv parameter determines wheter a copy of the object should remian in the character's inventory /// /// @param npc npc to remove the item from /// @param slotName name of the slot fro which to remove the item /// @param object object to be inserted into the slot /// @param copyInInv should a copy of the object stay in character inventory func void Npc_PutInSlot ( var C_Npc npc , var string slotName , var instance object , var int copyInInv ) {}; /// Removes an object from the slotName of the NPC. /// The dropIt parameter in Gothic 2 defines, wheter or not the object should drop out of the slot. In Gothic 1, this parameter is reserved and must be 0. /// /// @param npc npc to remove the item from /// @param slotName name of the slot fro which to remove the item /// @param dropIt should the object be dropped func void Npc_RemoveFromSlot ( var C_Npc npc , var string slotName , var int dropIt ) {}; MOB interactive object functions Functions to manipulate interactive objects like destroying MOBs, setting lockpick combination and such. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func void Mob_Destroy ( var instance object ) {}; func void Mob_RemoveItem ( var instance object , var int item ) {}; func void Mob_RemoveItems ( var instance object , var int item , var int cnt ) {}; func void Mob_InsertItem ( var instance object , var int item ) {}; func void Mob_InsertItems ( var instance object , var int item , var int cnt ) {}; func string Mob_GetLockCombination ( var instance object ) {}; func void Mob_SetLockCombination ( var instance object , var string comb ) {}; func int Mob_IsLocked ( var instance object ) {}; func void Mob_SetLocked ( var instance object , var int locked ) {}; func instance Mob_GetKeyInstance ( var instance object ) {}; func void Mob_SetKeyInstance ( var instance object , var int key ) {}; AI functions for working with AI Functions to work with the new C_Trigger class and NPC's AI queue. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func void AI_CallScript ( var string funcName , var C_Npc slf , var C_Npc oth ) {}; func C_Trigger AI_StartTriggerScript ( var string funcName , var int delay ) {}; func C_Trigger AI_StartTriggerScriptEx ( var string funcName , var int delay , var C_Npc slf , var C_Npc oth , var C_Npc vct ) {}; const int selfID = 0 ; const int otherID = 1 ; const int victimID = 2 ; func int Hlp_IsNULL ( var instance pointer ) {}; func C_Trigger AI_GetTriggerByID ( var int ID ) {}; func int AI_GetTriggersNum () {}; func C_Trigger AI_GetTriggerNPC ( var int npcID ) {}; func func AI_GetTriggerFunc ( var C_Trigger trigger ) {}; func string AI_GetTriggerFuncName ( var C_Trigger trigger ) {}; AI_GetNextTriggerByFunc ( var C_Trigger startTrigger , var func function ) {}; AI_GetNextTriggerByFuncName ( var C_Trigger startTrigger , var string functionName ) {}; AI_GetNextTriggerBySelf ( var C_Trigger startTrigger , var C_Npc self ) {}; AI_GetNextTriggerByOther ( var C_Trigger startTrigger , var C_Npc other ) {}; AI_GetNextTriggerByVictim ( var C_Trigger startTrigger , var C_Npc victim ) {}; AI_GetNextTriggerByNPCs ( var C_Trigger startTrigger , var C_Npc self , var C_Npc other , var C_Npc victim ) {}; /// Returns the name of the current Steam user /// Returns empty string when not run with Steam /// /// @return string containing the Steam username, or empty string func string Hlp_GetSteamPersonalName () {}; PAR functions for parser manipulation Parser functions are used to manipulate the parsers. Retrieve SymbolID, access arrays and such. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func int Par_GetParserID ( var string parName ) {}; func int Par_GetSymbolID ( var int parId , var string symName ) {}; func int Par_GetSymbolLength ( var int parId , var int symId ) {}; func int Par_GetSymbolValueInt ( var int parId , var int symId ) {}; func float Par_GetSymbolValueFloat ( var int parId , var int symId ) {}; func string Par_GetSymbolValueString ( var int parId , var int symId ) {}; func instance Par_GetSymbolValueInstance ( var int parId , var int symId ) {}; func int Par_GetSymbolValueIntArray ( var int parId , var int symId , var int arrayId ) {}; func float Par_GetSymbolValueFloatArray ( var int parId , var int symId , var int arrayId ) {}; func string Par_GetSymbolValueStringArray ( var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueInt ( var int value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueFloat ( var float value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueString ( var string value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueInstance ( var instance value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueIntArray ( var int value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueFloatArray ( var float value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueStringArray ( var string value , var int parId , var int symId , var int arrayId ) {}; VOB functions for object manipulation VOB functions allow you to manipulate game world objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 /// Returns the current position of the object in the world /// /// @param vob vob to ge the position of /// @return C_Position instace - position of the VOB func C_Position Vob_GetVobPosition ( var C_Vob vob ) {}; /// Sets the current position of the object in the world /// /// @param vob vob to get the position of /// @param pos new position of the vob func void Vob_SetVobPosition ( var C_Vob vob , var C_Position pos ) {}; /// Returns the universal data of the zCVob object /// /// @param vob VOB to get the position of /// @return general vob data C_Vob_Data func C_Vob_Data Vob_GetVobData ( var C_Vob vob ) {}; /// Sets the universal data to a zCVob object /// /// @param vob VOB to get the position of /// @param data general vob data C_Vob_Data func void Vob_SetVobData ( var C_Vob vob , var C_Vob_Data data ) {}; /// Returns zCVobLight object data /// /// @param vobLight vobLight object /// @return C_Light_Data of the light func C_Light_Data Vob_GetLightData ( var C_Vob vobLight ) {}; /// Sets the data of a zCVobLight object /// /// @param vobLight object to apply the light data to /// @param data C_Light_Data light data to be set func void Vob_SetLightData ( var C_Vob vobLight , var C_Light_Data data ) {}; /// Clears the list of animation colours for the light source /// /// @param vobLight light vob func void Vob_ClearLightAniList ( var C_Vob vobLight ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param col colour to be applied func void Vob_AddLightAniColor ( var C_Vob vobLight , var C_Color col ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param r red colour channel /// @param g green colour channel /// @param b blue colour channel func void Vob_AddLightAniColorRGB ( var C_Vob vobLight , var int r , var int g , var int b ) {}; /// Returns the data of the oCMOB object /// /// @param mob oCMOB object /// @return mob data func C_Mob_Data Vob_GetMobData ( var C_Vob mob ) {}; /// Sets the data of the oCMOB object /// /// @param mob oCMOB object /// @param data C_Mob_Data to be set func void Vob_SetMobData ( var C_Vob mob , var C_Mob_Data data ) {}; /// Returns the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @return MobInter_Data of the object func MobInter_Data Vob_GetMobInterData ( var C_Vob mobInter ) {}; /// Sets the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @param data MobInter_Data of the object func void Vob_SetMobInterData ( var C_Vob mobInter , var C_MobInter_Data data ) {}; /// Returns the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data MobInter_Data of the object func C_MobLockable_Data Vob_GetMobInterData ( var C_Vob mobLock ) {}; /// Sets the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data C_MobLockable_Data of the object func void Vob_SetMobInterData ( var C_Vob mobLock , var C_MobLockable_Data data ) {}; String function Functions to manipulate and format strings. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /// Returns formatted string using format specifiers /// /// Format specifiers: /// %s - inserts a string /// %i - inserts a integer number /// %x - inserts a integer in hexadecimal /// %f - inserts a floating point number /// %b - inserts a logical expression /// %p - inserts a pointer /// /// @return formatted string func string Str_Format ( var string format , ... ) {}; /// Returns a string in the current language, otherwise in English. /// Arguments MUST be encoded in UTF-8! The result string will be converted to apropriate ANSI string. /// /// @param russian Russian string /// @param english English string /// @param german German string /// @param polish Polish string /// /// @return string in the current language func string Str_GetLocalizedString ( var string russian , var string english , var string german , var string polish ) {}; /// Returns a string in the current language, otherwise in English. /// Offers additional languages /// /// @param russian Russian string /// @param english English string /// @param german German string /// @param polish Polish string /// @param czech Czech string /// @param romanian Romanian string /// @param italian Italian string /// @param spanish Spanish string /// /// @return string in the current language func string Str_GetLocalizedStringEx ( var string russian , var string english , var string german , var string polish , var string czech , var string romanian , var string italian , var string spanish ) {}; /// Converts UTF-8 string into an ANSI string with codePage /// /// @param utf8 string encoded in UTF8 /// @param codePage codePage id, can be obtained from Str_GetCurrentCP func string Str_UTF8_to_ANSI ( var string utf8 , var int codePage ) {}; /// Return the code page corresponding to the current language set in the Union System func int Str_GetCurrentCP () {}; /// Returns the length of a string /// /// @param str string to be measured /// @return length of the string func int Str_GetLength ( var int str ) {}; Menu function 1 2 3 4 /// Find all C_MenuItem object instances by the mask and automatically places them in the current menu instance /// /// @param mask regex like mask for searching func void Menu_SearchItems ( var string mask ) {}; Log functions As discussed on Inside Gothic , vanilla Gothic has no way of getting the status of a quest. These functions implement that functionality. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /// Returns the status of diary topic /// Not found - (-1) /// Free - 0 /// Running - 1 /// Success - 2 /// Failure - 3 /// Obsolete - 4 /// /// @param topic name of the topic /// @return topic status func int Log_GetTopicStatus ( var string topic ) {}; /// Returns the topic the diary topic is in /// Not found - (-1) /// Missions - 0 /// Notes - 1 /// All - 2 /// /// @param topic name of the topic /// @return topic section func int Log_GetTopicSection ( var string topic ) {}; Event functions and variables On top of external functions, zParserExtender also adds event functions and constants 1 2 3 4 5 6 7 func event GameLoop () {}; func event GameInit () {}; const instance null ; const float NaN ;","title":"External functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#external-functions","text":"External functions are Daedalus functions (defined in the engine itself) used to interface with the engine. zParseExtender adds a rather huge amount of new functions that help scripters to interface with the engine in more ways than what was possible before without script extenders such as Ikarus and LeGo.","title":"External functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#cast-data-type-conversion-functions","text":"External functions for data type conversion and pointer casting. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func instance Cast_PointerToInstance ( var int address ) {}; func int Cast_InstanceToPointer ( var instance object ) {}; func C_NPC Cast_PointerToNpc ( var int address ) {}; func C_ITEM Cast_PointerToItem ( var int address ) {}; func int Cast_InstanceIsNpc ( var instance object ) {}; func int Cast_InstanceIsItem ( var instance object ) {}; func int Cast_InstanceIsMob ( var instance object ) {}; func int Cast_GetInstanceIndex ( var instance object ) {}; /// Returns the class identifier of a class by its name /// /// @param className name of the class /// @return class identifier func int Cast_GetClassID ( var string className ) {}; /// Returns class identifier of the zCObject vob class /// /// @param object object instance /// @return class zCObject identifier func int Cast_GetVobClassID ( var instance object ) {}; /// Checks if the classId class is the parent class of the object /// /// @param classId class identifier, from Cast_GetClassID function /// @param object object instance /// @return class zCObject identifier func int Cast_CheckVobClassID ( var int classId , var instance object ) {};","title":"CAST data type conversion functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#hlp-help-functions","text":"Helper functions used for safety checks or to get specific information from the engine. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func int Hlp_HasFocusVob ( var C_NPC npc ) {}; func instance Hlp_GetFocusVob ( var C_NPC npc ) {}; func string Hlp_GetFocusVobName ( var C_NPC npc ) {}; func int Hlp_GetStringLength ( var string str ) {}; func int IsNAN ( var float value ) {}; func int Hlp_KeyToggled ( var int key ) {}; func int Hlp_KeyPressed ( var int key ) {}; func int Hlp_LogicalKeyToggled ( var int key ) {}; func int Hlp_GameOnPause () {}; func void Hlp_MessageBox ( var string message ) {}; func void Hlp_PrintConsole ( var string message ) {}; func int Hlp_ReadOptionInt ( var string optName , var string section , var string entry , var int default ) {}; func float Hlp_ReadOptionFloat ( var string optName , var string section , var string entry , var float default ) {}; func string Hlp_ReadOptionString ( var string optName , var string section , var string entry , var string default ) {}; func int Hlp_OptionIsExists ( var string optName , var string section , var string entry ) {}; func void Hlp_WriteOptionInt ( var string optName , var string section , var string entry , var int value ) {}; func void Hlp_WriteOptionFloat ( var string optName , var string section , var string entry , var float value ) {}; func void Hlp_WriteOptionString ( var string optName , var string section , var string entry , var string value ) {};","title":"HLP help functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#wld-world-manipulation-functions","text":"Functions related to the world. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func void Wld_ChangeLevel ( var string world , var string waypoint ) {}; func instance Wld_FindVob ( var string vobname ) {}; func void Wld_PlayEffectVob ( var string effect , var instance pvob , var int level , var int damage , var int damage_type , var int damage_speed ) {}; func void Wld_PlayEffectAt ( var string effect , var instance coord , var int level , var int damage , var int damage_type , var int damage_speed ) {}; func void Wld_ToggleRain ( var float weight , var flaot time ) {}; func void Wld_SetWeatherType ( var int type ) {}; func int Wld_GetWeatherType () {};","title":"WLD world manipulation functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#mdl-model-functions","text":"Functions to tweak animation and other model related settings. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 func int Mdl_GetAnimationIndex ( var C_NPC npc , var string ani_name ) {}; func string Mdl_GetAnimationName ( var C_NPC npc , var int ani_index ) {}; func int Mdl_AnimationIsExists ( var C_NPC npc , var int ani_index ) {}; func int Mdl_AnimationIsActive ( var C_NPC npc , var int ani_index ) {}; func float Mdl_SetAllAnimationsFPS ( var C_NPC npc , var float fps ) {}; func float Mdl_ResetAllAnimationsFPS ( var C_NPC npc ) {}; func float Mdl_SetAnimationFPS ( var C_NPC npc , var int idx , var float fps ) {}; func float Mdl_ResetAnimationFPS ( var C_NPC npc , var int ani_index ) {}; func void Mdl_SetVisible ( var C_NPC npc , var int isVisible ) {}; /// Applies or moves existing overlay to the top of the list /// /// @param mdsName name of the overlay func void Mdl_ApplyOverlayMds_AtFirst ( var string mdsName ) {}; /// Sets a multipler for animation speed /// 1.0 = 100% speed (normal speed) /// /// @param npc npc to be affected /// @param multiplier speed of the animation func void Mdl_SetNpcSpeedMultiplier ( var C_Npc npc , var float multiplier ) {}; /// Resets the animation speed of an NPC /// /// @param npc npc to be affected func void Mdl_ResetNpcSpeedMultiplier ( var C_Npc npc ) {};","title":"MDL model functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#npc-character-functions","text":"NPC related functions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func void Npc_SetAsHero ( var C_NPC npc ) {}; func void Npc_OpenInventory ( var C_NPC npc ) {}; func void Npc_OpenInventorySteal ( var C_NPC npc ) {}; func void Npc_OpenInventoryTrade ( var C_NPC npc ) {}; /// Returns an item in NPC's left hand slot /// /// @param npc npc to be affected func C_Item Npc_GetLeftHandItem ( var C_Npc npc ) {}; /// Returns an item in NPC's right hand slot /// /// @param npc npc to be affected func C_Item Npc_GetRightHandItem ( var C_Npc npc ) {}; /// Returns an item from a slot with the slotName /// /// @param npc npc to be affected /// @param slotName name of the slot func C_Item Npc_GetSlotItem ( var C_Npc npc , var string slotName ) {}; /// Places an instance of the oCVom class (including items and NPCs) object into the slotName of the NPC /// The copyInInv parameter determines wheter a copy of the object should remian in the character's inventory /// /// @param npc npc to remove the item from /// @param slotName name of the slot fro which to remove the item /// @param object object to be inserted into the slot /// @param copyInInv should a copy of the object stay in character inventory func void Npc_PutInSlot ( var C_Npc npc , var string slotName , var instance object , var int copyInInv ) {}; /// Removes an object from the slotName of the NPC. /// The dropIt parameter in Gothic 2 defines, wheter or not the object should drop out of the slot. In Gothic 1, this parameter is reserved and must be 0. /// /// @param npc npc to remove the item from /// @param slotName name of the slot fro which to remove the item /// @param dropIt should the object be dropped func void Npc_RemoveFromSlot ( var C_Npc npc , var string slotName , var int dropIt ) {};","title":"NPC character functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#mob-interactive-object-functions","text":"Functions to manipulate interactive objects like destroying MOBs, setting lockpick combination and such. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func void Mob_Destroy ( var instance object ) {}; func void Mob_RemoveItem ( var instance object , var int item ) {}; func void Mob_RemoveItems ( var instance object , var int item , var int cnt ) {}; func void Mob_InsertItem ( var instance object , var int item ) {}; func void Mob_InsertItems ( var instance object , var int item , var int cnt ) {}; func string Mob_GetLockCombination ( var instance object ) {}; func void Mob_SetLockCombination ( var instance object , var string comb ) {}; func int Mob_IsLocked ( var instance object ) {}; func void Mob_SetLocked ( var instance object , var int locked ) {}; func instance Mob_GetKeyInstance ( var instance object ) {}; func void Mob_SetKeyInstance ( var instance object , var int key ) {};","title":"MOB interactive object functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#ai-functions-for-working-with-ai","text":"Functions to work with the new C_Trigger class and NPC's AI queue. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 func void AI_CallScript ( var string funcName , var C_Npc slf , var C_Npc oth ) {}; func C_Trigger AI_StartTriggerScript ( var string funcName , var int delay ) {}; func C_Trigger AI_StartTriggerScriptEx ( var string funcName , var int delay , var C_Npc slf , var C_Npc oth , var C_Npc vct ) {}; const int selfID = 0 ; const int otherID = 1 ; const int victimID = 2 ; func int Hlp_IsNULL ( var instance pointer ) {}; func C_Trigger AI_GetTriggerByID ( var int ID ) {}; func int AI_GetTriggersNum () {}; func C_Trigger AI_GetTriggerNPC ( var int npcID ) {}; func func AI_GetTriggerFunc ( var C_Trigger trigger ) {}; func string AI_GetTriggerFuncName ( var C_Trigger trigger ) {}; AI_GetNextTriggerByFunc ( var C_Trigger startTrigger , var func function ) {}; AI_GetNextTriggerByFuncName ( var C_Trigger startTrigger , var string functionName ) {}; AI_GetNextTriggerBySelf ( var C_Trigger startTrigger , var C_Npc self ) {}; AI_GetNextTriggerByOther ( var C_Trigger startTrigger , var C_Npc other ) {}; AI_GetNextTriggerByVictim ( var C_Trigger startTrigger , var C_Npc victim ) {}; AI_GetNextTriggerByNPCs ( var C_Trigger startTrigger , var C_Npc self , var C_Npc other , var C_Npc victim ) {}; /// Returns the name of the current Steam user /// Returns empty string when not run with Steam /// /// @return string containing the Steam username, or empty string func string Hlp_GetSteamPersonalName () {};","title":"AI functions for working with AI"},{"location":"zengin/scripts/extenders/zparserextender/externals/#par-functions-for-parser-manipulation","text":"Parser functions are used to manipulate the parsers. Retrieve SymbolID, access arrays and such. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func int Par_GetParserID ( var string parName ) {}; func int Par_GetSymbolID ( var int parId , var string symName ) {}; func int Par_GetSymbolLength ( var int parId , var int symId ) {}; func int Par_GetSymbolValueInt ( var int parId , var int symId ) {}; func float Par_GetSymbolValueFloat ( var int parId , var int symId ) {}; func string Par_GetSymbolValueString ( var int parId , var int symId ) {}; func instance Par_GetSymbolValueInstance ( var int parId , var int symId ) {}; func int Par_GetSymbolValueIntArray ( var int parId , var int symId , var int arrayId ) {}; func float Par_GetSymbolValueFloatArray ( var int parId , var int symId , var int arrayId ) {}; func string Par_GetSymbolValueStringArray ( var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueInt ( var int value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueFloat ( var float value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueString ( var string value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueInstance ( var instance value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueIntArray ( var int value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueFloatArray ( var float value , var int parId , var int symId , var int arrayId ) {}; func void Par_SetSymbolValueStringArray ( var string value , var int parId , var int symId , var int arrayId ) {};","title":"PAR functions for parser manipulation"},{"location":"zengin/scripts/extenders/zparserextender/externals/#vob-functions-for-object-manipulation","text":"VOB functions allow you to manipulate game world objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 /// Returns the current position of the object in the world /// /// @param vob vob to ge the position of /// @return C_Position instace - position of the VOB func C_Position Vob_GetVobPosition ( var C_Vob vob ) {}; /// Sets the current position of the object in the world /// /// @param vob vob to get the position of /// @param pos new position of the vob func void Vob_SetVobPosition ( var C_Vob vob , var C_Position pos ) {}; /// Returns the universal data of the zCVob object /// /// @param vob VOB to get the position of /// @return general vob data C_Vob_Data func C_Vob_Data Vob_GetVobData ( var C_Vob vob ) {}; /// Sets the universal data to a zCVob object /// /// @param vob VOB to get the position of /// @param data general vob data C_Vob_Data func void Vob_SetVobData ( var C_Vob vob , var C_Vob_Data data ) {}; /// Returns zCVobLight object data /// /// @param vobLight vobLight object /// @return C_Light_Data of the light func C_Light_Data Vob_GetLightData ( var C_Vob vobLight ) {}; /// Sets the data of a zCVobLight object /// /// @param vobLight object to apply the light data to /// @param data C_Light_Data light data to be set func void Vob_SetLightData ( var C_Vob vobLight , var C_Light_Data data ) {}; /// Clears the list of animation colours for the light source /// /// @param vobLight light vob func void Vob_ClearLightAniList ( var C_Vob vobLight ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param col colour to be applied func void Vob_AddLightAniColor ( var C_Vob vobLight , var C_Color col ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param r red colour channel /// @param g green colour channel /// @param b blue colour channel func void Vob_AddLightAniColorRGB ( var C_Vob vobLight , var int r , var int g , var int b ) {}; /// Returns the data of the oCMOB object /// /// @param mob oCMOB object /// @return mob data func C_Mob_Data Vob_GetMobData ( var C_Vob mob ) {}; /// Sets the data of the oCMOB object /// /// @param mob oCMOB object /// @param data C_Mob_Data to be set func void Vob_SetMobData ( var C_Vob mob , var C_Mob_Data data ) {}; /// Returns the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @return MobInter_Data of the object func MobInter_Data Vob_GetMobInterData ( var C_Vob mobInter ) {}; /// Sets the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @param data MobInter_Data of the object func void Vob_SetMobInterData ( var C_Vob mobInter , var C_MobInter_Data data ) {}; /// Returns the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data MobInter_Data of the object func C_MobLockable_Data Vob_GetMobInterData ( var C_Vob mobLock ) {}; /// Sets the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data C_MobLockable_Data of the object func void Vob_SetMobInterData ( var C_Vob mobLock , var C_MobLockable_Data data ) {};","title":"VOB functions for object manipulation"},{"location":"zengin/scripts/extenders/zparserextender/externals/#string-function","text":"Functions to manipulate and format strings. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /// Returns formatted string using format specifiers /// /// Format specifiers: /// %s - inserts a string /// %i - inserts a integer number /// %x - inserts a integer in hexadecimal /// %f - inserts a floating point number /// %b - inserts a logical expression /// %p - inserts a pointer /// /// @return formatted string func string Str_Format ( var string format , ... ) {}; /// Returns a string in the current language, otherwise in English. /// Arguments MUST be encoded in UTF-8! The result string will be converted to apropriate ANSI string. /// /// @param russian Russian string /// @param english English string /// @param german German string /// @param polish Polish string /// /// @return string in the current language func string Str_GetLocalizedString ( var string russian , var string english , var string german , var string polish ) {}; /// Returns a string in the current language, otherwise in English. /// Offers additional languages /// /// @param russian Russian string /// @param english English string /// @param german German string /// @param polish Polish string /// @param czech Czech string /// @param romanian Romanian string /// @param italian Italian string /// @param spanish Spanish string /// /// @return string in the current language func string Str_GetLocalizedStringEx ( var string russian , var string english , var string german , var string polish , var string czech , var string romanian , var string italian , var string spanish ) {}; /// Converts UTF-8 string into an ANSI string with codePage /// /// @param utf8 string encoded in UTF8 /// @param codePage codePage id, can be obtained from Str_GetCurrentCP func string Str_UTF8_to_ANSI ( var string utf8 , var int codePage ) {}; /// Return the code page corresponding to the current language set in the Union System func int Str_GetCurrentCP () {}; /// Returns the length of a string /// /// @param str string to be measured /// @return length of the string func int Str_GetLength ( var int str ) {};","title":"String function"},{"location":"zengin/scripts/extenders/zparserextender/externals/#menu-function","text":"1 2 3 4 /// Find all C_MenuItem object instances by the mask and automatically places them in the current menu instance /// /// @param mask regex like mask for searching func void Menu_SearchItems ( var string mask ) {};","title":"Menu function"},{"location":"zengin/scripts/extenders/zparserextender/externals/#log-functions","text":"As discussed on Inside Gothic , vanilla Gothic has no way of getting the status of a quest. These functions implement that functionality. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /// Returns the status of diary topic /// Not found - (-1) /// Free - 0 /// Running - 1 /// Success - 2 /// Failure - 3 /// Obsolete - 4 /// /// @param topic name of the topic /// @return topic status func int Log_GetTopicStatus ( var string topic ) {}; /// Returns the topic the diary topic is in /// Not found - (-1) /// Missions - 0 /// Notes - 1 /// All - 2 /// /// @param topic name of the topic /// @return topic section func int Log_GetTopicSection ( var string topic ) {};","title":"Log functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/#event-functions-and-variables","text":"On top of external functions, zParserExtender also adds event functions and constants 1 2 3 4 5 6 7 func event GameLoop () {}; func event GameInit () {}; const instance null ; const float NaN ;","title":"Event functions and variables"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/","text":"Engine classes zParserExtender implements various proxy classes that can be used to access game world objects. Warning It is not recommended to implement complex mechanics using these classes and functions. They are present as a simple backup option for accessing game world objects and for quick fixes. C_VOB This class represents basic pointer to a game world object. C_Color Represents color in the RGBA format 1 2 3 4 5 6 7 class C_Color { var int R ; // red channel value var int G ; // green channel value var int B ; // blue channel value var int A ; // alpha channel value }; C_Position Represents 3D position in the world 1 2 3 4 5 6 class C_Position { var int X ; // X coordinate var int Y ; // Y coordinate var int Z ; // Z coordinate }; Externals: 1 2 3 4 5 6 7 8 9 10 11 /// Returns the current position of the object in the world /// /// @param vob vob to ge the position of /// @return C_Position instace - position of the VOB func C_Position Vob_GetVobPosition ( var C_Vob vob ) {}; /// Sets the current position of the object in the world /// /// @param vob vob to get the position of /// @param pos new position of the vob func void Vob_SetVobPosition ( var C_Vob vob , var C_Position pos ) {}; Note The following classes define properties of C_VOB objects or classes derived from it. C_VOB_DATA Represents universal zCVob class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class C_VOB_DATA { var string Name ; // object name var float VisualAlpha ; // object's transparency 0.0 - 1.0 var int ShowVisual ; // display the mode var int DrawBBox3D ; // show objects bounding box var int VisualAlphaEnabled ; // enables objects transparency var int PhysicsEnabled ; // enables object's physics var int IgnoredByTraceRay ; // allow any object collisions var int CollDetectionStatic ; // allow collision with static world polygons var int CollDetectionDynamic ; // allow collision with dynamic world objects var int CastDynShadow ; // display shadow of the object var int LightColorStatDirty ; // allow static liging of the object var int LightColorDynDirty ; // allow dynamic lighing of the object var int SleepingMode ; // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only) var int DontWriteIntoArchive ; // turns of the serialization of this object to the save file }; Externals: 1 2 3 4 5 6 7 8 9 10 11 /// Returns the universal data of the zCVob object /// /// @param vob VOB to get the position of /// @return general vob data C_Vob_Data func C_Vob_Data Vob_GetVobData ( var C_Vob vob ) {}; /// Sets the universal data to a zCVob object /// /// @param vob VOB to get the position of /// @param data general vob data C_Vob_Data func void Vob_SetVobData ( var C_Vob vob , var C_Vob_Data data ) {}; C_LIGHT_DATA Represents zCVobLight objects 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class C_LIGHT_DATA { var int R ; // red light intensity var int G ; // green light intensity var int B ; // blue light intensity var int Range ; // radius var int RangeInv ; // var int RangeBackup ; // var int RangeAniActFrame ; // current light animation frame for the radius var int RangeAniFPS ; // speed of light animation for the radius var int ColorAniActFrame ; // current light animation frame for colour var int ColorAniFPS ; // speed of light animation for colour var int SpotConeAngleDeg ; // angle of cone light source var int IsStatic ; // whether the source is static var int RangeAniSmooth ; // [UNUSED] var int RangeAniLoop ; // [UNUSED] var int ColorAniSmooth ; // allows soft transitions between colours var int ColorAniLoop ; // [UNUSED] var int IsTurnedOn ; // whether the light source is on var int LightQuality ; // source quality (when statically compiling light) (0 - high, 1 - medium, 2 - low) var int LightType ; // type of source (at static light compilation) (0 - point, 1 - cone) }; Externals: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// Returns zCVobLight object data /// /// @param vobLight vobLight object /// @return C_Light_Data of the light func C_Light_Data Vob_GetLightData ( var C_Vob vobLight ) {}; /// Sets the data of a zCVobLight object /// /// @param vobLight object to apply the light data to /// @param data C_Light_Data light data to be set func void Vob_SetLightData ( var C_Vob vobLight , var C_Light_Data data ) {}; /// Clears the list of animation colours for the light source /// /// @param vobLight light vob func void Vob_ClearLightAniList ( var C_Vob vobLight ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param col colour to be applied func void Vob_AddLightAniColor ( var C_Vob vobLight , var C_Color col ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param r red colour channel /// @param g green colour channel /// @param b blue colour channel func void Vob_AddLightAniColorRGB ( var C_Vob vobLight , var int r , var int g , var int b ) {}; C_MOB_DATA Represents data for the used oCMOB object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class C_MOB_DATA { var string VisibleName ; // name shown above the object var int Hitpoints ; // number of hitpoints var int Damage ; // damage the object can cause var int IsDestroyed ; // if the object is destroyed var int Moveable ; // whether the object can be moved var int Takeable ; // whether the object can be taken var int FocusOverride ; // if the object will redefine focus in combat mode var int SndMat ; // object's material (0 - wood, 1 - stone, 2 - metal, 3 - skin, 4 - clay, 5 - glass) var string VisualDestroyed ; // model when the object is destroyed var string OwnerStr ; // name of the instance of the owner of the object var string OwnerGuildStr ; // name of the guild of the object var int Owner ; // instance of the owner var int OwnerGuild ; // guild instance var int FocusNameIndex ; // the script string of the displayed name }; 1 2 3 4 5 6 7 8 9 10 11 /// Returns the data of the oCMOB object /// /// @param mob oCMOB object /// @return mob data func C_Mob_Data Vob_GetMobData ( var C_Vob mob ) {}; /// Sets the data of the oCMOB object /// /// @param mob oCMOB object /// @param data C_Mob_Data to be set func void Vob_SetMobData ( var C_Vob mob , var C_Mob_Data data ) {}; C_MOBINTER_DATA Represents data for the interactive object oCMobInter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class C_MOBINTER_DATA { var string TriggerTarget ; // object name which will be triggered by OnTrigger var string UseWithItem ; // name of the object instance that is needed for interaction var string Sceme ; // name of the scene that corresponds to the object and character animations var string ConditionFunc ; // scripting condition under which the interaction can be performed var string OnStateFuncName ; // the name pattern of the functions that will be called when the object changes the state var int State ; // the current state of the object var int State_num ; // number of object's states var int State_target // current state of the object var int Rewind ; // prohibits object updating var int MobStateAni ; // current animation of the object var int NpcStateAni ; // current character animation }; 1 2 3 4 5 6 7 8 9 10 11 /// Returns the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @return MobInter_Data of the object func MobInter_Data Vob_GetMobInterData ( var C_Vob mobInter ) {}; /// Sets the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @param data MobInter_Data of the object func void Vob_SetMobInterData ( var C_Vob mobInter , var C_MobInter_Data data ) {}; C_MOBLOCKABLE_DATA Represents data for the locked interactive object oCMobLockable 1 2 3 4 5 6 7 8 class C_MOBLOCKABLE_DATA { var int Locked ; // whether the object is locked var int AutoOpen ; // [UNUSED] var int PickLockNr ; // current rotation number var string KeyInstance ; // key instance name for the object var string PickLockStr ; // combination to open the object (\"LRRLR\") }; 1 2 3 4 5 6 7 8 9 10 11 /// Returns the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data MobInter_Data of the object func C_MobLockable_Data Vob_GetMobInterData ( var C_Vob mobLock ) {}; /// Sets the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data C_MobLockable_Data of the object func void Vob_SetMobInterData ( var C_Vob mobLock , var C_MobLockable_Data data ) {};","title":"Engine classes"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#engine-classes","text":"zParserExtender implements various proxy classes that can be used to access game world objects. Warning It is not recommended to implement complex mechanics using these classes and functions. They are present as a simple backup option for accessing game world objects and for quick fixes.","title":"Engine classes"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_vob","text":"This class represents basic pointer to a game world object.","title":"C_VOB"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_color","text":"Represents color in the RGBA format 1 2 3 4 5 6 7 class C_Color { var int R ; // red channel value var int G ; // green channel value var int B ; // blue channel value var int A ; // alpha channel value };","title":"C_Color"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_position","text":"Represents 3D position in the world 1 2 3 4 5 6 class C_Position { var int X ; // X coordinate var int Y ; // Y coordinate var int Z ; // Z coordinate }; Externals: 1 2 3 4 5 6 7 8 9 10 11 /// Returns the current position of the object in the world /// /// @param vob vob to ge the position of /// @return C_Position instace - position of the VOB func C_Position Vob_GetVobPosition ( var C_Vob vob ) {}; /// Sets the current position of the object in the world /// /// @param vob vob to get the position of /// @param pos new position of the vob func void Vob_SetVobPosition ( var C_Vob vob , var C_Position pos ) {}; Note The following classes define properties of C_VOB objects or classes derived from it.","title":"C_Position"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_vob_data","text":"Represents universal zCVob class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class C_VOB_DATA { var string Name ; // object name var float VisualAlpha ; // object's transparency 0.0 - 1.0 var int ShowVisual ; // display the mode var int DrawBBox3D ; // show objects bounding box var int VisualAlphaEnabled ; // enables objects transparency var int PhysicsEnabled ; // enables object's physics var int IgnoredByTraceRay ; // allow any object collisions var int CollDetectionStatic ; // allow collision with static world polygons var int CollDetectionDynamic ; // allow collision with dynamic world objects var int CastDynShadow ; // display shadow of the object var int LightColorStatDirty ; // allow static liging of the object var int LightColorDynDirty ; // allow dynamic lighing of the object var int SleepingMode ; // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only) var int DontWriteIntoArchive ; // turns of the serialization of this object to the save file }; Externals: 1 2 3 4 5 6 7 8 9 10 11 /// Returns the universal data of the zCVob object /// /// @param vob VOB to get the position of /// @return general vob data C_Vob_Data func C_Vob_Data Vob_GetVobData ( var C_Vob vob ) {}; /// Sets the universal data to a zCVob object /// /// @param vob VOB to get the position of /// @param data general vob data C_Vob_Data func void Vob_SetVobData ( var C_Vob vob , var C_Vob_Data data ) {};","title":"C_VOB_DATA"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_light_data","text":"Represents zCVobLight objects 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class C_LIGHT_DATA { var int R ; // red light intensity var int G ; // green light intensity var int B ; // blue light intensity var int Range ; // radius var int RangeInv ; // var int RangeBackup ; // var int RangeAniActFrame ; // current light animation frame for the radius var int RangeAniFPS ; // speed of light animation for the radius var int ColorAniActFrame ; // current light animation frame for colour var int ColorAniFPS ; // speed of light animation for colour var int SpotConeAngleDeg ; // angle of cone light source var int IsStatic ; // whether the source is static var int RangeAniSmooth ; // [UNUSED] var int RangeAniLoop ; // [UNUSED] var int ColorAniSmooth ; // allows soft transitions between colours var int ColorAniLoop ; // [UNUSED] var int IsTurnedOn ; // whether the light source is on var int LightQuality ; // source quality (when statically compiling light) (0 - high, 1 - medium, 2 - low) var int LightType ; // type of source (at static light compilation) (0 - point, 1 - cone) }; Externals: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /// Returns zCVobLight object data /// /// @param vobLight vobLight object /// @return C_Light_Data of the light func C_Light_Data Vob_GetLightData ( var C_Vob vobLight ) {}; /// Sets the data of a zCVobLight object /// /// @param vobLight object to apply the light data to /// @param data C_Light_Data light data to be set func void Vob_SetLightData ( var C_Vob vobLight , var C_Light_Data data ) {}; /// Clears the list of animation colours for the light source /// /// @param vobLight light vob func void Vob_ClearLightAniList ( var C_Vob vobLight ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param col colour to be applied func void Vob_AddLightAniColor ( var C_Vob vobLight , var C_Color col ) {}; /// Adds a color to the colour list /// /// @param vobLight object to apply the colour to /// @param r red colour channel /// @param g green colour channel /// @param b blue colour channel func void Vob_AddLightAniColorRGB ( var C_Vob vobLight , var int r , var int g , var int b ) {};","title":"C_LIGHT_DATA"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_mob_data","text":"Represents data for the used oCMOB object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class C_MOB_DATA { var string VisibleName ; // name shown above the object var int Hitpoints ; // number of hitpoints var int Damage ; // damage the object can cause var int IsDestroyed ; // if the object is destroyed var int Moveable ; // whether the object can be moved var int Takeable ; // whether the object can be taken var int FocusOverride ; // if the object will redefine focus in combat mode var int SndMat ; // object's material (0 - wood, 1 - stone, 2 - metal, 3 - skin, 4 - clay, 5 - glass) var string VisualDestroyed ; // model when the object is destroyed var string OwnerStr ; // name of the instance of the owner of the object var string OwnerGuildStr ; // name of the guild of the object var int Owner ; // instance of the owner var int OwnerGuild ; // guild instance var int FocusNameIndex ; // the script string of the displayed name }; 1 2 3 4 5 6 7 8 9 10 11 /// Returns the data of the oCMOB object /// /// @param mob oCMOB object /// @return mob data func C_Mob_Data Vob_GetMobData ( var C_Vob mob ) {}; /// Sets the data of the oCMOB object /// /// @param mob oCMOB object /// @param data C_Mob_Data to be set func void Vob_SetMobData ( var C_Vob mob , var C_Mob_Data data ) {};","title":"C_MOB_DATA"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_mobinter_data","text":"Represents data for the interactive object oCMobInter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class C_MOBINTER_DATA { var string TriggerTarget ; // object name which will be triggered by OnTrigger var string UseWithItem ; // name of the object instance that is needed for interaction var string Sceme ; // name of the scene that corresponds to the object and character animations var string ConditionFunc ; // scripting condition under which the interaction can be performed var string OnStateFuncName ; // the name pattern of the functions that will be called when the object changes the state var int State ; // the current state of the object var int State_num ; // number of object's states var int State_target // current state of the object var int Rewind ; // prohibits object updating var int MobStateAni ; // current animation of the object var int NpcStateAni ; // current character animation }; 1 2 3 4 5 6 7 8 9 10 11 /// Returns the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @return MobInter_Data of the object func MobInter_Data Vob_GetMobInterData ( var C_Vob mobInter ) {}; /// Sets the data of the oCMobInter object /// /// @param mobInter oCMobInter object /// @param data MobInter_Data of the object func void Vob_SetMobInterData ( var C_Vob mobInter , var C_MobInter_Data data ) {};","title":"C_MOBINTER_DATA"},{"location":"zengin/scripts/extenders/zparserextender/helperclasses/#c_moblockable_data","text":"Represents data for the locked interactive object oCMobLockable 1 2 3 4 5 6 7 8 class C_MOBLOCKABLE_DATA { var int Locked ; // whether the object is locked var int AutoOpen ; // [UNUSED] var int PickLockNr ; // current rotation number var string KeyInstance ; // key instance name for the object var string PickLockStr ; // combination to open the object (\"LRRLR\") }; 1 2 3 4 5 6 7 8 9 10 11 /// Returns the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data MobInter_Data of the object func C_MobLockable_Data Vob_GetMobInterData ( var C_Vob mobLock ) {}; /// Sets the data of the oCMobLockable object /// /// @param mobLock oCMobLockable object /// @param data C_MobLockable_Data of the object func void Vob_SetMobInterData ( var C_Vob mobLock , var C_MobLockable_Data data ) {};","title":"C_MOBLOCKABLE_DATA"},{"location":"zengin/scripts/extenders/zparserextender/hooks/","text":"Hooking Daedalus Daedalus hooking is one of the most powerful features of this plugin. Hooking is a mechanism that allows you to replace any scripted object with a new one. To do this, you must define a new object with the same type, name and in the same namespace . Hook/replacement will be performed only if the MergeMode setting is set to true for the current script in the META block or in the parameter of the same name in the .ini file of the mod. Warning If you forget to turn on the MergeMode , the compilation will fail with the redefinition error. When an object (instance, function or variable) is hooked/replaced, the original one is available under the same name with the _old suffix ( PC_Hero -> PC_Hero_old ). This allows you to refer to the old object. Function hook example 1 2 3 4 5 6 7 8 9 10 11 12 func void ZS_Attack_Loop () { // if the enemy is a player and has no weapon, then // also sheath the weapon. if ( Npc_IsPlayer ( other ) && ! Npc_HasReadiedWeapon ( other )) { return LOOP_END ; }; // otherwise call the original function return ZS_Attack_Loop_Old (); }; This kind of substitution works for instances and variables too. Warning While hooking an instances, you have to take care not to call the prototype. Prototype should be always changed back to the original class. This is wrong 1 2 3 4 5 instance pc_hero ( Npc_Default ) { pc_hero_old (); name = \"Pepe\" ; }; This leads to a double call of prototype Npc_Default which is considered an unsafe practice with undefined behaviour. The correct way is to call it like this: 1 2 3 4 5 instance pc_hero ( C_NPC ) // no prototype Npc_Default { pc_hero_old (); name = \"Pepe\" ; }; This way the prototype is called in the original function pc_hero_old() and not for the second time when creating the new hooked instance. Dialogue hook example The hooking mechanism is designed to introduce new dialogues into the game as well as replacing old ones with hooks. The scripter can create new merchants, quests, dialogues, as well as attach svm phrases to them. All new or replaced dialogues will immediately become available, including from saves. In the event that new dialogs are disabled (plugin or script removed), the engine will continue to keep them in the save file, which will allow the dialogs to return at any time with the same state they were in the last time. Warning Currently not working as intended (I think). The old dialogue is still used and as a result you will end up with both the old and the new dialogue (unless you edit the old condition function). 1 2 3 4 5 instance DIA_XARDAS_HELLO ( C_INFO ) { DIA_XARDAS_HELLO_old (); important = FALSE ; };","title":"Hooking"},{"location":"zengin/scripts/extenders/zparserextender/hooks/#hooking-daedalus","text":"Daedalus hooking is one of the most powerful features of this plugin. Hooking is a mechanism that allows you to replace any scripted object with a new one. To do this, you must define a new object with the same type, name and in the same namespace . Hook/replacement will be performed only if the MergeMode setting is set to true for the current script in the META block or in the parameter of the same name in the .ini file of the mod. Warning If you forget to turn on the MergeMode , the compilation will fail with the redefinition error. When an object (instance, function or variable) is hooked/replaced, the original one is available under the same name with the _old suffix ( PC_Hero -> PC_Hero_old ). This allows you to refer to the old object.","title":"Hooking Daedalus"},{"location":"zengin/scripts/extenders/zparserextender/hooks/#function-hook-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 func void ZS_Attack_Loop () { // if the enemy is a player and has no weapon, then // also sheath the weapon. if ( Npc_IsPlayer ( other ) && ! Npc_HasReadiedWeapon ( other )) { return LOOP_END ; }; // otherwise call the original function return ZS_Attack_Loop_Old (); }; This kind of substitution works for instances and variables too. Warning While hooking an instances, you have to take care not to call the prototype. Prototype should be always changed back to the original class. This is wrong 1 2 3 4 5 instance pc_hero ( Npc_Default ) { pc_hero_old (); name = \"Pepe\" ; }; This leads to a double call of prototype Npc_Default which is considered an unsafe practice with undefined behaviour. The correct way is to call it like this: 1 2 3 4 5 instance pc_hero ( C_NPC ) // no prototype Npc_Default { pc_hero_old (); name = \"Pepe\" ; }; This way the prototype is called in the original function pc_hero_old() and not for the second time when creating the new hooked instance.","title":"Function hook example"},{"location":"zengin/scripts/extenders/zparserextender/hooks/#dialogue-hook-example","text":"The hooking mechanism is designed to introduce new dialogues into the game as well as replacing old ones with hooks. The scripter can create new merchants, quests, dialogues, as well as attach svm phrases to them. All new or replaced dialogues will immediately become available, including from saves. In the event that new dialogs are disabled (plugin or script removed), the engine will continue to keep them in the save file, which will allow the dialogs to return at any time with the same state they were in the last time. Warning Currently not working as intended (I think). The old dialogue is still used and as a result you will end up with both the old and the new dialogue (unless you edit the old condition function). 1 2 3 4 5 instance DIA_XARDAS_HELLO ( C_INFO ) { DIA_XARDAS_HELLO_old (); important = FALSE ; };","title":"Dialogue hook example"},{"location":"zengin/scripts/extenders/zparserextender/injection/","text":"Daedalus Injection Script injection is a process of injecting Daedalus scripts on runtime without the need to recompile the scripts. This is essential for Union plugins that need to alter the scripts in a certain way, either for hotfixes or just for testing scripts without the need to recompile the whole .dat file. To inject a script, simply put a .d or .src file in Gothic/System/Autorun directory and run the game. Tip Automatic injection does not extend to nested directories in the Autorun directory directly, but you can put a .src file into Autorun directory and the rest into a subdirectory to keep a cleaner structure. Scripts in subdirectories can be accessed in two ways They are specified in a .src file The script file is an API script API script API scripts are .d files placed in Autorun subdirectories and are used as a dependency. It is assumed that the API script is not called on its own (or from a .src ) file, but is called using the dependency keyword After in one of the injected script files' META block. These scripts are meant to contain ready-made solution that need to be used by many other scripts as a dependency. Warning If the file specified in the After tag in the META block does not exist, the current file will not be parsed and injected since the dependency is missing, and it would fail. Due to this it is best to ship the dependency in the Autorun directory even if it comes from a different plugin.","title":"Daedalus Injection"},{"location":"zengin/scripts/extenders/zparserextender/injection/#daedalus-injection","text":"Script injection is a process of injecting Daedalus scripts on runtime without the need to recompile the scripts. This is essential for Union plugins that need to alter the scripts in a certain way, either for hotfixes or just for testing scripts without the need to recompile the whole .dat file. To inject a script, simply put a .d or .src file in Gothic/System/Autorun directory and run the game. Tip Automatic injection does not extend to nested directories in the Autorun directory directly, but you can put a .src file into Autorun directory and the rest into a subdirectory to keep a cleaner structure. Scripts in subdirectories can be accessed in two ways They are specified in a .src file The script file is an API script","title":"Daedalus Injection"},{"location":"zengin/scripts/extenders/zparserextender/injection/#api-script","text":"API scripts are .d files placed in Autorun subdirectories and are used as a dependency. It is assumed that the API script is not called on its own (or from a .src ) file, but is called using the dependency keyword After in one of the injected script files' META block. These scripts are meant to contain ready-made solution that need to be used by many other scripts as a dependency. Warning If the file specified in the After tag in the META block does not exist, the current file will not be parsed and injected since the dependency is missing, and it would fail. Due to this it is best to ship the dependency in the Autorun directory even if it comes from a different plugin.","title":"API script"},{"location":"zengin/scripts/extenders/zparserextender/meta/","text":"META block The META block is optional. If it is specified, it has to be the very first thing in the file without any indent or a comment above it. Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 META { Parser // specifies into which compiled file the scripts are going to be injected /* Code Name DAT file --- ------ ------- Game parser Gothic.dat SFX parserSoundFX SFX.dat PFX parserParticleFX ParticleFX.dat VFX parserVisualFX VisualFX.dat Camera parserCamera Camera.dat Menu parserMenu Menu.dat Music parserMusic Music.dat */ MergeMode // 0 - if confilct occurs = comilation error, 1 - if conflict occurs = hook Engine // comma separated list of engines for which the scripts will be injected /* Code Engine Human readable name --- ----- ----------------------- G1 Gothic I Gothic I Classic G1A Gothic Sequel Gothic I Addon <3 G2 Gothic II Gothic II Classic G2A Gothic II NoTR Gothic II Addon */ NativeWhile // use native while Namespace // namespace of this script file Using // comma separated list of namespaces, that are considered local for this script file Mod // specify for which mod should this code be injected After // comma separated list of scripts, after which this script should be parsed };","title":"META block"},{"location":"zengin/scripts/extenders/zparserextender/meta/#meta-block","text":"The META block is optional. If it is specified, it has to be the very first thing in the file without any indent or a comment above it. Syntax: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 META { Parser // specifies into which compiled file the scripts are going to be injected /* Code Name DAT file --- ------ ------- Game parser Gothic.dat SFX parserSoundFX SFX.dat PFX parserParticleFX ParticleFX.dat VFX parserVisualFX VisualFX.dat Camera parserCamera Camera.dat Menu parserMenu Menu.dat Music parserMusic Music.dat */ MergeMode // 0 - if confilct occurs = comilation error, 1 - if conflict occurs = hook Engine // comma separated list of engines for which the scripts will be injected /* Code Engine Human readable name --- ----- ----------------------- G1 Gothic I Gothic I Classic G1A Gothic Sequel Gothic I Addon <3 G2 Gothic II Gothic II Classic G2A Gothic II NoTR Gothic II Addon */ NativeWhile // use native while Namespace // namespace of this script file Using // comma separated list of namespaces, that are considered local for this script file Mod // specify for which mod should this code be injected After // comma separated list of scripts, after which this script should be parsed };","title":"META block"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/","text":"Namespaces zParserExtender also implements namespaces. Namespaces ensure that all symbols inside the namespace are unique. Defining a namespace To define a namespace the new keyword namespace is used. Regular scripts Injectable scripts 1 2 3 4 5 namespace zTestNamespace { var int var01 ; func void func01 () { }; }; 1 2 3 4 5 6 7 META { Namespace = zTestNamespace ; }; var int var01 ; func void func01 () { }; Namespace nesting Namespaces can be nested for finer control. In case of injection, the namespace defined in META is applied to all code inside the script. To go deeper into the namespaces you use the namespace operator : . This code shows function with the same name within three different namespaces. The call in GameInit is made from the global namespace. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace zTestNamespace01 { func void func01 () { }; }; namespace zTestNamespace02 { func void func01 () { }; }; namespace zTestNamespace03 { namespace zTestNamespace04 { func void func01 () { }; }; }; func event GameInit () { // In this case, the reference is from global namespace to zTestNamespace zTestNamespace01 : func01 (); zTestNamespace02 : func01 (); zTestNamespace03 : zTestNamespace04 : func01 (); }; Namespace traversal To go up a namespace tree you use the namespace operator : without specifying a namespace. Number of operators determines how many levels you go up. Exiting nested namespaces 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func void func01 () { Hlp_MessageBox ( \"#1\" ); }; namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#2\" ); }; namespace zTestNamespace02 { func void func01 () { Hlp_MessageBox ( \"#3\" ); }; namespace zTestNamespace03 { func void func01 () { Hlp_MessageBox ( \"#4\" ); }; func event GameInit () { ::: func01 (); // Calls the function 3 levels up :: func01 (); // Calls the function 2 levels up : func01 (); // Calls the function 1 level up func01 (); // Calls the function from the current namespace }; }; }; }; Optional namespace specification There are three cases where the namespace prefix is optional Shares the same namespace If the function is in higher level namespace If using is specified in the META block 1 2 3 4 5 6 7 8 9 10 11 12 13 namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#1\" ); }; func event GameInit () { // Function call from the current namespace func01 (); }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func void func01 () { Hlp_MessageBox ( \"#1\" ); }; namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#2\" ); }; namespace zTestNamespace02 { func event GameInit () { // Function call from the global namespace func01 (); }; }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 META { using = zTestNamespace01 ; }; namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#1\" ); }; }; func event GameInit () { // Calls the function with the namespace specified in the META block func01 (); }; Global namespace and Daedalus hooking Namespace can not only be defined to an existing symbol but also to define new ones. Next code example shows how to implement a hook to a global instance. 1 2 3 4 5 6 7 8 9 10 11 namespace zTestNamespace01 { const string Var01 = \"New instance name\" ; // Hooking the global instance instance : ItAr_Pir_L_Addon ( C_Item ) { ItAr_Pir_L_Addon_Old (); name = Var01 ; }; }; To hook an object, both signature and namespace has to match. It is syntactically allowed to hook an instance from a different space. Specify explicitly to which namespace the object will belong. This means that to hook instance ItAr_Pir_L_Addon from the namespace zTestNamespace01 to a global namespace, you have to refer to the global namespace using the namespace operator : . Since the function will be defined globally (as every symbol in ZenGin), it will be a part of the zTestNamespace01 which means that all functions will be local to this namespace.","title":"Namespaces"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#namespaces","text":"zParserExtender also implements namespaces. Namespaces ensure that all symbols inside the namespace are unique.","title":"Namespaces"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#defining-a-namespace","text":"To define a namespace the new keyword namespace is used. Regular scripts Injectable scripts 1 2 3 4 5 namespace zTestNamespace { var int var01 ; func void func01 () { }; }; 1 2 3 4 5 6 7 META { Namespace = zTestNamespace ; }; var int var01 ; func void func01 () { };","title":"Defining a namespace"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#namespace-nesting","text":"Namespaces can be nested for finer control. In case of injection, the namespace defined in META is applied to all code inside the script. To go deeper into the namespaces you use the namespace operator : . This code shows function with the same name within three different namespaces. The call in GameInit is made from the global namespace. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 namespace zTestNamespace01 { func void func01 () { }; }; namespace zTestNamespace02 { func void func01 () { }; }; namespace zTestNamespace03 { namespace zTestNamespace04 { func void func01 () { }; }; }; func event GameInit () { // In this case, the reference is from global namespace to zTestNamespace zTestNamespace01 : func01 (); zTestNamespace02 : func01 (); zTestNamespace03 : zTestNamespace04 : func01 (); };","title":"Namespace nesting"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#namespace-traversal","text":"To go up a namespace tree you use the namespace operator : without specifying a namespace. Number of operators determines how many levels you go up. Exiting nested namespaces 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 func void func01 () { Hlp_MessageBox ( \"#1\" ); }; namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#2\" ); }; namespace zTestNamespace02 { func void func01 () { Hlp_MessageBox ( \"#3\" ); }; namespace zTestNamespace03 { func void func01 () { Hlp_MessageBox ( \"#4\" ); }; func event GameInit () { ::: func01 (); // Calls the function 3 levels up :: func01 (); // Calls the function 2 levels up : func01 (); // Calls the function 1 level up func01 (); // Calls the function from the current namespace }; }; }; };","title":"Namespace traversal"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#optional-namespace-specification","text":"There are three cases where the namespace prefix is optional Shares the same namespace If the function is in higher level namespace If using is specified in the META block 1 2 3 4 5 6 7 8 9 10 11 12 13 namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#1\" ); }; func event GameInit () { // Function call from the current namespace func01 (); }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func void func01 () { Hlp_MessageBox ( \"#1\" ); }; namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#2\" ); }; namespace zTestNamespace02 { func event GameInit () { // Function call from the global namespace func01 (); }; }; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 META { using = zTestNamespace01 ; }; namespace zTestNamespace01 { func void func01 () { Hlp_MessageBox ( \"#1\" ); }; }; func event GameInit () { // Calls the function with the namespace specified in the META block func01 (); };","title":"Optional namespace specification"},{"location":"zengin/scripts/extenders/zparserextender/namespaces/#global-namespace-and-daedalus-hooking","text":"Namespace can not only be defined to an existing symbol but also to define new ones. Next code example shows how to implement a hook to a global instance. 1 2 3 4 5 6 7 8 9 10 11 namespace zTestNamespace01 { const string Var01 = \"New instance name\" ; // Hooking the global instance instance : ItAr_Pir_L_Addon ( C_Item ) { ItAr_Pir_L_Addon_Old (); name = Var01 ; }; }; To hook an object, both signature and namespace has to match. It is syntactically allowed to hook an instance from a different space. Specify explicitly to which namespace the object will belong. This means that to hook instance ItAr_Pir_L_Addon from the namespace zTestNamespace01 to a global namespace, you have to refer to the global namespace using the namespace operator : . Since the function will be defined globally (as every symbol in ZenGin), it will be a part of the zTestNamespace01 which means that all functions will be local to this namespace.","title":"Global namespace and Daedalus hooking"},{"location":"zengin/scripts/extenders/zparserextender/other/","text":"Other functions of the extender ini parameters The choice of ini file depends on how the game was launched. If it was launched from Gothic.exe, then the parameters will be read from SystemPack.ini . If it was launched through GothicStarter.exe, then they will be read from the ini of the mod. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [zParserExtender] LoadScript(obsolete) = ;specifies a parser-script format script to run the scripts. The parameter is currently invalid. MergeMode = True ;specifies whether injections will produce hooks. CompileDat = False ;Determines if a copy of DAT file which has been modified by injection will be created. CompileOU = False ;determines if a copy of an injection-modified OU file will be created. NativeWhile = False ;Determines if a WHILE loop will be compiled. Defaults to False (for Ninja compatibility). MessagesLevel = 1 ;sets the output level. The higher the level, the more information will be printed to the debug console. StringIndexingMode = -1 ;defines string indexing mode (see string indexing). Default value is -1. ;Default = -1 - The default mode for the moment is Repair mode. ;Disabled = 0 - Do nothing with the indices. ;TopSymbol = 1 - The plugin finds the uppermost unnamed string and sets a counter for it. ;Repair = 2 - The plugin goes through the whole string table and, if the indexing order is broken, puts the correct names. The counter is set on the basis of the search. MARVIN console commands zParserExtender adds console commands that save copies of the .dat files with the injected code. Warning If the mod uses Ikarus, the CompileDat option (in the .ini file) should be used since a fatal error may occur whe using the command. 1 2 3 4 5 6 7 8 9 Parser SaveDat OU - exports OU.Edited.bin Parser SaveDat Game - exports Gothic.Edited.dat Parser SaveDat SFX - exports SFX.Edited.dat Parser SaveDat PFX - exports ParticleFX.Edited.dat Parser SaveDat VFX - exports VisualFX.Edited.dat Parser SaveDat Camera - exports Camera.Edited.dat Parser SaveDat Menu - exports Menu.Edited.dat Parser SaveDat Music - exports Music.Edited.dat Parser Export Stringlist - exports the full string table to Scripts\\Exports\\StringList.d Launch options Command line parameters can be passed to the game's exe via the command line or using GothicStarter_Mod. 1 2 3 4 5 6 7 8 zReparse_OU - parses and creates OU.bin zReparse_Game - parses and creates Gothic.dat zReparse_SFX - parses and creates SFX.dat zReparse_PFX - parses and creates ParticleFX.dat zReparse_VFX - parses and creates VisualFX.dat zReparse_Camera - parses and creates Camera.dat zReparse_Menu - parses and creates Menu.dat zReparse_Music - parses and creates Music.dat Note If you want to compile OU, you also have to include the Game parameter -zReparse_Game -zReparse_OU Const array access The original zParser doesn't allow direct access to const string arrays. zParserExtender allows you to do so. Example: 1 2 3 4 func event GameInit () { Hlp_MessageBox ( TXT_INV_CAT [ 4 ]); // Prints \"Artifacts\" }; Other engine fixes When creating an item instance, the instance is placed into the global item instance On DAT file load, the engine restores the original symbol hierarchy When loading a save, the engine now skips unknown symbols, instead of crashing","title":"Other features"},{"location":"zengin/scripts/extenders/zparserextender/other/#other-functions-of-the-extender","text":"","title":"Other functions of the extender"},{"location":"zengin/scripts/extenders/zparserextender/other/#ini-parameters","text":"The choice of ini file depends on how the game was launched. If it was launched from Gothic.exe, then the parameters will be read from SystemPack.ini . If it was launched through GothicStarter.exe, then they will be read from the ini of the mod. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [zParserExtender] LoadScript(obsolete) = ;specifies a parser-script format script to run the scripts. The parameter is currently invalid. MergeMode = True ;specifies whether injections will produce hooks. CompileDat = False ;Determines if a copy of DAT file which has been modified by injection will be created. CompileOU = False ;determines if a copy of an injection-modified OU file will be created. NativeWhile = False ;Determines if a WHILE loop will be compiled. Defaults to False (for Ninja compatibility). MessagesLevel = 1 ;sets the output level. The higher the level, the more information will be printed to the debug console. StringIndexingMode = -1 ;defines string indexing mode (see string indexing). Default value is -1. ;Default = -1 - The default mode for the moment is Repair mode. ;Disabled = 0 - Do nothing with the indices. ;TopSymbol = 1 - The plugin finds the uppermost unnamed string and sets a counter for it. ;Repair = 2 - The plugin goes through the whole string table and, if the indexing order is broken, puts the correct names. The counter is set on the basis of the search.","title":"ini parameters"},{"location":"zengin/scripts/extenders/zparserextender/other/#marvin-console-commands","text":"zParserExtender adds console commands that save copies of the .dat files with the injected code. Warning If the mod uses Ikarus, the CompileDat option (in the .ini file) should be used since a fatal error may occur whe using the command. 1 2 3 4 5 6 7 8 9 Parser SaveDat OU - exports OU.Edited.bin Parser SaveDat Game - exports Gothic.Edited.dat Parser SaveDat SFX - exports SFX.Edited.dat Parser SaveDat PFX - exports ParticleFX.Edited.dat Parser SaveDat VFX - exports VisualFX.Edited.dat Parser SaveDat Camera - exports Camera.Edited.dat Parser SaveDat Menu - exports Menu.Edited.dat Parser SaveDat Music - exports Music.Edited.dat Parser Export Stringlist - exports the full string table to Scripts\\Exports\\StringList.d","title":"MARVIN console commands"},{"location":"zengin/scripts/extenders/zparserextender/other/#launch-options","text":"Command line parameters can be passed to the game's exe via the command line or using GothicStarter_Mod. 1 2 3 4 5 6 7 8 zReparse_OU - parses and creates OU.bin zReparse_Game - parses and creates Gothic.dat zReparse_SFX - parses and creates SFX.dat zReparse_PFX - parses and creates ParticleFX.dat zReparse_VFX - parses and creates VisualFX.dat zReparse_Camera - parses and creates Camera.dat zReparse_Menu - parses and creates Menu.dat zReparse_Music - parses and creates Music.dat Note If you want to compile OU, you also have to include the Game parameter -zReparse_Game -zReparse_OU","title":"Launch options"},{"location":"zengin/scripts/extenders/zparserextender/other/#const-array-access","text":"The original zParser doesn't allow direct access to const string arrays. zParserExtender allows you to do so. Example: 1 2 3 4 func event GameInit () { Hlp_MessageBox ( TXT_INV_CAT [ 4 ]); // Prints \"Artifacts\" };","title":"Const array access"},{"location":"zengin/scripts/extenders/zparserextender/other/#other-engine-fixes","text":"When creating an item instance, the instance is placed into the global item instance On DAT file load, the engine restores the original symbol hierarchy When loading a save, the engine now skips unknown symbols, instead of crashing","title":"Other engine fixes"},{"location":"zengin/scripts/extenders/zparserextender/testelse/","text":"Test-else statements The test-else bind statement can be used to define sections of code to be compiled. If the code is within the boundaries of the inactive test-else branch, it will not be compiled. This operator can take values as input that are converted to logical values. For example, if an object is passed as an argument, the parser will check for its existence. If it is an engine tag, it will return the result of matching the current engine with the tag: Valid values: instance name - PC_HERO , ItMi_Gold , ... engine tag - G1 , G1A , G2 , G2A Steam Overlay activity - Steam The result can be combined from several arguments. Round brackets () ca be used to specify priority and expressions support the logical negation operator ! , logical AND && and OR || . The operator can be used anywhere in the script file. It is syntactically similar to if else statement, but curly braces {} can be omitted for single-line operations. For example: SteamActivated constant is set only when Steam is active 1 test Steam var const SteamActivated = 1 ; Example of a logical expression with an else branch 1 2 3 4 5 6 7 8 test SteamActivated && G2A { // TODO } else { // TODO }","title":"Test-else binding"},{"location":"zengin/scripts/extenders/zparserextender/testelse/#test-else-statements","text":"The test-else bind statement can be used to define sections of code to be compiled. If the code is within the boundaries of the inactive test-else branch, it will not be compiled. This operator can take values as input that are converted to logical values. For example, if an object is passed as an argument, the parser will check for its existence. If it is an engine tag, it will return the result of matching the current engine with the tag: Valid values: instance name - PC_HERO , ItMi_Gold , ... engine tag - G1 , G1A , G2 , G2A Steam Overlay activity - Steam The result can be combined from several arguments. Round brackets () ca be used to specify priority and expressions support the logical negation operator ! , logical AND && and OR || . The operator can be used anywhere in the script file. It is syntactically similar to if else statement, but curly braces {} can be omitted for single-line operations. For example: SteamActivated constant is set only when Steam is active 1 test Steam var const SteamActivated = 1 ; Example of a logical expression with an else branch 1 2 3 4 5 6 7 8 test SteamActivated && G2A { // TODO } else { // TODO }","title":"Test-else statements"},{"location":"zengin/scripts/extenders/zparserextender/while/","text":"Native WHILE loop Just like Ikarus zParserExtender implements a while loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 var int value ; value = 10 ; while ( value > 0 ) { if ( value == 8 ) { continue ; }; if ( value == 2 ) { break ; }; }; Note To activate while it is necessary to set NativeWhile setting in SystemPack.ini 1 2 [ZPARSE_EXTENDER] NativeWhile = true Compiled while loop works in vanilla engine without the plugin.","title":"While loop"},{"location":"zengin/scripts/extenders/zparserextender/while/#native-while-loop","text":"Just like Ikarus zParserExtender implements a while loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 var int value ; value = 10 ; while ( value > 0 ) { if ( value == 8 ) { continue ; }; if ( value == 2 ) { break ; }; }; Note To activate while it is necessary to set NativeWhile setting in SystemPack.ini 1 2 [ZPARSE_EXTENDER] NativeWhile = true Compiled while loop works in vanilla engine without the plugin.","title":"Native WHILE loop"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/","text":"Sign post teleportation This is a short \"problem-solving\" example, where we try to demonstrate the power of Daedalus injection using zParserExtender . GaroK asked me if there is a way to teleport to all the sign posts in Khorinis to gather information for a Gothic wiki article. The goal is to introduce a function that will teleport you to every signpost in Khorinis with the press of a button. The problem In ZenGin you can teleport to named game objects with the goto vob {vobname} command. But since the signposts do not have a vobname defined, I had to figure out a different approach. ASCII ZEN We want to get all the signposts position from Khorinis. The game world was loaded into one of the available world editor, I found one of the signposts and noted the visual which dictates the model of the in-game object nw_misc_sign_01.3DS . Alternatively, you can find the standard vanilla objects from both games on this website . Next, the world was saved as a ASCII ZEN format. This allows us to write a macro to search for all instances of objects with a specific visual and extract the position vector. One signpost object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 [% oCMOB:zCVob 47105 317] pack = int:0 presetName = string: bbox3DWS = rawFloat:7564.8291 127.361191 -80.5309067 7611.52441 377.422913 1.67681122 trafoOSToWSRot = raw:73e1673f9c4ec33b15efd8be4465d7bba0fe7f3f30ea7137e5edd83eecaa353bb7e2673f trafoOSToWSPos = vec3:7588.17627 252.391052 -39.4283791 vobName = string: visual = string:NW_MISC_SIGN_01.3DS showVisual = bool:1 visualCamAlign = enum:0 visualAniMode = enum:0 visualAniModeStrength = float:0 vobFarClipZScale = float:1 cdStatic = bool:1 cdDyn = bool:1 staticVob = bool:1 dynShadow = enum:0 zbias = int:0 isAmbient = bool:0 [visual zCProgMeshProto 53505 318] [] [ai % 0 0] [] focusName = string:MOBNAME_INCITY02 hitpoints = int:10 damage = int:0 moveable = bool:0 takeable = bool:0 focusOverride = bool:0 soundMaterial = enum:0 visualDestroyed = string: owner = string: ownerGuild = string: isDestroyed = bool:0 [] Tip You can also see that the focusName has a MOBNAME_INCITY02 string constant. This constant is defined in the scripts and its content is used as the focus name. 1 const string MOBNAME_INCITY02 = \"To Marketplace\" ; The injectable script As it is an injectable script, we have to specify the META tag. Lets tell zParseExtender to insert this code into the game parser. 1 2 3 4 META { Parser = Game }; We want to teleport the player and for this we will need the C_Position and C_Vob_Data classes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class C_Position { var int X ; // X coordinate var int Y ; // Y coordinate var int Z ; // Z coordinate }; class C_VOB_DATA { var string Name ; // object name var float VisualAlpha ; // object's transparency 0.0 - 1.0 var int ShowVisual ; // display the mode var int DrawBBox3D ; // show objects bounding box var int VisualAlphaEnabled ; // enables objects transparency var int PhysicsEnabled ; // enables object's physics var int IgnoredByTraceRay ; // allow any object collisions var int CollDetectionStatic ; // allow collision with static world polygons var int CollDetectionDynamic ; // allow collision with dynamic world objects var int CastDynShadow ; // display shadow of the object var int LightColorStatDirty ; // allow static liging of the object var int LightColorDynDirty ; // allow dynamic lighing of the object var int SleepingMode ; // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only) var int DontWriteIntoArchive ; // turns of the serialization of this object to the save file }; It turns out there is 54 instances of objects with the desired visual. Let us define const int NUM_OF_SIGNS = 54 and a const int MAX_COORDS = 3 * NUM_OF_SIGNS - we will store 3 times 54 integers - for every signpost a x , y and z coordinate. And lastly a const int array containing all the positions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Number of signs we want to jump to const int NUM_OF_SIGNS = 54 ; const int MAX_COORDS = 3 * NUM_OF_SIGNS ; const int sign_coordinates [ MAX_COORDS ] = { 11974 , 309 , 6815 , 12024 , 310 , 6778 , 12411 , 1668 , - 22495 , 19491 , 1281 , 1669 , 19563 , 1281 , 1687 , 20294 , 2058 , 12487 , 20324 , 2058 , 12419 , 21917 , 2900 , - 22751 , 2600 , - 57 , - 4351 , 26695 , 2419 , 4308 , 26770 , 2418 , 4319 , 26978 , 2937 , 6130 , 27015 , 2936 , 6104 , 27049 , 2937 , 6159 , 2964 , 2142 , 14424 , 31383 , 3896 , 4699 , 31427 , 3896 , 4640 , 35368 , 3870 , - 4374 , 35435 , 3870 , - 4355 , 35437 , 3871 , - 4399 , 36205 , 3333 , - 27186 , 37774 , 3875 , - 501 , 37812 , 3874 , - 469 , 37849 , 3874 , - 512 , 38291 , 3732 , - 6699 , 39276 , 3926 , - 3357 , 39307 , 3924 , - 3313 , 39351 , 3924 , - 3359 , 39435 , 4350 , 10902 , 39458 , 4350 , 10827 , 40932 , 3861 , - 3054 , 42454 , 2838 , - 19437 , 5297 , 387 , - 2145 , 5358 , 387 , - 2184 , 5362 , 387 , - 2128 , 54006 , 1723 , - 10316 , 54035 , 1723 , - 10387 , 551 , - 62 , - 1820 , 61080 , 2132 , - 11622 , 61155 , 2132 , - 11625 , 6408 , 392 , 3598 , 6432 , 393 , 3652 , 7000 , 387 , - 1482 , 73439 , 3341 , - 11307 , 7588 , 252 , - 39 , 7590 , 252 , - 109 , 7642 , 253 , - 83 , 7713 , 387 , - 4782 , 7758 , 386 , - 4775 , 7776 , 388 , - 4811 , 8154 , 1206 , - 17022 , 8855 , 395 , - 2402 , 9704 , 393 , 5129 , 9738 , 392 , 5108 }; Next define a built in event GameLoop function, to check for a pressed key. If the key U is pressed, the jump_to_sign function is called. 1 2 3 4 5 6 7 8 9 // check for pressed U button every frame func event GameLoop () { // if U is toggled, run the function if ( Hlp_KeyToggled ( KEY_U )) { jump_to_sign (); }; }; Let's look at the jump_to_sign function now. This function is called on every U key press and goes through all the signposts and teleports the player to them. At the start of the function we check if the index is not out of bounds and if it is, sets it back to 0 and starts over. 1 2 3 4 5 // if we reached the end, start over if ( tp_index >= NUM_OF_SIGNS ) { tp_index = 0 ; }; Notice the use of Str_Format function for the formatted output. 1 2 3 4 5 // give information to the player Print ( Str_Format ( \"Sign %i/%i\" , tp_index + 1 , NUM_OF_SIGNS )); var C_Position pos ; pos = Vob_GetVobPosition ( hero ); var C_Vob_Data data ; data = Vob_GetVobData ( hero ); Daedalus does not allow array access with variables (only constants and literals). To access the coordinate array we use a selection of parser functions. Firstly we get the game parser ID. Then we can use the Par_GetSymbolValueIntArray to access the sign_coordinates array and assign the coordinates to the pos variable. 1 2 3 4 5 6 7 8 9 10 // get parser ID for the GAME parser var int game_par_id ; game_par_id = Par_GetParserID ( \"game\" ); // get parser ID of the array var int arr_id ; arr_id = Par_GetSymbolID ( game_par_id , \"sign_coordinates\" ); // access the coordinates from above array pos . x = Par_GetSymbolValueIntArray ( game_par_id , arr_id , tp_index * 3 ); pos . y = Par_GetSymbolValueIntArray ( game_par_id , arr_id , tp_index * 3 + 1 ); pos . z = Par_GetSymbolValueIntArray ( game_par_id , arr_id , tp_index * 3 + 2 ); And now comes the big trick. If you try to just change the position the dynamic and static collision is going to stop you at the first wall, tree or a mountain. To disable it, we can use the C_Vob_Data helper class, get players data, and disable both the static a dynamic collision. First we create a backup of the values just so we can restore them back after the teleport. 1 2 3 4 5 6 7 // backup original collision detection var int dyn ; dyn = data . CollDetectionDynamic ; var int stat ; stat = data . CollDetectionStatic ; // turn off collision detection data . CollDetectionDynamic = 0 ; data . CollDetectionStatic = 0 ; Let us apply the changed data to the player and edit the position. 1 2 3 4 5 // apply the edited data to player Vob_SetVobData ( hero , data ); // move the player Vob_SetVobPosition ( hero , pos ); Restore the collision detection data from the backup we made and set it. 1 2 3 4 5 6 // restore collision detection data . CollDetectionDynamic = dyn ; data . CollDetectionStatic = stat ; // apply the edited data to player Vob_SetVobData ( hero , data ); Finally, we advance the index to jump to another signpost. 1 2 // advance the index tp_index += 1 ;","title":"Sign post example"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#sign-post-teleportation","text":"This is a short \"problem-solving\" example, where we try to demonstrate the power of Daedalus injection using zParserExtender . GaroK asked me if there is a way to teleport to all the sign posts in Khorinis to gather information for a Gothic wiki article. The goal is to introduce a function that will teleport you to every signpost in Khorinis with the press of a button.","title":"Sign post teleportation"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#the-problem","text":"In ZenGin you can teleport to named game objects with the goto vob {vobname} command. But since the signposts do not have a vobname defined, I had to figure out a different approach.","title":"The problem"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#ascii-zen","text":"We want to get all the signposts position from Khorinis. The game world was loaded into one of the available world editor, I found one of the signposts and noted the visual which dictates the model of the in-game object nw_misc_sign_01.3DS . Alternatively, you can find the standard vanilla objects from both games on this website . Next, the world was saved as a ASCII ZEN format. This allows us to write a macro to search for all instances of objects with a specific visual and extract the position vector. One signpost object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 [% oCMOB:zCVob 47105 317] pack = int:0 presetName = string: bbox3DWS = rawFloat:7564.8291 127.361191 -80.5309067 7611.52441 377.422913 1.67681122 trafoOSToWSRot = raw:73e1673f9c4ec33b15efd8be4465d7bba0fe7f3f30ea7137e5edd83eecaa353bb7e2673f trafoOSToWSPos = vec3:7588.17627 252.391052 -39.4283791 vobName = string: visual = string:NW_MISC_SIGN_01.3DS showVisual = bool:1 visualCamAlign = enum:0 visualAniMode = enum:0 visualAniModeStrength = float:0 vobFarClipZScale = float:1 cdStatic = bool:1 cdDyn = bool:1 staticVob = bool:1 dynShadow = enum:0 zbias = int:0 isAmbient = bool:0 [visual zCProgMeshProto 53505 318] [] [ai % 0 0] [] focusName = string:MOBNAME_INCITY02 hitpoints = int:10 damage = int:0 moveable = bool:0 takeable = bool:0 focusOverride = bool:0 soundMaterial = enum:0 visualDestroyed = string: owner = string: ownerGuild = string: isDestroyed = bool:0 [] Tip You can also see that the focusName has a MOBNAME_INCITY02 string constant. This constant is defined in the scripts and its content is used as the focus name. 1 const string MOBNAME_INCITY02 = \"To Marketplace\" ;","title":"ASCII ZEN"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#the-injectable-script","text":"As it is an injectable script, we have to specify the META tag. Lets tell zParseExtender to insert this code into the game parser. 1 2 3 4 META { Parser = Game }; We want to teleport the player and for this we will need the C_Position and C_Vob_Data classes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class C_Position { var int X ; // X coordinate var int Y ; // Y coordinate var int Z ; // Z coordinate }; class C_VOB_DATA { var string Name ; // object name var float VisualAlpha ; // object's transparency 0.0 - 1.0 var int ShowVisual ; // display the mode var int DrawBBox3D ; // show objects bounding box var int VisualAlphaEnabled ; // enables objects transparency var int PhysicsEnabled ; // enables object's physics var int IgnoredByTraceRay ; // allow any object collisions var int CollDetectionStatic ; // allow collision with static world polygons var int CollDetectionDynamic ; // allow collision with dynamic world objects var int CastDynShadow ; // display shadow of the object var int LightColorStatDirty ; // allow static liging of the object var int LightColorDynDirty ; // allow dynamic lighing of the object var int SleepingMode ; // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only) var int DontWriteIntoArchive ; // turns of the serialization of this object to the save file }; It turns out there is 54 instances of objects with the desired visual. Let us define const int NUM_OF_SIGNS = 54 and a const int MAX_COORDS = 3 * NUM_OF_SIGNS - we will store 3 times 54 integers - for every signpost a x , y and z coordinate. And lastly a const int array containing all the positions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // Number of signs we want to jump to const int NUM_OF_SIGNS = 54 ; const int MAX_COORDS = 3 * NUM_OF_SIGNS ; const int sign_coordinates [ MAX_COORDS ] = { 11974 , 309 , 6815 , 12024 , 310 , 6778 , 12411 , 1668 , - 22495 , 19491 , 1281 , 1669 , 19563 , 1281 , 1687 , 20294 , 2058 , 12487 , 20324 , 2058 , 12419 , 21917 , 2900 , - 22751 , 2600 , - 57 , - 4351 , 26695 , 2419 , 4308 , 26770 , 2418 , 4319 , 26978 , 2937 , 6130 , 27015 , 2936 , 6104 , 27049 , 2937 , 6159 , 2964 , 2142 , 14424 , 31383 , 3896 , 4699 , 31427 , 3896 , 4640 , 35368 , 3870 , - 4374 , 35435 , 3870 , - 4355 , 35437 , 3871 , - 4399 , 36205 , 3333 , - 27186 , 37774 , 3875 , - 501 , 37812 , 3874 , - 469 , 37849 , 3874 , - 512 , 38291 , 3732 , - 6699 , 39276 , 3926 , - 3357 , 39307 , 3924 , - 3313 , 39351 , 3924 , - 3359 , 39435 , 4350 , 10902 , 39458 , 4350 , 10827 , 40932 , 3861 , - 3054 , 42454 , 2838 , - 19437 , 5297 , 387 , - 2145 , 5358 , 387 , - 2184 , 5362 , 387 , - 2128 , 54006 , 1723 , - 10316 , 54035 , 1723 , - 10387 , 551 , - 62 , - 1820 , 61080 , 2132 , - 11622 , 61155 , 2132 , - 11625 , 6408 , 392 , 3598 , 6432 , 393 , 3652 , 7000 , 387 , - 1482 , 73439 , 3341 , - 11307 , 7588 , 252 , - 39 , 7590 , 252 , - 109 , 7642 , 253 , - 83 , 7713 , 387 , - 4782 , 7758 , 386 , - 4775 , 7776 , 388 , - 4811 , 8154 , 1206 , - 17022 , 8855 , 395 , - 2402 , 9704 , 393 , 5129 , 9738 , 392 , 5108 }; Next define a built in event GameLoop function, to check for a pressed key. If the key U is pressed, the jump_to_sign function is called. 1 2 3 4 5 6 7 8 9 // check for pressed U button every frame func event GameLoop () { // if U is toggled, run the function if ( Hlp_KeyToggled ( KEY_U )) { jump_to_sign (); }; }; Let's look at the jump_to_sign function now. This function is called on every U key press and goes through all the signposts and teleports the player to them. At the start of the function we check if the index is not out of bounds and if it is, sets it back to 0 and starts over. 1 2 3 4 5 // if we reached the end, start over if ( tp_index >= NUM_OF_SIGNS ) { tp_index = 0 ; }; Notice the use of Str_Format function for the formatted output. 1 2 3 4 5 // give information to the player Print ( Str_Format ( \"Sign %i/%i\" , tp_index + 1 , NUM_OF_SIGNS )); var C_Position pos ; pos = Vob_GetVobPosition ( hero ); var C_Vob_Data data ; data = Vob_GetVobData ( hero ); Daedalus does not allow array access with variables (only constants and literals). To access the coordinate array we use a selection of parser functions. Firstly we get the game parser ID. Then we can use the Par_GetSymbolValueIntArray to access the sign_coordinates array and assign the coordinates to the pos variable. 1 2 3 4 5 6 7 8 9 10 // get parser ID for the GAME parser var int game_par_id ; game_par_id = Par_GetParserID ( \"game\" ); // get parser ID of the array var int arr_id ; arr_id = Par_GetSymbolID ( game_par_id , \"sign_coordinates\" ); // access the coordinates from above array pos . x = Par_GetSymbolValueIntArray ( game_par_id , arr_id , tp_index * 3 ); pos . y = Par_GetSymbolValueIntArray ( game_par_id , arr_id , tp_index * 3 + 1 ); pos . z = Par_GetSymbolValueIntArray ( game_par_id , arr_id , tp_index * 3 + 2 ); And now comes the big trick. If you try to just change the position the dynamic and static collision is going to stop you at the first wall, tree or a mountain. To disable it, we can use the C_Vob_Data helper class, get players data, and disable both the static a dynamic collision. First we create a backup of the values just so we can restore them back after the teleport. 1 2 3 4 5 6 7 // backup original collision detection var int dyn ; dyn = data . CollDetectionDynamic ; var int stat ; stat = data . CollDetectionStatic ; // turn off collision detection data . CollDetectionDynamic = 0 ; data . CollDetectionStatic = 0 ; Let us apply the changed data to the player and edit the position. 1 2 3 4 5 // apply the edited data to player Vob_SetVobData ( hero , data ); // move the player Vob_SetVobPosition ( hero , pos ); Restore the collision detection data from the backup we made and set it. 1 2 3 4 5 6 // restore collision detection data . CollDetectionDynamic = dyn ; data . CollDetectionStatic = stat ; // apply the edited data to player Vob_SetVobData ( hero , data ); Finally, we advance the index to jump to another signpost. 1 2 // advance the index tp_index += 1 ;","title":"The injectable script"},{"location":"zengin/scripts/extenders/zparserextender/externals/","text":"Externals External functions are Daedalus functions (defined in the engine itself) used to interface with the engine. zParseExtender adds a lot of new functions that help scripters to interface with the engine in more ways that were not possible before, at least without script extenders such as Ikarus and LeGo.","title":"Externals"},{"location":"zengin/scripts/extenders/zparserextender/externals/#externals","text":"External functions are Daedalus functions (defined in the engine itself) used to interface with the engine. zParseExtender adds a lot of new functions that help scripters to interface with the engine in more ways that were not possible before, at least without script extenders such as Ikarus and LeGo.","title":"Externals"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/","text":"AI - functions for working with AI Functions to work with the new C_Trigger class and NPC's AI queue. AI_CallScript Adds a funcName function call to the AI queue 1 2 3 func void AI_CallScript ( var string funcName , var C_NPC slf , var C_NPC oth ) {}; funcName - name of the function to be called slf - will be inserted into global self instance oth - will be inserted into global other instance AI_startTriggerScript Creates a trigger script that calls function funcName once every interval in milliseconds 1 func C_Trigger AI_startTriggerScript ( var string funcName , var int interval ) {}; funcName - name of the function to be called interval - call period in milliseconds return - created C_Trigger instance AI_startTriggerScriptEx Extended version call - Creates a trigger script, that calls function funcName once every interval in milliseconds also updates the self , other and victim global instances based on slf , oth and vct parameters respectively 1 2 3 4 5 func C_Trigger AI_startTriggerScriptEx ( var string funcName , var int interval , var C_NPC slf , var C_NPC oth , var C_NPC vct ) {}; funcName - name of the function to be called interval - call period in milliseconds slf - will be inserted into global self instance oth - will be inserted into global other instance vct - will be inserted into global victim instance return - created C_Trigger instance AI_GetTriggerByID Returns a C_Trigger instance from the array of active triggers by the array index ID 1 func C_Trigger AI_GetTriggerByID ( var int ID ) {}; ID - array id return - active C_Trigger instance AI_GetTriggersNum Returns the number of active C_Trigger scripts 1 func int AI_GetTriggersNum () {}; return - number of active C_Trigger scripts AI_GetTriggerNPC Returns the npc associated with the C_Trigger script based on the ID selfID = 0; otherID = 1; victimID = 2; 1 func C_NPC AI_GetTriggerNPC ( var C_Trigger trigger , var int npcID ) {}; trigger - C_Trigger script npcID - NPC id return - active C_Trigger instance AI_GetTriggerFunc Returns the function associated with the specified C_Trigger 1 func func AI_GetTriggerFunc ( var C_Trigger trigger ) {}; trigger - C_Trigger script return - trigger function AI_GetTriggerFuncName Returns the function name of a function associated with the specified C_Trigger 1 func string AI_GetTriggerFuncName ( var C_Trigger trigger ) {}; trigger - C_Trigger script return - active C_Trigger instance Ai_GetNextTriggerByFunc Returns the next trigger in the active trigger array based on the trigger function, starting on the startTrigger trigger 1 func C_Trigger Ai_GetNextTriggerByFunc ( var C_Trigger startTrigger , var func function ) {}; startTrigger - C_Trigger script to start the search from function - function to be matched return - C_Trigger instance Ai_GetNextTriggerByFuncName Returns the next trigger in the active trigger array based on the trigger function name, starting on the startTrigger trigger 1 func C_Trigger Ai_GetNextTriggerByFuncName ( var C_Trigger startTrigger , var string functionName ) {}; startTrigger - C_Trigger script to start the search from functionName - name of a function to be matched return - C_Trigger instance Ai_GetNextTriggerBySelf Returns the next trigger in the active trigger array based on the self trigger parameter, starting on the startTrigger instance set in the trigger 1 func C_Trigger Ai_GetNextTriggerBySelf ( var C_Trigger startTrigger , var C_NPC self ) {}; startTrigger - C_Trigger script to start the search from self - C_NPC instance return - C_Trigger instance Ai_GetNextTriggerByOther Returns the next trigger in the active trigger array based on the other trigger parameter, starting on the startTrigger instance set in the trigger 1 func C_Trigger Ai_GetNextTriggerByOther ( var C_Trigger startTrigger , var C_NPC other ) {}; startTrigger - C_Trigger script to start the search from other - C_NPC instance return - C_Trigger instance Ai_GetNextTriggerByVictim Returns the next trigger in the active trigger array based on the victim trigger parameter, starting on the startTrigger instance set in the trigger 1 func C_Trigger Ai_GetNextTriggerByVictim ( var C_Trigger startTrigger , var C_NPC victim ) {}; startTrigger - C_Trigger script to start the search from victim - C_NPC instance return - C_Trigger instance Ai_GetNextTriggerByNPCs Returns the next trigger in the active trigger array based on all the NPCs set in the trigger script self , other and victim , starting on the startTrigger instance set in the trigger 1 2 3 4 func c_trigger Ai_GetNextTriggerByNPCs ( var C_Trigger startTrigger , var C_NPC self , var C_NPC other , var C_NPC victim ) {}; startTrigger - C_Trigger script to start the search from self - self C_NPC instance other - other C_NPC instance victim - victim C_NPC instance return - C_Trigger instance","title":"AI functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai-functions-for-working-with-ai","text":"Functions to work with the new C_Trigger class and NPC's AI queue.","title":"AI - functions for working with AI"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_callscript","text":"Adds a funcName function call to the AI queue 1 2 3 func void AI_CallScript ( var string funcName , var C_NPC slf , var C_NPC oth ) {}; funcName - name of the function to be called slf - will be inserted into global self instance oth - will be inserted into global other instance","title":"AI_CallScript"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_starttriggerscript","text":"Creates a trigger script that calls function funcName once every interval in milliseconds 1 func C_Trigger AI_startTriggerScript ( var string funcName , var int interval ) {}; funcName - name of the function to be called interval - call period in milliseconds return - created C_Trigger instance","title":"AI_startTriggerScript"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_starttriggerscriptex","text":"Extended version call - Creates a trigger script, that calls function funcName once every interval in milliseconds also updates the self , other and victim global instances based on slf , oth and vct parameters respectively 1 2 3 4 5 func C_Trigger AI_startTriggerScriptEx ( var string funcName , var int interval , var C_NPC slf , var C_NPC oth , var C_NPC vct ) {}; funcName - name of the function to be called interval - call period in milliseconds slf - will be inserted into global self instance oth - will be inserted into global other instance vct - will be inserted into global victim instance return - created C_Trigger instance","title":"AI_startTriggerScriptEx"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerbyid","text":"Returns a C_Trigger instance from the array of active triggers by the array index ID 1 func C_Trigger AI_GetTriggerByID ( var int ID ) {}; ID - array id return - active C_Trigger instance","title":"AI_GetTriggerByID"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggersnum","text":"Returns the number of active C_Trigger scripts 1 func int AI_GetTriggersNum () {}; return - number of active C_Trigger scripts","title":"AI_GetTriggersNum"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggernpc","text":"Returns the npc associated with the C_Trigger script based on the ID selfID = 0; otherID = 1; victimID = 2; 1 func C_NPC AI_GetTriggerNPC ( var C_Trigger trigger , var int npcID ) {}; trigger - C_Trigger script npcID - NPC id return - active C_Trigger instance","title":"AI_GetTriggerNPC"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerfunc","text":"Returns the function associated with the specified C_Trigger 1 func func AI_GetTriggerFunc ( var C_Trigger trigger ) {}; trigger - C_Trigger script return - trigger function","title":"AI_GetTriggerFunc"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerfuncname","text":"Returns the function name of a function associated with the specified C_Trigger 1 func string AI_GetTriggerFuncName ( var C_Trigger trigger ) {}; trigger - C_Trigger script return - active C_Trigger instance","title":"AI_GetTriggerFuncName"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyfunc","text":"Returns the next trigger in the active trigger array based on the trigger function, starting on the startTrigger trigger 1 func C_Trigger Ai_GetNextTriggerByFunc ( var C_Trigger startTrigger , var func function ) {}; startTrigger - C_Trigger script to start the search from function - function to be matched return - C_Trigger instance","title":"Ai_GetNextTriggerByFunc"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyfuncname","text":"Returns the next trigger in the active trigger array based on the trigger function name, starting on the startTrigger trigger 1 func C_Trigger Ai_GetNextTriggerByFuncName ( var C_Trigger startTrigger , var string functionName ) {}; startTrigger - C_Trigger script to start the search from functionName - name of a function to be matched return - C_Trigger instance","title":"Ai_GetNextTriggerByFuncName"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyself","text":"Returns the next trigger in the active trigger array based on the self trigger parameter, starting on the startTrigger instance set in the trigger 1 func C_Trigger Ai_GetNextTriggerBySelf ( var C_Trigger startTrigger , var C_NPC self ) {}; startTrigger - C_Trigger script to start the search from self - C_NPC instance return - C_Trigger instance","title":"Ai_GetNextTriggerBySelf"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyother","text":"Returns the next trigger in the active trigger array based on the other trigger parameter, starting on the startTrigger instance set in the trigger 1 func C_Trigger Ai_GetNextTriggerByOther ( var C_Trigger startTrigger , var C_NPC other ) {}; startTrigger - C_Trigger script to start the search from other - C_NPC instance return - C_Trigger instance","title":"Ai_GetNextTriggerByOther"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyvictim","text":"Returns the next trigger in the active trigger array based on the victim trigger parameter, starting on the startTrigger instance set in the trigger 1 func C_Trigger Ai_GetNextTriggerByVictim ( var C_Trigger startTrigger , var C_NPC victim ) {}; startTrigger - C_Trigger script to start the search from victim - C_NPC instance return - C_Trigger instance","title":"Ai_GetNextTriggerByVictim"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbynpcs","text":"Returns the next trigger in the active trigger array based on all the NPCs set in the trigger script self , other and victim , starting on the startTrigger instance set in the trigger 1 2 3 4 func c_trigger Ai_GetNextTriggerByNPCs ( var C_Trigger startTrigger , var C_NPC self , var C_NPC other , var C_NPC victim ) {}; startTrigger - C_Trigger script to start the search from self - self C_NPC instance other - other C_NPC instance victim - victim C_NPC instance return - C_Trigger instance","title":"Ai_GetNextTriggerByNPCs"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/","text":"CAST - data type conversion functions External functions for data type conversion and pointer casting. Cast_PointerToInstance Converts memory address (pointer) to an instance 1 func instance Cast_PointerToInstance ( var int address ) {}; address - object pointer return - instance of the object Cast_InstanceToPointer Converts instance to a memory address (pointer) 1 func int Cast_InstanceToPointer ( var instance object ) {}; object - object instance return - memory address (pointer) of the object Cast_PointerToNpc Casts memory address (pointer) to an NPC 1 func C_NPC Cast_PointerToNpc ( var int address ) {}; address - npc pointer return - NPC instance Cast_PointerToItem Casts memory address (pointer) to an Item 1 func C_ITEM Cast_PointerToItem ( var int address ) {}; address - item pointer return - Item instance Cast_InstanceIsNpc Checks whether object is an NPC 1 func int Cast_InstanceIsNpc ( var instance object ) {}; object - object to check return - TRUE or FALSE Cast_InstanceIsItem Checks whether object is an Item 1 func int Cast_InstanceIsItem ( var instance object ) {}; object - object to check return - TRUE or FALSE Cast_InstanceIsMob Checks whether object is an MOB 1 func int Cast_InstanceIsMob ( var instance object ) {}; object - object to check return - TRUE or FALSE Cast_GetInstanceIndex Returns symbolID of the object, returns -1 when not found 1 func int Cast_GetInstanceIndex ( var instance object ) {}; object - instance of an object return - symbol table index, -1 when not found Cast_GetClassID Returns the class identifier of a class by its name 1 func int Cast_GetClassID ( var string className ) {}; className - name of the class return - class identifier Cast_GetVobClassID Returns class identifier of the zCObject vob class 1 func int Cast_GetVobClassID ( var instance object ) {}; object - object instance return - class zCObject identifier Cast_CheckVobClassID Checks if the classId class is the parent class of the object 1 func int Cast_CheckVobClassID ( var int classId , var instance object ) {}; classId - class identifier, from Cast_GetClassID function object - object instance return - class zCObject identifier","title":"CAST functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast-data-type-conversion-functions","text":"External functions for data type conversion and pointer casting.","title":"CAST - data type conversion functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertoinstance","text":"Converts memory address (pointer) to an instance 1 func instance Cast_PointerToInstance ( var int address ) {}; address - object pointer return - instance of the object","title":"Cast_PointerToInstance"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instancetopointer","text":"Converts instance to a memory address (pointer) 1 func int Cast_InstanceToPointer ( var instance object ) {}; object - object instance return - memory address (pointer) of the object","title":"Cast_InstanceToPointer"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertonpc","text":"Casts memory address (pointer) to an NPC 1 func C_NPC Cast_PointerToNpc ( var int address ) {}; address - npc pointer return - NPC instance","title":"Cast_PointerToNpc"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertoitem","text":"Casts memory address (pointer) to an Item 1 func C_ITEM Cast_PointerToItem ( var int address ) {}; address - item pointer return - Item instance","title":"Cast_PointerToItem"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceisnpc","text":"Checks whether object is an NPC 1 func int Cast_InstanceIsNpc ( var instance object ) {}; object - object to check return - TRUE or FALSE","title":"Cast_InstanceIsNpc"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceisitem","text":"Checks whether object is an Item 1 func int Cast_InstanceIsItem ( var instance object ) {}; object - object to check return - TRUE or FALSE","title":"Cast_InstanceIsItem"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceismob","text":"Checks whether object is an MOB 1 func int Cast_InstanceIsMob ( var instance object ) {}; object - object to check return - TRUE or FALSE","title":"Cast_InstanceIsMob"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getinstanceindex","text":"Returns symbolID of the object, returns -1 when not found 1 func int Cast_GetInstanceIndex ( var instance object ) {}; object - instance of an object return - symbol table index, -1 when not found","title":"Cast_GetInstanceIndex"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getclassid","text":"Returns the class identifier of a class by its name 1 func int Cast_GetClassID ( var string className ) {}; className - name of the class return - class identifier","title":"Cast_GetClassID"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getvobclassid","text":"Returns class identifier of the zCObject vob class 1 func int Cast_GetVobClassID ( var instance object ) {}; object - object instance return - class zCObject identifier","title":"Cast_GetVobClassID"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_checkvobclassid","text":"Checks if the classId class is the parent class of the object 1 func int Cast_CheckVobClassID ( var int classId , var instance object ) {}; classId - class identifier, from Cast_GetClassID function object - object instance return - class zCObject identifier","title":"Cast_CheckVobClassID"},{"location":"zengin/scripts/extenders/zparserextender/externals/events_vars/","text":"Event functions and variables On top of external functions, zParserExtender also adds these event functions and constants. 1 2 3 4 5 6 7 8 9 10 11 /// Every event function with this name is exectued once every frame func event GameLoop () {}; /// Every event function with this name is exectued once on game init func event GameInit () {}; /// empty instance const instance null ; /// not a number floating point constant const float NaN ;","title":"Event function"},{"location":"zengin/scripts/extenders/zparserextender/externals/events_vars/#event-functions-and-variables","text":"On top of external functions, zParserExtender also adds these event functions and constants. 1 2 3 4 5 6 7 8 9 10 11 /// Every event function with this name is exectued once every frame func event GameLoop () {}; /// Every event function with this name is exectued once on game init func event GameInit () {}; /// empty instance const instance null ; /// not a number floating point constant const float NaN ;","title":"Event functions and variables"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/","text":"HLP - help functions Helper functions generally used for safety checks, to get specific information from the engine or to interface with the configuration .ini files. Hlp_HasFocusVob Returns TRUE , if a specified NPC has a Vob in focus 1 func int Hlp_HasFocusVob ( var C_NPC npc ) {}; npc - NPC return - TRUE if npc has a focus Vob, FALSE if it does not Hlp_GetFocusVob Returns NPC's focus Vob 1 func instance Hlp_GetFocusVob ( var C_NPC npc ) {}; npc - NPC return - focus vob Hlp_GetFocusVobName Returns the name of NPC's focus vob 1 func string Hlp_GetFocusVobName ( var C_NPC npc ) {}; npc - NPC return - focus vob name Hlp_GetStringLength Returns the length of a specified string 1 func int Hlp_GetStringLength ( var string str ) {}; return - length of str IsNAN Checks whether floating point number is valid 1 func int IsNAN ( var float value ) {}; return - TRUE if value is NaN, FALSE if value is a valid floating point number Hlp_KeyToggled Checks whether key is toggled 1 func int Hlp_KeyToggled ( var int key ) {}; key - key code return - TRUE if key is toggled, FALSE if key is not toggled Hlp_KeyPressed Checks whether key is pressed 1 func int Hlp_KeyPressed ( var int key ) {}; key - key code return - TRUE if key is pressed, FALSE if key is not pressed Hlp_LogicalKeyToggled Checks whether logical key is toggled 1 func int Hlp_LogicalKeyToggled ( var int key ) {}; key - key code return - TRUE if key is toggled, FALSE if key is not toggled Hlp_GameOnPause Checks whether the game is paused 1 func int Hlp_GameOnPause () {}; return - TRUE if the game is paused, FALSE if the game is not paused Hlp_MessageBox Opens a message box with a specified message 1 func void Hlp_MessageBox ( var string message ) {}; message - message to be printed Hlp_PrintConsole Prints a message to the Union debug console 1 func void Hlp_PrintConsole ( var string message ) {}; message - message to be printed Hlp_OptionIsExists Checks whether the entry in section in .ini file optName exists optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func int Hlp_OptionIsExists ( var string optName , var string section , var string entry ) {}; optName - the .ini file section - settings section like [GAME] entry - one setting entry like playLogoVideos return - TRUE if the option exists, FALSE if the option does not exist Hlp_ReadOptionInt Read an integer value from specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func int Hlp_ReadOptionInt ( var string optName , var string section , var string entry , var int default ) {}; optName - the .ini file section - settings section like [GAME] entry - one setting entry like playLogoVideos default - default value - if the value is empty return - the option value Hlp_ReadOptionFloat Read a floating point value from specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func float Hlp_ReadOptionFloat ( var string optName , var string section , var string entry , var float default ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale default - default value - if the value is empty return - the option value Hlp_ReadOptionString Read a string value from specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func string Hlp_ReadOptionString ( var string optName , var string section , var string entry , var string default ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale default - default value - if the value is empty return - the option value Hlp_WriteOptionInt Writes an integer value to specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func void Hlp_WriteOptionInt ( var string optName , var string section , var string entry , var int value ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale value - value to be written Hlp_WriteOptionFloat Writes a floating point value to specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func void Hlp_WriteOptionFloat ( var string optName , var string section , var string entry , var float value ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale value - value to be written Hlp_WriteOptionString Writes a string value to specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func void Hlp_WriteOptionString ( var string optName , var string section , var string entry , var string value ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale value - value to be written Hlp_GetSteamPersonalName Returns the name of the current Steam user Returns empty string when not run with Steam 1 func string Hlp_GetSteamPersonalName () {}; return - string containing the Steam username, or an empty string","title":"HLP functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp-help-functions","text":"Helper functions generally used for safety checks, to get specific information from the engine or to interface with the configuration .ini files.","title":"HLP - help functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_hasfocusvob","text":"Returns TRUE , if a specified NPC has a Vob in focus 1 func int Hlp_HasFocusVob ( var C_NPC npc ) {}; npc - NPC return - TRUE if npc has a focus Vob, FALSE if it does not","title":"Hlp_HasFocusVob"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getfocusvob","text":"Returns NPC's focus Vob 1 func instance Hlp_GetFocusVob ( var C_NPC npc ) {}; npc - NPC return - focus vob","title":"Hlp_GetFocusVob"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getfocusvobname","text":"Returns the name of NPC's focus vob 1 func string Hlp_GetFocusVobName ( var C_NPC npc ) {}; npc - NPC return - focus vob name","title":"Hlp_GetFocusVobName"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getstringlength","text":"Returns the length of a specified string 1 func int Hlp_GetStringLength ( var string str ) {}; return - length of str","title":"Hlp_GetStringLength"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#isnan","text":"Checks whether floating point number is valid 1 func int IsNAN ( var float value ) {}; return - TRUE if value is NaN, FALSE if value is a valid floating point number","title":"IsNAN"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_keytoggled","text":"Checks whether key is toggled 1 func int Hlp_KeyToggled ( var int key ) {}; key - key code return - TRUE if key is toggled, FALSE if key is not toggled","title":"Hlp_KeyToggled"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_keypressed","text":"Checks whether key is pressed 1 func int Hlp_KeyPressed ( var int key ) {}; key - key code return - TRUE if key is pressed, FALSE if key is not pressed","title":"Hlp_KeyPressed"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_logicalkeytoggled","text":"Checks whether logical key is toggled 1 func int Hlp_LogicalKeyToggled ( var int key ) {}; key - key code return - TRUE if key is toggled, FALSE if key is not toggled","title":"Hlp_LogicalKeyToggled"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_gameonpause","text":"Checks whether the game is paused 1 func int Hlp_GameOnPause () {}; return - TRUE if the game is paused, FALSE if the game is not paused","title":"Hlp_GameOnPause"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_messagebox","text":"Opens a message box with a specified message 1 func void Hlp_MessageBox ( var string message ) {}; message - message to be printed","title":"Hlp_MessageBox"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_printconsole","text":"Prints a message to the Union debug console 1 func void Hlp_PrintConsole ( var string message ) {}; message - message to be printed","title":"Hlp_PrintConsole"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_optionisexists","text":"Checks whether the entry in section in .ini file optName exists optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func int Hlp_OptionIsExists ( var string optName , var string section , var string entry ) {}; optName - the .ini file section - settings section like [GAME] entry - one setting entry like playLogoVideos return - TRUE if the option exists, FALSE if the option does not exist","title":"Hlp_OptionIsExists"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionint","text":"Read an integer value from specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func int Hlp_ReadOptionInt ( var string optName , var string section , var string entry , var int default ) {}; optName - the .ini file section - settings section like [GAME] entry - one setting entry like playLogoVideos default - default value - if the value is empty return - the option value","title":"Hlp_ReadOptionInt"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionfloat","text":"Read a floating point value from specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func float Hlp_ReadOptionFloat ( var string optName , var string section , var string entry , var float default ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale default - default value - if the value is empty return - the option value","title":"Hlp_ReadOptionFloat"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionstring","text":"Read a string value from specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func string Hlp_ReadOptionString ( var string optName , var string section , var string entry , var string default ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale default - default value - if the value is empty return - the option value","title":"Hlp_ReadOptionString"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionint","text":"Writes an integer value to specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func void Hlp_WriteOptionInt ( var string optName , var string section , var string entry , var int value ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale value - value to be written","title":"Hlp_WriteOptionInt"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionfloat","text":"Writes a floating point value to specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func void Hlp_WriteOptionFloat ( var string optName , var string section , var string entry , var float value ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale value - value to be written","title":"Hlp_WriteOptionFloat"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionstring","text":"Writes a string value to specified .ini file, section and entry. optName values \"Gothic\" \"Mod\" \"SystemPack\" 1 func void Hlp_WriteOptionString ( var string optName , var string section , var string entry , var string value ) {}; optName - the .ini file section - settings section like [INTERFACE] entry - one setting entry like scale value - value to be written","title":"Hlp_WriteOptionString"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getsteampersonalname","text":"Returns the name of the current Steam user Returns empty string when not run with Steam 1 func string Hlp_GetSteamPersonalName () {}; return - string containing the Steam username, or an empty string","title":"Hlp_GetSteamPersonalName"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/","text":"Log functions As discussed on Inside Gothic , vanilla Gothic has no way of getting the status of a quest. These functions implement that functionality. Log_GetTopicStatus Returns the status of diary topic -1 - Not found 0 - Free 1 - Running 2 - Success 3 - Failure 4 - Obsolete 1 func int Log_GetTopicStatus ( var string topic ) {}; topic - name of the topic return - topic status Log_GetTopicSection Returns the topic the diary topic is in -1 - Not found 0 - Missions 1 - Notes 2 - All 1 func int Log_GetTopicSection ( var string topic ) {}; topic - name of the topic return - topic section","title":"Log function"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log-functions","text":"As discussed on Inside Gothic , vanilla Gothic has no way of getting the status of a quest. These functions implement that functionality.","title":"Log functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log_gettopicstatus","text":"Returns the status of diary topic -1 - Not found 0 - Free 1 - Running 2 - Success 3 - Failure 4 - Obsolete 1 func int Log_GetTopicStatus ( var string topic ) {}; topic - name of the topic return - topic status","title":"Log_GetTopicStatus"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log_gettopicsection","text":"Returns the topic the diary topic is in -1 - Not found 0 - Missions 1 - Notes 2 - All 1 func int Log_GetTopicSection ( var string topic ) {}; topic - name of the topic return - topic section","title":"Log_GetTopicSection"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/","text":"MDL - model functions Functions to tweak animation and other model related settings. Mdl_GetAnimationIndex Returns animation's index for specified NPC based on animation's name 1 func int Mdl_GetAnimationIndex ( var C_NPC npc , var string ani_name ) {}; npc - NPC with the animation ani_name - name of the animation in uppercase return - animation index Mdl_GetAnimationName Returns animation's name for specified NPC based on animation's index 1 func string Mdl_GetAnimationName ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index return - animation name Mdl_AnimationIsExists Checks whether animation exists 1 func int Mdl_AnimationIsExists ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index return - animation name Mdl_AnimationIsActive Checks whether animation is active (whether it is currently played) 1 func int Mdl_AnimationIsActive ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index return - TRUE if the animation is playing, FALSE if it is not playing Mdl_SetAllAnimationsFPS Set framerate for all animations 1 func void Mdl_SetAllAnimationsFPS ( var C_NPC npc , var float fps ) {}; npc - NPC with the animation fps - framerate Mdl_ResetAllAnimationsFPS Reset framerate for all animations to default value 1 func void Mdl_ResetAllAnimationsFPS ( var C_NPC npc ) {}; npc - NPC with the animation Mdl_SetAnimationFPS Set framerate for animation specified by animation index 1 func void Mdl_SetAnimationFPS ( var C_NPC npc , var int ani_index , var float fps ) {}; npc - NPC with the animation ani_index - animation index fps - framerate Mdl_ResetAnimationFPS Reset framerate to default for animation specified by animation index 1 func void Mdl_ResetAnimationFPS ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index Mdl_SetVisible Set NPCs visibility 1 func void Mdl_SetVisible ( var C_NPC npc , var int isVisible ) {}; npc - specified NPC isVisible - TRUE - visible, FALSE - invisible Mdl_ApplyOverlayMds_AtFirst Applies or moves existing overlay to the top of the list 1 func void Mdl_ApplyOverlayMds_AtFirst ( var string mdsName ) {}; mdsName - name of the overlay Mdl_SetNpcSpeedMultiplier Sets a multiplier for animation speed 1.0 = 100% speed (normal speed) 1 func void Mdl_SetNpcSpeedMultiplier ( var C_Npc npc , var float multiplier ) {}; npc - npc to be affected multiplier - speed of the animation Mdl_ResetNpcSpeedMultiplier Resets the animation speed of an NPC 1 func void Mdl_ResetNpcSpeedMultiplier ( var C_Npc npc ) {}; npc - npc to be affected","title":"MDL functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl-model-functions","text":"Functions to tweak animation and other model related settings.","title":"MDL - model functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_getanimationindex","text":"Returns animation's index for specified NPC based on animation's name 1 func int Mdl_GetAnimationIndex ( var C_NPC npc , var string ani_name ) {}; npc - NPC with the animation ani_name - name of the animation in uppercase return - animation index","title":"Mdl_GetAnimationIndex"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_getanimationname","text":"Returns animation's name for specified NPC based on animation's index 1 func string Mdl_GetAnimationName ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index return - animation name","title":"Mdl_GetAnimationName"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_animationisexists","text":"Checks whether animation exists 1 func int Mdl_AnimationIsExists ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index return - animation name","title":"Mdl_AnimationIsExists"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_animationisactive","text":"Checks whether animation is active (whether it is currently played) 1 func int Mdl_AnimationIsActive ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index return - TRUE if the animation is playing, FALSE if it is not playing","title":"Mdl_AnimationIsActive"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setallanimationsfps","text":"Set framerate for all animations 1 func void Mdl_SetAllAnimationsFPS ( var C_NPC npc , var float fps ) {}; npc - NPC with the animation fps - framerate","title":"Mdl_SetAllAnimationsFPS"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetallanimationsfps","text":"Reset framerate for all animations to default value 1 func void Mdl_ResetAllAnimationsFPS ( var C_NPC npc ) {}; npc - NPC with the animation","title":"Mdl_ResetAllAnimationsFPS"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setanimationfps","text":"Set framerate for animation specified by animation index 1 func void Mdl_SetAnimationFPS ( var C_NPC npc , var int ani_index , var float fps ) {}; npc - NPC with the animation ani_index - animation index fps - framerate","title":"Mdl_SetAnimationFPS"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetanimationfps","text":"Reset framerate to default for animation specified by animation index 1 func void Mdl_ResetAnimationFPS ( var C_NPC npc , var int ani_index ) {}; npc - NPC with the animation ani_index - animation index","title":"Mdl_ResetAnimationFPS"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setvisible","text":"Set NPCs visibility 1 func void Mdl_SetVisible ( var C_NPC npc , var int isVisible ) {}; npc - specified NPC isVisible - TRUE - visible, FALSE - invisible","title":"Mdl_SetVisible"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_applyoverlaymds_atfirst","text":"Applies or moves existing overlay to the top of the list 1 func void Mdl_ApplyOverlayMds_AtFirst ( var string mdsName ) {}; mdsName - name of the overlay","title":"Mdl_ApplyOverlayMds_AtFirst"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setnpcspeedmultiplier","text":"Sets a multiplier for animation speed 1.0 = 100% speed (normal speed) 1 func void Mdl_SetNpcSpeedMultiplier ( var C_Npc npc , var float multiplier ) {}; npc - npc to be affected multiplier - speed of the animation","title":"Mdl_SetNpcSpeedMultiplier"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetnpcspeedmultiplier","text":"Resets the animation speed of an NPC 1 func void Mdl_ResetNpcSpeedMultiplier ( var C_Npc npc ) {}; npc - npc to be affected","title":"Mdl_ResetNpcSpeedMultiplier"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/","text":"Menu function Menu_SearchItems Find all C_MenuItem object instances by the mask and automatically places them in the current menu instance 1 func void Menu_SearchItems ( var string mask ) {}; mask - regex like mask for searching Example This function is used in the Union Menu API script . In this script the Menu_SearchItems external is used to collect all Union menu scripts that are placed into the Union & Plugins menu that will appear in the game if you use any of the plugins that use this feature. Usage of Menu_SearchItems external function 1 2 3 4 5 6 7 8 9 10 11 instance MENU_OPT_UNION ( C_MENU_DEF ) { Menu_SearchItems ( \"MENUITEM_UNION_AUTO_*\" ); MENU_OPT_UNION_PY = 1200 ; backpic = MENU_BACK_PIC ; items [ 0 ] = \"UNION_MENUITEM_TITLE\" ; items [ 100 ] = \"UNION_MENUITEM_BACK\" ; defaultoutgame = 0 ; defaultingame = 0 ; Flags = Flags | MENU_SHOW_INFO ; }; In this case all instances are of the name MENUITEM_UNION_AUTO_* where * is a wildcard that can be substituted with anything. The plugin will search the scripts and find all instances (in the case of zGamePad it is MenuItem_Union_Auto_zGamePad ) This example comes from the zUnionMenu.d injectable API script that is part of the zGamePad plugin, GitHub link .","title":"Menu function"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#menu-function","text":"","title":"Menu function"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#menu_searchitems","text":"Find all C_MenuItem object instances by the mask and automatically places them in the current menu instance 1 func void Menu_SearchItems ( var string mask ) {}; mask - regex like mask for searching","title":"Menu_SearchItems"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#example","text":"This function is used in the Union Menu API script . In this script the Menu_SearchItems external is used to collect all Union menu scripts that are placed into the Union & Plugins menu that will appear in the game if you use any of the plugins that use this feature. Usage of Menu_SearchItems external function 1 2 3 4 5 6 7 8 9 10 11 instance MENU_OPT_UNION ( C_MENU_DEF ) { Menu_SearchItems ( \"MENUITEM_UNION_AUTO_*\" ); MENU_OPT_UNION_PY = 1200 ; backpic = MENU_BACK_PIC ; items [ 0 ] = \"UNION_MENUITEM_TITLE\" ; items [ 100 ] = \"UNION_MENUITEM_BACK\" ; defaultoutgame = 0 ; defaultingame = 0 ; Flags = Flags | MENU_SHOW_INFO ; }; In this case all instances are of the name MENUITEM_UNION_AUTO_* where * is a wildcard that can be substituted with anything. The plugin will search the scripts and find all instances (in the case of zGamePad it is MenuItem_Union_Auto_zGamePad ) This example comes from the zUnionMenu.d injectable API script that is part of the zGamePad plugin, GitHub link .","title":"Example"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/","text":"MOB - interactive object functions Functions to manipulate interactive objects like destroying MOBs, setting lockpick combination and such. Mob_Destroy Marks oCMOB as destroyed, changes the visual to visualDestroyed (if present). 1 func void Mob_Destroy ( var instance object ) {}; object - oCMOB to be destroyed Mob_RemoveItem Removes an item from a oCMobContainer 1 func void Mob_RemoveItem ( var instance object , var int item ) {}; object - oCMobContainer object item - item to be removed Mob_RemoveItems Removes specified number of items from a oCMobContainer 1 func void Mob_RemoveItems ( var instance object , var int item , var int cnt ) {}; object - oCMobContainer object item - item to be removed cnt - number of items to be removed Mob_InsertItem Inserts an item into a oCMobContainer 1 func void Mob_InsertItem ( var instance object , var int item ) {}; object - oCMobContainer object item - item to be inserted Mob_InsertItems Inserts specified number of items into a oCMobContainer 1 func void Mob_InsertItems ( var instance object , var int item , var int cnt ) {}; object - oCMobContainer object item - item to be inserted cnt - number of items to be inserted Mob_GetLockCombination Returns a lock combination of a oCMobContainer 1 func string Mob_GetLockCombination ( var instance object ) {}; object - oCMobContainer object return - lock combination Mob_SetLockCombination Sets a lock combination to a oCMobContainer 1 func void Mob_SetLockCombination ( var instance object , var string comb ) {}; object - oCMobContainer object comb - lock combination Mob_IsLocked Returns TRUE if the object is locked 1 func int Mob_IsLocked ( var instance object ) {}; object - oCMobLockable object return - TRUE if locked, FALSE if unlocked Mob_SetLocked Set the lock status of the object 1 func void Mob_SetLocked ( var instance object , var int locked ) {}; object - oCMobLockable object locked - lock or unlock the object Mob_GetKeyInstance Returns the key instance, that unlocks the object 1 func instance Mob_GetKeyInstance ( var instance object ) {}; object - oCMobLockable object return - the key C_ITEM instance Mob_SetKeyInstance Stets the key instance, that unlocks the object 1 func void Mob_SetKeyInstance ( var instance object , var int key ) {}; object - oCMobLockable object key - the key C_ITEM instance","title":"MOB functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob-interactive-object-functions","text":"Functions to manipulate interactive objects like destroying MOBs, setting lockpick combination and such.","title":"MOB - interactive object functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_destroy","text":"Marks oCMOB as destroyed, changes the visual to visualDestroyed (if present). 1 func void Mob_Destroy ( var instance object ) {}; object - oCMOB to be destroyed","title":"Mob_Destroy"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_removeitem","text":"Removes an item from a oCMobContainer 1 func void Mob_RemoveItem ( var instance object , var int item ) {}; object - oCMobContainer object item - item to be removed","title":"Mob_RemoveItem"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_removeitems","text":"Removes specified number of items from a oCMobContainer 1 func void Mob_RemoveItems ( var instance object , var int item , var int cnt ) {}; object - oCMobContainer object item - item to be removed cnt - number of items to be removed","title":"Mob_RemoveItems"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_insertitem","text":"Inserts an item into a oCMobContainer 1 func void Mob_InsertItem ( var instance object , var int item ) {}; object - oCMobContainer object item - item to be inserted","title":"Mob_InsertItem"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_insertitems","text":"Inserts specified number of items into a oCMobContainer 1 func void Mob_InsertItems ( var instance object , var int item , var int cnt ) {}; object - oCMobContainer object item - item to be inserted cnt - number of items to be inserted","title":"Mob_InsertItems"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_getlockcombination","text":"Returns a lock combination of a oCMobContainer 1 func string Mob_GetLockCombination ( var instance object ) {}; object - oCMobContainer object return - lock combination","title":"Mob_GetLockCombination"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setlockcombination","text":"Sets a lock combination to a oCMobContainer 1 func void Mob_SetLockCombination ( var instance object , var string comb ) {}; object - oCMobContainer object comb - lock combination","title":"Mob_SetLockCombination"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_islocked","text":"Returns TRUE if the object is locked 1 func int Mob_IsLocked ( var instance object ) {}; object - oCMobLockable object return - TRUE if locked, FALSE if unlocked","title":"Mob_IsLocked"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setlocked","text":"Set the lock status of the object 1 func void Mob_SetLocked ( var instance object , var int locked ) {}; object - oCMobLockable object locked - lock or unlock the object","title":"Mob_SetLocked"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_getkeyinstance","text":"Returns the key instance, that unlocks the object 1 func instance Mob_GetKeyInstance ( var instance object ) {}; object - oCMobLockable object return - the key C_ITEM instance","title":"Mob_GetKeyInstance"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setkeyinstance","text":"Stets the key instance, that unlocks the object 1 func void Mob_SetKeyInstance ( var instance object , var int key ) {}; object - oCMobLockable object key - the key C_ITEM instance","title":"Mob_SetKeyInstance"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/","text":"NPC - character functions NPC related functions. Npc_SetAsHero Changes players character to specified npc 1 func void Npc_SetAsHero ( var C_NPC npc ) {}; npc - NPC to be set as players character Npc_OpenInventory Opens NPCs main inventory 1 func void Npc_OpenInventory ( var C_NPC npc ) {}; npc - NPC Npc_OpenInventorySteal Opens the steal inventory of npc 's focus NPC 1 func void Npc_OpenInventorySteal ( var C_NPC npc ) {}; npc - NPC Npc_OpenInventoryTrade Start the trading dialogue with specified NPC 1 func void Npc_OpenInventoryTrade ( var C_NPC npc ) {}; npc - NPC Npc_GetLeftHandItem Returns an item in NPC's left hand slot 1 func C_Item Npc_GetLeftHandItem ( var C_Npc npc ) {}; npc - npc to be affected return - found C_ITEM instance Npc_GetRightHandItem Returns an item in NPC's right hand slot 1 func C_Item Npc_GetRightHandItem ( var C_Npc npc ) {}; npc - npc to be affected return - found C_ITEM instance Npc_GetSlotItem Returns an item from a slot with the slotName 1 func C_Item Npc_GetSlotItem ( var C_Npc npc , var string slotName ) {}; npc - npc to be affected slotName - name of the slot return - found C_ITEM instance Npc_PutInSlot Places an instance of the oCVom class (including items and NPCs) object into the slotName of the NPC The copyInInv parameter determines whether a copy of the object should remain in the character's inventory 1 func void Npc_PutInSlot ( var C_Npc npc , var string slotName , var instance object , var int copyInInv ) {}; npc - npc to remove the item from slotName - name of the slot from which to remove the item object - object to be inserted into the slot copyInInv - should a copy of the object stay in character inventory Npc_RemoveFromSlot Removes an object from the slotName of the NPC. The dropIt parameter in Gothic 2 defines, whether object should drop out of the slot. In Gothic 1, this parameter is reserved and must be 0. 1 func void Npc_RemoveFromSlot ( var C_Npc npc , var string slotName , var int dropIt ) {}; npc - npc to remove the item from slotName - name of the slot from which to remove the item dropIt - should the object be dropped","title":"NPC functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc-character-functions","text":"NPC related functions.","title":"NPC - character functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_setashero","text":"Changes players character to specified npc 1 func void Npc_SetAsHero ( var C_NPC npc ) {}; npc - NPC to be set as players character","title":"Npc_SetAsHero"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventory","text":"Opens NPCs main inventory 1 func void Npc_OpenInventory ( var C_NPC npc ) {}; npc - NPC","title":"Npc_OpenInventory"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventorysteal","text":"Opens the steal inventory of npc 's focus NPC 1 func void Npc_OpenInventorySteal ( var C_NPC npc ) {}; npc - NPC","title":"Npc_OpenInventorySteal"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventorytrade","text":"Start the trading dialogue with specified NPC 1 func void Npc_OpenInventoryTrade ( var C_NPC npc ) {}; npc - NPC","title":"Npc_OpenInventoryTrade"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getlefthanditem","text":"Returns an item in NPC's left hand slot 1 func C_Item Npc_GetLeftHandItem ( var C_Npc npc ) {}; npc - npc to be affected return - found C_ITEM instance","title":"Npc_GetLeftHandItem"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getrighthanditem","text":"Returns an item in NPC's right hand slot 1 func C_Item Npc_GetRightHandItem ( var C_Npc npc ) {}; npc - npc to be affected return - found C_ITEM instance","title":"Npc_GetRightHandItem"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getslotitem","text":"Returns an item from a slot with the slotName 1 func C_Item Npc_GetSlotItem ( var C_Npc npc , var string slotName ) {}; npc - npc to be affected slotName - name of the slot return - found C_ITEM instance","title":"Npc_GetSlotItem"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_putinslot","text":"Places an instance of the oCVom class (including items and NPCs) object into the slotName of the NPC The copyInInv parameter determines whether a copy of the object should remain in the character's inventory 1 func void Npc_PutInSlot ( var C_Npc npc , var string slotName , var instance object , var int copyInInv ) {}; npc - npc to remove the item from slotName - name of the slot from which to remove the item object - object to be inserted into the slot copyInInv - should a copy of the object stay in character inventory","title":"Npc_PutInSlot"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_removefromslot","text":"Removes an object from the slotName of the NPC. The dropIt parameter in Gothic 2 defines, whether object should drop out of the slot. In Gothic 1, this parameter is reserved and must be 0. 1 func void Npc_RemoveFromSlot ( var C_Npc npc , var string slotName , var int dropIt ) {}; npc - npc to remove the item from slotName - name of the slot from which to remove the item dropIt - should the object be dropped","title":"Npc_RemoveFromSlot"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/","text":"PAR - functions for parser manipulation Parser functions are used to manipulate the parsers. Retrieve SymbolID, access arrays and such. Par_GetParserID Returns a parser ID of the parser with a parName name Parser names: \"Game\" \"SFX\" \"PFX\" \"VFX\" \"Camera\" \"Menu\" \"Music\" 1 func int Par_GetParserID ( var string parName ) {}; parName - parser name return - parser ID Par_GetSymbolID Returns symbol ID for the symbol specified by its name 1 func int Par_GetSymbolID ( var int parId , var string symName ) {}; parID - parser ID symName - symbol name return - symbol ID Par_GetSymbolLength Returns symbol length (number of elements) 1 func int Par_GetSymbolLength ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol length Par_GetSymbolValueInt Returns the integer value of specified symbol 1 func int Par_GetSymbolValueInt ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value Par_GetSymbolValueFloat Returns the float value of specified symbol 1 func float Par_GetSymbolValueFloat ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value Par_GetSymbolValueString Returns the string value of specified symbol 1 func string Par_GetSymbolValueString ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value Par_GetSymbolValueInstance Returns the instance value of specified symbol 1 func instance Par_GetSymbolValueInstance ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value Par_GetSymbolValueIntArray Returns the value of specified integer array at the arrayID index 1 func int Par_GetSymbolValueIntArray ( var int parId , var int symId , var int arrayId ) {}; parID - parser ID symName - symbol name arrayID - array index return - value Par_GetSymbolValueFloatArray Returns the value of specified float array at the arrayID index 1 func float Par_GetSymbolValueFloatArray ( var int parId , var int symId , var int arrayId ) {}; parID - parser ID symName - symbol name arrayID - array index return - value Par_GetSymbolValueStringArray Returns the value of specified string array at the arrayID index 1 func string Par_GetSymbolValueStringArray ( var int parId , var int symId , var int arrayId ) {}; parID - parser ID symName - symbol name arrayID - array index return - value Par_SetSymbolValueInt Sets a new integer value to specified symbol 1 func void Par_SetSymbolValueInt ( var int value , var int parId , var int symId ) {}; value - value to be set parID - parser ID symId - symbol ID Par_SetSymbolValueFloat Sets a new float value to specified symbol 1 func void Par_SetSymbolValueFloat ( var float value , var int parId , var int symId ) {}; value - value to be set parID - parser ID symId - symbol ID Par_SetSymbolValueString Sets a new string value to specified symbol 1 func void Par_SetSymbolValueString ( var string value , var int parId , var int symId ) {}; value - value to be set parID - parser ID symId - symbol ID Par_SetSymbolValueInstance Sets a new instance value to specified symbol 1 func void Par_SetSymbolValueInstance ( var instance value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID Par_SetSymbolValueIntArray Sets a new integer value to specified integer array symbol 1 func void Par_SetSymbolValueIntArray ( var int value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID arrayId - array index Par_SetSymbolValueFloatArray Sets a new float value to specified float array symbol 1 func void Par_SetSymbolValueFloatArray ( var float value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID arrayId - array index Par_SetSymbolValueStringArray Sets a new string value to specified string array symbol 1 func void Par_SetSymbolValueStringArray ( var string value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID arrayId - array index","title":"PAR functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par-functions-for-parser-manipulation","text":"Parser functions are used to manipulate the parsers. Retrieve SymbolID, access arrays and such.","title":"PAR - functions for parser manipulation"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getparserid","text":"Returns a parser ID of the parser with a parName name Parser names: \"Game\" \"SFX\" \"PFX\" \"VFX\" \"Camera\" \"Menu\" \"Music\" 1 func int Par_GetParserID ( var string parName ) {}; parName - parser name return - parser ID","title":"Par_GetParserID"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolid","text":"Returns symbol ID for the symbol specified by its name 1 func int Par_GetSymbolID ( var int parId , var string symName ) {}; parID - parser ID symName - symbol name return - symbol ID","title":"Par_GetSymbolID"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbollength","text":"Returns symbol length (number of elements) 1 func int Par_GetSymbolLength ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol length","title":"Par_GetSymbolLength"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueint","text":"Returns the integer value of specified symbol 1 func int Par_GetSymbolValueInt ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value","title":"Par_GetSymbolValueInt"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluefloat","text":"Returns the float value of specified symbol 1 func float Par_GetSymbolValueFloat ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value","title":"Par_GetSymbolValueFloat"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluestring","text":"Returns the string value of specified symbol 1 func string Par_GetSymbolValueString ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value","title":"Par_GetSymbolValueString"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueinstance","text":"Returns the instance value of specified symbol 1 func instance Par_GetSymbolValueInstance ( var int parId , var int symId ) {}; parID - parser ID symName - symbol name return - symbol value","title":"Par_GetSymbolValueInstance"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueintarray","text":"Returns the value of specified integer array at the arrayID index 1 func int Par_GetSymbolValueIntArray ( var int parId , var int symId , var int arrayId ) {}; parID - parser ID symName - symbol name arrayID - array index return - value","title":"Par_GetSymbolValueIntArray"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluefloatarray","text":"Returns the value of specified float array at the arrayID index 1 func float Par_GetSymbolValueFloatArray ( var int parId , var int symId , var int arrayId ) {}; parID - parser ID symName - symbol name arrayID - array index return - value","title":"Par_GetSymbolValueFloatArray"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluestringarray","text":"Returns the value of specified string array at the arrayID index 1 func string Par_GetSymbolValueStringArray ( var int parId , var int symId , var int arrayId ) {}; parID - parser ID symName - symbol name arrayID - array index return - value","title":"Par_GetSymbolValueStringArray"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueint","text":"Sets a new integer value to specified symbol 1 func void Par_SetSymbolValueInt ( var int value , var int parId , var int symId ) {}; value - value to be set parID - parser ID symId - symbol ID","title":"Par_SetSymbolValueInt"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluefloat","text":"Sets a new float value to specified symbol 1 func void Par_SetSymbolValueFloat ( var float value , var int parId , var int symId ) {}; value - value to be set parID - parser ID symId - symbol ID","title":"Par_SetSymbolValueFloat"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluestring","text":"Sets a new string value to specified symbol 1 func void Par_SetSymbolValueString ( var string value , var int parId , var int symId ) {}; value - value to be set parID - parser ID symId - symbol ID","title":"Par_SetSymbolValueString"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueinstance","text":"Sets a new instance value to specified symbol 1 func void Par_SetSymbolValueInstance ( var instance value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID","title":"Par_SetSymbolValueInstance"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueintarray","text":"Sets a new integer value to specified integer array symbol 1 func void Par_SetSymbolValueIntArray ( var int value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID arrayId - array index","title":"Par_SetSymbolValueIntArray"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluefloatarray","text":"Sets a new float value to specified float array symbol 1 func void Par_SetSymbolValueFloatArray ( var float value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID arrayId - array index","title":"Par_SetSymbolValueFloatArray"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluestringarray","text":"Sets a new string value to specified string array symbol 1 func void Par_SetSymbolValueStringArray ( var string value , var int parId , var int symId , var int arrayId ) {}; value - value to be set parID - parser ID symId - symbol ID arrayId - array index","title":"Par_SetSymbolValueStringArray"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/","text":"String functions Functions to manipulate and format strings. Str_Format Returns formatted string using format specifiers Format specifiers: %s - inserts a string %i - inserts an integer number %x - inserts an integer in hexadecimal %f - inserts a floating point number %b - inserts a logical expression %p - inserts a pointer 1 func string Str_Format ( var string format , ... ) {}; return - formatted string Examples Very powerful function, can be used to streamline strings used in the scripts as well as optimize them for translations. Define constants containing the string with format specifiers. 1 2 const string MENU_SAVE = \"Slot %i - press ENTER to save in this slot.\" ; const string MENU_LOAD = \"Slot %i - press ENTER to load saved game.\" ; Then define two format functions as such: 1 2 3 4 func string GetSaveSlotString ( var int number ) { return Str_format ( MENU_SAVE , number ); }; 1 2 3 4 func string GetLoadSlotString ( var int number ) { return Str_format ( MENU_LOAD , number ); }; Tip Since the whole translatable string is saved in one constant, it is very easy for translators to change the word order. This was not possible to do without code change to the ConcatStrings function calls within the scripts. With this simple change, translators have to translate only 2 strings instead of 30 (15 + 15 slots) and only 2 strings are compiled into the compiled Menu.dat file. Str_GetLocalizedString Returns a string in the current language, otherwise in English. Arguments MUST be encoded in UTF-8! The result string will be converted to appropriate ANSI string. 1 2 3 4 func string Str_GetLocalizedString ( var string russian , var string english , var string german , var string polish ) {}; russian - Russian string english - English string german - German string polish - Polish string return - string in the current language Str_GetLocalizedStringEx Returns a string in the current language, otherwise in English. Offers additional languages 1 2 3 4 5 6 7 8 func string Str_GetLocalizedStringEx ( var string russian , var string english , var string german , var string polish , var string romanian , var string italian , var string czech , var string spanish ) {}; russian - Russian string english - English string german - German string polish - Polish string romanian - Romanian string italian - Italian string czech - Czech string spanish - Spanish string return - string in the current language Str_UTF8_to_ANSI Converts UTF-8 string into an ANSI string with codePage 1 func string Str_UTF8_to_ANSI ( var string utf8 , var int codePage ) {}; utf8 - string encoded in UTF8 codePage - codePage id, can be obtained from Str_GetCurrentCP return - Str_GetCurrentCP Return the code page corresponding to the current language set in the Union System 1 func int Str_GetCurrentCP () {}; return - code page corresponding to the current language Str_GetLength Returns the length of a string 1 func int Str_GetLength ( var int str ) {}; str - string to be measured return - length of the string","title":"String functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#string-functions","text":"Functions to manipulate and format strings.","title":"String functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_format","text":"Returns formatted string using format specifiers Format specifiers: %s - inserts a string %i - inserts an integer number %x - inserts an integer in hexadecimal %f - inserts a floating point number %b - inserts a logical expression %p - inserts a pointer 1 func string Str_Format ( var string format , ... ) {}; return - formatted string","title":"Str_Format"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#examples","text":"Very powerful function, can be used to streamline strings used in the scripts as well as optimize them for translations. Define constants containing the string with format specifiers. 1 2 const string MENU_SAVE = \"Slot %i - press ENTER to save in this slot.\" ; const string MENU_LOAD = \"Slot %i - press ENTER to load saved game.\" ; Then define two format functions as such: 1 2 3 4 func string GetSaveSlotString ( var int number ) { return Str_format ( MENU_SAVE , number ); }; 1 2 3 4 func string GetLoadSlotString ( var int number ) { return Str_format ( MENU_LOAD , number ); }; Tip Since the whole translatable string is saved in one constant, it is very easy for translators to change the word order. This was not possible to do without code change to the ConcatStrings function calls within the scripts. With this simple change, translators have to translate only 2 strings instead of 30 (15 + 15 slots) and only 2 strings are compiled into the compiled Menu.dat file.","title":"Examples"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlocalizedstring","text":"Returns a string in the current language, otherwise in English. Arguments MUST be encoded in UTF-8! The result string will be converted to appropriate ANSI string. 1 2 3 4 func string Str_GetLocalizedString ( var string russian , var string english , var string german , var string polish ) {}; russian - Russian string english - English string german - German string polish - Polish string return - string in the current language","title":"Str_GetLocalizedString"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlocalizedstringex","text":"Returns a string in the current language, otherwise in English. Offers additional languages 1 2 3 4 5 6 7 8 func string Str_GetLocalizedStringEx ( var string russian , var string english , var string german , var string polish , var string romanian , var string italian , var string czech , var string spanish ) {}; russian - Russian string english - English string german - German string polish - Polish string romanian - Romanian string italian - Italian string czech - Czech string spanish - Spanish string return - string in the current language","title":"Str_GetLocalizedStringEx"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_utf8_to_ansi","text":"Converts UTF-8 string into an ANSI string with codePage 1 func string Str_UTF8_to_ANSI ( var string utf8 , var int codePage ) {}; utf8 - string encoded in UTF8 codePage - codePage id, can be obtained from Str_GetCurrentCP return -","title":"Str_UTF8_to_ANSI"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getcurrentcp","text":"Return the code page corresponding to the current language set in the Union System 1 func int Str_GetCurrentCP () {}; return - code page corresponding to the current language","title":"Str_GetCurrentCP"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlength","text":"Returns the length of a string 1 func int Str_GetLength ( var int str ) {}; str - string to be measured return - length of the string","title":"Str_GetLength"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/","text":"VOB - functions for object manipulation VOB functions allow you to manipulate game world objects. Vob_GetVobPosition Returns the current position of the object in the world 1 func C_Position Vob_GetVobPosition ( var C_Vob vob ) {}; vob - vob to ge the position of return - C_Position instance - position of the VOB Vob_SetVobPosition Sets the current position of the object in the world 1 func void Vob_SetVobPosition ( var C_Vob vob , var C_Position pos ) {}; vob - vob to get the position of pos - new position of the vob Vob_GetVobData Returns the universal data of the zCVob object 1 func C_Vob_Data Vob_GetVobData ( var C_Vob vob ) {}; vob - VOB to get the position of return - general vob data C_Vob_Data Vob_SetVobData Sets the universal data to a zCVob object 1 func void Vob_SetVobData ( var C_Vob vob , var C_Vob_Data data ) {}; vob - VOB to get the position of data - general vob data C_Vob_Data Vob_GetLightData Returns zCVobLight object data 1 func C_Light_Data Vob_GetLightData ( var C_Vob vobLight ) {}; vobLight - vobLight object return - C_Light_Data of the light Vob_SetLightData Sets the data of a zCVobLight object 1 func void Vob_SetLightData ( var C_Vob vobLight , var C_Light_Data data ) {}; vobLight - object to apply the light data to data - C_Light_Data light data to be set Vob_ClearLightAniList Clears the list of animation colours for the light source 1 func void Vob_ClearLightAniList ( var C_Vob vobLight ) {}; vobLight - light vob Vob_AddLightAniColor Adds a color to the colour list 1 func void Vob_AddLightAniColor ( var C_Vob vobLight , var C_Color col ) {}; vobLight - object to apply the colour to col - colour to be applied Vob_AddLightAniColorRGB Adds a color to the colour list 1 2 3 4 func void Vob_AddLightAniColorRGB ( var C_Vob vobLight , var int r , var int g , var int b ) {}; vobLight - object to apply the colour to r - red colour channel g - green colour channel b - blue colour channel Vob_GetMobData Returns the data of the oCMOB object 1 func C_Mob_Data Vob_GetMobData ( var C_Vob mob ) {}; mob - oCMOB object return - mob data Vob_SetMobData Sets the data of the oCMOB object 1 func void Vob_SetMobData ( var C_Vob mob , var C_Mob_Data data ) {}; mob - oCMOB object data - C_Mob_Data to be set Vob_GetMobInterData Returns the data of the oCMobInter object 1 func MobInter_Data Vob_GetMobInterData ( var C_Vob mobInter ) {}; mobInter - oCMobInter object return - MobInter_Data of the object Vob_SetMobInterData Sets the data of the oCMobInter object 1 func void Vob_SetMobInterData ( var C_Vob mobInter , var C_MobInter_Data data ) {}; mobInter - oCMobInter object data - MobInter_Data of the object Vob_GetMobInterData Returns the data of the oCMobLockable object 1 func C_MobLockable_Data Vob_GetMobInterData ( var C_Vob mobLock ) {}; mobLock - oCMobLockable object data - MobInter_Data of the object return - C_MobLockable_Data of the object Vob_SetMobInterData Sets the data of the oCMobLockable object 1 func void Vob_SetMobInterData ( var C_Vob mobLock , var C_MobLockable_Data data ) {}; mobLock - oCMobLockable object data - C_MobLockable_Data of the object","title":"VOB functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob-functions-for-object-manipulation","text":"VOB functions allow you to manipulate game world objects.","title":"VOB - functions for object manipulation"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getvobposition","text":"Returns the current position of the object in the world 1 func C_Position Vob_GetVobPosition ( var C_Vob vob ) {}; vob - vob to ge the position of return - C_Position instance - position of the VOB","title":"Vob_GetVobPosition"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setvobposition","text":"Sets the current position of the object in the world 1 func void Vob_SetVobPosition ( var C_Vob vob , var C_Position pos ) {}; vob - vob to get the position of pos - new position of the vob","title":"Vob_SetVobPosition"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getvobdata","text":"Returns the universal data of the zCVob object 1 func C_Vob_Data Vob_GetVobData ( var C_Vob vob ) {}; vob - VOB to get the position of return - general vob data C_Vob_Data","title":"Vob_GetVobData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setvobdata","text":"Sets the universal data to a zCVob object 1 func void Vob_SetVobData ( var C_Vob vob , var C_Vob_Data data ) {}; vob - VOB to get the position of data - general vob data C_Vob_Data","title":"Vob_SetVobData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getlightdata","text":"Returns zCVobLight object data 1 func C_Light_Data Vob_GetLightData ( var C_Vob vobLight ) {}; vobLight - vobLight object return - C_Light_Data of the light","title":"Vob_GetLightData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setlightdata","text":"Sets the data of a zCVobLight object 1 func void Vob_SetLightData ( var C_Vob vobLight , var C_Light_Data data ) {}; vobLight - object to apply the light data to data - C_Light_Data light data to be set","title":"Vob_SetLightData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_clearlightanilist","text":"Clears the list of animation colours for the light source 1 func void Vob_ClearLightAniList ( var C_Vob vobLight ) {}; vobLight - light vob","title":"Vob_ClearLightAniList"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_addlightanicolor","text":"Adds a color to the colour list 1 func void Vob_AddLightAniColor ( var C_Vob vobLight , var C_Color col ) {}; vobLight - object to apply the colour to col - colour to be applied","title":"Vob_AddLightAniColor"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_addlightanicolorrgb","text":"Adds a color to the colour list 1 2 3 4 func void Vob_AddLightAniColorRGB ( var C_Vob vobLight , var int r , var int g , var int b ) {}; vobLight - object to apply the colour to r - red colour channel g - green colour channel b - blue colour channel","title":"Vob_AddLightAniColorRGB"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobdata","text":"Returns the data of the oCMOB object 1 func C_Mob_Data Vob_GetMobData ( var C_Vob mob ) {}; mob - oCMOB object return - mob data","title":"Vob_GetMobData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobdata","text":"Sets the data of the oCMOB object 1 func void Vob_SetMobData ( var C_Vob mob , var C_Mob_Data data ) {}; mob - oCMOB object data - C_Mob_Data to be set","title":"Vob_SetMobData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobinterdata","text":"Returns the data of the oCMobInter object 1 func MobInter_Data Vob_GetMobInterData ( var C_Vob mobInter ) {}; mobInter - oCMobInter object return - MobInter_Data of the object","title":"Vob_GetMobInterData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobinterdata","text":"Sets the data of the oCMobInter object 1 func void Vob_SetMobInterData ( var C_Vob mobInter , var C_MobInter_Data data ) {}; mobInter - oCMobInter object data - MobInter_Data of the object","title":"Vob_SetMobInterData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobinterdata_1","text":"Returns the data of the oCMobLockable object 1 func C_MobLockable_Data Vob_GetMobInterData ( var C_Vob mobLock ) {}; mobLock - oCMobLockable object data - MobInter_Data of the object return - C_MobLockable_Data of the object","title":"Vob_GetMobInterData"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobinterdata_1","text":"Sets the data of the oCMobLockable object 1 func void Vob_SetMobInterData ( var C_Vob mobLock , var C_MobLockable_Data data ) {}; mobLock - oCMobLockable object data - C_MobLockable_Data of the object","title":"Vob_SetMobInterData"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/","text":"WLD - world manipulation functions Functions related to the world. Wld_ChangeLevel Trigger level change. 1 func void Wld_ChangeLevel ( var string world , var string waypoint ) {}; world - name of the world waypoint - target waypoint Wld_FindVob Return the VOB instance based on its name. 1 func instance Wld_FindVob ( var string vobname ) {}; vobname - name of the vob return - zCVob pointer return - Wld_PlayEffectVob Play a visual effect at specified vob 1 2 3 4 5 6 func void Wld_PlayEffectVob ( var string effect , var instance pvob , var int level , var int damage , var int damage_type , var int damage_speed ) {}; effect - effect name pvob - Vob to play the effect at level - effect level damage - damage amount damage_type - damage type damage_speed - damage interval Wld_PlayEffectAt Play a visual effect at specified world coordinates 1 2 3 4 5 6 func void Wld_PlayEffectAt ( var string effect , var instance coord , var int level , var int damage , var int damage_type , var int damage_speed ) {}; effect - effect name coord - world coordinates to play the effect at level - effect level damage - damage amount damage_type - damage type damage_speed - damage interval Wld_ToggleRain Turns on the rain 1 func void Wld_ToggleRain ( var float weight , var float time ) {}; weight - the strength of the rain time - rain duration Wld_SetWeatherType Sets the weather type. Types: 0 - snow 1 - rain 1 func void Wld_SetWeatherType ( var int type ) {}; type - weather type Wld_GetWeatherType() Returns the weather type. Types: 0 - snow 1 - rain 1 func int Wld_GetWeatherType () {}; return - weather type","title":"WLD functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld-world-manipulation-functions","text":"Functions related to the world.","title":"WLD - world manipulation functions"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_changelevel","text":"Trigger level change. 1 func void Wld_ChangeLevel ( var string world , var string waypoint ) {}; world - name of the world waypoint - target waypoint","title":"Wld_ChangeLevel"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_findvob","text":"Return the VOB instance based on its name. 1 func instance Wld_FindVob ( var string vobname ) {}; vobname - name of the vob return - zCVob pointer return -","title":"Wld_FindVob"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_playeffectvob","text":"Play a visual effect at specified vob 1 2 3 4 5 6 func void Wld_PlayEffectVob ( var string effect , var instance pvob , var int level , var int damage , var int damage_type , var int damage_speed ) {}; effect - effect name pvob - Vob to play the effect at level - effect level damage - damage amount damage_type - damage type damage_speed - damage interval","title":"Wld_PlayEffectVob"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_playeffectat","text":"Play a visual effect at specified world coordinates 1 2 3 4 5 6 func void Wld_PlayEffectAt ( var string effect , var instance coord , var int level , var int damage , var int damage_type , var int damage_speed ) {}; effect - effect name coord - world coordinates to play the effect at level - effect level damage - damage amount damage_type - damage type damage_speed - damage interval","title":"Wld_PlayEffectAt"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_togglerain","text":"Turns on the rain 1 func void Wld_ToggleRain ( var float weight , var float time ) {}; weight - the strength of the rain time - rain duration","title":"Wld_ToggleRain"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_setweathertype","text":"Sets the weather type. Types: 0 - snow 1 - rain 1 func void Wld_SetWeatherType ( var int type ) {}; type - weather type","title":"Wld_SetWeatherType"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_getweathertype","text":"Returns the weather type. Types: 0 - snow 1 - rain 1 func int Wld_GetWeatherType () {}; return - weather type","title":"Wld_GetWeatherType()"},{"location":"zengin/tools/","text":"Tools The community has developed many tools to help with the creation of Gothic mods. Note This list is work in progress Daedalus Daedalus Language Server - a VS Code/VS Codium extension that adds IDE like functionality for Daedalus scripting language Ikarus - A daedalus library for the game Gothic. Exploits the interpreter to allow arbitrary memory access and defines a lot of useful functions for interfacing with the engine. LeGo - A daedalus library for the game Gothic. It contains various packages to support modders. AFSP - Fawkes' & Auronen's script package for Gothic 1 and Gothic 2: Night of the Raven. Ninja - Ninja introduces the possibility of true modular modifications for the video games Gothic and Gothic 2 Night of the Raven. VDFS tools GothicVDFS - NiceDE's viewer, extractor and builder for .vdf and .mod volumes VDFS Tool - Gratt's Union VDFS viewer, extractor, builder, optimizer and ZIP compressor for .vdf and .mod volumes World Editors Spacer - the original world editor for ZenGin, ships with the MDK Union Gothic World Editor - Saturas' world editor, supports new object classes created with Union Gothic World Editor - World editor for vanilla worlds, works with G1, G2 and G2 NotR worlds","title":"Tools"},{"location":"zengin/tools/#tools","text":"The community has developed many tools to help with the creation of Gothic mods. Note This list is work in progress Daedalus Daedalus Language Server - a VS Code/VS Codium extension that adds IDE like functionality for Daedalus scripting language Ikarus - A daedalus library for the game Gothic. Exploits the interpreter to allow arbitrary memory access and defines a lot of useful functions for interfacing with the engine. LeGo - A daedalus library for the game Gothic. It contains various packages to support modders. AFSP - Fawkes' & Auronen's script package for Gothic 1 and Gothic 2: Night of the Raven. Ninja - Ninja introduces the possibility of true modular modifications for the video games Gothic and Gothic 2 Night of the Raven. VDFS tools GothicVDFS - NiceDE's viewer, extractor and builder for .vdf and .mod volumes VDFS Tool - Gratt's Union VDFS viewer, extractor, builder, optimizer and ZIP compressor for .vdf and .mod volumes World Editors Spacer - the original world editor for ZenGin, ships with the MDK Union Gothic World Editor - Saturas' world editor, supports new object classes created with Union Gothic World Editor - World editor for vanilla worlds, works with G1, G2 and G2 NotR worlds","title":"Tools"},{"location":"zengin/tools/dls/","text":"Daedalus Language Server Daedalus Language Server Todo TODO","title":"Daedalus Language Server"},{"location":"zengin/tools/dls/#daedalus-language-server","text":"Daedalus Language Server Todo TODO","title":"Daedalus Language Server"},{"location":"zengin/tools/gothic_sourcer/","text":"Gothic Sourcer Gothic Sourcer can be used to do a lot of things. Todo TODO","title":"Gothic Sourcer"},{"location":"zengin/tools/gothic_sourcer/#gothic-sourcer","text":"Gothic Sourcer can be used to do a lot of things. Todo TODO","title":"Gothic Sourcer"},{"location":"zengin/tools/gothic_vdfs/","text":"GothicVDFS Gothic VDFS is still the most popular VDFS tool. It was created by NicoDE. Download You can download the tool from NicoDE's website - direct link . Quick overview","title":"GothicVDFS"},{"location":"zengin/tools/gothic_vdfs/#gothicvdfs","text":"Gothic VDFS is still the most popular VDFS tool. It was created by NicoDE.","title":"GothicVDFS"},{"location":"zengin/tools/gothic_vdfs/#download","text":"You can download the tool from NicoDE's website - direct link .","title":"Download"},{"location":"zengin/tools/gothic_vdfs/#quick-overview","text":"","title":"Quick overview"},{"location":"zengin/tools/vdfs_tool/","text":"VDFS Tool VDFS Tool is a new program that supports new features introduced to VDFS by the Union team. Like ZIP compression or drag and drop support. Download You can download the tool from the post on WoP.ru - VDFS Tool or using the Resource Manager Quick overview","title":"VDFS Tool"},{"location":"zengin/tools/vdfs_tool/#vdfs-tool","text":"VDFS Tool is a new program that supports new features introduced to VDFS by the Union team. Like ZIP compression or drag and drop support.","title":"VDFS Tool"},{"location":"zengin/tools/vdfs_tool/#download","text":"You can download the tool from the post on WoP.ru - VDFS Tool or using the Resource Manager","title":"Download"},{"location":"zengin/tools/vdfs_tool/#quick-overview","text":"","title":"Quick overview"},{"location":"zengin/union/","text":"Union Union is a system to patch and extend Gothic's engine the ZenGin. It allows you to load .dll files - ZenGin extensions created using the Gothic/Union SDK and .patch files - files designed to patch the game's executable. The Union installer also contains the SystemPack a collection of bug fixes and engine edits that improve performance. Plug-ins Union plugins are shipped in the form of a .dll library. This library contains the compiled C++ code with the Union SDK and an embedded .patch file. Union SDK & Gothic API Union software development kit is a collection of tools and the Gothic API that allow you to create Union plugins and alter the engine's behavior. Gothic API a set of 4 interfaces (each for one different ZenGin version) that allow you to interface with the engine, access the engine objects, change their behavior and introduce new classes and functionality. PATCH file format The .patch file contains one or more small programs that are designed to change the engine code (game executable). This is usually done to fix bugs. Union plug-ins contain an embedded .patch file and this file usually contains changes to the binary necessary for the proper function of the plug-in.","title":"Union"},{"location":"zengin/union/#union","text":"Union is a system to patch and extend Gothic's engine the ZenGin. It allows you to load .dll files - ZenGin extensions created using the Gothic/Union SDK and .patch files - files designed to patch the game's executable. The Union installer also contains the SystemPack a collection of bug fixes and engine edits that improve performance.","title":"Union"},{"location":"zengin/union/#plug-ins","text":"Union plugins are shipped in the form of a .dll library. This library contains the compiled C++ code with the Union SDK and an embedded .patch file.","title":"Plug-ins"},{"location":"zengin/union/#union-sdk-gothic-api","text":"Union software development kit is a collection of tools and the Gothic API that allow you to create Union plugins and alter the engine's behavior. Gothic API a set of 4 interfaces (each for one different ZenGin version) that allow you to interface with the engine, access the engine objects, change their behavior and introduce new classes and functionality.","title":"Union SDK &amp; Gothic API"},{"location":"zengin/union/#patch-file-format","text":"The .patch file contains one or more small programs that are designed to change the engine code (game executable). This is usually done to fix bugs. Union plug-ins contain an embedded .patch file and this file usually contains changes to the binary necessary for the proper function of the plug-in.","title":"PATCH file format"},{"location":"zengin/union/zgamepad/","text":"zGamePad zGamePad plugin adds gamepad support for ZenGin games. Important Visit the excellent original GitHub wiki page . Contacts Author Gratt GitHub zGamePad Forum zGamePad Gamepad support All xinput compatible (including emulators) Xbox controller family Dualshock 4 Dualsense Nintendo Switch Joy-Cons Nintendo Switch Pro Controller Features Natural Movements Intuitiveness and smoothness of movement controls is the main goal of this plugin. Touch the world of Gothic with your hands. Interactive hints Interactive hints will help you in mastering the controls. You can always customize their appearance or disable them. Quick access The plugin has two quick access rings - **weapons and items. Use them to always have access to your items. Automatic save naming Sit comfortably. You do not have to reach for your keyboard, because the plugin itself will give a name to your saves. Saves rotation The best alternative to quicksaves for gamepad controls. Vibration response Immerse yourself in the game even more. Vibration will allow you to feel your character and everything that happens in the world. Target locking The plugin will always help you win. Keeping the enemy in focus will allow you to fight much more effectively. Stuck protection Oops! If you get stuck, hold both analogue sticks for a few seconds and the character will reset.","title":"zGamePad"},{"location":"zengin/union/zgamepad/#zgamepad","text":"zGamePad plugin adds gamepad support for ZenGin games. Important Visit the excellent original GitHub wiki page . Contacts Author Gratt GitHub zGamePad Forum zGamePad","title":"zGamePad"},{"location":"zengin/union/zgamepad/#gamepad-support","text":"All xinput compatible (including emulators) Xbox controller family Dualshock 4 Dualsense Nintendo Switch Joy-Cons Nintendo Switch Pro Controller","title":"Gamepad support"},{"location":"zengin/union/zgamepad/#features","text":"Natural Movements Intuitiveness and smoothness of movement controls is the main goal of this plugin. Touch the world of Gothic with your hands. Interactive hints Interactive hints will help you in mastering the controls. You can always customize their appearance or disable them. Quick access The plugin has two quick access rings - **weapons and items. Use them to always have access to your items. Automatic save naming Sit comfortably. You do not have to reach for your keyboard, because the plugin itself will give a name to your saves. Saves rotation The best alternative to quicksaves for gamepad controls. Vibration response Immerse yourself in the game even more. Vibration will allow you to feel your character and everything that happens in the world. Target locking The plugin will always help you win. Keeping the enemy in focus will allow you to fight much more effectively. Stuck protection Oops! If you get stuck, hold both analogue sticks for a few seconds and the character will reset.","title":"Features"},{"location":"zengin/union/zgamepad/controls/","text":"Gamepad controls The zGamePad plugin comes with a default control scheme, but it is possible to create your own. The plugin will search for any file with the .gamepad.overlay extension placed in Gothic/System directory or in any of the loaded .mod and .vdf archives. Control file syntax Gamepad controls are set using the .gamepad configuration file. This file encodes the controls for different actions in the game and the hint string in multiple languages. Warning The .gamepad file must be encoded in Unicode or UTF-8 to accommodate the multilingual hint strings. Regions The format supports code blocks specified by the #region and #endregion keywords. These regions do not have any syntactical meaning, they only offer a convenient way to collapse sections of the code in editors with the syntax highlighting capabilities such as Notepad++ Regions 1 2 3 4 5 6 7 #region strings // TODO #endregion #region fight scheme // TODO #endregion Comments Comments are useful for quick information or just to disable some old code that might come in handy later. The .gamepad file syntax supports C++ line comments using two forward slashes // . Warning Comments can only be used at the start of any given line! Comments 1 2 // this is a comment KeyRecord // this is NOT a comment Strings Strings are used for interactive hints. They should be defined at the top of the file. To define a string, use the keyword String . Strings have the following format: Multilang string syntax 1 2 3 4 String [id] [langTag] [text] [langTag] [text] [langTag] [text] Example 1 2 3 4 5 6 7 8 9 10 11 String interact Rus \"\u0412\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c\" Eng \"Interact\" Pol \"Interakcja\" Deu \"Interagieren\" String remove_weapon Rus \"\u0423\u0431\u0440\u0430\u0442\u044c \u043e\u0440\u0443\u0436\u0438\u0435\" Eng \"Remove weapon\" Pol \"Chowanie broni\" Deu \"Waffe entfernen\" The string name must be unique and is used to reference the string while defining hints. The language tag matches the language in SystemPack.ini . If the file does not contain the user's language, English will be taken by default. If there is no English, then the first one. Control bindings A binding is a description of an event that includes emulation object and conditions. Hints are part of the binding. The general structure of the bind starts with the keyword KeyRecord and has the following format: Control binding 1 2 3 4 5 6 KeyRecord [modifier] Id [key name] Combination [gamepad keys] Emulation [engine logical and absolute keys] Condition [engine logical, absolute keys or logical functions] Help [name of the hint string] Id - unique identifier used by other users to override this control binding [modifier] - can be empty or take the value of Toggled If the value is empty, the control binding will work as long as the player holds down the specified button or button combination. If the value is Toggled , the control binding will work only when the player toggles the button or button combination. (One press to start sneaking, another press to stop sneaking) Combination - these are the gamepad buttons that the player must press or hold to activate the control binding. Emulation - specify which buttons will be emulated. You can specify absolute buttons, or that are defined in the game settings (logical). Condition - specify the condition under which the control binding can be activated. To invert condition, use the operator ! before the operand (!Cond_IsOverlayTop, !JOY_B) Help - name of the text string with a hint which will be displayed when the Conditions are met. [gamepad keys] - Gamepad key list [engine logical keys] - Engine logical key list [engine absolute keys] - Engine absolute key list [logical functions] - Logical function list Tip All operators are optional! This means that if a binding should only show a hint, it doesn't have to contain Combination. Example Control binding examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 KeyRecord Id StopUsingPicklock Combination JOY_B Emulation KEY_DOWN Condition Cond_InterfaceIsOpen, Cond_UsesPicklock, !JOY_B KeyRecord Toggled Id ReturnToHumanForm Combination JOY_A Emulation KEY_RETURN Condition Cond_InTransformation Help end_transform KeyRecord Id QuickRingSelectSlot Combination JOY_RSTICK_FULL Condition !Cond_InventoryIsOpen, Cond_IsOverlayTop Help focus_item Controls override If you want to change or remove bindings from another controls file, use the KeyDisable keyword. Default controls file Controls override syntax 1 KeyDisable [fileName].[Id] Where fileName is the name of the controls file without extension and id is a key of the binding. Example Controls override example 1 2 3 4 5 6 7 8 // remove key from the main controls file KeyDisable Controls.ArrowDown // create new key based on the same buttons KeyRecord Toggled Id ArrowDownNew Combination JOY_DOWN Emulation GAME_DOWN","title":"Controls customization"},{"location":"zengin/union/zgamepad/controls/#gamepad-controls","text":"The zGamePad plugin comes with a default control scheme, but it is possible to create your own. The plugin will search for any file with the .gamepad.overlay extension placed in Gothic/System directory or in any of the loaded .mod and .vdf archives.","title":"Gamepad controls"},{"location":"zengin/union/zgamepad/controls/#control-file-syntax","text":"Gamepad controls are set using the .gamepad configuration file. This file encodes the controls for different actions in the game and the hint string in multiple languages. Warning The .gamepad file must be encoded in Unicode or UTF-8 to accommodate the multilingual hint strings.","title":"Control file syntax"},{"location":"zengin/union/zgamepad/controls/#regions","text":"The format supports code blocks specified by the #region and #endregion keywords. These regions do not have any syntactical meaning, they only offer a convenient way to collapse sections of the code in editors with the syntax highlighting capabilities such as Notepad++ Regions 1 2 3 4 5 6 7 #region strings // TODO #endregion #region fight scheme // TODO #endregion","title":"Regions"},{"location":"zengin/union/zgamepad/controls/#comments","text":"Comments are useful for quick information or just to disable some old code that might come in handy later. The .gamepad file syntax supports C++ line comments using two forward slashes // . Warning Comments can only be used at the start of any given line! Comments 1 2 // this is a comment KeyRecord // this is NOT a comment","title":"Comments"},{"location":"zengin/union/zgamepad/controls/#strings","text":"Strings are used for interactive hints. They should be defined at the top of the file. To define a string, use the keyword String . Strings have the following format: Multilang string syntax 1 2 3 4 String [id] [langTag] [text] [langTag] [text] [langTag] [text]","title":"Strings"},{"location":"zengin/union/zgamepad/controls/#example","text":"1 2 3 4 5 6 7 8 9 10 11 String interact Rus \"\u0412\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c\" Eng \"Interact\" Pol \"Interakcja\" Deu \"Interagieren\" String remove_weapon Rus \"\u0423\u0431\u0440\u0430\u0442\u044c \u043e\u0440\u0443\u0436\u0438\u0435\" Eng \"Remove weapon\" Pol \"Chowanie broni\" Deu \"Waffe entfernen\" The string name must be unique and is used to reference the string while defining hints. The language tag matches the language in SystemPack.ini . If the file does not contain the user's language, English will be taken by default. If there is no English, then the first one.","title":"Example"},{"location":"zengin/union/zgamepad/controls/#control-bindings","text":"A binding is a description of an event that includes emulation object and conditions. Hints are part of the binding. The general structure of the bind starts with the keyword KeyRecord and has the following format: Control binding 1 2 3 4 5 6 KeyRecord [modifier] Id [key name] Combination [gamepad keys] Emulation [engine logical and absolute keys] Condition [engine logical, absolute keys or logical functions] Help [name of the hint string] Id - unique identifier used by other users to override this control binding [modifier] - can be empty or take the value of Toggled If the value is empty, the control binding will work as long as the player holds down the specified button or button combination. If the value is Toggled , the control binding will work only when the player toggles the button or button combination. (One press to start sneaking, another press to stop sneaking) Combination - these are the gamepad buttons that the player must press or hold to activate the control binding. Emulation - specify which buttons will be emulated. You can specify absolute buttons, or that are defined in the game settings (logical). Condition - specify the condition under which the control binding can be activated. To invert condition, use the operator ! before the operand (!Cond_IsOverlayTop, !JOY_B) Help - name of the text string with a hint which will be displayed when the Conditions are met. [gamepad keys] - Gamepad key list [engine logical keys] - Engine logical key list [engine absolute keys] - Engine absolute key list [logical functions] - Logical function list Tip All operators are optional! This means that if a binding should only show a hint, it doesn't have to contain Combination.","title":"Control bindings"},{"location":"zengin/union/zgamepad/controls/#example_1","text":"Control binding examples 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 KeyRecord Id StopUsingPicklock Combination JOY_B Emulation KEY_DOWN Condition Cond_InterfaceIsOpen, Cond_UsesPicklock, !JOY_B KeyRecord Toggled Id ReturnToHumanForm Combination JOY_A Emulation KEY_RETURN Condition Cond_InTransformation Help end_transform KeyRecord Id QuickRingSelectSlot Combination JOY_RSTICK_FULL Condition !Cond_InventoryIsOpen, Cond_IsOverlayTop Help focus_item","title":"Example"},{"location":"zengin/union/zgamepad/controls/#controls-override","text":"If you want to change or remove bindings from another controls file, use the KeyDisable keyword. Default controls file Controls override syntax 1 KeyDisable [fileName].[Id] Where fileName is the name of the controls file without extension and id is a key of the binding.","title":"Controls override"},{"location":"zengin/union/zgamepad/controls/#example_2","text":"Controls override example 1 2 3 4 5 6 7 8 // remove key from the main controls file KeyDisable Controls.ArrowDown // create new key based on the same buttons KeyRecord Toggled Id ArrowDownNew Combination JOY_DOWN Emulation GAME_DOWN","title":"Example"},{"location":"zengin/union/zgamepad/keys_engine_absolute/","text":"Engine absolute keys Absolute keys are the physical keys on your keyboard. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 MOUSE_DX MOUSE_DY MOUSE_UP MOUSE_DOWN MOUSE_LEFT MOUSE_RIGHT MOUSE_WHEELUP MOUSE_WHEELDOWN MOUSE_BUTTONLEFT MOUSE_BUTTONRIGHT MOUSE_BUTTONMID MOUSE_XBUTTON1 MOUSE_XBUTTON2 MOUSE_XBUTTON3 MOUSE_XBUTTON4 MOUSE_XBUTTON5 KEY_ESCAPE KEY_1 KEY_2 KEY_3 KEY_4 KEY_5 KEY_6 KEY_7 KEY_8 KEY_9 KEY_0 KEY_MINUS KEY_EQUALS KEY_BACK KEY_TAB KEY_Q KEY_W KEY_E KEY_R KEY_T KEY_Y KEY_U KEY_I KEY_O KEY_P KEY_LBRACKET KEY_RBRACKET KEY_RETURN KEY_LCONTROL KEY_A KEY_S KEY_D KEY_F KEY_G KEY_H KEY_J KEY_K KEY_L KEY_SEMICOLON KEY_APOSTROPHE KEY_GRAVE KEY_LSHIFT KEY_BACKSLASH KEY_Z KEY_X KEY_C KEY_V KEY_B KEY_N KEY_M KEY_COMMA KEY_PERIOD KEY_SLASH KEY_RSHIFT KEY_MULTIPLY KEY_LMENU KEY_SPACE KEY_CAPITAL KEY_F1 KEY_F2 KEY_F3 KEY_F4 KEY_F5 KEY_F6 KEY_F7 KEY_F8 KEY_F9 KEY_F10 KEY_NUMLOCK KEY_SCROLL KEY_NUMPAD7 KEY_NUMPAD8 KEY_NUMPAD9 KEY_SUBTRACT KEY_NUMPAD4 KEY_NUMPAD5 KEY_NUMPAD6 KEY_ADD KEY_NUMPAD1 KEY_NUMPAD2 KEY_NUMPAD3 KEY_NUMPAD0 KEY_DECIMAL KEY_OEM_102 KEY_F11 KEY_F12 KEY_F13 KEY_F14 KEY_F15 KEY_KANA KEY_ABNT_C1 KEY_CONVERT KEY_NOCONVERT KEY_YEN KEY_ABNT_C2 KEY_NUMPADEQUALS KEY_PREVTRACK KEY_AT KEY_COLON KEY_UNDERLINE KEY_KANJI KEY_STOP KEY_AX KEY_UNLABELED KEY_NEXTTRACK KEY_NUMPADENTER KEY_RCONTROL KEY_MUTE KEY_CALCULATOR KEY_PLAYPAUSE KEY_MEDIASTOP KEY_VOLUMEDOWN KEY_VOLUMEUP KEY_WEBHOME KEY_NUMPADCOMMA KEY_DIVIDE KEY_SYSRQ KEY_RMENU KEY_PAUSE KEY_HOME KEY_UP KEY_PRIOR KEY_LEFT KEY_RIGHT KEY_END KEY_DOWN KEY_NEXT KEY_INSERT KEY_DELETE KEY_LWIN KEY_RWIN KEY_APPS KEY_POWER KEY_SLEEP KEY_WAKE KEY_WEBSEARCH KEY_WEBFAVORITES KEY_WEBREFRESH KEY_WEBSTOP KEY_WEBFORWARD KEY_WEBBACK KEY_MYCOMPUTER KEY_MAIL KEY_MEDIASELECT KEY_BACKSPACE KEY_NUMPADSTAR KEY_LALT KEY_CAPSLOCK KEY_NUMPADMINUS KEY_NUMPADPLUS KEY_NUMPADPERIOD KEY_NUMPADSLASH KEY_RALT KEY_UPARROW KEY_PGUP KEY_LEFTARROW KEY_RIGHTARROW KEY_DOWNARROW KEY_PGDN","title":"Engine absolute key list"},{"location":"zengin/union/zgamepad/keys_engine_absolute/#engine-absolute-keys","text":"Absolute keys are the physical keys on your keyboard. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 MOUSE_DX MOUSE_DY MOUSE_UP MOUSE_DOWN MOUSE_LEFT MOUSE_RIGHT MOUSE_WHEELUP MOUSE_WHEELDOWN MOUSE_BUTTONLEFT MOUSE_BUTTONRIGHT MOUSE_BUTTONMID MOUSE_XBUTTON1 MOUSE_XBUTTON2 MOUSE_XBUTTON3 MOUSE_XBUTTON4 MOUSE_XBUTTON5 KEY_ESCAPE KEY_1 KEY_2 KEY_3 KEY_4 KEY_5 KEY_6 KEY_7 KEY_8 KEY_9 KEY_0 KEY_MINUS KEY_EQUALS KEY_BACK KEY_TAB KEY_Q KEY_W KEY_E KEY_R KEY_T KEY_Y KEY_U KEY_I KEY_O KEY_P KEY_LBRACKET KEY_RBRACKET KEY_RETURN KEY_LCONTROL KEY_A KEY_S KEY_D KEY_F KEY_G KEY_H KEY_J KEY_K KEY_L KEY_SEMICOLON KEY_APOSTROPHE KEY_GRAVE KEY_LSHIFT KEY_BACKSLASH KEY_Z KEY_X KEY_C KEY_V KEY_B KEY_N KEY_M KEY_COMMA KEY_PERIOD KEY_SLASH KEY_RSHIFT KEY_MULTIPLY KEY_LMENU KEY_SPACE KEY_CAPITAL KEY_F1 KEY_F2 KEY_F3 KEY_F4 KEY_F5 KEY_F6 KEY_F7 KEY_F8 KEY_F9 KEY_F10 KEY_NUMLOCK KEY_SCROLL KEY_NUMPAD7 KEY_NUMPAD8 KEY_NUMPAD9 KEY_SUBTRACT KEY_NUMPAD4 KEY_NUMPAD5 KEY_NUMPAD6 KEY_ADD KEY_NUMPAD1 KEY_NUMPAD2 KEY_NUMPAD3 KEY_NUMPAD0 KEY_DECIMAL KEY_OEM_102 KEY_F11 KEY_F12 KEY_F13 KEY_F14 KEY_F15 KEY_KANA KEY_ABNT_C1 KEY_CONVERT KEY_NOCONVERT KEY_YEN KEY_ABNT_C2 KEY_NUMPADEQUALS KEY_PREVTRACK KEY_AT KEY_COLON KEY_UNDERLINE KEY_KANJI KEY_STOP KEY_AX KEY_UNLABELED KEY_NEXTTRACK KEY_NUMPADENTER KEY_RCONTROL KEY_MUTE KEY_CALCULATOR KEY_PLAYPAUSE KEY_MEDIASTOP KEY_VOLUMEDOWN KEY_VOLUMEUP KEY_WEBHOME KEY_NUMPADCOMMA KEY_DIVIDE KEY_SYSRQ KEY_RMENU KEY_PAUSE KEY_HOME KEY_UP KEY_PRIOR KEY_LEFT KEY_RIGHT KEY_END KEY_DOWN KEY_NEXT KEY_INSERT KEY_DELETE KEY_LWIN KEY_RWIN KEY_APPS KEY_POWER KEY_SLEEP KEY_WAKE KEY_WEBSEARCH KEY_WEBFAVORITES KEY_WEBREFRESH KEY_WEBSTOP KEY_WEBFORWARD KEY_WEBBACK KEY_MYCOMPUTER KEY_MAIL KEY_MEDIASELECT KEY_BACKSPACE KEY_NUMPADSTAR KEY_LALT KEY_CAPSLOCK KEY_NUMPADMINUS KEY_NUMPADPLUS KEY_NUMPADPERIOD KEY_NUMPADSLASH KEY_RALT KEY_UPARROW KEY_PGUP KEY_LEFTARROW KEY_RIGHTARROW KEY_DOWNARROW KEY_PGDN","title":"Engine absolute keys"},{"location":"zengin/union/zgamepad/keys_engine_logical/","text":"Engine logical keys Logical keys are the keys you set in keyboard settings in the game menu. These can fill multiple roles in different situations and the gamepad controls can be set to emulate these logical keys. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 GAME_LEFT GAME_RIGHT GAME_UP GAME_DOWN GAME_ACTION GAME_SLOW GAME_ACTION2 GAME_WEAPON GAME_SMOVE GAME_SMOVE2 GAME_SHIFT GAME_END GAME_INVENTORY GAME_LOOK GAME_SNEAK GAME_STRAFELEFT GAME_STRAFERIGHT GAME_SCREEN_STATUS GAME_SCREEN_LOG GAME_SCREEN_MAP GAME_LOOK_FP GAME_LOCK_TARGET GAME_PARADE GAME_ACTIONLEFT GAME_ACTIONRIGHT GAME_LAME_POTION GAME_LAME_HEAL","title":"Engine logical key list"},{"location":"zengin/union/zgamepad/keys_engine_logical/#engine-logical-keys","text":"Logical keys are the keys you set in keyboard settings in the game menu. These can fill multiple roles in different situations and the gamepad controls can be set to emulate these logical keys. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 GAME_LEFT GAME_RIGHT GAME_UP GAME_DOWN GAME_ACTION GAME_SLOW GAME_ACTION2 GAME_WEAPON GAME_SMOVE GAME_SMOVE2 GAME_SHIFT GAME_END GAME_INVENTORY GAME_LOOK GAME_SNEAK GAME_STRAFELEFT GAME_STRAFERIGHT GAME_SCREEN_STATUS GAME_SCREEN_LOG GAME_SCREEN_MAP GAME_LOOK_FP GAME_LOCK_TARGET GAME_PARADE GAME_ACTIONLEFT GAME_ACTIONRIGHT GAME_LAME_POTION GAME_LAME_HEAL","title":"Engine logical keys"},{"location":"zengin/union/zgamepad/keys_gamepad/","text":"Gamepad keys In order to set gamepad keys, you have to know the key codes as they are listed below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 JOY_UP JOY_DOWN JOY_LEFT JOY_RIGHT JOY_MENU JOY_VIEW JOY_LSTICK JOY_RSTICK JOY_LB JOY_RB JOY_A JOY_B JOY_X JOY_Y JOY_LSTICK_LOWUP JOY_LSTICK_UP JOY_LSTICK_DOWN JOY_LSTICK_LEFT JOY_LSTICK_RIGHT JOY_RT JOY_LT JOY_DPAD JOY_UPDOWN JOY_LEFTRIGHT JOY_LSTICK_FULL JOY_RSTICK_FULL","title":"Gamepad key list"},{"location":"zengin/union/zgamepad/keys_gamepad/#gamepad-keys","text":"In order to set gamepad keys, you have to know the key codes as they are listed below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 JOY_UP JOY_DOWN JOY_LEFT JOY_RIGHT JOY_MENU JOY_VIEW JOY_LSTICK JOY_RSTICK JOY_LB JOY_RB JOY_A JOY_B JOY_X JOY_Y JOY_LSTICK_LOWUP JOY_LSTICK_UP JOY_LSTICK_DOWN JOY_LSTICK_LEFT JOY_LSTICK_RIGHT JOY_RT JOY_LT JOY_DPAD JOY_UPDOWN JOY_LEFTRIGHT JOY_LSTICK_FULL JOY_RSTICK_FULL","title":"Gamepad keys"},{"location":"zengin/union/zgamepad/logical_functions/","text":"Logical function names Conditions for when to show or allow the control binding to work are specified using these logic functions. They describe different useful states of the game or user interface, allowing the user to set when will a certain control work. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Cond_FightMode - player is in the fight mode Cond_FightModeMelee - player is in the melee fight mode Cond_FightModeRange - player is in the ranged fight mode Cond_FightModeMagic - player is in the magical fight mode Cond_CanShoot - player is in the aim mode and can shoot now Cond_CanSneaking - player is sneaking now Cond_Diving - player is diving now Cond_HasFocusVob - player has a focus vob Cond_HasFocusNpc - player has a focus npc Cond_OnChooseWeapon - weapon selection is active Cond_InventoryIsOpen - inventory is open Cond_InTransformation - player is transformed Cond_VideoIsOpen - video is playing Cond_CanLockTarget - player in the fight mode now and can lock the focus vob Cond_G1 - this engine is a Gothic 1 (or sequel) Cond_G2 - this engine is a Gothic 2 NoTR (or classic) Cond_IsDialogTop - dialog window is open on the top Cond_IsDocumentTop - document object is open on the top Cond_IsOverlayTop - gamepad overlay object is open on the top Cond_IsMenuTop - game menu is open on the top Cond_OnSpellBook - magic selection ring is active Cond_IsPlayerTalking - player is talking to someone Cond_InterfaceIsOpen - open any interface element Cond_HasLeftContainer - the left container is open (chest, plunder, trader) Cond_UsesPicklock - player is picking a lock now Cond_IsOnTrade - player is trading Cond_IsOverlayTop - gamepad overlay object is open on the top Cond_IsMenuTop - game menu is open on the top","title":"Logical function list"},{"location":"zengin/union/zgamepad/logical_functions/#logical-function-names","text":"Conditions for when to show or allow the control binding to work are specified using these logic functions. They describe different useful states of the game or user interface, allowing the user to set when will a certain control work. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Cond_FightMode - player is in the fight mode Cond_FightModeMelee - player is in the melee fight mode Cond_FightModeRange - player is in the ranged fight mode Cond_FightModeMagic - player is in the magical fight mode Cond_CanShoot - player is in the aim mode and can shoot now Cond_CanSneaking - player is sneaking now Cond_Diving - player is diving now Cond_HasFocusVob - player has a focus vob Cond_HasFocusNpc - player has a focus npc Cond_OnChooseWeapon - weapon selection is active Cond_InventoryIsOpen - inventory is open Cond_InTransformation - player is transformed Cond_VideoIsOpen - video is playing Cond_CanLockTarget - player in the fight mode now and can lock the focus vob Cond_G1 - this engine is a Gothic 1 (or sequel) Cond_G2 - this engine is a Gothic 2 NoTR (or classic) Cond_IsDialogTop - dialog window is open on the top Cond_IsDocumentTop - document object is open on the top Cond_IsOverlayTop - gamepad overlay object is open on the top Cond_IsMenuTop - game menu is open on the top Cond_OnSpellBook - magic selection ring is active Cond_IsPlayerTalking - player is talking to someone Cond_InterfaceIsOpen - open any interface element Cond_HasLeftContainer - the left container is open (chest, plunder, trader) Cond_UsesPicklock - player is picking a lock now Cond_IsOnTrade - player is trading Cond_IsOverlayTop - gamepad overlay object is open on the top Cond_IsMenuTop - game menu is open on the top","title":"Logical function names"}]}