{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Gothic Modding Community page","text":""},{"location":"#welcome-to-gothic-modding-community-page","title":"Welcome to Gothic Modding Community page","text":"<p>This GitHub page is designed to contain community maintained set of articles, tutorials and documentation for everything Gothic.</p> <p>First two Gothic games use engine called ZenGin, developed by Piranha Bytes and Mad Scientists. If you want to know more about the history of the development, there is a heap of information on the Gothic Archive.</p> <p>The content here is not meant to be taken as the holy word of modding. We are just modders sharing our experiences, knowledge and our favorite work flows.</p> <p>Feel free to open a pull request with your article or propose changes.</p> <p>You can open a pull request in this repository</p>"},{"location":"notready/","title":"Notready","text":"<p>Warning</p> <p>Sorry, this page is not ready yet! </p>"},{"location":"contribute/","title":"How to contribute","text":""},{"location":"contribute/#how-to-contribute","title":"How to contribute","text":"<p>The Gothic Modding Community is a community-driven project. We encourage people to contribute.</p> <p>This site is built with a Static Site Generator MkDocs and the Material for MkDocs theme together with multiple other MkDocs plugins.</p> <p>Prerequisites for contribution differ based on the scale and type of the contribution.</p>"},{"location":"contribute/#feedback","title":"Feedback","text":"<p>Using English, you can either open an issue via GitHub or join us on Discord.</p>"},{"location":"contribute/#direct-contribution","title":"Direct contribution","text":"<p>Direct contribution is made via creating a copy of this repository (a fork) and creating a pull request (PR) on GitHub with changes for approval.</p> <p>Don't waste time</p> <p>Please make sure that the content you are contributing does not already exist on the dev page. You can use the search tool to filter GMC for different keywords and contents.</p> <p>How to edit the source files?</p> <p>The source files for the articles are written using the Markdown <code>.md</code> file format (Markdown cheatsheet). Other than that, this site also uses Python Markdown Extensions which add more syntax rules like indented admonitions.</p>"},{"location":"contribute/#minor-changes","title":"Minor changes","text":"<p>Minor changes like fixing typos, grammatical errors or removing/adding words to paragraphs in a single file can be done quickly with the  button in the upper right corner of each article. This will open up a GitHub editing interface which will create a fork with a patch branch after modifying the file and guide the user to open up the pull request.</p> <p>Select the correct branch for the pull request</p> <p>Make sure that the pull request is directed towards the <code>dev</code> or a special <code>pre-merge</code> branch and not the <code>main</code> branch.</p>"},{"location":"contribute/#major-changes","title":"Major changes","text":"<p>More elaborate changes like editing multiple files at once, adding new articles, images, other miscellaneous files or changing the configuration of the page are easier to make via external tools on your local PC. While most of these operations can be done with the GitHub interface, it is rather cumbersome, and it may be harder to spot issues during the process as changes are not immediately visible in the browser in their final form.</p> <p>Some preparation is needed before working on the files as MkDocs requires an installation of Python on the system to run. GitHub works on top of git so an installation of git is also required. A basic familiarity with Terminal/Command Prompt/Powershell command line interfaces is helpful.</p>"},{"location":"contribute/#system-setup-video","title":"System setup (video)","text":"<p>Firstly, you should install Python. You can follow this step-by-step tutorial for Windows or macOS on how to install Python.</p> <p>This video is from 2017?!</p> <p>The process of installing Python hasn't changed since that point. However, please install the latest version of Python 3.</p> <p>To work remotely with GitHub, you can install the latest version of git on your system following this tutorial.</p> <p>If you just plan on editing the content of the articles with Markdown, you can simply install the latest version of Visual Studio Code for GUI git management and Markdown preview or work with any other familiar text editor and omit the environment setup.</p> <p>If you are planning to do some elaborate Python programming, you can follow this step-by-step tutorial for Windows or macOS on how to set up an environment with Visual Studio Code.</p>"},{"location":"contribute/#system-setup-text","title":"System setup (text)","text":"<p>To prepare your system to run the project follow those instructions:</p> <ol> <li> <p>Install the latest version of Python .     Make sure to select the \"Add Python to PATH\" option during the installation process.</p> </li> <li> <p>Open up a Terminal/Command Prompt (cmd)/Powershell window.</p> </li> <li> <p>Check that Python was properly installed with this command (might need a terminal restart):</p> <pre><code>python --version\n</code></pre> </li> <li> <p>Install the latest version of git following this tutorial.</p> </li> <li> <p>Check that git was properly installed with this command (might need a terminal restart):</p> <pre><code>git --version\n</code></pre> </li> <li> <p>(optional) Install the latest version of Visual Studio Code for GUI git management and Markdown preview.</p> </li> </ol>"},{"location":"contribute/#working-locally","title":"Working locally","text":"<p>In order to work locally:</p> <ol> <li>Create a fork on GitHub.</li> <li>On your local PC navigate to a directory where you want to clone your forked repository and open a Terminal window inside.</li> <li> <p>Clone the forked repository, using this command:</p> <pre><code>git clone https://github.com/user-name/forked-repository-name.git &lt;DIR-PATH&gt;\n</code></pre> <p>Instead of <code>https://github.com/user-name/forked-repository-name.git</code> use your own link which can be found after clicking on the green <code>&lt;&gt; Code</code> button and selecting the <code>HTTPS</code> tab.</p> <p>Replace the <code>&lt;DIR-PATH&gt;</code> with a path to a directory or <code>.</code> if you're inside the directory you want the project files to be cloned into.</p> <p>This will automatically create a remote <code>origin</code> repository pointing to your own fork.</p> </li> <li> <p>Add the remote <code>upstream</code> repository using this command:</p> <pre><code>git remote add upstream https://github.com/Gothic-Modding-Community/gmc.git\n</code></pre> </li> <li> <p>(optional) Create a Virtual Environment and activate it.</p> <p>If you work on multiple Python projects, it might be worthwhile to create a Virtual Environment for each project to have separate library directories with installed modules/plugins.</p> <pre><code>python -m venv venv\n</code></pre> <p>This will create a <code>venv</code> directory inside the current Terminal directory. Please keep that name as it's added to the <code>.gitignore</code> project file.</p> <p>Depending on the system, use one of these commands to activate the virtual environment.</p> <p></p>Linux / macOS<pre><code>source venv/bin/activate\n</code></pre> Windows Powershell<pre><code>venv\\Scripts\\activate.ps1\n</code></pre> Windows Command Prompt (cmd)<pre><code>venv\\Scripts\\activate.bat\n</code></pre> <p>After activation there will be a <code>(venv)</code> indicator near the Terminal prompt.</p> <p>Don't close the Terminal</p> <p>The virtual environment must be activated each time a new Terminal window is opened.</p> </li> <li> <p>Install MkDocs with plugins using this command:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>This will install all dependencies.</p> </li> <li> <p>Fetch the git history from <code>upstream</code> using this command:</p> <pre><code>git fetch upstream\n</code></pre> </li> <li> <p>Checkout a new local branch based on the <code>upstream</code> <code>dev</code> branch:</p> <pre><code>git checkout -b name-of-branch --track upstream/dev\n</code></pre> <p>An appropriate name for a branch is either a feature name or short description of what it changes - for example <code>3ds-articles</code>, <code>fix-typos-for-contribution</code>. They do not have to be elaborate, up-to 4 words suffices.</p> </li> <li> <p>Start a server with MkDocs using this command:</p> <pre><code>mkdocs serve\n</code></pre> <p>Visit the local site with this url <code>http://127.0.0.1:8000/gmc/</code>. Any time you make change to any file, the website will rebuild itself and your browser will auto-refresh.</p> <p>The server may be closed using the <code>Control-C</code> shortcut while in the terminal/console.</p> </li> <li> <p>When you are satisfied with a part of work, add and commit the files using these commands:</p> <pre><code>git add .\ngit commit -m \"add 3 articles about ZenGin\"\n</code></pre> <p>An appropriate commit message should be a sentence describing the changes.</p> </li> <li> <p>When you are finished with the work, push the branch to <code>origin</code> using this command:</p> <pre><code>git push origin name-of-branch\n</code></pre> </li> <li> <p>Create the pull request to the appropriate branch.</p> <p>After pushing your local branch to the remote <code>origin</code>, there will be a link available in the Terminal window. Use it to create the pull request using the pushed branch.</p> </li> <li> <p>Another contribution:</p> <p>Before contributing again, always use this command: </p><pre><code>git fetch upstream </code></pre> to make sure that you have an up-to-date <code>upstream</code> git history. Follow then from step 8. <pre><code>git status\n</code></pre> <p>This command allows to check, if there are any changes in the project compared to the <code>upstream</code> repository.</p> </li> </ol>"},{"location":"contribute/#build-preferences","title":"Build preferences","text":"<p>While working with the project, it's possible to set various environmental variables to configure it to your own preferences:</p> <ul> <li><code>GMC_DEV_LOCALE</code> - is a 2-character language identifier (ex. <code>en</code>, <code>pl</code>), it sets the development language of the site. This will enforce that language to be the default and only built language. Helps to decrease build time and allows to easily change the language without modyfying the config file. Because of changes in the <code>mkdocs-static-i18n</code> plugin, this is the only way to temporarily change the default language</li> <li><code>GMC_BUILD_ALTERNATES</code> - <code>True</code> or <code>False</code> value, activates the site build to also include alternate languages apart of the default language. Default behaviour is to omit alternates to decrease build time.</li> <li><code>GMC_ENABLE_ON_PUBLISH</code> - <code>True</code> or <code>False</code> value, activates all of the final build procedures, like adding of the last modified date, minifying of the resources etc. </li> </ul> <p>Environmental variables can be set temporarily for the currently open Terminal window:</p> Linux<pre><code>export GMC_DEV_LOCALE=en export GMC_BUILD_ALTERNATES=False; mkdocs serve\n</code></pre> Windows Powershell<pre><code>$env:GMC_DEV_LOCALE=\"en\"\n$env:GMC_BUILD_ALTERNATES=\"False\"\nmkdocs serve\n</code></pre> Windows Command Prompt (cmd)<pre><code>set GMC_DEV_LOCALE=en\nset GMC_BUILD_ALTERNATES=False\nmkdocs serve\n</code></pre>"},{"location":"contribute/#build-performance","title":"Build performance","text":"<p>To speed up the build process during development make sure that only 1 language is built, and consider using the <code>--dirtyreload</code> option:</p> <pre><code>mkdocs serve --dirtyreload\n</code></pre> <p>This will cause only changed <code>.md</code> files to rebuild. However, if you make changes to a template in the <code>overrides</code> directory, no changes will be visible after the rebuild, because template modification requires a full rebuild.</p>"},{"location":"contribute/#submit-a-file","title":"Submit a file","text":"<p>If working with git or Markdown is not viable or possible for you, you can submit files in a Google Docs format on the GMC Discord server and we will format and upload it to the page.</p> <p>Only New English Content</p> <p>This option is limited to new content in English. We can't deal with translations in this manner. For translations send a translated <code>.md</code> file via a feedback channel, if you don't want to work directly with git, nor add the file via the GitHub interface.</p>"},{"location":"contribute/#translations","title":"Translations","text":"<p>To provide multilingual support, our site uses the MkDocs i18n plugin.</p>"},{"location":"contribute/#add-new-language-support","title":"Add new language support","text":"<p>To support a new language it needs to be added:</p> <p>Indentation is important</p> <p>You must preserve the correct amount of indentation, aka spacing between entries.</p> <ol> <li> <p>In the <code>mkdocs.yml</code> configuration, in this example we're adding the <code>xx</code> language:</p> <pre><code>plugins:\n- i18n:\n# ...\nlanguages:\nen:\nname: en - English\nbuild: true\nxx:\nname: xx - Language Name\nbuild: true\n</code></pre> </li> <li> <p>In the <code>overrides/main.html</code> file to add the announcement text for untranslated content:</p> <pre><code>{%\n    set announcement = {\n        \"en\": \"This page has not yet been translated into LANGUAGE, therefore it is displayed in English.\",\n        \"xx\": \"yyy\",\n    }\n%}\n{%\n    set call_to_action = {\n        \"en\": \"Support us and translate!\",\n        \"xx\": \"yyy\",\n    }\n%}\n</code></pre> </li> <li> <p>Visit the official theme site.      Make sure that the theme translation is complete there. If it's not, just follow their contribution guide and come back here, there is no need to wait for the changes in the theme.</p> </li> </ol>"},{"location":"contribute/#add-translated-pages","title":"Add translated pages","text":"<p>Each <code>.md</code> file in the <code>docs</code> directory can have a translated version. To add a translation for a given language create a copy with an added language suffix. For example <code>index.md</code> will become <code>index.xx.md</code> for the <code>xx</code> language based on the settings in the <code>mkdocs.yml</code> file.</p> <p>Each untranslated article has the  button in the upper right corner next to the title. It allows to quickly add the translation via the GitHub interface without the need for local file configuration.</p>"},{"location":"genome/","title":"Genome engine","text":""},{"location":"genome/#genome-engine","title":"Genome engine","text":"<p>Genome engine is new engine by Piranha Bytes created for the game Gothic 3 and later used for the Risen and ELEX series of games.</p>"},{"location":"genome/general_info/object_persistence/","title":"Object persistence","text":""},{"location":"genome/general_info/object_persistence/#object-persistence","title":"Object persistence","text":"<p>Please note the following warning about Risen 2, 3 and ELEX 1 and 2</p> <p>The following information only applies to Gothic 3 (2006) and Risen (2009). While newer Genome engine games share the same overall concepts, they have significant implementation differences that warrant their own section.</p> <p>The engine is, due to the nature of the games themselves, required to store and load a vast amount of different types of data from the user's hard-drive. In order to streamline this parsing and/or serialization process, Genome implements an object persistence system using its own built-in runtime type information (RTTI) system.</p> <p>Any class derived from <code>bCObjectBase</code> may declare its own member properties in such a way that when the object is then written into a file using the <code>bCAccessorPropertyObject</code> class, its associated properties will be automatically serialized into the stream by using special preprocessor macros. When the object is read back from the file, the class will be automatically initialized using the stored members.</p> <p>Additionally, classes may overload the <code>Read</code> and <code>Write</code> (<code>OnRead</code> and <code>OnWrite</code> in Risen 1) virtual methods that allow the class to save additional data required during parsing such as paths to other necessary files.</p> <p>As this system is quite flexible, it is used to store most of the game's data, from meshes, animations and textures to level and quest data. This is quite different from ZenGin, as its object persistence system is only used for worlds, saves, output units and parts of compiled meshes.</p>"},{"location":"genome/general_info/object_persistence/#file-format","title":"File format","text":""},{"location":"genome/general_info/object_persistence/#files","title":"Files","text":"<pre><code>struct bCIOStream\n{\nchar data[];\n};\n</code></pre> <pre><code>struct eCArchiveFile\n{\nchar8_t  magic[8];  // \"GENOMFLE\"\nuint16_t version;   // 0001\nuint32_t offset;\nchar data[];\nuint32_t magic;    // DEADBEEF\nuint8_t  version;  // 01\nuint32_t count;\nfor( Count )\n{\nuint16_t length;\nchar8_t  string[length];  // (ASCII)\n}\n};\n</code></pre>"},{"location":"genome/general_info/object_persistence/#bcaccessorpropertyobject","title":"bCAccessorPropertyObject","text":"<pre><code>bCAccessorPropertyObject::Read {\nuint16_t    version;    // 0x0001\nbool        hasPropertyObject;\nif (hasPropertyObject)\n{\nbCPropertyObjectSingleton::ReadObject\n{\nuint16_t    version;    // 0x0001\nbool        isPersistable;    // 0x01 (GETrue)\nbCString    className;\nbCPropertyObjectFactory::ReadObject\n{\nuint16_t    version;        // 0x0001\nbool        isRoot;            // 0x00 (GEFalse)\nuint16_t    classVersion;\nbTPropertyObject&lt;%,%&gt;::Read\n{\nbCPropertyObjectBase::Read\n{\nuint16_t version;    // 0x00C9 (201)\n}\nuint32_t size;\n}\nbTPropertyObject&lt;%,%&gt;::ReadData\n{\nbCPropertyObjectBase::ReadData\n{\nuint16_t version;    // 0x00C9 (201)\nuint32_t count;\nfor (count)\n{\nbCString    name;\nbCString    type;\nuint16_t    version;    // 0x001E (30)\nuint32_t    size;\nuint8_t        value[size];\n}\n}\n%::Read\n{\n// ClassName::OnRead/OnWrite()\n// uint16_t ClassVersion; ...\n}\n}\n}\n}\n}\n}\n</code></pre>"},{"location":"genome/general_info/object_persistence/#ecprocessibleelement","title":"eCProcessibleElement","text":"Gothic 3Risen <pre><code>eCProcessibleElement::Load\n{\nuint32_t magic; // 0xD0DEFADE\nbCAccessorPropertyObject::Read\n{\n// Look above for bCAccessorPropertyObject definition\n}\n}\n</code></pre> <pre><code>eCProcessibleElement::Load\n{\nbCAccessorPropertyObject::Read\n{\n// Look above for bCAccessorPropertyObject definition\n}\n}\n</code></pre>"},{"location":"genome/general_info/object_persistence/#implementation","title":"Implementation","text":""},{"location":"genome/general_info/object_persistence/#a-practical-example","title":"A practical example","text":"<p>Let's propose that we have a class which is declared like so:</p> <pre><code>class gCMyClass : public bCObjectRefBase\n{\npublic:\ngCMyClass()                {}\nvirtual ~gCMyClass()    {}\nvirtual bEResult Write(bCOStream&amp;); // OnWrite for Risen\nvirtual bEResult Read(bCIStream&amp;);  // OnRead for Risen\nprivate:\nDECLARE_PROPERTY(myInt, int);\nint someData;\n};\n</code></pre> <p>The hypothetical class then implements these virtual functions:</p> <pre><code>bEResult gCMyClass::Write(bCOStream&amp; file)\n{\nfile &lt;&lt; someData;\nreturn bEResult_Ok;\n}\nbEResult gCMyClass::Read(bCIStream&amp; file)\n{\nfile &gt;&gt; someData;\nreturn bEResult_Ok;\n}\n</code></pre> <p>We then initialize the class in the following way:</p> <pre><code>gCMyClass object;\nobject.myInt = 1;\nobject.someData = 1;\n</code></pre> <p>If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII stream, the result would look like this:</p> <pre><code>\n</code></pre>"},{"location":"genome/tools/","title":"Tools","text":""},{"location":"genome/tools/#tools","title":"Tools","text":"<p>Piranha Bytes did not release a modkit for their Genome engine, but the modding community has released a wide range of tools to work with the game's files and the engine itself.</p> <p>Info</p> <p>This page is under construction, for now, only handful of links are present.</p>"},{"location":"genome/tools/#gothic-3-sdk","title":"Gothic 3 SDK","text":"<p>Georgeto, inspired by NiceDE's Risen SDK, has created an SDK for Gothic 3. It can be used to manipulate the engine in the similar way Union is able to manipulate ZenGin. GitHub repository</p>"},{"location":"zengin/","title":"ZenGin","text":""},{"location":"zengin/#zengin","title":"ZenGin","text":"<p>The game engine ZenGin is used by Gothic 1 and 2. This section contains the documentation of the various aspects of ZenGin modding.</p>"},{"location":"zengin/meshes/","title":"Meshes","text":""},{"location":"zengin/meshes/#meshes","title":"Meshes","text":"<p>Everything about 3D models in ZenGin.</p>"},{"location":"zengin/music/","title":"Music","text":""},{"location":"zengin/music/#music","title":"Music","text":"<p>Zengin uses DirectMusic for playing in-game soundtrack. To edit Gothic music files you need the Direct Music Producer, a program released by Microsoft and provided with older DirectX SDK.  </p> <p>Warning</p> <p>Music files can't be packed in the <code>.vdf</code> or <code>.mod</code> archives, all music files must be located in <code>/_work/Data/Music</code> directory.</p>"},{"location":"zengin/music/#file-formats","title":"File formats","text":"<p>The music directory contains these file types:</p> <ul> <li> <p><code>.dls</code> - Downloadable Sound format file. This is the base for all other files. Contains:   </p> <ul> <li>Collections of virtual musical instruments.</li> <li>Wave files instruments use.</li> </ul> </li> <li> <p><code>.sty</code> - Style file. Contains:</p> <ul> <li>Bands - settings for virtual instruments from <code>.dls</code>.</li> <li>Patterns - fragments of tracks, that can be later merged, looped and superimposed on each other</li> </ul> </li> <li> <p><code>.sgt</code> - File with properly connected patterns - the final track</p> </li> </ul>"},{"location":"zengin/music/#alternative-music-system","title":"Alternative Music System","text":"<p>The zBassMusic plugin replaces Zengin's default music library with the much newer BASS library. This allows, among other things, to play music in such formats as <code>.mp3</code> or <code>.ogg</code>, and to pack songs into <code>.vdf</code> and <code>.mod</code> archives.</p>"},{"location":"zengin/textures/","title":"Textures","text":""},{"location":"zengin/textures/#textures","title":"Textures","text":"<p>Textures are pictures that get projected onto a 3D models and on a 2D user interface in the game. We will discuss how to work with textures in this section.</p>"},{"location":"zengin/video/","title":"Video","text":""},{"location":"zengin/video/#video","title":"Video","text":"<p>To get a video cutscene, intro or outro into the game, the video needs to be in a proper format - BINK video format <code>.bik</code>.</p>"},{"location":"zengin/video/#editing-the-video","title":"Editing the video","text":"<p>The video you recorded and want to use has to be edited. My go-to editor for this is kdenlive. It works very well, it is free and open source, and it supports BINK video as an input, which is great if you want to include subtitles in the video.</p> <p>My version of kdenlive does not know how to export video straight to <code>.bik</code> so I just export my video to <code>.mp4</code> and then convert it with RAD Video Tools.</p>"},{"location":"zengin/video/#rad-video-tools","title":"RAD Video Tools","text":"<p>RAD Video Tools is a tool for converting other video formats to BINK <code>.bik</code> that Gothic can use.</p> <p>Warning</p> <p>Gothic 1 bink implementation has some problems as you have to set the audio compression to 104 and above in RAD tools to get video to work in Gothic 1.</p> <p>NicoDE's comment: </p> <p>Add 100 to the audio compression level when encoding videos, e.g. 104 for level 4 with old sound format (should be mentioned in the RAD Video Tools documentation) for G1 without updated Miles libraries.  </p> <p>Note</p> <p>Newest Union (1.0m at the time of writing) has a new patch for BINK video playback. The issue with sound should be fixed.</p>"},{"location":"zengin/anims/","title":"Animation","text":""},{"location":"zengin/anims/#animation","title":"Animation","text":""},{"location":"zengin/anims/#animations-in-zengin","title":"Animations in ZenGin","text":"<p>Animations are (apart from maybe advanced programming work using Ikarus or Union) one of the most advanced modding techniques, since you not only must understand the way they work, but also know how to write the animation script and understand the whole scheme selection system, naming convention and of course know how to animate (that is my biggest problem :D). To get a new animation into ZenGin (the Gothic engine) is not difficult per se, I would describe it as tedious.</p> <p>Luckily, there are tools to help us to achieve our goal - get a new animation to be used by the engine, and in effect, to be used and seen in the game.</p> <p>To describe the whole process, I constructed this small tutorial, to help other people to get animations working and to spare them many hours of searching the excellent forum posts, that describe parts of the process. __</p> <p>Excluding advanced programming work with Ikarus or Union, animations are arguably the most advanced modding discipline of ZenGin engine. Its difficulty stems for the fact that you not only have to understand the general concept, but also learn how to write the animation scripts and understand the whole scheme selection system, including naming conventions and, most important for last - actually know how to animate. Adding new animations into ZenGin is more tedious than actually difficult.</p> <p>There are tool to help with this endeavor - to get a new animation implemented in the engine, and seeing its effects in game. Following tutorial has been constructed to help others to get their animations working without having to scour old forum posts for hours.</p>"},{"location":"zengin/anims/#prerequisites---tools--materials","title":"Prerequisites - Tools &amp; Materials","text":"<ol> <li>Gothic Mod Development Kit (MDK)<ul> <li>Gothic 1 MDK - link</li> <li>Gothic 2 MDK - link</li> </ul> </li> <li>Blender</li> <li>Kerrax's Import Export plugin - follow the installation instructions to install the plugin, make sure to set up the texture paths too</li> <li>Tool for decompiling animations GothicSourcer, or use phoenix or write your own using ZenLib</li> </ol>"},{"location":"zengin/anims/#the-workflow","title":"The workflow","text":"<p>This is the basic step-by-step workflow on how to get the animation into the game.</p> <ol> <li>Load the actor (character or object) into your 3D software</li> <li>Create your animation</li> <li>Export the animation as an <code>.asc</code> file</li> <li>Write the MDS file</li> <li>Run the game to compile your animations</li> <li>Test your animations in-game using a Daedalus script or a console command</li> </ol> <p>Sounds simple enough, except there is a lot missing. Even though the steps start with loading the actor into blender, understanding the system of animations to get high quality assets into your mod is more important.</p>"},{"location":"zengin/anims/#animation-types","title":"Animation \"types\"","text":"<p>There are two main types of animations - <code>skeletal</code> and <code>morphmesh</code> animations. Character body animations are skeletal, and we animate the skeleton and the entire model (skin) moves around it. Morph mesh animation is, on the other hand, used for facial animations such as eating, blinking or talking and for animated meshes like wave water ferns or fish in Khorinis' harbor.</p> <p>This guide focuses on skeletal animations. There are few different ones, all of which will have their own demonstration in the future. Categories are:</p> <ol> <li>Standalone animation - waving, bowing, eating</li> <li>MOBSI animations - bed, alchemy table, anvil</li> <li>Item animations - sweeping the floor with a broomstick, using the horn, playing the lute</li> <li>Mandatory animations - running, walking, sneaking</li> <li>Combined/interpolated animations - picking stuff up, aiming with a bow/crossbow</li> </ol> <p>All of these animations are defined in an MDS file which will be talked about in the next sections.</p>"},{"location":"zengin/anims/events/","title":"Events","text":"<p>Acknowledgment</p> <p>This tutorial was possible thanks to Kerrax, VAM and their excelent articles (MDS, EventTags) and Avallach from theModders who provided valuable insight.</p>"},{"location":"zengin/anims/events/#animation-event-block-overview","title":"Animation event block overview","text":"<p>We often need to perform some other actions together with our animation, such as playing a sound effect, inserting item into NPC's hand or changing an item instance into a different one, like turning a raw steel into hot raw steel. These actions often need to be done at very specific moment during the animation playback, therefore they are defined using events(#aniamtion-events) in the event block which follows right after the animation definition. The event block is started and closed by curly brackets.</p> <p>Example: </p><pre><code>ani (\"s_RunL\" 1 \"s_RunL\" 0.0 0.1 M. \"Hum_RunLoop_M01.asc\" F 12 31) // animation\n{ // event block start\n*eventSFXGrnd    (12    \"Run\") // animation event\n*eventSFXGrnd    (24    \"Run\") // animation event\n...\n*eventSFXGrnd    (30    \"Run\") // animation event\n} // event block end\n</code></pre> <p>Warning</p> <p>Each animation can define a maximum of 16 events. Should you need more, split the animation into parts and use <code>next_ani</code> to chain them together.</p>"},{"location":"zengin/anims/events/#animation-events","title":"Animation events","text":"<p>Animation events are commands telling engine to do something. Event <code>*eventSFXGrnd(12 \"Run\")</code> will command the engine to play sound <code>Run</code> at the very moment (12th frame) the character lands food on the ground. So with that in mind here is the general syntax as well as each animation event in the game.</p> <p>General Syntax: </p><pre><code>    *EVENTNAME (FRAME KEYWORD \"INSTANCE\" [OPTIONAL] [A:VALUE] [B:VALUE])\n</code></pre> <p><code>FRAME</code> - all events specify on what frame int the animation source file <code>.ASC</code> should this event happen</p> <p><code>KEYWORD</code> - some events expect very specific keywords.</p> <p><code>\"INSTANCE\"</code> - this indicates parameter is expected to be inside quotes, usually it;s slot/bone or item/sound instance name from the scrips</p> <p><code>[OPTIONAL]</code> - this is an example of the optional parameter. Optional parameters will be indicated by brackets <code>[]</code>, if you don't specify them, the event will use the default value defined by the engine. </p> <p><code>A:VALUE</code> - some events that have  more than one optional parameter use a prefix to know which was specified</p> <p><code>NODE_NAME</code> - will indicate any <code>NODE</code> should work, be it bones (<code>BIP01</code>...) or <code>ZS_</code> slots (<code>ZS_RIGHTHAND</code>) </p> <p><code>SLOT</code> - this will indicate most likely only <code>ZS_</code> slots will work.</p> <p>Warning</p> <p>Events should follow in ascending order by the frame they appear on. i. e. <code>*eventTag(1 ...)</code> must come before <code>*eventTag(2 ...)</code> </p> Event Description eventCamTremor camera shake eventMMStartAni start morph-mesh eventPFX create particle effect eventPFXStop destroy particle effect eventSwapMesh exchange item meshes between two slots eventSFX create sound effect eventSFXGRND create sound effect on the ground eventTag generic event, does action specified in parameters Defined in engine but never used ? eventPFXGRND creats particle effect on the ground eventSetMesh ? modelTag same as eventTag, but applies to morphmesh?"},{"location":"zengin/anims/events/#eventcamtremor","title":"eventCamTremor","text":"<p>Earthquake effect (camera shake)</p> <p>Example: </p><pre><code>*eventCamTremor (12 1000    500   2  8 )\n</code></pre> <p>Syntax: </p><pre><code>*eventCamTremor (FRAME RANGE DURATION MIN_AMPLIFIER MAX_AMPLIFIER)\n</code></pre> <p><code>eventCamTremor</code> - is a keyword, for camera shake event</p> <p>Let's describe all the parameters</p> <p><code>FRAME</code>             - animation frame at which this event starts </p> <p><code>RANGE</code>             - range from which the effect will be 'felt' defined in in-game centimeters (1000 is 10 meters in-game)</p> <p><code>DURATION</code>          - duration of the effect in milliseconds</p> <p><code>MIN_AMPLIFIER</code>     - minimum amount of shaking in in-game centimeters</p> <p><code>MAX_AMPLIFIER</code>     - the maximum amount of shaking.</p>"},{"location":"zengin/anims/events/#eventmmstartani","title":"eventMMStartAni","text":"<p>Start the animation of the morph-mesh that is attached to the specified node. Mostly used to start NPC facial animations or to animate bows/crossbows shooting.</p> <p>Example: </p><pre><code>*eventMMStartAni    (14 \"T_HURT\")\n*eventMMStartAni    (6  \"S_SHOOT\"   \"ZS_RIGHTHAND\")\n*eventMMStartAni    (6  \"S_BOOK_NEXT_PAGE\"  \"ZS_RIGHTHAND\" I:0.5 H:5)\n</code></pre> <p>Syntax: </p><pre><code>*eventMMStartAni (FRAME \"ANI_NAME\" [\"NODE_NAME\"] [I:INTENSITY] [H:HOLD_TIME])\n</code></pre> <p><code>FRAME</code>             - animation frame at which animation should start </p> <p><code>ANI_NAME</code>          - name of the morph-mesh animation (specified in .MMS) file</p> <p><code>NODE_NAME</code>         - node in the hierarchy, to which morph mesh is attached. If not specified, a default value of <code>BIP01 HEAD</code> will be used. </p> <p><code>I:INTENSITY</code>       - float value to specify blending of morph animation with the current one ?</p> <p><code>H:HOLD_TIME</code>       - time in seconds, how long will the animation \"stay\"</p> <p>Both <code>INTENSITY</code> and <code>HOLD_TIME</code> can be specified in the MMS script. All gothic morph meshes specify those values in .MMS, therefore behavior when both specified in eventMMStartAni and .MMS file is unknown/untested</p>"},{"location":"zengin/anims/events/#eventpfx","title":"eventPfx","text":"<p>Start particle effect at the specified bone. </p> <p>Example: </p><pre><code>*eventPFX   (12     \"ZMODELLANDDUST\"    \"Bip01\" )\n*eventPFX   (2  1   \"DEMON_ATTACK\"      \"BIP01 R HAND\"  ATTACH)\n</code></pre> <p>Syntax: </p><pre><code>*eventPFX (FRAME [PFX_HANDLE] \"PFX_NAME\" \"NODE_NAME\" [ATTACH])\n</code></pre> <p><code>FRAME</code>             - animation frame at which particle effect starts</p> <p><code>PFX_NAME</code>          - name of the PFX instance</p> <p><code>PFX_HANDLE</code>        - an optional integer value. Specifying this creates a 'handle' and allows stop the PFX later using eventPFXStop</p> <p><code>NODE_NAME</code>         - node in the hierarchy. particle effect will be spawned at the node's position. If not specified, a default value of <code>BIP01</code> will be used.</p> <p><code>ATTACH</code>             - keyword, including this keyword, will make particle effect follow the node specified, otherwise, it will stay where it spawned. </p> <p>Tip</p> <p><code>ATTACH</code> is used to create demons burning hand during the attack, while without this keyword dust particles are made to stay at the position where NPC landed after falling.</p>"},{"location":"zengin/anims/events/#eventpfxstop","title":"eventPFXStop","text":"<p>Stops particle effect previously started by eventPfx</p> <p>Example: </p><pre><code>*eventPFX       (2  1   \"DEMON_ATTACK\"      \"BIP01 R HAND\"  ATTACH) // starts pfx with handle 1\n...\n*eventPFXStop   (70 1) // stops pfx started above\n</code></pre> <p>Syntax: </p><pre><code>*eventPFXStop (FRAME PFX_HANDLE)\n</code></pre> <p><code>FRAME</code>             - animation frame at which particle effect should disappear</p> <p><code>PFX_HANDLE</code>        - an integer value. Handle of the particle effect, that should be destroyed. Particle effect must be spawned using the same handle by eventPfx first</p>"},{"location":"zengin/anims/events/#eventswapmesh","title":"eventSwapMesh","text":"<p>Move mesh from source <code>NODE</code> to target node.  Item should be present in the node already. Only mesh of the Items is moved, engine internally still keeps a reference to items in the original slot? Never used in game?</p> <p>Example: </p><pre><code>*eventSwapMesh (5 \"ZS_CROSSBOW\" \"ZS_LEFTARM\")\n</code></pre> <p>Syntax: </p><pre><code>*eventSWAPMESH      (FRAME \"SOURCE_NODE_NAME\" \"TARGET_NODE_NAME\")\n</code></pre> <p><code>FRAME</code>             - animation frame at which transport of the mesh should happen</p> <p><code>SOURCE_NODE_NAME</code>        - source node containing the item.</p> <p><code>TARGET_NODE_NAME</code>        - target node that the item should be moved to.</p> <p>Note</p> <p>In some rare occasions duplicates item </p>"},{"location":"zengin/anims/events/#eventsfx","title":"eventSfx","text":"<p>Play sound effect. It can be either <code>SFX</code> instance from scripts, or <code>.WAV</code> file.</p> <p>Example: </p><pre><code>*eventSFX   (0  \"Drown\")\n*eventSFX   (8  \"WHOOSH\"    EMPTY_SLOT)\n*eventSFX   (8  \"BAB_SIGH\" R:5000   EMPTY_SLOT)   </code></pre> <p>Syntax: </p><pre><code>*eventPFX (FRAME \"SFX_NAME\" [R:RANGE] [EMPTY_SLOT])\n</code></pre> <p><code>FRAME</code>             - animation frame at which particle effect starts</p> <p><code>SFX_NAME</code>          - name of the SFX instance or <code>.WAV</code> file</p> <p><code>R:RANGE</code>        - an optional integer value. The range from which the effect will be 'heard' defined in in-game centimeters (1000 is 10 meters in-game)</p> <p><code>[EMPTY_SLOT]</code>         - optional keyword. By default audio effects use a single audio channel (slot) per Model. That means every <code>eventSFX</code> request will cancel any currently playing effect. If <code>EMPTY_SLOT</code> is specified, audio will be played on the next available (empty) audio slot and other sounds will not be interrupted.</p> <p>Note</p> <p>A lot of original game animations contain <code>EMTPY_SLOT</code> instead of <code>EMPTY_SLOT</code> which was probably unintended. Gothic therefore acts as no keyword was provided, which causes a lot of sound interruptions. Therefore be mindful of spelling when copying original MDS scripts</p>"},{"location":"zengin/anims/events/#eventsfxgrnd","title":"eventSfxGrnd","text":"<p>the same as eventSfx with only one difference, the sound effect name is appended with the current material name.</p> <p>Example: </p><pre><code>*eventSFXGrnd (12 \"Run\")\n</code></pre> <p>Syntax: </p><pre><code>*eventSFXGrnd (FRAME \"SFX_NAME\" [R:RANGE] [EMPTY_SLOT])\n</code></pre> <p>Depending on the material of the texture, the character is standing on, the game will add one of the following suffixes:</p> Spacer Material Suffix Gothic 1 Gothic 2a <code>UNDEF</code> _Undef \u2714\ufe0f \u2714\ufe0f <code>EARTH</code> _Earth \u2714\ufe0f \u2714\ufe0f <code>SAND</code> _Sand \u2714\ufe0f \u2714\ufe0f <code>METAL</code> _Metal \u2714\ufe0f \u2714\ufe0f <code>WATER</code> _Water \u2714\ufe0f \u2714\ufe0f <code>WOOD</code> _Wood \u2714\ufe0f \u2714\ufe0f <code>SNOW</code> _Snow \u274c \u2714\ufe0f <code>STONE</code> _Stone \u2714\ufe0f \u2714\ufe0f default _Stone \u2714\ufe0f \u2714\ufe0f <p>NPC running on grass texture, with material set to EARTH in world editor,  will play sound <code>Run_Earth</code> by using <code>*eventSFXGrnd (12 \"Run\")</code> in run animation. <code>_Earh</code> suffix is determined and added by the engine.</p>"},{"location":"zengin/anims/events/#eventtag","title":"eventTag","text":"<p>This is a generic type of event that does different actions based on the first parameter after the frame parameter. It was probably later in development to extend MDS functionality without the need to expand parser itself. All parameters except <code>FRAME</code> are passed inside quotes Further parameters are specific for every <code>EVENT_TAG_TYPE</code>. </p> <p>Waning</p> <p>eventTag contrary to other events is validated only at runtime. If parameters are wrong, it won't work or might crash the game</p> <p>Syntax: </p><pre><code>*eventTag (FRAME \"EVENT_TAG_TYPE\" \"PARAMETER_1\"  \"PARAMETER_2\" ... \"PARAMETER_N\")\n</code></pre> <p><code>FRAME</code> - Frame at which the event will execute. This parameter is always first and the same for all <code>eventTags</code></p> <p><code>EVENT_TAG_TYPE</code> - a type of event = action that should happen. </p> <p>Here is a list of event tag types:</p> EVENT TAG TYPE Description DEF_CREATE_ITEM Creates item into slot DEF_INSERT_ITEM Inserts item to slot from inventory DEF_REMOVE_ITEM Removes item from slot to inventory DEF_DESTROY_ITEM Destroys item in slot DEF_PLACE_ITEM ~~Places item from slot into mob slot~~  Destroys item in slot DEF_EXCHANGE_ITEM Removes item in slot and replaces with new item DEF_FIGHTMODE Sets npc into weapon stance DEF_PLACE_MUNITION Inserts munition into slot DEF_REMOVE_MUNITION Remove munition back to inventory DEF_DRAWSOUND Plays weapon drawing sound based on weapon material DEF_UNDRAWSOUND Plays weapon sheating sound based on weapon material DEF_SWAPMESH Moves items visual to different slot visually DEF_DRAWTORCH Inserts torch DEF_INV_TORCH Moves torch to different slot temporarily DEF_DROP_TORCH Drops torch from slot to world DEF_HIT_LIMB Defines node which deals damage DEF_DIR Defines attack direction DEF_DAM_MULTIPLIER Defines damage mutliplier DEF_PAR_FRAME Defines frame range for blocking DEF_OPT_FRAME Defines damage frames DEF_HIT_END Defines last frame to continue combo DEF_WINDOW Defines frame for combo continuation"},{"location":"zengin/anims/events/#def_create_item","title":"DEF_CREATE_ITEM","text":"<p>Creates a new item instance and inserts it into the specified slot. Item is not inserted permanently but only for the duration of interaction. </p> <p>Example: </p><pre><code>*eventTag    (4    \"DEF_CREATE_ITEM\"    \"ZS_RIGHTHAND\"    \"ItMw_1H_Mace_L_04\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_CREATE_ITEM\" \"SLOT\" \"ITEM_INSTANCE\")\n</code></pre> <p><code>SLOT</code>         - a name of the <code>ZS_</code> slot, write in UPPERCASE</p> <p><code>ITEM_INSTANCE</code>     - item instance from the scripts</p> <p>Warning</p> <p>This event tag most likely works only during Mob/Item interaction</p>"},{"location":"zengin/anims/events/#def_insert_item","title":"DEF_INSERT_ITEM","text":"<p>Insert the interaction item into the specified slot. </p> <ul> <li>during mob interaction, inserted item instance is of instance taken from UseWithItem mob property.</li> <li>during item interation (i.e. drink potion) item that started the SceneName will be inserted. </li> </ul> <p>In the example below: <code>(1)</code> inserts <code>ItMiSwordrawhot</code> that is defined in spacer into <code>ZS_LEFTHAND</code>, then <code>(2)</code> spawns <code>ItMw_1H_Mace_L_04</code> (hammer) into <code>ZS_RIGHTHAND</code> for anvil interaction.</p> <p>Example: </p><pre><code>ani    (\"t_BSANVIL_S0_2_S1\"    1    \"s_BSANVIL_S1\"    0.0    0.0    M.    \"Hum_BSAnvil_Jue00.asc\"    F    4    9)\n{\n*eventTag    (4    \"DEF_INSERT_ITEM\"    \"ZS_LEFTHAND\")    // (1)\n*eventTag    (4    \"DEF_CREATE_ITEM\"    \"ZS_RIGHTHAND\"    \"ItMw_1H_Mace_L_04\")    // (2)\n}\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_INSERT_ITEM\" \"SLOT\")\n</code></pre> <p><code>SLOT</code>         - a name of the <code>ZS_</code> slot, use UPPERCASE</p> <p><code>ITEM_INSTANCE</code>     - item instance from the scripts</p> <p>Warning</p> <p>This event tag most likely works only during Mob/Item interaction</p> <p>The well-known Gothic bug: </p> <p>If player gets hit while drinking a potion, the effect of the potion is applied, but the potion remains in the inventory - the reason for the bug is that the potion item is inserted into hand using  <code>DEF_INSERT_ITEM</code> and would be removed from the world at the end of the drinking animation, while the potion's effect (a script function that increases stats) is applied at the very beginning of the animation. When the player is hit, the drinking animation is interrupted, and the engine does not remove the item from the world.</p>"},{"location":"zengin/anims/events/#def_remove_item","title":"DEF_REMOVE_ITEM","text":"<p>Remove an item inserted into a slot via <code>DEF_INSERT_ITEM</code> from the slot back into the inventory. </p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_REMOVE_ITEM\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_REMOVE_ITEM\")\n</code></pre> <p>Warning</p> <p>This event tag most likely works only during Mob/Item interaction</p>"},{"location":"zengin/anims/events/#def_destroy_item","title":"DEF_DESTROY_ITEM","text":"<p>Destroys an item inserted into a slot via <code>DEF_INSERT_ITEM</code>. The item is removed from the world.</p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_DESTROY_ITEM\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_DESTROY_ITEM\")\n</code></pre> <p>Warning</p> <p>This event tag most likely works only during Mob/Item interaction</p>"},{"location":"zengin/anims/events/#def_place_item","title":"DEF_PLACE_ITEM","text":"<p>Remove the item inserted via eventTag <code>DEF_INSERT_ITEM</code> from the slot and the world. In terms of its action, eventTag <code>DEF_PLACE_ITEM</code> is a synonym for <code>DEF_DESTROY_ITEM</code>.  Possibly fixed by SystemPack. See intended use.</p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_PLACE_ITEM\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_PLACE_ITEM\")\n</code></pre> <p>Warning</p> <p>This event tag most likely works only during Mob/Item interaction</p> Intended use <p>Presumably, the eventTag <code>DEF_PLACE_ITEM</code> was intended to have different behavior: If an NPC interacts with a MOB that has a <code>ZS_SLOT</code> node, then move the item inserted via <code>DEF_INSERT_ITEM</code> from the NPC node into the <code>ZS_SLOT</code> node on the MOB. An example would be orc priest hearts in the Temple of the Sleeper, Gothic 1.</p> <pre><code>// Sleeper Portal\nani (\"t_SPORTAL_Stand_2_S0\"     1    \"s_SPORTAL_S0\"     0.0    0.0    M.    \"Hum_SleeperPortal_M01.asc\"    F    0    19)\nani (\"s_SPORTAL_S0\"             1    \"s_SPORTAL_S0\"     0.0    0.0    M.    \"Hum_SleeperPortal_M01.asc\"    F    20    20)\nani (\"t_SPORTAL_S0_2_Stand\"     1    \"\"                 0.0    0.2    M.    \"Hum_SleeperPortal_M01.asc\"    R    0    19)\nani (\"t_SPORTAL_S0_2_S1\"        1    \"s_SPORTAL_S1\"     0.0    0.0    M.    \"Hum_SleeperPortal_M01.asc\"    F    21    90    FPS:10)\n{\n*eventTag    (60    \"DEF_INSERT_ITEM\"    \"ZS_RIGHTHAND\")    // (1)\n*eventTag    (90    \"DEF_PLACE_ITEM\")    // (2)\n}\nani (\"s_SPORTAL_S1\"             1    \"s_SPORTAL_S1\"     0.0    0.0    M.    \"Hum_SleeperPortal_M01.asc\"    F    91    91)\nani (\"t_SPORTAL_S1_2_Stand\"     1    \"\"                 0.0    0.2    M.    \"Hum_SleeperPortal_M01.asc\"    F    90    100)\n</code></pre> <p>During animation on 60th frame,<code>(1)</code> inserts orc priest sword from the inventory, and <code>(2)</code> on 90th frame, presumably, should have left the sword inserted into the heart sticking out. There is <code>ZS_SLOT</code> present to indicate the location of the sword after insertion into the heart.</p> <p>In reality, <code>(2)</code> simply removes the sword from the world like <code>DEF_DESTROY_ITEM</code>. This was most likely an unrealized idea. In G2, eventTag <code>DEF_PLACE_ITEM</code> is not used.  </p>"},{"location":"zengin/anims/events/#def_exchange_item","title":"DEF_EXCHANGE_ITEM","text":"<p>Replace an item in a slot with another item. Item present in the slot is removed from the slot and the world, new item specified in parameters is created and inserted in the same slot.</p> <p>Example: </p><pre><code>*eventTag (37 \"DEF_EXCHANGE_ITEM\" \"ZS_LEFTHAND\" \"ItMiSwordrawhot\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_EXCHANGE_ITEM\" \"SLOT\" \"ITEM_INSTANCE\")\n</code></pre> <p><code>SLOT</code>         - a name of the <code>ZS_</code> slot, use UPPERCASE</p> <p><code>ITEM_INSTANCE</code>     - item instance from the scripts</p> <p>Warning</p> <p>This event tag most likely works only during Mob/Item interaction</p>"},{"location":"zengin/anims/events/#def_fightmode","title":"DEF_FIGHTMODE","text":"<p>Set fight mode for the model. Used in transition animations to weapon stances like <code>t_1h_2_1hRun</code>.</p> <p>Example: </p><pre><code>*eventTag (5 \"DEF_FIGHTMODE\" \"FIST\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_FIGHTMODE\" \"FIGHT_MODE\")\n</code></pre> <p><code>FIGHT_MODE</code> - fight modes are defined in the engine and can be one of the following:</p> <ul> <li><code>\"\"</code> - remove weapon</li> <li><code>\"FIST\"</code> - fists</li> <li><code>\"1H\"</code> or <code>\"1HS\"</code> - one-handed weapon</li> <li><code>\"2H\"</code> or <code>\"2HS\"</code> - two-handed weapon</li> <li><code>\"BOW\"</code> - bow</li> <li><code>\"CBOW\"</code> - crossbow</li> <li><code>\"MAG\"</code> - magic</li> </ul> <p>Example: Parameter <code>1H</code> sets fight mode for the actor (in the engine), but also exchanges sword from <code>ZS_SWORD</code> slot to the <code>ZS_RIGHTHAND</code></p>"},{"location":"zengin/anims/events/#def_place_munition","title":"DEF_PLACE_MUNITION","text":"<p>Place ammunition, from inventory such as an arrow into the specified slot. Used in reloading animations after a bow/crossbow shot.</p> <p>Example: </p><pre><code>*eventTag (9 \"DEF_PLACE_MUNITION\" \"ZS_RIGHTHAND\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_PLACE_MUNITION\" \"SLOT\")\n</code></pre> <p><code>SLOT</code>         - slot where the ammunition is created. There are only two valid slot names: <code>\"ZS_LEFTHAND\"</code> and <code>\"ZS_RIGHTHAND\"</code>.</p> <p>Ammunition always corresponds to the equipped ranged weapon instance and its <code>munition</code> field in the <code>C_ITEM</code> instance</p> <pre><code>instance ItRw_Sld_Bow(C_Item)\n{\nname = \"\u041b\u0443\u043a\";\nmainflag = ITEM_KAT_FF;\nflags = ITEM_BOW;\nmaterial = MAT_WOOD;\nvalue = Value_SldBogen;\ndamageTotal = Damage_SldBogen;\ndamagetype = DAM_POINT;\nmunition = ItRw_Arrow;\ncond_atr[2] = ATR_DEXTERITY;\ncond_value[2] = Condition_SldBogen;\nvisual = \"ItRw_Sld_Bow.mms\";\ndescription = name;\ntext[2] = NAME_Damage;\ncount[2] = damageTotal;\ntext[3] = NAME_Dex_needed;\ncount[3] = cond_value[2];\ntext[5] = NAME_Value;\ncount[5] = value;\n};\n</code></pre>"},{"location":"zengin/anims/events/#def_remove_munition","title":"DEF_REMOVE_MUNITION","text":"<p>Remove ammunition previously placed by DEF_PLACE_MUNITION event</p> <p>Example: </p><pre><code>*eventTag (19 \"DEF_REMOVE_MUNITION\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_REMOVE_MUNITION\")\n</code></pre>"},{"location":"zengin/anims/events/#def_drawsound","title":"DEF_DRAWSOUND","text":"<p>Play weapon drawing sound. Determined by drawn weapon <code>material</code> field in the <code>C_ITEM</code> instance</p> <ul> <li><code>\u201cDrawSound_WO.wav\u201d</code> - for MAT_WOOD;</li> <li><code>\"DrawSound_ME.wav\"</code> - for MAT_METAL.</li> </ul> <p>Example: </p><pre><code>*eventTag (19 \"DEF_DRAWSOUND\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_DRAWSOUND\")\n</code></pre>"},{"location":"zengin/anims/events/#def_undrawsound","title":"DEF_UNDRAWSOUND","text":"<p>Play weapon sheathing sound. Determined by drawn weapon <code>material</code> field in the <code>C_ITEM</code> instance</p> <ul> <li><code>\"UndrawSound_WO.wav\u201d</code> - for MAT_WOOD;</li> <li><code>\"UndrawSound_ME.wav\"</code> - for MAT_METAL.</li> </ul> <p>Example: </p><pre><code>*eventTag (19 \"DEF_UNDRAWSOUND\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_UNDRAWSOUND\")\n</code></pre>"},{"location":"zengin/anims/events/#def_swapmesh","title":"DEF_SWAPMESH","text":"<p>Swap items in the specified slots.</p> <p>Example: </p><pre><code>*eventTag (5 \"DEF_SWAPMESH\" \"ZS_CROSSBOW\" \"ZS_LEFTHAND\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_SWAPMESH\" \"SLOT1\" \"SLOT2\")\n</code></pre> <p><code>SLOT1</code> - name of the slot with item to be exchanged.</p> <p><code>SLOT2</code> - name of the slot with item to be exchanged. </p> <p>Warning</p> <p>In case <code>SLOT1</code> or <code>SLOT2</code> is equal to <code>\"ZS_LEFTHAND\"</code> or <code>\"ZS_RIGHTHAND\"</code>, the engine will attempt to put the model into fight mode similar to DEF_FIGHTMODE event. This can lead to game freezing.</p> <p>Tip</p> <p>This event is similar to the *eventSwapMesh. The main difference is *eventSwapMesh will swap only visuals (meshes) of the items, while eventTag DEF_SWAPMESH will swap items and their slot references. After a game reload, meshes would reset their positions if swapped using *eventSwapMesh. Additionally *eventSwapMesh does not try to set the model into fight mode.</p>"},{"location":"zengin/anims/events/#def_drawtorch","title":"DEF_DRAWTORCH","text":"<p>Does nothing? never used.</p> <p>Example: </p><pre><code>*eventTag (5 \"DEF_DRAWTORCH\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_DRAWTORCH\")\n</code></pre>"},{"location":"zengin/anims/events/#def_inv_torch","title":"DEF_INV_TORCH","text":"<p>Temporarily return torch into inventory, for the duration of mob/item interaction. Does nothing if a torch is not present in <code>ZS_LEFTHAND</code>. Used before interacting with mobs like bed, or before performing eating animations that require a left hand.</p> <p>Example: </p><pre><code>*eventTag (5 \"DEF_INV_TORCH\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_INV_TORCH\")\n</code></pre>"},{"location":"zengin/anims/events/#def_drop_torch","title":"DEF_DROP_TORCH","text":"<p>Drop the torch onto the ground if present in <code>ZS_LEFTHAND</code>.</p> <p>Example: </p><pre><code>*eventTag (5 \"DEF_DROP_TORCH\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_DROP_TORCH\")\n</code></pre>"},{"location":"zengin/anims/events/#def_hit_limb","title":"DEF_HIT_LIMB","text":"<p>Set which node is dealing damage to others. This node is then used in calculations for collisions. Up to four slots can be specified.</p> <p>Example: </p><pre><code>// humans - fist attacks\n*eventTag (0     \"DEF_HIT_LIMB\"     \"BIP01 R HAND\")\n// humans - sword attacks\n*eventTag (0 \"DEF_HIT_LIMB\" \"ZS_RIGHTHAND\")\n// animals \neventTag (0 \"DEF_HIT_LIMB\"    \"BIP01 HEAD\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_HIT_LIMB\" \"SLOT1\" \"SLOT2\" \"SLOT3\" \"SLOT4\")\n</code></pre>"},{"location":"zengin/anims/events/#def_dir","title":"DEF_DIR","text":"<p>Set the direction of the attack. Enemy block animation is determined by this information. Not used.</p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_DIR\"  \"O\")\n*eventTag (0 \"DEF_DIR\"  \"L\")\n*eventTag (0 \"DEF_DIR\"  \"OUOL\") // combo attack - top, under, \n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_DIR\" \"DIRECTIONS\")\n</code></pre> <p><code>DIRECTIONS</code> - can be up to 10 characters, each character defines one attack direction during combo attack, default is <code>O</code> - capital letter <code>O</code>, not zero <code>0</code>. Possible values are</p> <ul> <li> <p><code>O</code> - (oben) from top/ over</p> </li> <li> <p><code>U</code> - (unter) from under</p> </li> <li> <p><code>R</code> - from right</p> </li> <li> <p><code>L</code> - from left</p> </li> </ul> <p>If the enemy is trying to block an attack with a defined direction it will choose a matching animation adding a direction suffix like <code>t_1hParade_U</code> for opponent's attack direction <code>U</code></p> <p>Note</p> <p>Sadly this feature was unused in Gothic 1. All attacks use <code>O</code> direction and only defined animations for blocking are for said <code>t_1hParade_O</code> But can be easily restored with a few new animations and MDS file edits. In Gothic 2, blocking animation uses zero <code>0</code> instead of <code>O</code> which might indicate the feature no longer works.</p>"},{"location":"zengin/anims/events/#def_dam_multiplier","title":"DEF_DAM_MULTIPLIER","text":"<p>Set damage multiplier. For the attack animation. The damage will be multiplied by a provided number regardless of whether the attack is a critical attack or not.</p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_DAM_MULTIPLIER\"    \"0.2\")\n*eventTag (0 \"DEF_DAM_MULTIPLIER\"    \"2.0\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_DAM_MULTIPLIER\" \"MULTIPLIER\")\n</code></pre> <p><code>MULTIPLIER</code> - float value inside quotes </p>"},{"location":"zengin/anims/events/#def_par_frame","title":"DEF_PAR_FRAME","text":"<p>Set frame range during which damage is blocked. If not provided whole animation is blocking damage.</p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_PAR_FRAME\"    \"1 8\")\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_PAR_FRAME\" \"START_FRAME_END_FRAME\")\n</code></pre> <p><code>START_FRAME_END_FRAME</code> - Two integer numbers inside quotes. if <code>\"0 0\"</code> is provided, the animation will be blocking it's whole duration</p>"},{"location":"zengin/anims/events/#def_opt_frame","title":"DEF_OPT_FRAME","text":"<p>Set frames during which damage collisions should be evaluated. Damage is checked for collision with \"hit limb\". This event usually comes in pair with eventTags DEF_WINDOW and DEF_HIT_END</p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_OPT_FRAME\" \"6\") // on hit attack, hit on 6th frame\n*eventTag (0 \"DEF_OPT_FRAME\"  \"6 30\") // 2 attack combo, hit at 6th and 30th frame\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_OPT_FRAME\" \"HIT_FRAME1 HIT_FRAME2 ... HIT_FRAME10\")\n</code></pre> <p><code>HIT_FRAME1 HIT_FRAME2 ... HIT_FRAME10</code> - specify 1 and up to 10 integers separated by space inside quotes. Each number represents frame at which damage should be done. Number of provided hit frames determines number of combos (max 10 possible).</p>"},{"location":"zengin/anims/events/#def_hit_end","title":"DEF_HIT_END","text":"<p>Set frames at which the combo is \u201ccut off\u201d if you do not press the \u201cup\u201d key (G1) or the left mouse button (G2) during the attack. Gothic has bug that in this case we will hear all the sound effects following this frame, and the animation ends with the character\u2019s characteristic twitching. The number of frames specified in this entry must match the number of frames of the eventTag DEF_OPT_FRAME. </p> <p>Example: </p><pre><code>*eventTag (0  \"DEF_HIT_END\"   \"32\") *eventTag (0  \"DEF_HIT_END\"   \"27 48 75\")      </code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_HIT_END\" \"HIT_END1 HIT_END2 ... HIT_END10\")\n</code></pre> <p><code>HIT_END1 HIT_END2 ... HIT_END10</code> - specify 1 and up to 10 integers separated by space inside quotes. After this frame combo cannot be continued and model will continue animation until the current <code>DEF_WINDOW -</code> 1`. Which is usually animation returning to idle stance</p>"},{"location":"zengin/anims/events/#def_window","title":"DEF_WINDOW","text":"<p>Set a \u201cwindow\u201d in the animation - an interval of frames during which you need to press the \u201cup\u201d (G1) or the left mouse button (G2) to continue the combo strike.</p> <p>Example: </p><pre><code>*eventTag (0 \"DEF_WINDOW\"    \"9 19\") // one combo with window from 9-19 (can be chained)\n*eventTag (0  \"DEF_WINDOW\"    \"10 23 32 41 58 70\") // 3 combos with windows 10-23 then 32-41, 58-70\n</code></pre> <p>Syntax: </p><pre><code>*eventTag (FRAME \"DEF_WINDOW\" \"HIT_1_WINDOW_START HIT_1_WINDOW_END HIT_2_WINDOW_START HIT_2_WINDOW_END  ...\")\n</code></pre> <p><code>HIT_1_WINDOW_START HIT_1_WINDOW_END HIT_2_WINDOW_START HIT_2_WINDOW_END</code> - specify 1 and up to 20? integers separated by space inside quotes. A window consists of a start and end frame, therefore for each DEF_OPT_FRAME, you must provide 2 numbers.</p> <ul> <li><code>HIT_WINDOW_START</code> - First value of the pair defines frame from which attack can continue.</li> <li><code>HIT_WINDOW_END</code> - Second value is a little confusing. It defines START of the next attack animation. Ability to continue combo stops at DEF_HIT_END frames. Usually there are few frames of animation, where characters returns to idle position. <code>HIT_WINDOW_END</code> should be one frame after characters return to idle stance, which should also be first frame of the next attack</li> </ul>"},{"location":"zengin/anims/events/#attack-eventtags-explained","title":"Attack eventTags explained","text":"<p>This is original attack combo from Gothic 1</p> <pre><code>ani (\"s_1hAttack\"   1   \"s_1hAttack\"    0.0 0.1 M.  \"Hum_1hAttackComboT3_M05.asc\"   F   1   114)\n{\n*eventTag       (0 \"DEF_HIT_LIMB\"   \"ZS_RIGHTHAND\")\n*eventTag       (0 \"DEF_OPT_FRAME\"  \"4 36 73 107\") *eventTag       (0 \"DEF_HIT_END\"    \"31 63 95 113\")\n*eventTag       (0 \"DEF_WINDOW\"     \"10 33 42 65 78 97 110 113\")\n*eventSFX       (4  \"Whoosh\"    EMPTY_SLOT  )\n*eventSFX       (72 \"BACK\"  EMPTY_SLOT  )\n}\n</code></pre> <p>I will edit it slightly to make it more readable. Let's focus on the DEF_OPT_FRAME, DEF_HIT_END, </p> <pre><code>ani (\"s_1hAttack\"   1   \"s_1hAttack\"    0.0 0.1 M.  \"Hum_1hAttackComboT3_M05.asc\"   F   1   114)\n{\n...\n*eventTag       (0 \"DEF_OPT_FRAME\"  \"4         36         73         107         \") *eventTag       (0 \"DEF_HIT_END\"    \"      31         63       95             113\")\n*eventTag       (0 \"DEF_WINDOW\"     \"   10   33     42  65   78  97     110   113\")\n...\n}\n</code></pre> <p>Let's focus only on the first combo.</p> <pre><code>ani (\"s_1hAttack\"   1   \"s_1hAttack\"    0.0 0.1 M.  \"Hum_1hAttackComboT3_M05.asc\"   F   1   114)\n{\n...\n*eventTag       (0 \"DEF_OPT_FRAME\"  \"4          ...\") *eventTag       (0 \"DEF_HIT_END\"    \"      31   ...\")\n*eventTag       (0 \"DEF_WINDOW\"     \"   10   33 ...\")\n...\n}\n</code></pre> Frames Aniamtion Description 1 animation start 1..4 swing of the sword 4 sword is in the front of the model <code>DEF_OPT_FRAME</code> - test damage collisions at this frame 4..10 end of the sword swing 10 model stands ready to start next swing <code>DEF_WINDOW</code> - user can press key to advance combo from this frame. 10..31 slight idle 'shake' if player continues combo, animation playback will jump to the frame 33 (<code>DEF_WINDOW</code> second pair), from the animation perspective, next attack starts from pose similar to frame 10. If perfect inputs would be provided, animation would continue perfectly. 31 <code>DEF_HIT_END</code> - ends user input. 31..32 model returns to the idle position 32 idle position, standing with sword in hand animation will end here, if combo not continued (<code>DEF_WINDOW</code> second pair - 1) 33 first frame of the next attack (similar to frame 10) <code>DEF_WINDOW</code> second pair, start of next attack"},{"location":"zengin/anims/events/#eventpfxgrnd","title":"eventPfxGrnd","text":"<p>Not used anywhere in the original game. Could possibly spawn particle effect like eventPfx but with an added suffix similar to how eventSfxGrnd works. Needs to be investigated.</p> <p>Syntax: </p><pre><code>*eventPFXGRND (FRAME)\n</code></pre>"},{"location":"zengin/anims/events/#eventsetmesh","title":"eventSetMesh","text":"<p>Unknown</p> <p>Syntax: </p><pre><code>*eventSETMESH (FRAME \"NODE_NAME\")\n</code></pre>"},{"location":"zengin/anims/events/#modeltag","title":"modelTag","text":"<p>Should work similarly to eventTag, but can be defined inside aniEnum block and applies to all animations of the Model.</p> <p>Syntax: </p><pre><code>*modelTag (FRAME \"EVENT_TAG_TYPE\" \"PARAMETER1\" \"PARAMETER2\" \"PARAMETER3\" \"PARAMETER4\" ... )\n</code></pre>"},{"location":"zengin/anims/mds/","title":"MDS ModelScript","text":""},{"location":"zengin/anims/mds/#mds---model-animation-script","title":"MDS - model animation script","text":"<p>Tip</p> <p>The MDS syntax is very simple and scripts can be edited in any text editor. It is, however, easier to work in an editor with a proper syntax highlighting. Daedalus Language Server's dev branch already merged the MDS grammar for syntax highlighting, we can expect it in the next release.</p> <p>Model animation script is a file describing what skeleton should be used, what body meshes work with this set of animations and how should the animations be named, how fast they run, what animation is supposed to start after the current one is finished and much more. These files are located in <code>Gothic\\_work\\DATA\\Anims\\</code> directory.</p> <p>Whilst the code seems long and terrifying, it is in fact rather simple, and this guide will try to explain it whole.</p> <p>Don't forget to use the search</p> <p>If you search this file for <code>t_Yes</code>, you will get an example of the first type of animation - \"standalone\"</p> <p>To play the animation in game you use this console command <code>play ani t_yes</code>.</p> <p></p>"},{"location":"zengin/anims/mds/#syntax-and-keywords","title":"Syntax and keywords","text":"<p>Let us get a quick look at the naming convention to get a basic idea what is going on before we start.</p> <p>The first letter indicates a type of animation (transition - <code>t_</code> - or state - <code>s_</code>). Then depending on the animation type we have:</p> <p>Transition animation </p><pre><code>t_Run_2_Sneak\n</code></pre> Transition animation from the run animation to the sneak animation. <pre><code>t_BSANVIL_Stand_2_S0\n</code></pre> Transition animation for the blacksmith's anvil from standing to state 0. <p>State animation </p><pre><code>s_Run\n</code></pre> State animation for the looping animation. <pre><code>s_BSANVIL_S0\n</code></pre> State animation for the blacksmith's anvil and its first state."},{"location":"zengin/anims/mds/#ani","title":"ani","text":"<p>This is the main command you will be using while defining new animations.</p> <p>Example: </p><pre><code>ani    (\"t_Yes\" 2 \"\" 0.1 0.1 M. \"Hum_Yes_M01.asc\" F 1 44)\n</code></pre> Syntax: <pre><code>ani (ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ASC_NAME ANI_DIR START_FRAME END_FRAME)\n</code></pre> <code>ani</code> - is a keyword, we are defining new animation <p>Let's describe all the parameters</p> <p><code>ANI_NAME</code>    - animation name, we use it in Daedalus as animation identifier</p> <p>There is a naming convention, that is recommended and sometimes required to be used.</p> <ul> <li>prefix <code>t_</code> - transition animations</li> <li>prefix <code>s_</code> - state animations - they usually run in a loop</li> <li>prefix <code>c_</code> - animations used for animation combining/interpolation</li> </ul> <p><code>LAYER</code>       - layer number for multi-layer animations</p> <p><code>NEXT_ANI</code>    - name of the next animations</p> <p><code>BLEND_IN</code>    - time in seconds describing animation blending at the start</p> <p>If we set it to 0.5, it takes 0.5 seconds for this animation to take full effect. At 0.0 s the previous animation has full effect on the bones of the skeleton, at 0.1 s it is influenced by 20% by this animation and at 0.5s it is completely influenced by this animation and the previous one has no effect.</p> <p><code>BLEND_OUT</code>   - time in seconds describing animation blending at the end</p> <p><code>FLAGS</code>       - flags, that describe animation behavior</p> <ul> <li>M - specifies a movement animation, the animation of the model translates into a changed position in the game world</li> <li>R - the same as M but for rotation</li> <li>E - this flag makes this animation run only, if the animation in the same layer are finished, this is used in the movement animations. The animation <code>s_walk</code> (walking loop animation) runs, when the player is walking,when he stops the transition animation to standing state is played <code>t_walk_2_stand</code>. This animation uses the E flag to wait for the walk cycle animation to finish, to smoothly transition into the standing state.</li> <li>F - the engine ignores height coordinate - doesn't keep the model \"glued\" to the ground (falling/flying animation)</li> <li>I - specifies idle animation - breathing, standing with a drawn weapon and moving the weapon</li> </ul> <p><code>ASC_NAME</code>    - name of the source file exported from Blender</p> <p><code>ANI_DIR</code>     - direction of the animation</p> <ul> <li>F - forward</li> <li>R - reverse</li> </ul> <p><code>START_FRAME</code> - on what frame from the source file the animation starts</p> <p><code>END_FRAME</code>   - on what frame from the source file the animation ends</p>"},{"location":"zengin/anims/mds/#anialias","title":"aniAlias","text":"<p>Generally considered as one of the most useful commands, <code>aniAlias</code> is used to create an alias (hard link for UNIX users) for an already defined animation.</p> <p>Example: </p><pre><code>aniAlias (\"t_Sneak_2_Run\" 1 \"s_Run\" 0.0    0.1    M. \"t_Run_2_Sneak\" R)\n</code></pre> Syntax: <pre><code>aniAlias (ANI_NAME LAYER NEXT_ANI BLEND_IN BLEND_OUT FLAGS ALIAS_NAME ANI_DIR)\n</code></pre> <p><code>ANI_NAME</code>   - name of the new animation</p> <p><code>LAYER</code>      - layer the animation is on</p> <p><code>NEXT_ANI</code>   - name of the next animations</p> <p><code>BLEND_IN</code>   - time in seconds describing animation blending at the start</p> <p><code>BLEND_OUT</code>  - time in seconds describing animation blending at the end</p> <p><code>FLAGS</code>      - flags, that describe animation behavior</p> <p><code>ALIAS_NAME</code> - name of the animation we want to use as a source for the alias</p> <p><code>ANI_DIR</code>    - direction of the animation</p> <p>If we look for the animation in the example we can see that there is a related one just one line above </p><pre><code>ani            (\"t_Run_2_Sneak\" 1 \"s_Sneak\" 0.1 0.0 M. \"Hum_Sneak_M01.asc\"     F 0 10)\naniAlias    (\"t_Sneak_2_Run\" 1 \"s_Run\"      0.0 0.1 M. \"t_Run_2_Sneak\"      R)\n</code></pre> In this example we are defining <code>t_Sneak_2_Run</code> animation and we are specifying that the animation after this one is finished will be <code>s_Run</code> and that it is being made by reversing animation <code>t_Run_2_Sneak</code> by specifying the <code>R</code> flag."},{"location":"zengin/anims/mds/#aniblend","title":"aniBlend","text":"<p>AniBlend is used to define animations that are a result of blending of two animations. This animation is not animated by hand, but it is dynamically generated by the engine during run-time.</p> <p>Example </p><pre><code>aniBlend (\"t_RunR_2_Run\" \"s_Run\" 0.2 0.2)\n</code></pre> Syntax: <pre><code>aniBlend (ANI_NAME NEXT_ANI BLEND_IN BLEND_OUT)\n</code></pre> <p><code>ANI_NAME</code>   - name of the new animation</p> <p><code>NEXT_ANI</code>   - name of the next animations</p> <p><code>BLEND_IN</code>   - time in seconds describing animation blending at the start</p> <p><code>BLEND_OUT</code>  - time in seconds describing animation blending at the end</p>"},{"location":"zengin/anims/mds/#anisync","title":"aniSync","text":"<p>Not used in the game.</p>"},{"location":"zengin/anims/mds/#anibatch","title":"aniBatch","text":"<p>Not used in the game.</p>"},{"location":"zengin/anims/mds/#animation-state-machine","title":"Animation state machine","text":"<p>More complex animations such as MOBSI animations form a state machine - an animation set.</p> <p></p>MDS script for the big chest<pre><code>Model (\"CHESTBIG_OCCRATELARGE\")\n{\nmeshAndTree (\"CHESTBIG_OCCRATELARGE.asc\")\naniEnum\n{\n// Closed chest\nani         (\"s_S0\"                 1   \"s_S0\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"  F   20  20)\n// Opening the chest \nani         (\"t_S0_2_S1\"            1   \"s_S1\"  0.0 0.0 M.  \"CHESTBIG_USE.ASC\"  F   50  79)\n{\n*eventSFX   (50 \"chest_try\")\n*eventSFX   (55 \"chest_open\")\n}\n// Opened chest\nani         (\"s_S1\"                 1   \"s_S1\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"  F   80  80)\n// Closing the chest\nani         (\"t_S1_2_S0\"            1   \"s_S0\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"  R   50  79)\n{\n*eventSFX   (78 \"chest_close\")\n}\n// Pick lock broken\nani         (\"t_S0_Try\"             1   \"s_S0\"  0.0 0.0 M.  \"CHESTBIG_USE.asc\"          F   96  124)\n{\n*eventSFX   (100    \"chest_try\")\n*eventSFX   (115    \"Hammer\")\n}\n}\n}\n</code></pre> <pre><code>stateDiagram-v2\n    s_S0      : Closed chest\n    t_S0_2_S1 : Opening the chest\n    s_S1      : Opened chest\n    t_S1_2_S0 : Closing the chest\n    t_S0_Try  : Pick lock broken\n    [*] --&gt; s_S0\n    s_S0 --&gt; s_S0\n\n    s_S0 --&gt; t_S0_2_S1\n    t_S0_2_S1 --&gt; s_S1\n    s_S1 --&gt; s_S1\n\n    s_S1 --&gt; t_S1_2_S0\n    t_S1_2_S0 --&gt; s_S0\n\n    s_S0 --&gt; t_S0_Try\n    t_S0_Try --&gt; s_S0</code></pre>"},{"location":"zengin/anims/tutorials/standalone_animation/","title":"Standalone animation","text":""},{"location":"zengin/anims/tutorials/standalone_animation/#standalone-animation","title":"Standalone animation","text":"<p>Acknowledgment</p> <p>This tutorial would not be possible without the ZenGin documentation available in the mod-kit. Further credits also go to Mark56 who helped me understand animations in the first place, Fawkes and his request for me to do some animations for his excellent mod - Replay Mod, and last but not least Flosha from the Phoenix team who was the one for whom I offered to write this tutorial to help with the development of the Phoenix project.</p> <p>Let us start with the easiest animation - a very simple gesturing animation.</p> <p>Info</p> <p>You can find some of the videos that are mentioned in the text below in this play-list.</p> <p>Firstly we have to have the animation source files ready. Best way to decompile them is using Gothic Sourcer. In GothicSourcer you choose Tools &gt; Decompiler models &gt; Dynamic (MDS or MSB) and choose an MDS file of your choice - <code>Humans.mds</code> in our case and then click the decompile button.</p>"},{"location":"zengin/anims/tutorials/standalone_animation/#animating","title":"Animating","text":"<p>Open Blender, File &gt; Import &gt; Kerrax ASCII model (.asc), navigate to the folder with your decompiled animation files and select <code>HUM_BODY_NAKED0.ASC</code>. This file contains the skeleton and skin model for human NPCs.</p> <p>What bone hierarchy is this model using?</p> <p>If you open the <code>.mds</code> file, you can see a command <code>meshAndTree</code> that specifies what model contains the skeleton. And there lies our answer:</p> <pre><code>Model (\"HuS\")\n{\nmeshAndTree (\"Hum_Body_Naked0.ASC\" DONT_USE_MESH)\n</code></pre> <p>A windows pops up and you can read some interesting information about the model you are about to import. We are interested in the fact that Completely replace current scene is ticked, we want to use Armature modifier, and we also want to Try to connect bones and Use sample meshes from folder. You should provide a path to a directory with the sample meshes - these are meshes for items, that usually go into slot bones. Lastly, the space transformation scale should be set to 0.01. This is because ZenGin works with centimeter units and one unit in Blender is a meter.</p> <p>Click import and wait for the magic to happen.</p> <p></p> <p>This video shows a freshly imported model with all default meshes.</p> <p>Note</p> <p>If we now want to play (or edit) existing animation, we can now load it on top of this. Just as before File &gt; Import &gt; Kerrax ASCII model (.asc) and select different animation file (or armor file), for example <code>Hum_SmokeHerb_Layer_M01.asc</code> for an animation file.  </p> <p></p> <p>Gothic characters are modular and you can change their heads on the fly, even during gameplay as seen in this amazing video from my dear friend and colleague Fawkes - Head changing. Let's add a head so that we can see how the whole body will behave while we are animating. File &gt; Import &gt; Kerrax ASCII model (.asc), navigate to your head model. You will have to decompile it like we did with the body itself. We will import <code>HUM_HEAD_PONY.ASC</code>. Please make sure to select the target bone for importing Bip01 Head, this will attach the head to the proper bone, just like the engine does it.</p> <p></p> <p>Now we have everything ready to start animating. The video shows the DopeSheet a nice way to edit keyframes.</p> <p>DopeSheet</p> <p>Blender's dope sheet can be used to copy entire sets of keyframes. It is useful if we want to create a looping animation.</p> <p>We can import an animation into Blender as a base.</p> <p>Tip</p> <p>If you don't know the name of the animation, just go into the game and make your character perform the animation you want. While in MARVIN mode, you can press <code>G</code> and the animation information together with other info will be displayed right on the screen</p> <p></p> <p>In this video we can see that the idle standing animation is <code>s_run</code>. We want to make an animation that is going to start from this idle animation, so we will import it into blender. We find it by looking into the <code>.mds</code> file, look for <code>s_run</code> name and get the name of the file. </p><pre><code>ani    (\"s_Run\" 1 \"s_Run\" 0.1 0.1 MI \"Hum_RunAmbient_M01.asc\" F 1 50)  </code></pre> As we can see, we have to import the <code>Hum_RunAmbient_M01.asc</code> file. <p>Next goes the first trick. Since we want our animation to end exactly, as it started - ether because we want the hero to continue his standing animation, or we want to make a looping animation, we somehow have to copy the pose. We use the DopeSheet screen, to delete all keyframes and then copy the keyframe set from keyframe number 0 and drag it somewhere to the end of the timeline.</p> <p></p> <p>Once the animation is done, we have to export it into an <code>asc</code> format again, File &gt; Export &gt; Kerrax ASCII model (.asc) and then save it to <code>_work\\data\\Anims\\asc\\</code> so the engine can see it and convert it. There are many options here that we will explore later, but we have tick Export animation and pick bones that we want to export - this is useful for animations that are played on different layers (dialogue gestures, scratching head, scratching a shoulder,...).</p>"},{"location":"zengin/anims/tutorials/standalone_animation/#animation-script","title":"Animation script","text":"<p>Now that we have exported the animation, we now have to define it in <code>Humans.mds</code>.</p> <p>Open the file, scroll to the end and define a new animation.</p> <p>Attention</p> <p>All <code>ani</code> code has to be between the curly brackets, this means you have to insert it before the last two closing curly brackets <code>} }</code>.</p> <p>Example: </p><pre><code>ani (\"t_backpain\" 1 \"\" 0.0 0.0 M. \"Hum_back.ASC\" F 0 121)  </code></pre> <p>Save the <code>Humans.mds</code> file and try it in game. Nothing happens! The reason is that the <code>mds</code> has been already compiled, and we have to recompile it. The easiest is to go to <code>Anims\\_compiled</code> and delete <code>HUMANS.MSB</code>. Run the game and try to play the animation again (<code>play ani t_backpain</code> in MARVIN console) and now everything should work.</p> <p></p> <p>Amazing, now you have your first animation in the game. And you can use it to do some fun stuff, like in dialogues using the <code>AI_PlayAni</code> function.</p>"},{"location":"zengin/anims/tutorials/standalone_animation/#example-dialogue","title":"Example dialogue","text":"<pre><code>instance DIA_Xardas_Back (C_INFO)\n{\nnpc         = NONE_100_Xardas;\nnr          = 11;\ncondition   = DIA_Xardas_Back_Condition;\ninformation = DIA_Xardas_Back_Info;\npermanent   = TRUE;\ndescription = \"What's wrong?\";\n};\nfunc int DIA_Xardas_Back_Condition () {\nreturn TRUE;\n};\nfunc void DIA_Xardas_Back_Info () {\nAI_Output (self, hero, \"DIA_Xardas_MOB_14_00\"); // My back hurts so much.\n// This is our animation!!!!!\nAI_PlayAni(self, \"T_BACKPAIN\"); AI_Output (self, hero, \"DIA_Xardas_MOB_14_01\"); // How do YOU feel?\nAI_Output (hero, self, \"DIA_Xardas_MOB_14_02\"); // My back is fine.\nAI_StopProcessInfos(self);\n};\n</code></pre>"},{"location":"zengin/general_info/directory_structure/","title":"Directory structure","text":""},{"location":"zengin/general_info/directory_structure/#zengin-directory-structure","title":"ZenGin directory structure","text":"<p>Modding is all about changing the game files. To achieve that, we have to know the directory (folder) structure of a Gothic game.</p> <pre><code>\u251c\u2500\u2500 Data\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 $Templates$\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 modvdf\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Plugins\n\u251c\u2500\u2500 Miles\n\u251c\u2500\u2500 Saves\n\u251c\u2500\u2500 System\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Autorun\n\u2514\u2500\u2500 _work\n    \u2514\u2500\u2500 DATA\n        \u251c\u2500\u2500 Anims\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 _Compiled\n        \u251c\u2500\u2500 Meshes\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 _Compiled\n        \u251c\u2500\u2500 Music\n        \u251c\u2500\u2500 Presets\n        \u251c\u2500\u2500 Scripts\n        \u2502\u00a0\u00a0 \u251c\u2500\u2500 _compiled\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 content\n        \u2502\u00a0\u00a0     \u2514\u2500\u2500 CUTSCENE\n        \u251c\u2500\u2500 Sound\n        \u251c\u2500\u2500 Textures\n        \u251c\u2500\u2500 Video\n        \u2514\u2500\u2500 Worlds\n</code></pre>"},{"location":"zengin/general_info/directory_structure/#data","title":"<code>Data</code>","text":"<p>Data directory contains <code>.vdf</code> volumes of the game. These contain <code>anims.vdf</code> - animations, <code>speech.vdf</code> - dubbing, <code>worlds.vdf</code> - world ZEN files.</p>"},{"location":"zengin/general_info/directory_structure/#saves","title":"<code>Saves</code>","text":"<p>Contains saved games.</p>"},{"location":"zengin/general_info/directory_structure/#system","title":"<code>System</code>","text":"<p>The system directory contains the game executable, <code>GothicStarter.exe</code>, <code>GothicStarter_mod.exe</code>, configuration <code>.ini</code> files, mod <code>.ini</code> files and mod icons and description <code>.rtf</code> files.</p> <p><code>system/Autorun</code> is a Union specific directory, it serves as a default search directory for Daedalus injection scripts with zParserExtender and Union plugins.</p>"},{"location":"zengin/general_info/directory_structure/#_workdata","title":"<code>_work/DATA</code>","text":"<p>This is where the magic happens:</p> <ul> <li><code>Anims</code> - contains animations and animated models.<ul> <li><code>_compiled</code> - contains compiled animations.</li> </ul> </li> <li><code>Meshes</code> - contains meshes source and compiled files.<ul> <li><code>_compiled</code> - contains compiled meshes.</li> </ul> </li> <li><code>Music</code> - contains music files.</li> <li><code>Presets</code> - contains basic presets.</li> <li><code>Scripts</code><ul> <li><code>_compiled</code> - contains compiled scripts - <code>.dat</code> files.</li> <li><code>Content</code> - contains scripts that make up the content of the game.</li> <li><code>System</code> - contains scripts that make up the menu.</li> </ul> </li> <li><code>Sound</code> - contains sound effects <code>.wav</code> or <code>.ogg</code> format (Union only).</li> <li><code>Video</code> - contains videos in <code>.bik</code> format.</li> </ul>"},{"location":"zengin/general_info/object_persistence/","title":"Object persistence","text":""},{"location":"zengin/general_info/object_persistence/#object-persistence","title":"Object persistence","text":"<p>In order to simplify the process of loading and saving data of various types to and from the user's hard-drive, ZenGin implements a simple object persistence system using the <code>zCArchiver</code> class and its derivatives that allow the individual engine classes to implement a routine specifying which data should be saved or loaded from disk and in which manner.</p> <p>An object that is derived from the <code>zCObject</code> class may overload the <code>Archive</code> and <code>Unarchive</code> virtual methods. The class may then call on an interface provided by the <code>zCArchiver</code> class within these methods which allows it to directly read from or write to a stream using several modes. Those are ASCII and BinSafe by default. There are, however, more options, as is explained below.</p>"},{"location":"zengin/general_info/object_persistence/#archive-format","title":"Archive format","text":"<p>In order to better understand how this process works, it would be best to look at an example of a .ZEN file containing an instance of an <code>oCWorld</code> object.</p>"},{"location":"zengin/general_info/object_persistence/#header","title":"Header","text":"<p>When you open up a ZenGin archive, you will see the following at the start of the file:</p> <pre><code>ZenGin Archive\nver 1\nzCArchiverGeneric\nASCII\nsaveGame 0\ndate 7.1.2001 23:9:19\nuser roeske\nEND\nobjects 2594     \nEND\n</code></pre> <p>Let's look at each of these properties and what they mean:</p> <p><code>ZenGin Archive</code></p> <p>This simply specifies that the following data is an <code>zCArchiver</code> archive.</p> <p><code>ver 1</code></p> <p>Version specification. Can be either <code>0</code> or <code>1</code>. Both Gothic 1 and 2 are already on version 1, although version 0 archives can also be occasionally found.</p> <p><code>zCArchiverGeneric</code></p> <p>Specifies which derived <code>zCArchiver</code> class should be used to read this archive. Accepted values are <code>zCArchiverGeneric</code> for ASCII and Binary archives, and <code>zCArchiverBinSafe</code> for BinSafe archives. More info below. This property might not be present in older archives.</p> <p><code>ASCII</code></p> <p>This is the most important part of the header as it specifies in which format should the data be stored. There are 4 different modes:</p> <ul> <li>ASCII - The simplest one. It stores data in human-readable ASCII notation (not unlike JSON for example). This is usually used when saving data during development and/or testing, while the final version of said data will most likely be stored as BIN_SAFE.</li> <li>ASCII_PROPS - Same as ASCII except with more additional data that the developer can specify for visual clarity. In practice, it is not used anywhere and mostly serves only to prettify debug info (try typing <code>ZWORLD VOBPROPS</code> in the console and look in zSpy ;) ).</li> <li>BINARY - Binary representation of the class instance, which mostly copies the data 1:1 into/from the stream. In practice, this format is only used to store savefiles (.SAV).</li> <li>BIN_SAFE - BinSafe, short for Binary Safe, is an extended version of Binary which stores type information along with the data itself. This is meant to make error checking for invalid data easier. There are other changes which are explained below. Most, if not all world files (.ZEN), are stored in this format.</li> </ul> <p><code>saveGame 0</code></p> <p>Specifies if this archive is a savefile. This property might not be present in older archives.</p> <p><code>date 7.1.2001 23:9:19</code></p> <p>The date at which this archive was created.</p> <p><code>user roeske</code></p> <p>The user which created the archive. This property might not be present in older archives.</p> <p><code>END</code></p> <p>Tells the parses that this is the end of the header.</p> <p>We may additionally find a property called <code>csum</code> in version 0 archives which stores the checksum of the whole archive. This property is, however, unused and equals <code>00000000</code> by default.</p> <p>In order to correctly read the archive's header across varying engine versions, one should not count on the properties always being in the same order or even being there at all.</p> <p>If the archive utilizes <code>zCArchiverGeneric</code> then this header will also be followed by a short section specifying the number of object instances in this archive. This value will be used to initialize the objectList, which is an array of pointers where the addresses of loaded objects will be stored for later referencing. This property would be directly part of the main header in older versions.</p> <pre><code>objects 2594 END  \n</code></pre> <p>If the archive is created using <code>zCArchiverBinSafe</code>, this data will be stored in the following binary structure:</p> <pre><code>struct BinSafeArchiveHeader  {  uint32_t version;     // Always equals 2 uint32_t objectCount;  // Serves the same function as \"objects n\" uint32_t chunkPos;    // Offset to chunk hash table};\n};  </code></pre>"},{"location":"zengin/general_info/object_persistence/#contents","title":"Contents","text":"<p>Looking further into the archive, we see what appears to be a nested structure.</p> <pre><code>[% oCWorld:zCWorld 64513 0]\n    [VobTree % 0 0]\n        childs0=int:1\n        [% zCVobLevelCompo:zCVob 12289 1]\n            pack=int:0\n            presetName=string:\n            bbox3DWS=rawFloat:-71919.9609 -13091.8232 -59900 108999.992 20014.0352 67399.9922 \n            trafoOSToWSRot=raw:0000803f0000000000000000000000000000803f0000000000000000000000000000803f\n            trafoOSToWSPos=vec3:0 0 0\n            vobName=string:LEVEL-VOB\n            visual=string:SURFACE.3DS\n            showVisual=bool:0\n            visualCamAlign=enum:0\n            cdStatic=bool:1\n            cdDyn=bool:0\n            staticVob=bool:0\n            dynShadow=enum:0\n            [visual zCMesh 0 2]\n            []\n            [ai % 0 0]\n            []\n        []\n        ...\n</code></pre> <p>We primarily differentiate between chunks and properties within ZenGin archives:  </p>"},{"location":"zengin/general_info/object_persistence/#chunks","title":"Chunks","text":"<p>A chunk is a structure that groups properties together. For most of the time, a chunk represents a class instance. This is, however, not always true as classes may arbitrarily create chunks as is needed. For example, the sample above contains a chunk called <code>VobTree</code>, which does not represent a class instance, but only serves to make the reading of the archive easier.  </p> <p>While in ASCII mode, the start of a chunk is represented using square brackets.  </p> <p><code>[% oCWorld:zCWorld 64513 0]</code> </p> <p>There are 4 pieces of data separated by spaces inside the start of each chunk, which are:  </p> <ul> <li>Object name - The name of the chunk to use while reading. If the chunk has no name, then it will be simply equal to <code>%</code>.  </li> <li>Class name - The name of the class which this chunk represents. Class names are stored with their full inheritance hierarchy (e.g. <code>oCMobLadder:oCMobInter:oCMOB:zCVob</code>). In case the chunk is not an object, but an arbitrary chunk, then this field will be equal to <code>%</code> (<code>%</code> can also mean that this chunk is a nullptr). In some cases you may encounter the symbol <code>\u00a7</code> instead. This means that the object already exists and that the parser should look for it in the objectList using the object index. Using this mechanism, a single instance can be referenced multiple times without worrying about duplicity.  </li> <li>Class version - Used to ensure that the data being read is compatible with the current game/engine version, so that there are no mismatches in the data pattern. This value is different for every class and varies between game versions.  </li> <li>Object index - An index into the objectList under which this object will be stored. If the class name is equal to <code>\u00a7</code>, then this value will be used to retrieve an existing instance from the objectList.  </li> </ul> <p>If this is a Binary archive, the same data will be stored in the following binary structure:  </p> <pre><code>struct BinaryObjectHeader\n{\nuint32_t    objectSize;        // Size of the whole object in bytes\nuint16_t    classVersion;\nuint32_t    objectIndex;\nchar        objectName[];    // Null-terminated string\nchar        className[];    // Null-terminated string\n};\n</code></pre> <p>Oddly enough, if the archive is BinSafe, then the data will be encoded the same way as in ASCII mode, except that it will be stored as a type-checked property.</p> <pre><code>struct BinSafeObjectHeader\n{\nuint32_t    type;    // 0x1 = TYPE_STRING\nuint16_t    length;    // Length of the text\nchar        text[];    // [% oCWorld:zCWorld 64513 0]\n};\n</code></pre> <p>In ASCII mode <code>[]</code> represents the end of the current chunk.</p>"},{"location":"zengin/general_info/object_persistence/#properties","title":"Properties","text":"<p>We find properties inside the chunks which are key-value pairs that classes use to store the actual data. Each property stores its name, type and value. In ASCII mode the format for this is<code>name=type:value</code>.</p> <p>For example:</p> <p><code>visual=string:SURFACE.3DS</code></p> <p>By default, <code>zCArchiver</code> allows to store properties of the following types:</p> <ul> <li> <p>Int - A regular 32-bit integer. In ASCII mode, int gets stored as <code>name=int:1</code>, while in Binary mode, it's just the raw value stored as 4 bytes.</p> </li> <li> <p>Byte - A 8-bit integer. ASCII mode doesn't differentiate between Int and Byte, so this will be stored as <code>name=int:1</code> regardless. Binary mode stores only the single byte.</p> </li> <li> <p>Word - A 16-bit integer. ASCII mode doesn't differentiate between Int and Word, so this will be stored as <code>name=int:1</code> regardless. Binary mode stores only the 2 bytes.</p> </li> <li> <p>Float - A standard IEEE 754 32-bit floating point number. In ASCII mode the format is <code>name=float:1.0</code>, while in Binary mode the float gets stored raw as 4 bytes.</p> </li> <li> <p>Bool - Stores a single-byte boolean value. In ASCII mode its <code>name=bool:1</code> and in Binary mode it's a single byte.</p> </li> <li> <p>String - An ASCII encoded string. While in ASCII mode, strings are stored as <code>name=string:value</code>. In Binary mode, strings are NULL terminated.</p> </li> <li> <p>Vec3 - A three component vector, mainly used to store positional data. The ASCII mode format is <code>name=vec3:1.0 1.0 1.0</code>. In Binary mode the three components of the vector are stored in series, which equals to a total size of 12 bytes.</p> </li> <li> <p>Color - A 32-bit color value stored as BGRA. In ASCII mode the color is stored as <code>name=color:255 255 255 255</code> while in Binary mode it's just 4 raw bytes.</p> </li> <li> <p>Raw - Raw binary data. In order to maintain readability, in ASCII mode this gets stored as a hex encoded string such as <code>name=raw:63D15B07</code>. In Binary mode, only the data itself is stored, without any other info. Be aware that due to this you must know the size of the data beforehand.</p> </li> <li> <p>RawFloat - An array of floats, mainly used to store bounding boxes. In ASCII mode, the floats are stored as <code>name=rawFloat:1.0 1.0 1.0 1.0 1.0 1.0</code>. In Binary mode the floats are stored in series as raw bytes. Same as with <code>Raw</code>, you must know the size of the array beforehand.</p> </li> <li> <p>Enum - An enum value. In ASCII mode, it gets stored as <code>name=enum:1</code>. In Binary mode, it behaves the same as <code>Int</code>.</p> </li> </ul> <p>As you might have noticed, binary mode doesn't perform any kind of checks on if it's reading the right property or even data of the correct type. This is why BinSafe mode exists, as it stores the property type in along with the data itself.</p> <pre><code>enum TYPE\n{\nTYPE_STRING        = 0x1,\nTYPE_INTEGER    = 0x2,\nTYPE_FLOAT        = 0x3,\nTYPE_BYTE        = 0x4,\nTYPE_WORD        = 0x5,\nTYPE_BOOL        = 0x6,\nTYPE_VEC3        = 0x7,\nTYPE_COLOR        = 0x8,\nTYPE_RAW        = 0x9,\nTYPE_RAWFLOAT    = 0x10,\nTYPE_ENUM        = 0x11\nTYPE_HASH        = 0x12,\n};\nstruct BinSafeProperty\n{\nTYPE type;\nunion\n{\nstruct\n{\nuint16_t    stringLength;\nchar        stringValue[];\n}\nuint32_t    integerOrHashOrEnumValue;\nfloat        floatValue;\nuint8_t        byteOrBoolValue;\nzVEC3        vec3Value;\nzCOLOR        colorValue;\nstruct\n{\nuint16_t    rawLength;\nchar        rawValue[];\n}\nstruct\n{\nuint16_t    rawFloatLength;\nfloat        rawFloatValue[];\n}        };\n};\n</code></pre> <p>Looking at the enumeration of types, you might notice that BinSafe mode has an additional property type called Hash. BinSafe archives include a hash table which is stored in the following manner:</p> <pre><code>struct BinSafeHashTable\n{\nuint32_t chunkCount;\nfor (chunkCount)\n{\nuint16_t    stringLength;\nuint16_t    linearValue;\nuint32_t    hashValue;\nchar        text[stringLength];\n}\n};\n</code></pre> <p>Instead of storing the raw value, properties may save a hash instead, which is then used to look up the corresponding value from the hash table.</p>"},{"location":"zengin/general_info/object_persistence/#implementation","title":"Implementation","text":"<p>As mentioned in the opening paragraph, classes may use the described functionality by overloading the <code>Archive</code> and <code>Unarchive</code> virtual methods, which pass an instance of <code>zCArchiver</code> by reference. When the class instance is then serialized and/or parsed, these methods are called and perform the desired serialization/parsing work.</p> <p>The class uses methods provided by the <code>zCArchiver</code> instance within these routines. These methods return/accept a value of a specific type (e.g. ReadInt/WriteInt), while they do the actual reading/writing work behind the scenes based on the current mode (ASCII/Binary/BinSafe). The programmer writing the class then does not care whether the final archive will be saved as ASCII, Binary or BinSafe, as they only use the <code>zCArchiver</code> Read* and Write* methods.</p>"},{"location":"zengin/general_info/object_persistence/#a-practical-example","title":"A practical example","text":"<p>Let's propose that we have a class which is declared like so:</p> <pre><code>class zCMyClass : public zCObject\n{\npublic:\nzCMyClass()                {}\nvirtual ~zCMyClass()    {}\nvirtual void Archive(zCArchiver&amp;);\nvirtual void Unarchive(zCArchiver&amp;);\nint myInt;\nzCMyClass* myObject;\nzCMyClass* secondPointerToMyObject;\n};\n</code></pre> <p>The hypothetical class then implements these virtual functions:</p> <pre><code>void zCMyClass::Archive(zCArchiver&amp; archiver)\n{\narchiver.WriteInt(\"myInt\", myInt);\narchiver.WriteObject(\"myObject\", myObject);\narchiver.WriteChunkStart(\"myChunk\", 0);\narchiver.WriteObject(\"secondPointerToMyObject\", secondPointerToMyObject);\narchiver.WriteChunkEnd();\n}\nvoid zCMyClass::Unarchive(zCArchiver&amp; archiver)\n{\narchiver.ReadInt(\"myInt\", myInt);\nmyObject = dynamic_cast&lt;zCMyClass*&gt;(archiver.ReadObject(\"myObject\"));\narchiver.ReadChunkStart(\"myChunk\");\nsecondPointerToMyObject = dynamic_cast&lt;zCMyClass*&gt;(archiver.ReadObject(\"secondPointerToMyObject\"));\narchiver.ReadChunkEnd();\n}\n</code></pre> <p>We then initialize the class in the following way:</p> <pre><code>zCMyClass object;\nobject.myInt = 12121212;\nobject.myObject = new zCMyClass();\nobject.myObject-&gt;myInt = 34343434;\nobject.secondPointerToMyObject = object.myObject;\n</code></pre> <p>If we now serialized, or to use the engine's term \"archived\", this instance into an ASCII archive, the result would look like this:</p> <pre><code>ZenGin Archive\nver 1\nzCArchiverGeneric\nASCII\nsaveGame 0\ndate 3.7.2022 0:0:0\nuser GMC\nEND\nobjects 2     \nEND\n\n[% zCMyClass 0 0]\n    myInt=int:12121212\n    [myObject zCMyClass 0 1]\n        myInt=int:34343434\n        [myObject % 0 0]\n        []\n        [myChunk % 0 0]\n            [secondPointerToMyObject % 0 0]\n            []\n        []\n    []\n    [myChunk % 0 0]\n        [secondPointerToMyObject \u00a7 0 1]\n        []\n    []\n[]\n</code></pre> <p>Notice how <code>secondPointerToMyObject</code> doesn't have any contents. The character <code>\u00a7</code> tells the parser that this object already exists in the objectList, and that instead of creating a new instance, it should return an existing instance which is stored under index <code>1</code> in the objectList.  This allows an instance to be referenced from multiple places, without the need to worry about duplicity.</p> <p>If we used Binary or BinSafe mode, we would see a big blob of binary data instead. This would, of course, store the exact same data, although in a slightly less human-readable format.</p>"},{"location":"zengin/general_info/object_persistence/#final-thoughts","title":"Final thoughts","text":"<p>We hope this helps you better understand the inner workings of ZenGin. If you want to see how Piranha Bytes went about implementing a much more advanced version of this system for their next engine, check out Genome's object persistence system.</p>"},{"location":"zengin/general_info/vdfs/","title":"VDFS virtual file system","text":""},{"location":"zengin/general_info/vdfs/#vdfs","title":"VDFS","text":"<p>VDFS is the virtual file system used by ZenGin to distribute and store many, but not all, game assets.</p>"},{"location":"zengin/general_info/vdfs/#tools","title":"Tools","text":"<p>The community created variety of different modding tools for work with VDFS volumes over the times, such as:</p> <p>GothicVDFS</p> <ul> <li>Viewing</li> <li>Extracting</li> <li>Building <code>.mod</code> and <code>.vdf</code> archives</li> </ul> <p>VDFS Tool</p> <ul> <li>Viewing</li> <li>Extracting</li> <li>Building</li> <li>Optimizing</li> <li>Compressing <code>.mod</code> and <code>.vdf</code> archives</li> </ul>"},{"location":"zengin/scripts/","title":"Scripts","text":""},{"location":"zengin/scripts/#scripts","title":"Scripts","text":"<p>ZenGin uses its own scripting language called Daedalus. It is similar to C programming language, so if you know some C programming, it will be quite easy to get started.</p> <p>The <code>Scripts</code> directory is where the scripts live. You will be able to find Daedalus script files - <code>.d</code> extension and <code>.src</code> files, that list all files to be compiled.</p> <p>Daedalus scripts can be edited in any text editor. To get useful features like syntax highlighting you can use community developed tools like </p> <ul> <li>Gothic Sourcer</li> <li>Daedalus VS Code extension</li> </ul>"},{"location":"zengin/scripts/classes/c_info/","title":"C_INFO","text":""},{"location":"zengin/scripts/classes/c_info/#c_info-daedalus-class","title":"C_INFO Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library.</p> <p>The <code>C_INFO</code> class is used to define dialogues in the game.</p>"},{"location":"zengin/scripts/classes/c_info/#class-definition","title":"Class definition","text":"<p>Class definition as it is defined in <code>Scripts/Content/_intern/Classes.d</code> script file.</p> C_Info Daedalus class <pre><code>class C_Info\n{\nvar int    npc;         // npc instance has the dialogue\nvar int    nr;          // number of the dialogue (for sorting)\nvar int    important;   // should the npc start the dialogue automatically\nvar func   condition;   // condition function\nvar func   information; // function called on selecting the dialogue\nvar string description; // text in the dialogue box\nvar int    trade;       // should the dialogue show the trade window\nvar int    permanent;   // should the dialogue be permanent or only one time deal\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_info/#class-members","title":"Class members","text":"Variable Type Description npc int npc instance to have the dialogue nr int dialogue order number important int npc addresses player automatically condition func condition function whether the dialogue is shown or not information func function called on dialogue selection - contains the dialogue lines and other logic description string text shown in the dialogue box trade int is it a trade dialogue permanent int does the dialogue stay after being played once"},{"location":"zengin/scripts/classes/c_info/#class-member-overview","title":"Class member overview","text":"<p>Description of the class member variables.</p>"},{"location":"zengin/scripts/classes/c_info/#npc","title":"npc","text":"<p>Sets what NPC will have this dialogue instance. Set an NPC instance. </p><pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\nnpc    = PC_Thief; // NPC instance for Diego\n// ...\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_info/#nr","title":"nr","text":"<p>The <code>nr</code> member variables determines the order of shown dialogues. Dialogues are ordered in the ascending order - instances with higher <code>nr</code> are below instances with lower <code>nr</code>.</p> <pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\n// ...\nnr = 1;\n// ...\n};\n</code></pre> <p>Note</p> <p>This is why the end dialogues usually have <code>nr = 999;</code> this is the highest number out of any dialogues therefore will always show up at the bottom. (999 is not the highest number the <code>nr</code> can store, it is just considered the highest number, as there will hardly be 998 dialogue instances for a single character)</p>"},{"location":"zengin/scripts/classes/c_info/#important","title":"important","text":"<p>The <code>important</code> member variable determines whether the NPC will automatically address the player or not.</p> <ul> <li><code>important = TRUE</code> - the NPC will address the player</li> <li><code>important = FALSE</code> - the player has to talk to the NPC</li> </ul> <p>When <code>important</code> is set to <code>TRUE</code>, the description is not needed since the dialogue is never shown in the dialogue box.  </p> <p>Info</p> <p>If there are multiple important dialogues that satisfy their condition function, they will be played in the order specified by <code>nr</code>.</p> <p>Tip</p> <p><code>important</code> variable is of the type integer, and it is initialized by the engine to the value of <code>0</code>. If you do not want your dialogue to be important, you can omit the <code>important</code> member variable since it will be initialized to <code>0</code> by the engine.</p>"},{"location":"zengin/scripts/classes/c_info/#condition","title":"condition","text":"<p>Condition function with signature <code>func int f()</code>. If the function returns <code>TRUE</code> the dialogue is displayed, if it returns <code>FALSE</code> it is not displayed. The function name does not have to follow a particular naming convention, but a naming convention is used throughout all the Gothic scripts: <code>{DialogueName}_Condition</code>.</p> Conditioned dialogueUnconditioned dialogue <pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\n// ...\ncondition = Info_Diego_Gamestart_Condition;\n// ...\n};\nfunc int Info_Diego_Gamestart_Condition()\n{\nif (Kapitel &lt; 2) // Show only when chapter is less than 2\n{\nreturn TRUE;\n};\nreturn FALSE; // Not needed, but added for readability\n};\n</code></pre> <pre><code>instance Info_Diego_EXIT_Gamestart(C_INFO)\n{\n// ...\ncondition = Info_Diego_EXIT_Gamestart_Condition;\n// ...\n};\nfunc int Info_Diego_EXIT_Gamestart_Condition()\n{\nreturn TRUE; // or return 1;\n};\n</code></pre> <p>Tip</p> <p>It is unnecessary to return <code>FALSE</code> from dialogue conditions, but in other cases it can very rarely cause subtle bugs. It is thus good practice to always return some value, even if that is <code>FALSE</code>.</p>"},{"location":"zengin/scripts/classes/c_info/#information","title":"information","text":"<p>The <code>information</code> function contains the function name (without double quotes <code>\"\"</code> as <code>func</code> is a type in Daedalus) that is called when the dialogue option is selected. It contains the lines NPCs will say, items that will be transferred, quests related logic and much more. The function name does not have to follow a particular naming convention, but a naming convention is used throughout all the Gothic scripts: <code>{DialogueName}_Info</code>.</p> <pre><code>instance Info_Diego_Gamestart (C_INFO)\n{\nnpc         = PC_Thief;\nnr          = 1;\ncondition   = Info_Diego_Gamestart_Condition;\ninformation = Info_Diego_Gamestart_Info;\npermanent   = FALSE;\nimportant   = TRUE;\n};\nfunc int Info_Diego_Gamestart_Condition()\n{\nif (Kapitel &lt; 2)\n{\nreturn TRUE;\n};\nreturn FALSE;\n};\nfunc void Info_Diego_Gamestart_Info()\n{\nAI_Output(self,hero,\"Info_Diego_Gamestart_11_00\"); //I'm Diego.\nAI_Output(hero,self,\"Info_Diego_Gamestart_15_01\"); //I'm...\nAI_Output(self,hero,\"Info_Diego_Gamestart_11_02\"); //I'm not interested in who you are. You've just arrived. I look after the new arrivals. That's all for now.\nAI_Output(self,hero,\"Info_Diego_Gamestart_11_03\"); //If you plan to stay alive for a while, you should talk to me. But of course I won't keep you from choosing your own destruction. Well, what do you think?\nB_Kapitelwechsel(1); // Show the chapter 1 screen\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_info/#description","title":"description","text":"<p>Specify a string that will be shown in the dialogue window.</p> <pre><code>instance DIA_XARDAS_GMC(C_INFO)\n{\n// ...\ndescription = \"Hello, is this the GMC site?\";\n};\n</code></pre> <p></p>"},{"location":"zengin/scripts/classes/c_info/#trade","title":"trade","text":"<p>If <code>trade</code> is set to <code>TRUE</code> the trading interface will be launched after the content <code>information</code> function is finished. </p>Fisk's trade dialogue<pre><code>instance  Stt_311_Fisk_Trade (C_INFO)\n{\nnpc         = Stt_311_Fisk;\nnr          = 800;\ncondition   = Stt_311_Fisk_Trade_Condition;\ninformation = Stt_311_Fisk_Trade_Info;\npermanent   = TRUE;\ndescription = \"Show me your goods.\";\ntrade       = TRUE;\n};\nfunc int  Stt_311_Fisk_Trade_Condition()\n{\nreturn TRUE;\n};\nfunc void  Stt_311_Fisk_Trade_Info()\n{\nAI_Output (other, self, \"Stt_311_Fisk_Trade_15_00\"); //Show me your goods.\n};\n</code></pre> <p>Trivia</p> <p>Trade manager has been added to ZenGin not that long before the release of Gothic 1 (as discussed and discovered on Phoenix the Game Discord server with the acquisition of Gothic version <code>0.94k</code>). In version 0.94 the trade manager worked quite differently and used a special (nowadays unused) Daedalus class <code>C_ItemReact</code>.</p>"},{"location":"zengin/scripts/classes/c_info/#permanent","title":"permanent","text":"<p>Dialogues with <code>permanent = TRUE</code> do not disappear after the dialogue is played. This is used for dialogues where you ask for directions or flavor dialogues for unnamed NPCs.</p> <p>Bug</p> <p>Frequently used external function <code>Npc_KnowsInfo</code> which returns true if the dialogue instance has been played has had a bug in the implementation for a long time. This bug made it impossible to use this function with dialogue instances with <code>permanent = TRUE</code> as it would always return <code>FALSE</code>. This has been fixed in <code>Union 1.0m</code>.</p>"},{"location":"zengin/scripts/classes/c_info/#lego","title":"LeGo","text":"<p>LeGo implements a lot of useful functions for dialogues. It makes it possible to create Trialogues and change NPCs behaviour by Dialoggestures. Moreover, any Daedalus function can be added to NPCs AI queue via the AI_Function package.</p>"},{"location":"zengin/scripts/classes/c_info/#zparserextender","title":"zParserExtender","text":"<p>zParserExtender implements some Quality of Life features for dialogues. More information can be found in Dialogue constants article.</p>"},{"location":"zengin/scripts/classes/c_info/#af-script-packet","title":"AF Script Packet","text":"<p>Enhanced Info Manager (implemented using Ikarus and LeGo) adds tons of customizations and additional features to dialogues. More information can be found in the AFSP Enhanced Information Manager article.</p>"},{"location":"zengin/scripts/classes/c_item/","title":"C_ITEM","text":""},{"location":"zengin/scripts/classes/c_item/#c_item-daedalus-class","title":"C_ITEM Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>The <code>C_ITEM</code> class is used to define new items in the game.</p>"},{"location":"zengin/scripts/classes/c_item/#class-definition","title":"Class definition","text":"<p>Class definition as it is defined in <code>Scripts/Content/_intern/Classes.d</code> script file. </p> C_Item Daedalus class <pre><code>class C_Item\n{\n// For all Items\nvar int    id;                         // ID of the item\nvar string name;                       // Name of the item\nvar string nameID;                     // Name ID\nvar int    hp;                         // Current health of the item\nvar int    hp_max;                     // Maximum health of the item\nvar int    mainflag;                   // Item category flag\nvar int    flags;                      // Item type flag\nvar int    weight;                     // Weight of the item\nvar int    value;                      // Value of the item\n// For weapons\nvar int    damageType;                 // Damage type\nvar int    damageTotal;                // Total amount of damage\nvar int    damage[DAM_INDEX_MAX];      // Array of damage types\n// For armours\nvar int    wear;                       // Flag to specify where to wear an item\nvar int    protection[PROT_INDEX_MAX]; // Protection array of different damage types\n// For food\nvar int    nutrition;                  // The amount of HP healed\n// Ben\u00f6tigte Attribute zum Benutzen des Items\nvar int    cond_atr[3];                // Array of NPC attributes needed to equip the item\nvar int    cond_value[3];              // Array of values corresponding to the cond_atr arry\n// Attributes to be changed on equip\nvar int    change_atr[3];              // Array of attributes that will be changed on equip\nvar int    change_value[3];            // Array of values of the attributes defined in change_atr\n// Parser functions\nvar func   magic;\nvar func   on_equip;                   // Called on equpping an item\nvar func   on_unequip;                 // Called on unequipping an item\nvar func   on_state[4];\nvar func   owner;                      // Owner of the item: instance name\nvar int    ownerGuild;                 // Owner of the item: guild\nvar int    disguiseGuild;              // NPC guild set when equipping an item\n// 3DS model file\nvar string visual;                     // Item model file\n// NPC mesh change, when equipping an item\nvar string visual_change;              // .asc file\nvar string effect;                     // Effect instance\nvar int    visual_skin;                // Texture variation\nvar string scemeName;                  // Animation sceme name\nvar int    material;                   // Material of the object\nvar int    munition;                   // Ammo instance\nvar int    spell;                      // ID if the spell that this item does\nvar int    range;                      // Range of the weapon\nvar int    mag_circle;                 // Circle of magic needed to use this item\nvar string description;                // The name of the item shown in the preview box\nvar string text[ITM_TEXT_MAX];         // Array of string describing the item (left side)\nvar int    count[ITM_TEXT_MAX];        // Array of integers (the right side)\n// Parameters for displaying items in the inventory\nvar int    inv_zbias                   // How far away is the item from the screen\nvar int    inv_rotx                    // X-axis rotation\nvar int    inv_roty                    // Y-axis rotation\nvar int    inv_rotz                    // Z-axis rotation\nvar int    inv_animate                 // Should the item rotate in the inventory\n};\n</code></pre> <p>It has many member variables but not all of them are used for every item. It is not necessary to define every one of these variables for every item as it was discussed on InsideGothic.</p>"},{"location":"zengin/scripts/classes/c_item/#class-members","title":"Class members","text":"<p>A selection of the most important class members.</p>"},{"location":"zengin/scripts/classes/c_item/#change_atr--change_value","title":"change_atr &amp; change_value","text":"<p><code>change_atr</code> stores the attributes that will be changed by the amount specified in <code>change_value</code>.</p> <p>NPCs have these attributes: </p><pre><code>const int ATR_HITPOINTS      =  0;  // Hit points\nconst int ATR_HITPOINTS_MAX  =  1;  // Max hitpoints\nconst int ATR_MANA           =  2;  // Mana\nconst int ATR_MANA_MAX       =  3;  // Max mana\nconst int ATR_STRENGTH       =  4;  // Strength\nconst int ATR_DEXTERITY      =  5;  // Dexterity\nconst int ATR_REGENERATEHP   =  6;  // HP regeneration per second\nconst int ATR_REGENERATEMANA =  7;  // Mana regeneration per second\n</code></pre> <p>This can be used on all equipable items to change the attributes. As an example we can create a sword that has a 10 point dexterity bonus.</p> <pre><code>instance ItMw_testSword (C_Item)\n{\n// some code\nchange_atr[0]   = ATR_DEXTERITY;\nchange_value[0] = 10;\n// some code\n};\n</code></pre> <p>Warning</p> <p>Do not change <code>ATR_HITPOINTS</code>, <code>ATR_MANA</code>, <code>ATR_HITPOINTS_MAX</code> or <code>ATR_MANA_MAX</code> as it will result in unwanted behaviour with max health or max mana.</p> <p>You can change <code>ATR_HITPOINTS_MAX</code> and <code>ATR_MANA_MAX</code> attributes in on_equip and on_unequip</p>"},{"location":"zengin/scripts/classes/c_item/#cond_atr--cond_value","title":"cond_atr &amp; cond_value","text":"<p><code>cond_atr</code> stores the attributes that will be checked as a requirement to equip an item, the amount specified in <code>cond_value</code>.</p> <p>The next example sword is equipable only if the NPC has at least 5 strength. If the requirements are not met <code>G_CanNotUse()</code> is called. </p><pre><code>instance ItMw_testSword (C_Item)\n{\n// some code\ncond_atr[2]     = ATR_STRENGTH;\ncond_value[2]   = 5;\n// some code\n};\n</code></pre> <p>Try injecting the code below zParserExtender to test it in game right away. It is compatible with G2NotR.</p> <p></p><pre><code>instance ItMw_testSword (C_Item)\n{\nname            = TXT_Spells[10]; // demonstrates the usage of direct constr array access\nmainflag        = ITEM_KAT_NF;\nflags           = ITEM_SWD;\nmaterial        = MAT_METAL;\nvalue           = 10;\ndamageTotal     = 10;\ndamagetype      = DAM_EDGE;\nrange           = 100;\ncond_atr[2]     = ATR_STRENGTH;\ncond_value[2]   = 5;\nchange_atr[0]   = ATR_DEXTERITY;\nchange_value[0] = 10;\nvisual          = \"ItMw_010_1h_Sword_short_01.3DS\";\ndescription     = name;\nTEXT[2]         = NAME_Damage;      COUNT[2] = damageTotal;\nTEXT[3]         = NAME_Str_needed;  COUNT[3] = cond_value[2];\nTEXT[4]         = NAME_OneHanded;\nTEXT[5]         = NAME_Value;       COUNT[5] = value;\n};\n</code></pre> To insert it into the game use <code>insert ItMw_testSword</code> in console."},{"location":"zengin/scripts/classes/c_item/#text--count-arrays","title":"text &amp; count arrays","text":"<p>These two arrays are used to put information into the item information box.   The maximum number of lines is 6. This is defined in the engine, but for script side class definition is declared in the scripts too. </p><pre><code>const int ITM_TEXT_MAX = 6;\n</code></pre> This example shows an item with all elements of <code>TEXT</code> and <code>COUNT</code> array filled.   <p>Note</p> <p>Please notice the last <code>COUNT</code> element. It did not take the value we entered, but shows <code>10</code> which is the <code>value</code> of the item. This behaviour can be changed with Ikarus or Union.</p> <p></p> <p>You can find the code below </p><pre><code>instance ItMw_testSword (C_Item)\n{\nname          = TXT_Spells[10];\nmainflag      = ITEM_KAT_NF;\nflags         = ITEM_SWD;\nmaterial      = MAT_METAL;\nvalue         = 10;\ndamageTotal   = 10;\ndamagetype    = DAM_EDGE;\nrange         = 100;\ncond_atr[2]   = ATR_STRENGTH;\ncond_value[2] = 5;\nchange_atr[0] = ATR_DEXTERITY;\nchange_value[0] = 10;\nvisual        = \"ItMw_010_1h_Sword_short_01.3DS\";\ndescription   = name;\nTEXT[0]       = \"Line 0\";     COUNT[0]      = 0; TEXT[1]       = \"Line 1\";     COUNT[1]      = 1; TEXT[2]       = \"Line 2\";     COUNT[2]      = 2; TEXT[3]       = \"Line 3\";     COUNT[3]      = 3; TEXT[4]       = \"Line 4\";     COUNT[4]      = 34;\nTEXT[5]       = \"Line 5\";     COUNT[5]      = 35;\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_item/#description--name","title":"description &amp; name","text":"<p><code>description</code> - determines the name of the item in the inventory</p> <p><code>name</code> - determines the focus name of the item in the world</p> <p>In the scripts you often find that the description is assigned the value of <code>name</code>. </p><pre><code>instance ItMw_testSword (C_Item)\n{\nname = \"New amazing sword\";\n// ...\ndescription   = name; // description now has the same value as '    // ...name'\n// ...\n};\n</code></pre> This is used in the case where you want to show the name of the item on focus too. <p>There is a second way used in the scripts though with, for example,magic scrolls - the focus name in the world is \"Scroll\" and in inventory the scroll carries the name of the spell. This is how it is done: </p><pre><code>instance ItSc_InstantFireball (C_Item)\n{\nname                 =    NAME_Spruchrolle; // const string = \"Scroll\"\n// ...\ndescription            =     NAME_SPL_InstantFireball; // const string = \"Fireball\"\n// ...\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_item/#hp--hp_max","title":"hp &amp; hp_max","text":"<p>Both of these parameters are unused.</p> <p>Trivia</p> <p>In alpha ZenGin versions the player was able to destroy objects. This feature was abandoned during the course of the development. This video shows the reconstruction of this feature. </p>"},{"location":"zengin/scripts/classes/c_menu/","title":"C_MENU","text":""},{"location":"zengin/scripts/classes/c_menu/#c_menu-daedalus-class","title":"C_MENU Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>Class <code>C_Menu</code> is responsible for the behavior and properties of the game menus (options, save etc.).</p>"},{"location":"zengin/scripts/classes/c_menu/#class-definition","title":"Class definition","text":"<p>Class definition as it is defined in <code>Scripts/System/_intern/Menu.d</code> script file. </p> C_Menu Daedalus class <pre><code>class C_Menu {\nvar     string  backPic;            // Menu background image\nvar     string  backWorld;          // Background ZEN-world of the game menu (Not used)\nvar     int     posx;               // The top left point of the menu on the screen horizontally (X-axis)\nvar     int     posy;               // The top left point of the menu on the screen vertically (Y-axis)\nvar     int     dimx;               // Menu width in virtual coordinates\nvar     int     dimy;               // Menu height in virtual coordinates\nvar     int     alpha;              // Menu transparency\nvar     string  musicTheme;         // Music track of the menu\nvar     int     eventTimerMSec;     // trigger time for the event EVENT_TIMER\nvar     string  items[150];         // Menu items\nvar     int     flags;              // Menu flags\nvar     int     defaultOutGame;     // Menu item highlighted by default when the game is not running\nvar     int     defaultInGame;      // Menu item highlighted by default when the game is running\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_menu/#class-members","title":"Class members","text":"Variable Type Description backPic string Menu background image backWorld string Background ZEN-world of the game menu (Not used) posx int The top left point of the menu on the screen horizontally (X-axis) posy int The top left point of the menu on the screen vertically (Y-axis) dimx int Menu width in virtual coordinates dimy int Menu height in virtual coordinates alpha int Menu transparency musicTheme string Music track of the menu eventTimerMSec int The timer that triggered the event in seconds items string Menu items flags int Menu flags defaultOutGame int Menu item highlighted by default when the game is not running defaultInGame int Menu item highlighted by default when the game is running"},{"location":"zengin/scripts/classes/c_menu/#class-member-overview","title":"Class member overview","text":"<p>Description of the class member variables.</p>"},{"location":"zengin/scripts/classes/c_menu/#backpic","title":"backPic","text":"<p><code>backPic</code> is just a name of background image of the menu in <code>.tga</code> format.</p>"},{"location":"zengin/scripts/classes/c_menu/#backworld","title":"backWorld","text":"<p>Deprecated setting</p> <p>The background world of the game menu in <code>.ZEN</code> format.</p>"},{"location":"zengin/scripts/classes/c_menu/#posx","title":"posx","text":"<p>The horizontal position of the top left point of the menu on the screen, in virtual coordinates. </p>"},{"location":"zengin/scripts/classes/c_menu/#posy","title":"posy","text":"<p>The vertical position of the top left point of the menu on the screen, in virtual coordinates. </p>"},{"location":"zengin/scripts/classes/c_menu/#dimx","title":"dimx","text":"<p>Menu width in virtual coordinates.</p>"},{"location":"zengin/scripts/classes/c_menu/#dimy","title":"dimy","text":"<p>Menu height in virtual coordinates.</p>"},{"location":"zengin/scripts/classes/c_menu/#alpha","title":"alpha","text":"<p>Menu transparency. Accepts values \u200b\u200bfrom 0 to 255. Without the <code>backPic</code> property specified, the value of this parameter is ignored. </p> <p>Note</p> <p>Texture transparency can only be adjusted if the texture has an alpha channel.</p>"},{"location":"zengin/scripts/classes/c_menu/#musictheme","title":"musicTheme","text":"<p>Music theme of the menu. </p><pre><code>instance MENU_MAIN(C_MENU_DEF)\n{\n...\nmusictheme = \"SYS_Menu\";\n...\n};\n</code></pre> All instances of musical themes are stored in a file <code>Scripts/System/Music/MusicInst.d</code>"},{"location":"zengin/scripts/classes/c_menu/#eventtimermsec","title":"eventTimerMSec","text":"<p>Defines the trigger time for the event <code>EVENT_TIMER</code> in seconds.</p> <p>The list of constants for all menu events is described in the file <code>Scripts/System/_intern/Menu.d</code></p> <pre><code>const int EVENT_UNDEF       = 0;    // Undefined\nconst int EVENT_EXECUTE     = 1;    // Process start event\nconst int EVENT_CHANGED     = 2;    // Menu parameter change event\nconst int EVENT_LEAVE       = 3;    // Menu item focus loss event\nconst int EVENT_TIMER       = 4;    // Timer fire event\nconst int EVENT_CLOSE       = 5;    // Menu close event\nconst int EVENT_INIT        = 6;    // Initialization event\nconst int EVENT_SEL_PREV    = 7;    // Select event of the previous menu item\nconst int EVENT_SEL_NEXT    = 8;    // Select event of the next menu item\n</code></pre>"},{"location":"zengin/scripts/classes/c_menu/#items","title":"items","text":"<p>An array of items belonging to this menu. It is possible to use up to 150 items in one menu. The same elements can be used for different menus. The element instance is specified as the value. </p> <pre><code>// Menu\ninstance MENU_MAIN(C_MENU_DEF)\n{\n...\nitems[0]        = \"MENUITEM_MAIN_HEADLINE\";         items[1]        = \"MENUITEM_MAIN_HEADLINE2\";\nitems[2]        = \"MENUITEM_MAIN_NEWGAME\";\n...\n};\n// Menu elements: labels, checkboxes, sliders, etc.\ninstance MENUITEM_MAIN_HEADLINE(C_MENU_ITEM_DEF)\n{\n...\n};\ninstance MENUITEM_MAIN_HEADLINE2(C_MENU_ITEM_DEF)\n{\n...\n};\ninstance MENUITEM_MAIN_NEWGAME(C_MENU_ITEM_DEF)\n{\n...\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_menu/#flags","title":"flags","text":"<p>Menu flags. </p> <p>The list of flag constants can be found in the file <code>Scripts/System/_intern/Menu.d</code></p> <pre><code>const int MENU_OVERTOP          = 1;    // Show menu over previous menu or in game\nconst int MENU_EXCLUSIVE        = 2;    // Close all previous menus. Only the active menu is displayed\nconst int MENU_NOANI            = 4;    // No animation\nconst int MENU_DONTSCALE_DIM    = 8;    // Don't Scale Menu Sizes\nconst int MENU_DONTSCALE_POS    = 16;   // Empty flag\nconst int MENU_ALIGN_CENTER     = 32;   // Center Align Menu\nconst int MENU_SHOW_INFO        = 64;   // Display information at the bottom of the description menu from menu items text[1]\n</code></pre> <ul> <li>MENU_OVERTOP - Flag to display the menu over the previous menu. It is not advisable to use with a transparent menu.</li> <li>MENU_EXCLUSIVE - Hide all menus except the active one. When closed, the previous menu is restored.</li> <li>MENU_NOANI - Animation of minimizing and maximizing windows. The game is mainly used for dialogue windows. You can't enable or disable the animation of dialog windows through scripts. This is done using the <code>animatedWindows</code> setting in the Gothic.ini file.</li> <li>MENU_DONTSCALE_DIM - Scale the menu to fit 640x480 resolution.</li> <li>MENU_DONTSCALE_POS - Empty flag. Not used.</li> <li>MENU_ALIGN_CENTER - Align the menu to the center of the screen.</li> <li>MENU_SHOW_INFO - Display information at the bottom of menu description from menu item <code>text[1]</code>.</li> </ul>"},{"location":"zengin/scripts/classes/c_menu/#defaultoutgame","title":"defaultOutGame","text":"<p>The menu item that is highlighted by default when the game is not running.</p> <p>A value of -1 enables automatic selection of the first selectable element.</p> <p>Items with the <code>~IT_SELECTABLE</code> flag are not selected.</p>"},{"location":"zengin/scripts/classes/c_menu/#defaultingame","title":"defaultInGame","text":"<p>Menu item highlighted by default when the game is running.</p> <p>A value of -1 enables automatic selection of the first selectable element.</p> <p>Items with the <code>~IT_SELECTABLE</code> flag are not selected.</p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/","title":"C_MUSICSYS_CFG","text":""},{"location":"zengin/scripts/classes/c_musicsys_cfg/#c_musicsys_cfg-daedalus-class","title":"C_MUSICSYS_CFG Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>Class <code>C_MusicSys_CFG</code> defines the global settings for the game's music.</p> <p>An instance of this class is declared only once.</p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#class-definition","title":"Class definition","text":"<p>Class definition as it is defined in <code>Scripts/System/_intern/Music.d</code> script file.</p> C_MusicSys_CFG Daedalus class <pre><code>class C_MusicSys_CFG\n{\nvar float volume;               // Music volume\nvar int   bitResolution;        // Sound quality\nvar int   globalReverbEnabled;  // Enable global reverb\nvar int   sampleRate;           // Frequency\nvar int   numChannels;          // Sound channels\nvar int   reverbBufferSize;     // Reverb buffer size\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#class-members","title":"Class members","text":"Variable Type Description volume float Overall game music volume bitResolution int Sound quality globalReverbEnabled int Enable global reverb sampleRate int Frequency numChannels int Number of sound chanells reverbBufferSize int The size of reverb buffer"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#class-member-overview","title":"Class member overview","text":"<p>Description of the class member variables.</p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#volume","title":"volume","text":"<p>The overall volume of the background music (soundtrack). From 0.0 to 1.0. </p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#bitresolution","title":"bitResolution","text":"<p>Sound quality. 8 or 16 bit. </p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#globalreverbenabled","title":"globalReverbEnabled","text":"<p>Enable global reverb. </p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#samplerate","title":"sampleRate","text":"<p>Frequency. From 11050 to 44100. </p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#numchannels","title":"numChannels","text":"<p>Number of sound channels. From 16 to 32. </p>"},{"location":"zengin/scripts/classes/c_musicsys_cfg/#reverbbuffersize","title":"reverbBufferSize","text":"<p>The size of the reverb buffer. </p>"},{"location":"zengin/scripts/classes/c_musictheme/","title":"C_MUSICTHEME","text":""},{"location":"zengin/scripts/classes/c_musictheme/#c_musictheme-daedalus-class","title":"C_MUSICTHEME Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>Class <code>C_MusicTheme</code> describes musical themes.</p>"},{"location":"zengin/scripts/classes/c_musictheme/#class-definition","title":"Class definition","text":"<p>Class definition as it is defined in <code>Scripts/System/_intern/Music.d</code> script file.</p> C_MusicTheme Daedalus class <pre><code>class C_MusicTheme\n{\nvar string      file;           // Sound file in DirectMusic `.sgt` format\nvar float       vol;            // Sound volume\nvar int         loop;           // Enable cycle\nvar float       reverbMix;      // Reverb mixing\nvar float       reverbTime;     // Reverb time\nvar int         transType;      // Type of transition to the next theme\nvar int         transSubType;   // Subtype of transition to the next theme song\n};\n</code></pre>"},{"location":"zengin/scripts/classes/c_musictheme/#class-members","title":"Class members","text":"Variable Type Description file string Sound file in DirectMusic <code>.sgt</code> format vol float Sound volume loop int Enable/disable cycle reverbMix float Reverb mixing reverbTime float Reverb time transType int The type of transition to the next theme song transSubType int The subtype of transition to the next theme song"},{"location":"zengin/scripts/classes/c_musictheme/#class-member-overview","title":"Class member overview","text":"<p>Description of the class member variables.</p>"},{"location":"zengin/scripts/classes/c_musictheme/#file","title":"file","text":"<p>DirectMusic sound in *.sgt format or MIDI file. </p>"},{"location":"zengin/scripts/classes/c_musictheme/#vol","title":"vol","text":"<p>The volume of the theme song. From 0.0 to 1.0. </p>"},{"location":"zengin/scripts/classes/c_musictheme/#loop","title":"loop","text":"<p>Enable/disable theme music looping. Disabled = 0. Enabled = 1. </p>"},{"location":"zengin/scripts/classes/c_musictheme/#reverbmix","title":"reverbMix","text":"<p>Reverb mixing. Measured in decibels. </p>"},{"location":"zengin/scripts/classes/c_musictheme/#reverbtime","title":"reverbTime","text":"<p>Reverberation time in milliseconds.</p>"},{"location":"zengin/scripts/classes/c_musictheme/#transtype","title":"transType","text":"<p>The type of transition to the next theme song. </p> <p>The list of constants for all transitions types is described in the file <code>Scripts/System/_intern/Music.d</code></p> <pre><code>const int TRANSITION_TYPE_NONE          = 1;    // No transition\nconst int TRANSITION_TYPE_GROOVE        = 2;    // Ripple\nconst int TRANSITION_TYPE_FILL          = 3;    // Padding\nconst int TRANSITION_TYPE_BREAK         = 4;    // Break\nconst int TRANSITION_TYPE_INTRO         = 5;    // Introductory\nconst int TRANSITION_TYPE_END           = 6;    // End topic\nconst int TRANSITION_TYPE_ENDANDINTRO   = 7;    // End and start new\n</code></pre>"},{"location":"zengin/scripts/classes/c_musictheme/#transsubtype","title":"transSubType","text":"<p>The subtype of transition to the next theme song. </p> <p>The list of constants for all transitions subtypes is described in the file <code>Scripts/System/_intern/Music.d</code></p> <pre><code>const INT TRANSITION_SUB_TYPE_IMMEDIATE = 1;    // Instant transition\nconst INT TRANSITION_SUB_TYPE_BEAT      = 2;    // Rhythmic transition\nconst INT TRANSITION_SUB_TYPE_MEASURE   = 3;    // Gradual transition\n</code></pre>"},{"location":"zengin/scripts/classes/c_musictheme/#name-features","title":"Name features","text":"<p>The musical themes of the game are played depending on the game situation. By default, the theme with the <code>_STD</code> (standard) suffix is played. In case of a threat, the <code>_THR</code> (threat) theme will be played. During the combat the <code>_FGT</code> (fight) theme plays. </p> <p></p><pre><code>instance WOO_DAY_STD(C_MUSICTHEME_STANDARD)\n{\nfile = \"woo_daystd.sgt\";\n};\ninstance WOO_DAY_THR(C_MUSICTHEME_THREAT)\n{\nfile = \"woo_daythr.sgt\";\n};\ninstance WOO_DAY_FGT(C_MUSICTHEME_FIGHT)\n{\nfile = \"woo_dayfgt.sgt\";\n};\n</code></pre> In addition, the suffix <code>_DAY_</code> and <code>_NGT_</code> determines whether the theme should be played on day or night. <pre><code>instance OWD_DAY_FGT(C_MUSICTHEME_FIGHT)\n{\nfile = \"owp_dayfgt.sgt\";\n};\ninstance OWD_NGT_STD(C_MUSICTHEME_STANDARD)\n{\nfile = \"owd_daystd.sgt\";\n};\n</code></pre> <p>Tip</p> <p>In G2 the <code>C_MUSICTHEME_STANDARD</code>, <code>C_MUSICTHEME_THREAT</code> and <code>C_MUSICTHEME_FIGHT</code> prototypes are used by default.</p>"},{"location":"zengin/scripts/classes/c_svm/","title":"C_SVM","text":""},{"location":"zengin/scripts/classes/c_svm/#c_svm-daedalus-class","title":"C_SVM Daedalus class","text":"<p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p> <p>The <code>C_SVM</code> class is used to define sound dialogues (smalltalk, reactions) that are defined for every C_NPC.voice.</p>"},{"location":"zengin/scripts/classes/c_svm/#class-definition","title":"Class definition","text":"<p><code>C_SVM</code> class is the only class with variable number of members. The <code>C_SVM</code> definition in the scripts dictates the content of the class. Every Gothic game has a different number of SVM entries. As an interesting information (more than anything else) we include a table with the numbers of voice lines and voices below.</p> Game voice lines voices Gothic 1 136 17 Gothic Sequel 110 17 (30 planned) Gothic 2 202 19 Gothic 2 Addon 235 19 Chronicles of Myrtana 1346 73 Returning New Balance 495 19"},{"location":"zengin/scripts/classes/c_svm/#rules","title":"Rules","text":"<p>The number of instances is defined by a constant integer with a specified name read by the engine. </p><pre><code>const int SVM_MODULES = 18;\n</code></pre> <p>Info</p> <p>The value <code>SVM_MODULES = 18</code> means 18 SVMs will be parsed by the engine and because the first one, <code>SVM_0</code>, is empty, the final number of voices is 18 - 1 = 17.</p> <p>Instances of the <code>C_SVM</code> class must have the name <code>SVM_XXX</code>. </p><pre><code>instance svm_1(c_svm)\n{\n// ...\n};\n</code></pre> The first instance <code>svm_0</code> is always empty, it is used internally by the engine. <pre><code>instance svm_0(c_svm) {};\n</code></pre>"},{"location":"zengin/scripts/classes/c_svm/#usage-in-the-scripts","title":"Usage in the scripts","text":"<p>While some defined SVMs are used automatically by the engine - the 20 smalltalk lines for example, others are used in the scripts. To instruct the engine to run a specific SVM, external function <code>AI_OutputSVM</code> is used. In the original scripts it is wrapped in a script function B_Say. To reference the SVM, you use the <code>$</code> symbol followed by the name of the member variable in the <code>C_SVM</code> class definition. </p><pre><code>// some code\n{\nPrintScreen    (\"Not enough skill points!\", -1,-1,\"FONT_OLD_20_WHITE.TGA\",1);\nB_Say (self, other, \"$NOLEARNNOPOINTS\");\n};\n// some code\n</code></pre> Here the <code>$NOLEARNNOPOINTS</code> references the <code>var string NoLearnNoPoints</code> in SVM.D. The voice is then chosen automatically by the engine. <pre><code>class C_SVM\n{\n//...\n// Teacher comments\nvar string NoLearnNoPoints;       // NPC teacher doesn't teach - not enough learning points!\nvar string NoLearnOverMax;        // NPC teacher doesn't teach - cannot teach above 100 points!\nvar string NoLearnYouAlreadyKnow; // You have to know something to become a master!\nvar string NoLearnYoureBetter;    // You are better than the teacher!\n//...\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/","title":"Daedalus extenders","text":""},{"location":"zengin/scripts/extenders/#daedalus-extenders","title":"Daedalus extenders","text":"<p>The default scripting language Daedalus can be quite limiting. Over the years the community created quite a few extenders to, well, extend the functionality. Before Union came along, the standard to interface with the engine was the script library Ikarus and a collection of packages LeGo built on top of that. Not so recently, an additional script packet was made (and is actively being worked on) AF Script Packet that offers even more functionality and is built on top of Ikarus &amp; LeGo. With the adoption of Union and plugins the Union system can use a new extender emerged called zParserExtender. Other Union plugins can, of course, implement their own external functions. A lot of scripts are also scattered on the Gothic forums, and documentation of some of them can be found in the Standalone section.</p>"},{"location":"zengin/scripts/extenders/afsp/","title":"AF Script Packet","text":""},{"location":"zengin/scripts/extenders/afsp/#af-script-packet","title":"AF Script Packet","text":"<p>Auronen &amp; Fawkes' Script Packet is a script package built on top of Ikarus and LeGo. It implements many features and there is also a Union version which is in its infancy stage.</p> <p>Note</p> <p>AFSP's documentation is lacking (@Auronen: \"My fault\"). The authors will host the documentation on GMC.</p> Contacts Authors  Fawkes &amp; Auronen GitHub  AFSP Forum  AFSP"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/","title":"Enhanced Info Manager","text":""},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#enhanced-information-manager","title":"Enhanced Information Manager","text":"<p>Warning</p> <p>This is a quick paste-in of and old version of AFSP's documentation and the information should be taken with a grain of salt. It may not be up-to-date since AFSP is being developed all the time and this is only a demo page.</p> <p>Enhanced Information Manager allows you to more precisely control the Information Manager (dialogue manager). Change color, font and much more! This package \"scans\" the dialogue string for modifiers and alters the string based on the modifiers you specify.</p>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#initialization","title":"Initialization","text":"<p>To use this feature you have to:</p> <ol> <li>Add <code>_headers_G[1/2]_EnhancedInfoManager.src</code> or <code>_headers_G[1/2]_All.src</code> to your <code>Gothic.src</code> after Ikarus and LeGo initialization.</li> <li>Call <code>G12_EnhancedInfoManager_Init();</code> from your <code>INIT_GLOBAL()</code> function in <code>Startup.d</code></li> </ol>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-colour","title":"Change colour","text":"<p>Set font color for a dialogue choice. </p><pre><code>h@[hex color value]\n</code></pre> Set font color for highlighted dialogue choice. <pre><code>hs@[hex color value]\n</code></pre> Example<pre><code>description = \"h@2a85a3 hs@2ea9d1 This dialogue is blue.\";\n</code></pre>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-font","title":"Change font","text":"<p>Set font itself for a dialogue choice. </p><pre><code>f@[font name]\n</code></pre> Set font itself for highlighted dialogue choice. <pre><code>fs@[font name]\n</code></pre> Example<pre><code>description = \"f@font_old_20_white.tga fs@font_old_10_white.tga This dialogue has a different font, when selected.\";\n</code></pre>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#change-text-alignment","title":"Change text alignment","text":"<p>Align text left. </p><pre><code>al@\n</code></pre> Align text center. <pre><code>ac@\n</code></pre> Align text right. <pre><code>ar@\n</code></pre> Example<pre><code>description = \"al@ This dialogue has LEFT alignment.\";\ndescription = \"ac@ This dialogue has CENTER alignment.\";\ndescription = \"ar@ This dialogue has RIGHT alignment.\";\n</code></pre>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#disable-dialogue","title":"Disable dialogue","text":"<p>Player cannot highlight (and select) this dialogue. </p><pre><code>d@\n</code></pre>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#text-input-field","title":"Text input field","text":"<p>Input field allows you to turn a dialogue choice into an input text field. </p><pre><code>a@\n</code></pre> Example<pre><code>INSTANCE DIA_Xardas_Password (C_Info)\n{\nnpc         = NONE_100_Xardas;\nnr          = 1;\ncondition   = DIA_Xardas_Password_Condition;\ninformation = DIA_Xardas_Password_Info;\npermanent   = FALSE;\ndescription = \"a@ What is the password to get to the Mages of Water?\";\n};\nFUNC INT DIA_Xardas_Password_Condition () {\nreturn TRUE;\n};\nFUNC VOID DIA_Xardas_Password_Info () {\nif (Hlp_StrCmp (InfoManagerAnswer, \"TETRIANDOCH\"))\n{\nPrintScreen (\"Yes that is correct!\", -1, -1, \"font_old_10_white.tga\", 3);\n}\nelse\n{\nPrintScreen (\"No that is wrong!\", -1, -1, \"font_old_10_white.tga\", 3);\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#dialogue-numbers","title":"Dialogue numbers","text":"<p>This feature shows a dialogue number next to the dialogue line (visual for Dialogue keyboard controls). To turn this on you just set <code>InfoManagerNumKeysNumbers</code> variable to true. (in your <code>INIT_GLOBAL()</code> function). </p><pre><code>InfoManagerNumKeysNumbers = TRUE;\n</code></pre>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#dialogue-keyboard-controls","title":"Dialogue keyboard controls","text":"<p>Note</p> <p>This has also been fixed in Union and we noticed a strange behavior with different keyboard layouts.</p> <p>This feature changes the way number keys affect dialogue selection. The first dialogue is no longer 0 and you highlight the dialogue option by pressing appropriate number. </p><pre><code>InfoManagerNumKeysControls = TRUE;\n</code></pre>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#spinners","title":"Spinners","text":"<p>This is by far the most flashy feature of EIM as it allows you to use left/right arrow keys on a dialogue option to increase/decease numerical value. This can be used in many ways.</p> <p>This feature is a bit more complex:  </p> <ol> <li> <p>Set up a standard dialogue</p> <p>Notice</p> <p>Notice we are using \"dummy\" as a description, since it is going to get updated. If something goes wrong the \"dummy\" string shows up and you can clearly tell something went wrong.</p> <pre><code>INSTANCE PC_Pan_Cook_Meat (C_Info)\n{\nnr           = 1;\ncondition    = PC_Pan_Cook_Meat_Condition;\ninformation  = PC_Pan_Cook_Meat_Info;\npermanent    = TRUE;\ndescription  = \"dummy\"; //Description is updated in PC_Pan_Cook_Meat_Condition\n};\n</code></pre> </li> <li> <p>Most of the magic takes place in the condition function (apart from the code behind the scenes, of course).</p> <pre><code>var int selectedMeat; // global variable for this spinner value\nFUNC INT PC_Pan_Cook_Meat_Condition ()\n{\nif (PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN)\n{\nvar string lastSpinnerID;\nvar int total; total = NPC_HasItems (self, ItFoMuttonRaw);\nif (selectedMeat == 0) { selectedMeat = 1; }; //Default initial value\n//Check currently selected spinned ID --&gt; is it this one?\nif (Hlp_StrCmp (InfoManagerSpinnerID, \"CookMeat\"))\n{\n//Setup spinner if spinner ID has changed\nif (!Hlp_StrCmp (InfoManagerSpinnerID, lastSpinnerID))\n{\n//Restore previous value\nInfoManagerSpinnerValue = selectedMeat;\n};\n//Page Up/Down quantity\nInfoManagerSpinnerPageSize = 5;\n//Min/Max value (Home/End keys)\nInfoManagerSpinnerValueMin = 1;\nInfoManagerSpinnerValueMax = total;\n//Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT\nselectedMeat = InfoManagerSpinnerValue;\n};\nlastSpinnerID = InfoManagerSpinnerID; //Remember last active spinner ID\nvar string newDescription;\n//Spinner ID 'CookMeat'\nnewDescription = \"s@CookMeat Cook some meat: \";\nnewDescription = ConcatStrings (newDescription, IntToString (selectedMeat));\nnewDescription = ConcatStrings (newDescription, \" / \");\nnewDescription = ConcatStrings (newDescription, IntToString (total));\n//Update description\nPC_Pan_Cook_Meat.description = newDescription;\nreturn TRUE;\n};\nreturn FALSE;\n};\n</code></pre> </li> <li> <p>We can use the spinner value stored in <code>selectedMeat</code> variable here in the info function to create the meat (or do other stuff with it).</p> <pre><code>FUNC VOID PC_Pan_Cook_Meat_Info () {\n//If we don't have any meat ... don't cook any :)\nif (!NPC_HasItems (self, ItFoMuttonRaw)) { return; };\n//This should not happen - but you never know!\nif (selectedMeat &lt; 1) { return; };\n//This should not happen either! but just in case\nif (selectedMeat &gt; (NPC_HasItems (self, ItFoMuttonRaw))) {\nselectedMeat = NPC_HasItems (self, ItFoMuttonRaw);\n};\nNPC_RemoveInvItems (self, ItFoMuttonRaw, selectedMeat);\nCreateInvItems (self, ItFoMutton, selectedMeat);\n//Reset value for next time\nselectedMeat = 1;\n};\n</code></pre> </li> </ol>"},{"location":"zengin/scripts/extenders/afsp/afsp_eim/#spinners-full-code-example","title":"Spinners: Full code example","text":"Spinner example <pre><code>INSTANCE PC_Pan_Cook_Meat (C_Info)\n{\nnr           = 1;\ncondition    = PC_Pan_Cook_Meat_Condition;\ninformation  = PC_Pan_Cook_Meat_Info;\npermanent    = TRUE;\ndescription  = \"dummy\"; //Description is updated in PC_Pan_Cook_Meat_Condition\n};\nvar int selectedMeat;\nFUNC INT PC_Pan_Cook_Meat_Condition ()\n{\nif (PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN)\n{\nvar string lastSpinnerID;\nvar int total; total = NPC_HasItems (self, ItFoMuttonRaw);\nif (selectedMeat == 0) { selectedMeat = 1; }; //Default initial value\n//Check currently selected spinned ID --&gt; is it this one?\nif (Hlp_StrCmp (InfoManagerSpinnerID, \"CookMeat\"))\n{\n//Setup spinner if spinner ID has changed\nif (!Hlp_StrCmp (InfoManagerSpinnerID, lastSpinnerID))\n{\n//Restore previous value\nInfoManagerSpinnerValue = selectedMeat;\n};\n//Page Up/Down quantity\nInfoManagerSpinnerPageSize = 5;\n//Min/Max value (Home/End keys)\nInfoManagerSpinnerValueMin = 1;\nInfoManagerSpinnerValueMax = total;\n//Update number which is shown in description (in case it was changed by _HOOK_VIEWDIALOGCHOICE_HANDLEEVENT\nselectedMeat = InfoManagerSpinnerValue;\n};\nlastSpinnerID = InfoManagerSpinnerID; //Remember last active spinner ID\nvar string newDescription;\n//Spinner ID 'CookMeat'\nnewDescription = \"s@CookMeat Cook some meat: \";\nnewDescription = ConcatStrings (newDescription, IntToString (selectedMeat));\nnewDescription = ConcatStrings (newDescription, \" / \");\nnewDescription = ConcatStrings (newDescription, IntToString (total));\n//Update description\nPC_Pan_Cook_Meat.description = newDescription;\nreturn TRUE;\n};\nreturn FALSE;\n};\nFUNC VOID PC_Pan_Cook_Meat_Info ()\n{\n//If we don't have any meat ... don't cook any :)\nif (!NPC_HasItems (self, ItFoMuttonRaw)) { return; };\n//This should not happen - but you never know!\nif (selectedMeat &lt; 1) { return; };\n//This should not happen either! but just in case\nif (selectedMeat &gt; (NPC_HasItems (self, ItFoMuttonRaw)))\n{\nselectedMeat = NPC_HasItems (self, ItFoMuttonRaw);\n};\nNPC_RemoveInvItems (self, ItFoMuttonRaw, selectedMeat);\nCreateInvItems (self, ItFoMutton, selectedMeat);\n//Reset value for next time\nInfoManagerSpinnerValue = 1;\n};\nINSTANCE PC_Pan_Cook_Meat_Exit (C_Info)\n{\nnr          = 999;\ncondition   = PC_Pan_Cook_Meat_Exit_Condition;\ninformation = PC_Pan_Cook_Meat_Exit_Info;\npermanent   = TRUE;\ndescription = \"End\";\n};\nFUNC INT PC_Pan_Cook_Meat_Exit_Condition ()\n{\nif (PLAYER_MOBSI_PRODUCTION == MOBSI_DIALOG_PAN)\n{\nreturn TRUE;\n};\nreturn FALSE;\n};\nFUNC VOID PC_Pan_Cook_Meat_Exit_Info ()\n{\nif (PLAYER_MOBSI_PRODUCTION != MOBSI_DIALOG_NONE)\n{\nPLAYER_MOBSI_PRODUCTION = MOBSI_DIALOG_NONE;\nhero.aivar[AIV_INVINCIBLE] = FALSE;\nAI_StopProcessInfos (hero);\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/","title":"Ikarus","text":""},{"location":"zengin/scripts/extenders/ikarus/#ikarus","title":"Ikarus","text":"<p>Ikarus is a Daedalus library for Gothic. It exploits the interpreter to allow arbitrary memory access and defines tonne of useful functions for interfacing with the engine. </p> Contacts Author  Sektenspinner &amp; contributors GitHub  Ikarus Forum  Ikarus <p>Author Note (by Sektenspinner)</p> <p>This script package is not called Ikarus for nothing:</p> <p>One can leave the boundaries of Daedalus behind, but may also crash and burn. For instance, reading from invalid addresses won't trigger a zSpy warning but will result in a desktop crash with an Access Violation. This is not a reason to panic but requires a tolerance for frustration (which can be useful for scripters in general).</p> <p>Of course, such spectacular-looking errors can be fixed, and with focused and systematic work, something sensible can be achieved.</p> <p>In short: Extra care is needed! A bug that leads to a crash is not something you want in the release version. But if you work cleanly and test extensively, it's not such a big deal.</p> <p>A good friend in debugging crashes is undoubtedly <code>PrintDebug</code>. It allows sending messages to zSpy (for example, to narrow down where the crash is occurring). It's worth enabling debug messages by <code>MEM_SetShowDebug</code> and the text filter (Options -&gt; Textfilter) in zSpy.</p> <p>Note</p> <p>Ikarus is hosted on GitHub and the documentation is built in. The translation is planned.</p>"},{"location":"zengin/scripts/extenders/ikarus/constants/","title":"Constants","text":""},{"location":"zengin/scripts/extenders/ikarus/constants/#ikarus-user-constants","title":"Ikarus User Constants","text":"<p>In the Constants file, you'll find user variables that control various aspects, including the debug output of Ikarus. You can customize these variables to suit your needs.</p>"},{"location":"zengin/scripts/extenders/ikarus/constants/#mem-helper","title":"MEM-Helper","text":"<ul> <li><code>const string MEM_FARFARAWAY</code>     Waypoint where the Mem-Helper is spawned (default: <code>\"TOT\"</code>)</li> <li><code>const string MEM_HELPER_NAME</code>     Name of the Mem-Helper (default: <code>\"MEMHLP\"</code>)</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/constants/#debug","title":"Debug","text":"<ul> <li><code>const int zERR_ErrorBoxOnlyForFirst</code>     Controls whether only the first error should trigger an error box (default: <code>1</code>).</li> <li><code>const int zERR_StackTraceOnlyForFirst</code>     Determines if stack traces should be displayed only for the first error (default: <code>0</code>).</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/constants/#mem_debug","title":"MEM_Debug","text":"<p>The <code>MEM_Debug</code> function allows you to set up a custom message channel for debugging purposes. You can adjust the following variables to configure this channel:</p> <ul> <li><code>const string zERR_DEBUG_PREFIX</code>     Specifies a prefix to be added to each debug message (default: <code>\"Debug: \"</code>).</li> <li><code>const int zERR_DEBUG_TOSPY</code>     Controls whether <code>MEM_Debug</code> messages should be sent to zSpy (default: <code>1</code>).</li> <li><code>const int zERR_DEBUG_TYPE</code>     Specifies the message type for <code>MEM_Debug</code> messages when sent to zSpy (default: <code>zERR_TYPE_INFO</code>).</li> <li><code>const int zERR_DEBUG_TOSCREEN</code>     Determines whether <code>MEM_Debug</code> messages should be printed to the screen (default: <code>0</code>).</li> <li><code>const int zERR_DEBUG_ERRORBOX</code>     Allows you to display an error box for <code>MEM_Debug</code> messages (default: <code>0</code>).</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/constants/#error-message-types","title":"Error message types","text":"<pre><code>const int zERR_TYPE_OK    = 0; /* [ungenutzt]        */\nconst int zERR_TYPE_INFO  = 1; /* MEM_Info           */\nconst int zERR_TYPE_WARN  = 2; /* MEM_Warn           */\nconst int zERR_TYPE_FAULT = 3; /* MEM_Error          */\nconst int zERR_TYPE_FATAL = 4; /* [ungenutzt]        */\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/","title":"Examples","text":""},{"location":"zengin/scripts/extenders/ikarus/examples/#ikarus-examples","title":"Ikarus examples","text":"<p>A collection of examples ported from the original Ikarus documentation.</p> <p>Note</p> <p>The original Ikarus documentation is a part of the code. You can find it in the GitHub repository.</p>"},{"location":"zengin/scripts/extenders/ikarus/examples/#open-focused-chest-or-door","title":"Open focused chest or door","text":"<pre><code>func void OpenFocussedChestOrDoor() {\nvar oCNpc her; her = Hlp_GetNpc(hero);\n// No focus vob at all?\nif (!her.focus_vob) {\nPrint (\"No focus!\");\nreturn;\n};\n// Focus vob not a lockable vob?\nif (!Hlp_Is_oCMobLockable(her.focus_vob))\n{\nPrint (\"No chest or door in focus!\");\nreturn;\n};\nvar oCMobLockable Lockable;\nLockable = MEM_PtrToInst (her.focus_vob);\nif (Lockable.bitfield &amp; oCMobLockable_bitfield_locked) {\nLockable.bitfield = Lockable.bitfield &amp; ~ oCMobLockable_bitfield_locked;\nPrint (ConcatStrings (\"Opened the following vob: \", Lockable._zCObject_objectName));\n} else\n{\nPrint (ConcatStrings ( Lockable._zCObject_objectName, \"wasn't even complete!\"));\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#print-camera-position","title":"Print camera position","text":"<pre><code>func void PrintCameraPos()\n{\n// Initialize global instances (which only exist once):\n// Initializes MEM_World, MEM_Game, etc. including MEM_Camera\nMEM_InitGlobalInst();\n/* The camera object is not a vob (but something abstract), \n    do not know where and how there are position data.\n    I prefer to work on the camera vob : */\nvar zCVob camVob;\ncamVob = MEM_PtrToInst (MEM_Camera.connectedVob);\n/* Here you have to know how the transformation matrix is structured:\n    It consists of three vectors, the x, y and z directions of the local coordinate system of the camera vob\n    in world coordinates (where z specifies the\n    line of sight). These vectors are\n    denoted by v1, v2, v3.\n    In addition, in the 4th column there is the translation,\n    that is, the position of the camera.\n    v1_x v2_x v3_x x\n    v1_y v2_y v3_y y\n    v1_z v3_z v3_z z\n    0 0 0 0\n    The matrix is stored row by row in memory.\n    Since we are interested in the last column are the indices\n    in the trafoWorld Array 3, 7 and 11 that we need. */\nPrint (ConcatStrings (\"x: \",IntToString(roundf(camVob.trafoObjToWorld[3]))));\nPrint (ConcatStrings (\"y: \",IntToString(roundf(camVob.trafoObjToWorld[7]))));\nPrint (ConcatStrings (\"z: \",IntToString(roundf(camVob.trafoObjToWorld[11]))));\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#start-rain","title":"Start rain","text":"<pre><code>func void StartRain()\n{\n// Initialize global instances\n// This also includes Skycontroller\nMEM_InitGlobalInst(); // start at the beginning of the day (12:00 noon)\nMEM_SkyController.rainFX_timeStartRain = 0; // FLOATNULL constant\n// end at the end of the day (12:00 noon of the next day)\nMEM_SkyController.rainFX_timeStopRain = 1065353216; // FLOATONE constant\n/* Note: The start and end times are floating point numbers.\n    * 0 stands for the beginning of the day 1 for the end of the day.\n    * a day in the game begins at 12:00 p.m.\n    * For the structure of the floating point format, google for IEEE-745.*/\n/* Result: rain all day! (unless you are in a zone\n    * in which it snows, then snow all day) */\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#nested-loop","title":"Nested loop","text":"<pre><code>// Should enumerate all pairs (x,y) with 0 &lt;= x &lt; max_x, 0 &lt;= j &lt; max_y\nfunc void printpairs(var int max_x, var int max_y)\n{\n// Initialize labels\nMEM_InitLabels();\n// PrintDebug should be used, i.e. activate debug output\nMEM_SetShowDebug (1);\nvar int x; var int y; x = 0;\n// while (x &lt; max_x)\nvar int x_loop; x_loop = MEM_StackPos.position;\nif (x &lt; max_x)\n{ y = 0;\n// while (y &lt; max_y) \nvar int y_loop; y_loop = MEM_StackPos.position;\nif (y &lt; max_y)\n{ var string out; out = \"(\";\nout = ConcatStrings (out, IntToString (x));\nout = ConcatStrings (out, \", \");\nout = ConcatStrings (out, IntToString (y));\nout = ConcatStrings (out, \")\");\nPrintDebug (out);\ny += 1;\n// continue y_loop \nMEM_StackPos.position = y_loop;\n};\nx += 1;\n// continue x_loop\nMEM_StackPos.position = x_loop;\n};\n};\n/*\n    Output of a call printpairs(4,2) would then be: \n    00:36 Info: 5 U: Skript: (0, 0) .... \n    00:36 Info: 5 U: Skript: (0, 1) .... \n    00:36 Info: 5 U: Skript: (1, 0) .... \n    00:36 Info: 5 U: Skript: (1, 1) .... \n    00:36 Info: 5 U: Skript: (2, 0) .... \n    00:36 Info: 5 U: Skript: (2, 1) .... \n    00:36 Info: 5 U: Skript: (3, 0) .... \n    00:36 Info: 5 U: Skript: (3, 1) .... \n*/\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/examples/#calling-a-function-by-their-name","title":"Calling a function by their name","text":"<pre><code>// This example doesn't show why MEM_CallByString * is useful, but how to use the function.\nvar zCVob someObject;\nfunc int MyFunction(var int param1, var string str1, var int param2, var string str2)\n{\nPrint (ConcatStrings (str1, str2)); //(*)\nreturn 100 * param1 + param2;\n};\nfunc void foo()\n{ var int result;\n// The following code is in this case equivalent to:\n// result = MyFunction(42, \"Hello\", 23, \"World!\");\n// Lay the call arguments on the call stack\nMEM_PushIntParam (42);\nMEM_PushStringParam (\"Hello \");\nMEM_PushIntParam (23);\nMEM_PushStringParam (\"World!\");\nMEM_CallByString (\"MYFUNCTION\");\n// the function puts the result (of type int in this case) on the stack\n// we pop the int result and save it to a variable\nresult = MEM_PopIntResult();\n// print the result\nPrint (IntToString (result));\n};\n/*\n    Note: Since symbol indices are continuous and someObject's symbol index \n    is simply given by someObject itself, could\n    MEM_CallByString(\"MYFUNCTION\"); \n    also be replaced here by \n    MEM_CallByID(someObject + 1);\n*/\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/floats/","title":"Floats","text":""},{"location":"zengin/scripts/extenders/ikarus/floats/#floats","title":"Floats","text":"<p>This part of ikarus implements support for 32 bit IEEE 754 floats in Daedalus. The script was originally created to edit <code>zFLOAT</code> and <code>zREAL</code> variables, but can also be used to arthmetic operations on real float values (not to be confused with Daedalus floats).</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/floats/#implementation","title":"Implementation","text":"<p> float.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#functions","title":"Functions","text":"<p>Danger</p> <p>Ikarus floats are saved as int but it doesn't mean that you can use arthmetic operators on them. All operations on floats must be done with functions listed below.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#mkf","title":"<code>mkf</code>","text":"<p>(make float) Converts the input integer x to a float value. </p><pre><code>func int mkf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input integer</li> </ul> <p>Return value</p> <p>The function returns the float representation of the input integer x.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#truncf","title":"<code>truncf</code>","text":"<p>(truncate float) Truncates the decimal part of the input float x. </p><pre><code>func int truncf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the integer part of the input float x by discarding the decimal part.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#roundf","title":"<code>roundf</code>","text":"<p>(round float) Rounds the input float x to the nearest integer value. </p><pre><code>func int roundf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the nearest integer value to the input float x. If the decimal part is exactly halfway between two integers, the function rounds to the nearest even integer.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#addf","title":"<code>addf</code>","text":"<p>(add floats) Adds two ikarus floats together. </p><pre><code>func int addf(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The first float</li> <li><code>var int y</code>     The second float</li> </ul> <p>Return value</p> <p>The function returns the sum of the input floats <code>x</code> and <code>y</code>. (x + y)</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#subf","title":"<code>subf</code>","text":"<p>(subtract floats) Subtracts the second float from the first float. </p><pre><code>func int subf(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The first float</li> <li><code>var int y</code>     The second float</li> </ul> <p>Return value</p> <p>The function returns the difference between the first float <code>x</code> and the second float <code>y</code>. (x - y)</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#negf","title":"<code>negf</code>","text":"<p>(negate float) Negates the input float. </p><pre><code>func int negf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the negation of the input float <code>x</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#mulf","title":"<code>mulf</code>","text":"<p>(multiply floats) Multiplies two ikarus floats. </p><pre><code>func int mulf(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The first float</li> <li><code>var int y</code>     The second float</li> </ul> <p>Return value</p> <p>The function returns the product of multiplying the input floats x and y. (x * y)</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#divf","title":"<code>divf</code>","text":"<p>(divide floats) Divides two ikarus floats. </p><pre><code>func int divf(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The dividend float</li> <li><code>var int y</code>     The divisor float</li> </ul> <p>Return value</p> <p>The function returns the quotient of dividing the input float x by y. (x / y)</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#invf","title":"<code>invf</code>","text":"<p>(inverse float) Computes the inverse of the input float. </p><pre><code>func int invf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the inverse of the <code>x</code>, calculated as <code>1/x</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#gf","title":"<code>gf</code>","text":"<p>(greater) Checks if the first float is greater than the second float. </p><pre><code>func int gf(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The first float</li> <li><code>var int y</code>     The second float</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if <code>x</code> is greater than <code>y</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#gef","title":"<code>gef</code>","text":"<p>(greater or equal) Checks if the first float is greater than or equal to the second float. </p><pre><code>func int gef(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The first float</li> <li><code>var int y</code>     The second float</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if <code>x</code> is greater than or equal to <code>y</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#lf","title":"<code>lf</code>","text":"<p>(lower) Checks if the first float is less than the second float. </p><pre><code>func int lf(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The first float</li> <li><code>var int y</code>     The second float</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if <code>x</code> is less than <code>y</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#lef","title":"<code>lef</code>","text":"<p>(lower or equal) Checks if the first float is less than or equal to the second float. </p><pre><code>func int lef(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The first float</li> <li><code>var int y</code>     The second float</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if <code>x</code> is less than or equal to <code>y</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#sqrf","title":"<code>sqrf</code>","text":"<p>(square float) Calculates the square of the float. </p><pre><code>func int sqrf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the square of the input float <code>x</code>, computed as <code>x * x</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#sqrtf","title":"<code>sqrtf</code>","text":"<p>(square root float) Calculates the square root of the float. </p><pre><code>func int sqrtf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the square root of the input float <code>x</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#sqrtf_approx","title":"<code>sqrtf_approx</code>","text":"<p>Calculates the approximate square root of a float. </p><pre><code>func int sqrtf_approx(var int f)\n</code></pre> Parameters <ul> <li><code>var int f</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the approximate square root of the input float as an ikarus float.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#absf","title":"<code>absf</code>","text":"<p>(absolute value) Computes the absolute value of a float. </p><pre><code>func int absf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The input float</li> </ul> <p>Return value</p> <p>The function returns the absolute value of the input float <code>x</code>, which is the value without the negative sign (if present).</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#fracf","title":"<code>fracf</code>","text":"<p>(fraction) Computes the fraction of two integers p and q. </p><pre><code>func int fracf(var int p, var int q)\n</code></pre> Parameters <ul> <li><code>var int p</code>     Numerator</li> <li><code>var int q</code>     Denominator</li> </ul> <p>Return value</p> <p>The function returns the fraction of <code>p</code> divided by <code>q</code> as an ikarus float.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#castfromintf","title":"<code>castFromIntf</code>","text":"<p>Converts an ikarus float to a Daedalus float. </p><pre><code>func float castFromIntf(var int f)\n</code></pre> Parameters <ul> <li><code>var int f</code>     Ikarus float</li> </ul> <p>Return Value</p> <p>The function returns the value <code>f</code> as a Daedalus float.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#casttointf","title":"<code>castToIntf</code>","text":"<p>Converts a Daedalus float to an ikarus float. </p><pre><code>func int castToIntf(var float f)\n</code></pre> Parameters <ul> <li><code>var float f</code>     Daedalus float</li> </ul> <p>Return Value</p> <p>The function returns the value <code>f</code> as an ikarus float.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#tostringf","title":"<code>toStringf</code>","text":"<p>Converts a float value to its string representation. </p><pre><code>func string toStringf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     Input float value</li> </ul> <p>Return value</p> <p>The function returns a string representation of the input float value.</p>"},{"location":"zengin/scripts/extenders/ikarus/floats/#printf","title":"<code>printf</code>","text":"<p>(print float) Prints the float on screen using <code>Print()</code>. </p><pre><code>func void printf(var int x)\n</code></pre> Parameters <ul> <li><code>var int x</code>     The printed float</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/floats/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/ikarus/floats/#simple-operations","title":"Simple operations","text":"<pre><code>var int float1; float1 = mkf(5);        // Create an Ikarus float with value 5\nvar int float2; float2 = mkf(2);        // Create an Ikarus float with value 2\nvar int addResult; addResluts  = addf(float1, float2);     // Add float1 and float2\nvar int subResult; subResults  = subf(float1, float2);     // Subtract float2 from float1\nvar int mulResult; mulRelsults = mulf(float1, float2);     // Multiply float1 by float2\nvar int divResult; divResults  = divf(float1, float2);     // Divide float1 by float2\nprintf(addResult);   // Output: 7\nprintf(subResult);   // Output: 3\nprintf(mulResult);   // Output: 10\nprintf(divResult);   // Output: 2.5\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/setup/","title":"Setup","text":""},{"location":"zengin/scripts/extenders/ikarus/setup/#ikarus-setup","title":"Ikarus Setup","text":""},{"location":"zengin/scripts/extenders/ikarus/setup/#download","title":"Download","text":"<p>First you need to download ikarus from the official github repository. We recommend using the master branch as it contains the latest and most up-to-date version of Ikarus. However, you can also download a specific release if needed.</p>"},{"location":"zengin/scripts/extenders/ikarus/setup/#file-location","title":"File location","text":"<p>Before unpacking the downloaded archive it's needed to create a dedicated folder in <code>&lt;Gothic-dir&gt;\\_work\\Data\\Scripts\\Content</code> directory. You can name this folder as you wish; in this guide, we'll refer to it as the \"MOD\" folder. Unpack the downloaded files into this newly created folder. The archiver should create a folder named <code>Ikarus-master</code> or <code>Ikarus-X.X.X</code>. For better readability change its name to the much simpler <code>Ikarus</code>.</p> <p>Tip</p> <p>It's a good practice to delete any unused files, so delete files for other gothic version than this you are using.</p>"},{"location":"zengin/scripts/extenders/ikarus/setup/#parsing","title":"Parsing","text":"<p>Ikarus consists of three main parts, constants, classes and the Ikarus core. It's essential to parse these in a specific order. Additionally, there is a floats package which isn't essential, but it is highly recommended to parse it, especially if you are working with LeGo that depends on it.</p> <p>The Ikarus Core is identical for both Gothic 1 and 2 and is contained in a single file, <code>Ikarus.d</code>. However, there are separate files for the constants and classes for each engine, and they must be parsed correctly. Ikarus uses a C_NPC and therefore has to be parsed after the C_NPC class (after the <code>classes.d</code> file). There are no other dependencies.</p> <p>Since Ikarus 1.2.1 there is additional <code>.src</code> file for each game engine, to simplify adding files to <code>Gothic.src</code> </p> <p>Warning</p> <p>Following example is for Gothic 2. If you are using Gothic 1 replace the <code>G2</code> at the end of the file/directory name with <code>G1</code>.</p> Gothic.srcGothic.src (Ikarus 1.2.1+) <pre><code>_INTERN\\CONSTANTS.D\n_INTERN\\CLASSES.D\nMOD\\IKARUS\\Ikarus_Const_G2.d\nMOD\\IKARUS\\EngineClasses_G2\\*.d\nMOD\\IKARUS\\Ikarus.d\nMOD\\IKARUS\\float.d\n</code></pre> <pre><code>_INTERN\\CONSTANTS.D\n_INTERN\\CLASSES.D\nMOD\\IKARUS\\IKARUS_G2.SRC\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/setup/#initialization","title":"Initialization","text":"<p>Before you can use Ikarus in your scripts, it must be properly initialized. The initialization process differs between Gothic 1 and Gothic 2.</p>"},{"location":"zengin/scripts/extenders/ikarus/setup/#mem_initall","title":"<code>MEM_InitAll</code>","text":"<p>This is main ikarus initialization function, however it consists of some smaller initialization functions.</p> DeclarationDefinitionList of functions <pre><code>func void MEM_InitAll()\n</code></pre> <pre><code>func void MEM_InitAll() {\nif (!MEMINT_ReportVersionCheck()) {\nreturn;\n};\nMEM_ReinitParser(); /* depends on nothing */\nMEM_InitLabels(); /* depends in MEM_ReinitParser */\nMEM_InitGlobalInst(); /* depends on MEM_ReinitParser */\n/* now I can use MEM_ReplaceFunc, MEM_GetFuncID */\nMEM_GetAddress_Init(); /* depends on MEM_ReinitParser and MEM_InitLabels */\n/* now the nicer operators are available */\nMEM_InitStatArrs(); /* depends on MEM_ReinitParser and MEM_InitLabels */\nASMINT_Init();\nMEMINT_ReplaceLoggingFunctions();\nMEMINT_ReplaceSlowFunctions();\nMEM_InitRepeat();\n/* takes a wail the first time it is called.\n        call it to avoid delay later */\nvar int dump; dump = MEM_GetFuncIDByOffset(0);\n};\n</code></pre> <ul> <li>MEM_ReinitParser</li> <li>MEM_InitLabels</li> <li>MEM_InitGlobalInst</li> <li>MEM_GetAddress_Init</li> <li>MEM_InitStatArrs</li> <li>ASMINT_Init</li> <li>MEM_InitRepeat</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/setup/#gothic-1","title":"Gothic 1","text":"<p>To initialize Ikarus in Gothic 1 you must define your own <code>INIT_GLOBAL</code> function at the top of the <code>Startup.d</code> file. Then the <code>INIT_GLOBAL</code> should be called in every <code>INIT_&lt;location&gt;</code> function (e.g. <code>INIT_SURFACE</code>,<code>INIT_OLDCAMP</code> etc.). <code>INIT_SUB_&lt;location&gt;</code> functions can be skipped in that process.</p> <p>Then in your <code>INIT_GLOBAL</code> function you call <code>MEM_InitAll()</code> initialization function.</p> Startup.d<pre><code>FUNC VOID INIT_GLOBAL()\n{\n// Init Ikarus\nMEM_InitAll ();\n};\n// [...]\nfunc VOID INIT_SURFACE ()\n{\nInit_Global();\nINIT_SUB_SURFACE ();\n};\n// [...]\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/setup/#gothic-2","title":"Gothic 2","text":"<p>Gothic 2 has its own <code>INIT_GLOBAL</code> function, so the initialization process is much simpler. All you have to do is to call <code>MEM_InitAll()</code> in <code>INIT_GLOBAL</code> function located in the <code>Startup.d</code> file.</p> Startup.d<pre><code>FUNC VOID INIT_GLOBAL()\n{\n// Init Ikarus\nMEM_InitAll ();\n};\n// [...]\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/","title":"Arrays (zCArray)","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#arrays-zcarray","title":"Arrays (zCArray)","text":"<p>Set of function for working with ZenGin's <code>zCArray</code> data structure.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraycreate","title":"<code>MEM_ArrayCreate</code>","text":"<p>Creates an empty <code>zCArray</code> (allocates memory) and returns a pointer to it. </p><pre><code>func int MEM_ArrayCreate()\n</code></pre> Return value <p>The function returns a pointer to the created <code>zCArray</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayfree","title":"<code>MEM_ArrayFree</code>","text":"<p>Frees the memory allocated for a <code>zCArray</code> and its data. </p><pre><code>func void MEM_ArrayFree(var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code> to be freed</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayclear","title":"<code>MEM_ArrayClear</code>","text":"<p>Clears the data of a <code>zCArray</code>, freeing the memory used by its elements. The array becomes empty. </p><pre><code>func void MEM_ArrayClear (var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code> to be cleared</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraysize","title":"<code>MEM_ArraySize</code>","text":"<p>Returns the size (number of elements) of an array. </p><pre><code>func int MEM_ArraySize(var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> </ul> <p>Return value</p> <p>The function returns a number of a <code>zCArray</code> elements.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraywrite","title":"<code>MEM_ArrayWrite</code>","text":"<p>Writes a value at a specific position in the <code>zCArray</code>. </p><pre><code>func void MEM_ArrayWrite(var int zCArray_ptr, var int pos, var int value)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int pos</code>      Position in the array where the value will be written</li> <li><code>var int value</code>      Value to be written</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayread","title":"<code>MEM_ArrayRead</code>","text":"<p>Reads the value at a specific position in the <code>zCArray</code>. </p><pre><code>func int MEM_ArrayRead(var int zCArray_ptr, var int pos)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int pos</code>      Position in the array from which the value will be read</li> </ul> <p>Return value</p> <p>The function returns the value at a specific position in the <code>zCArray</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayinsert","title":"<code>MEM_ArrayInsert</code>","text":"<p>Appends a value to the end of the <code>zCArray</code>. The array is automatically resized if it is too small. </p><pre><code>func void MEM_ArrayInsert (var int zCArray_ptr, var int value)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int value</code>      Value to be inserted</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraypush","title":"<code>MEM_ArrayPush</code>","text":"<p>Alias for <code>MEM_ArrayInsert</code>, inserts a value at the end of the <code>zCArray</code>. </p><pre><code>func void MEM_ArrayPush (var int zCArray_ptr, var int value)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int value</code>      Value to be inserted</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraypop","title":"<code>MEM_ArrayPop</code>","text":"<p>Removes and returns the last element from the <code>zCArray</code>. </p><pre><code>func int MEM_ArrayPop(var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> </ul> <p>Return value</p> <p>The function returns the element removed from the end of an array.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraytop","title":"<code>MEM_ArrayTop</code>","text":"<p>Returns the last element of the <code>zCArray</code> without removing it. </p><pre><code>func int MEM_ArrayTop(var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> </ul> <p>Return value</p> <p>The function returns the last element of an array.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayindexof","title":"<code>MEM_ArrayIndexOf</code>","text":"<p>Searches the <code>zCArray</code> for the first occurrence of a <code>value</code> and returns its index. </p><pre><code>func int MEM_ArrayIndexOf(var int zCArray_ptr, var int value)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int value</code>      Value to search for</li> </ul> <p>Return value</p> <p>The function returns the index of a first occurrence of a <code>value</code>. If not found <code>-1</code> is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayremoveindex","title":"<code>MEM_ArrayRemoveIndex</code>","text":"<p>Removes the element at a specific index from the <code>zCArray</code>. </p><pre><code>func void MEM_ArrayRemoveIndex (var int zCArray_ptr, var int index)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int index</code>      Index of the element to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayremovevalue","title":"<code>MEM_ArrayRemoveValue</code>","text":"<p>Removes all occurrences of a value from the <code>zCArray</code>. </p><pre><code>func void MEM_ArrayRemoveValue (var int zCArray_ptr, var int value)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int value</code>      Value to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayremovevalueonce","title":"<code>MEM_ArrayRemoveValueOnce</code>","text":"<p>Removes the first occurrence of a value from the <code>zCArray</code>. If value is not found, a warning is issued. </p><pre><code>func void MEM_ArrayRemoveValueOnce (var int zCArray_ptr, var int value)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> <li><code>var int value</code>      Value to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraysort","title":"<code>MEM_ArraySort</code>","text":"<p>Sorts the elements of the <code>zCArray</code> in ascending order. </p><pre><code>func void MEM_ArraySort(var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arrayunique","title":"<code>MEM_ArrayUnique</code>","text":"<p>Removes duplicate elements from the <code>zCArray</code>. </p><pre><code>func void MEM_ArrayUnique(var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/arrays/#mem_arraytostring","title":"<code>MEM_ArrayToString</code>","text":"<p>Converts the <code>zCArray</code> to a string representation. </p><pre><code>func string MEM_ArrayToString (var int zCArray_ptr)\n</code></pre> Parameters <ul> <li><code>var int zCArray_ptr</code>      Pointer to the <code>zCArray</code></li> </ul> <p>Return value</p> <p>The function returns a string representation of a given array.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/","title":"ASM","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#ikarus-machine-code-implementation-asm","title":"Ikarus Machine Code Implementation (ASM)","text":"<p>Machine code refers to a program or program segment written in machine language, which can be directly executed by a processor without further translation steps. The relevant machine language for us is that belonging to the x86 processor architecture. All machine instructions, what they do, and how they are encoded in machine language can be found in the Intel Manuals.</p> <p>In practice, dealing with (abstract) machine instructions and manually translating them into (concrete) machine code is rarely necessary due to its complexity.</p> <p>However, machine code can be useful for performing technical tasks that cannot be expressed in Daedalus directly. For example, the CALL package use the ASM function set as a basis.</p> <p>Note</p> <p>The functions in this chapter have the <code>ASM_</code> prefix for Assembly (language). Assembly language is a human-readable language with one-to-one correspondences to machine language. Strictly speaking, the <code>ASM_</code> prefix is misleading here, as it pertains to machine code rather than assembly language. However, conceptually, the two are closely related.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#opcodes","title":"Opcodes","text":"<p>The code defines several constants that represent different machine code instructions. Each constant is assigned a hexadecimal value and corresponds to a specific machine code instruction. Here is a link to all instructions.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#internal-stack","title":"Internal Stack","text":"<p>The code includes an internal stack implementation, allowing the storage of data. The stack is already used at two points:</p> <ul> <li>When calling an engine function, the address of the current run is stored in the internal stack.</li> <li>When nesting the use of the CALL package, a push and pop operation is performed to manage the context.</li> </ul> <p>The internal stack is implemented using an array, and the following functions are provided:</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asmint_push","title":"<code>ASMINT_Push</code>","text":"<p>Pushes the specified <code>data</code> onto the internal stack. </p><pre><code>func void ASMINT_Push(var int data)\n</code></pre> Parameters <ul> <li><code>var int data</code>      Data pushed onto internal stack</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asmint_pop","title":"<code>ASMINT_Pop</code>","text":"<p>Pops and returns the topmost data from the internal stack. </p><pre><code>func int ASMINT_Pop()\n</code></pre> Return value <p>The function returns a data poped form the internal stack.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#functions-core","title":"Functions (Core)","text":"<p>The ASM core functionality provides a framework for assembling machine code instructions and executing them. The following functions are included:</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asmint_init","title":"<code>ASMINT_Init</code>","text":"<p>Initializes the ASM system by creating an internal stack and finding function addresses. </p><pre><code>func void ASMINT_Init()\n</code></pre> <p>Tip</p> <p>It's worth noting that <code>ASMINT_Ini</code> is also invoked by the <code>MEM_InitAll</code> function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_open","title":"<code>ASM_Open</code>","text":"<p>Changes the size of the memory allocated at the start o the dictation</p> <p>The memory in which the machine code is stored is allocated at the beginning of the dictation. If this function isn't called a default size (see Constant below) is allocated by <code>ASM</code> or <code>ASM_Here</code> function. The 256 bytes is often sufficient for simple applications, but if more memory is required, this function must be called at the beginning of the dictation. </p><pre><code>func void ASM_Open(var int space)\n</code></pre> Parameters <ul> <li><code>var int space</code>      Space allocated for machine code (in bytes)</li> </ul> <p>Constant</p> <p><code>ASM_StandardStreamLength</code> constant defines the default space available for an Assembler sequence (in bytes).</p> <pre><code>const int ASM_StandardStreamLength = 256;\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm","title":"<code>ASM</code>","text":"<p>Writes machine code instructions to the stream.</p> <p>Using this function it is possible to dictate machine code little by little. The <code>data</code> bytes of the <code>length</code> (maximum 4!) are appended to the previously dictated part. This creates a program piece by piece that can be executed by the processor. </p><pre><code>func void ASM(var int data, var int length)\n</code></pre> Parameters <ul> <li><code>var int data</code>      The machine code instruction or its part</li> <li><code>var int length</code>      Length of the <code>data</code> (max 4 bytes)</li> </ul> ASM_1ASM_2ASM_3ASM_4"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_1","title":"<code>ASM_1</code>","text":"<p><code>ASM</code> with <code>length</code> parameter hardcoded to 1. Writes one byte machine code instructions to the stream. </p><pre><code>func void ASM_1(var int data) </code></pre> Parameters <ul> <li><code>var int data</code>      One byte machine code instruction or its part</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_2","title":"<code>ASM_2</code>","text":"<p><code>ASM</code> with <code>length</code> parameter hardcoded to 2. Writes two bytes machine code instructions to the stream. </p><pre><code>func void ASM_1(var int data) </code></pre> Parameters <ul> <li><code>var int data</code>      Two bytes machine code instruction or its part</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_3","title":"<code>ASM_3</code>","text":"<p><code>ASM</code> with <code>length</code> parameter hardcoded to 3. Writes three bytes machine code instructions to the stream. </p><pre><code>func void ASM_1(var int data) </code></pre> Parameters <ul> <li><code>var int data</code>      Three bytes machine code instruction or its part</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_4","title":"<code>ASM_4</code>","text":"<p><code>ASM</code> with <code>length</code> parameter hardcoded to 4. Writes four bytes machine code instructions to the stream. </p><pre><code>func void ASM_1(var int data) </code></pre> Parameters <ul> <li><code>var int data</code>      Four bytes machine code instruction or its part</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_here","title":"<code>ASM_Here</code>","text":"<p>Provides, the address of the cursor, i.e., the address of the location that will be described next by a call to <code>ASM</code>. It is guaranteed that the location where the code is written is also the location where it will be executed. </p><pre><code>func int ASM_Here()\n</code></pre> <p>Return value</p> <p>The function returns an address that is the current position in the machine code stream.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_close","title":"<code>ASM_Close</code>","text":"<p>Finalizes the stream by adding a return instruction and returns the starting address of the stream. This pointer can now be passed to at any time and any number of times to execute the machine code. </p> <p>Warning</p> <p>The memory area obtained by <code>ASM_Close</code> must be released manually using <code>MEM_Free</code> to avoid memory leaks. It is probably sufficient for almost all practical purposes.</p> <p></p><pre><code>func int ASM_Close()\n</code></pre> Return value <p>The function returns a starting address of the stream (pointer to the stream).</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_run","title":"<code>ASM_Run</code>","text":"<p>Executes a machine code (stream) from a pointer.</p> <p>Note</p> <p><code>ASM_Run</code> can also be used to call engine functions with no parameters and no relevant return value. In this case <code>ptr</code> would simply have to point to the function to be executed in the code segment. </p> <p></p><pre><code>func void ASM_Run(var int ptr)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>      Pointer to the executed code (returned form <code>ASM_Close</code>)</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#asm_runonce","title":"<code>ASM_RunOnce</code>","text":"<p>Executes the code dictated up to that point, similar to how an external function is executed. After that the code is released, and new code can be dictated. </p><pre><code>func void ASM_RunOnce()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/asm/#example","title":"Example","text":"<p>The following function sets the NPC passed as slf as the player, as if you had pressed O in Marvin mode with this NPC in focus. This is so short because there is already a function for this exact purpose, it's just not normally accessible from the scripts. It is therefore sufficient to write assembly code that pushes the parameter of the function (the <code>this</code> pointer) into the appropriate register and then calls the function. </p><pre><code>func void SetAsPlayer(var C_NPC slf) { /* Adresse der Funktion */\nconst int oCNpc__SetAsPlayer = 7612064; //0x7426A0 (Gothic2.exe)\nvar int slfPtr;\nslfPtr = MEM_InstToPtr (slf);\n//mov ecx slfPtr\nASM_1(ASMINT_OP_movImToECX); /* move a value to ecx */\nASM_4(slfPtr); /* a value */\n//call oCNpc__SetAsPlayer\nASM_1(ASMINT_OP_call);\nASM_4(oCNpc__SetAsPlayer - ASM_Here() - 4);\nASM_RunOnce(); /* return will be added automatically */\n};\n</code></pre> <p>Note</p> <p>Call targets are specified relative to the instruction that would have been executed after the actual call instruction. Therefore, both ASM_Here() and the subtraction of 4 in the call parameter are necessary.</p> <p>The above example describes, among other things, <code>CALL__thiscall</code> function form the CALL Package that can be also used to implement <code>SetAsPlayer</code>. </p><pre><code>func void SetAsPlayer(var C_NPC slf) { const int oCNpc__SetAsPlayer = 7612064;\nCALL__thiscall(MEM_InstToPtr(slf), oCNpc__SetAsPlayer);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/","title":"CALL Package","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call-package","title":"CALL Package","text":"<p>This part of Ikarus makes possible to call engine functions directly from scripts.</p> <p>In order to be able to invoke an engine function, you must know some of its roperties. This includes the number and types of parameters, the type of return value, address of function and calling convention.</p> <p>Knowledge about engine functions can be obtained using tools like IDA, which can analyze and convert GothicMod.exe / Gothic2.exe into a more human-readable format.</p> <p>Info</p> <p>In fact, machine code execution (ASM) is part of the CALL package, but due to its complexity, this functionality is discussed in a separate article.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call-modes","title":"Call modes","text":"<p>There are two modes: </p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#disposable","title":"Disposable","text":"<p>The simple mode that produces a disposable call that is used only once. All parameters are hardcoded.</p> <pre><code>func int hero_GetAssessEnemy() {\nconst int oCNpc__GetPerceptionFunc = 7726080; //0x75E400\nCALL_IntParam(_@(PERC_ASSESSENEMY));\nCALL_PutRetValTo(_@(funcID));\nCALL__thiscall(_@(hero), oCNpc__GetPerceptionFunc);\nvar int funcID;\nreturn +funcID;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#recyclable","title":"Recyclable","text":"<p>The second version produces code that can be used more than once. Instead of the parameters the user specifies the address where the parameters are to be taken from. In addition to executing the code, the user will receive an address that he can use to repeat the call. This is much faster than rebuilding the call from scratch.</p> <pre><code>func int Npc_GetPercFunc(var C_Npc npc, var int type) {\nconst int oCNpc__GetPerceptionFunc = 7726080; //0x75E400\nvar int npcPtr; npcPtr = _@(npc);\nconst int call = 0;\nif (CALL_Begin(call)) {\nCALL_IntParam(_@(type));\nCALL_PutRetValTo(_@(funcID));\nCALL__thiscall(_@(npcPtr), oCNpc__GetPerceptionFunc);\ncall = CALL_End();\n};\nvar int funcID;\nreturn +funcID;\n};\n</code></pre> <p>Receives a pointer. In case the pointer is non-zero, the code at this position is executed and 0 is returned. In case pointer is zero, the current mode is changed into recyclable mode, this means that the call functions expect instructions to build a recyclable call. This mode will continue until <code>CALL_End()</code>. This allows code like this:</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#start-and-end","title":"Start and End","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_open","title":"<code>CALL_Open</code>","text":"<p>Initializes a Recyclable call mode. </p><pre><code>func void CALL_Open()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_begin","title":"<code>CALL_Begin</code>","text":"<p>A practical wrapper for <code>CALL_Open</code>. Makes a call if it had been already created, initializes it otherwise. </p><pre><code>func int CALL_Begin(var int ptr)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>      Zero if you need to create a new recyclable function to be called (usually, before first use). In this case <code>CALL_Open</code> is called and <code>CALL_Begin</code> returns <code>1</code>.</li> </ul> <p>Return Value</p> <p>The function returns <code>1</code> if the new call has been created, <code>0</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_close","title":"<code>CALL_Close</code>","text":"<p>Finalizes a function call in recyclable mode, restoring the previous execution context. </p><pre><code>func int CALL_Close()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_end","title":"<code>CALL_End</code>","text":"<p>Finalizes a function call, pushes the pointer onto the stack, and runs the associated assembly code (makes an actual call). </p><pre><code>func int CALL_End()\n</code></pre> <p>Return Value</p> <p>The function returns a pointer that could be used to repeat the call.</p> <p>Tip</p> <p><code>CALL_Close</code> only finalizes the function call, returning the pointer, while <code>CALL_End</code> additionally handles pushing the pointer onto the stack and running associated assembly code.   </p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#passing-parameters","title":"Passing parameters","text":"<p>Parameters must be arranged on the machine stack from right to left i.e. from the parameter on the far right to the parameter on the far left. These functions generate machine code that will place parameters on the machine stack when executed.</p> <p>Note</p> <p>These functions do not impose any parameters on the Machine stack. Exactly it should say: You create the machine code that will put parameters on the machine stack when it is executed. And it is only carried out in the second step with the announcement of the calling convention.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_intparam","title":"<code>CALL_IntParam</code>","text":"<p>Passes an integer (<code>int32</code>) as a parameter to the called function. </p><pre><code>func void CALL_IntParam(var int param)\n</code></pre> Parameters <ul> <li><code>var int param</code>      Address of an integer to be passed</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_floatparam","title":"<code>CALL_FloatParam</code>","text":"<p>Passes an IEEE 7554 floating-point number (<code>single</code> / <code>zREAL</code>) as a parameter to the called function. </p><pre><code>func void CALL_FloatParam(var int param)\n</code></pre> Parameters <ul> <li><code>var int param</code>      Address of a float to be passed</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_ptrparam","title":"<code>CALL_PtrParam</code>","text":"<p>Passes a pointer (<code>void*</code>) as a parameter to the called function. </p><pre><code>func void CALL_PtrParam(var int param)\n</code></pre> Parameters <ul> <li><code>var int param</code>      Pointer to be passed</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_zstringptrparam","title":"<code>CALL_zStringPtrParam</code>","text":"<p>Passes a string (<code>zString*</code>) as a parameter to the called function. </p><pre><code>func void CALL_zStringPtrParam(var string param)\n</code></pre> Parameters <ul> <li><code>var string param</code>      String to be passed</li> </ul> <p>Warning</p> <p>This function only works when writing a disposable call!</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_cstringptrparam","title":"<code>CALL_cStringPtrParam</code>","text":"<p>Passes a char array (<code>char **</code>) as a parameter to the called function. </p><pre><code>func void CALL_cStringPtrParam(var string param)\n</code></pre> Parameters <ul> <li><code>var string param</code>      String to be passed as character array`</li> </ul> <p>Warning</p> <p>This function only works when writing a disposable call!</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_structparam","title":"<code>CALL_StructParam</code>","text":"<p>Passes a structure (struct) as a parameter to the called function. </p><pre><code>func void CALL_StructParam(var int ptr, var int words)\n</code></pre> Parameters <ul> <li><code>var int param</code>      Pointer to the object</li> <li><code>var int words</code>      Size of a structure (1 word = 32 bits)</li> </ul> <p>Note</p> <p><code>CALL_IntParam</code>, <code>CALL_FloatParam</code>, and <code>CALL_PtrParam</code> are functionally identical and are differentiated for code readability.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#the-call","title":"The call","text":"<p>The calling convention determines how the function's parameters are passed. IDA or another disassembler can be used to identify the convention used by a specific engine function.</p> <p>The announcement of the calling convention, i.e. the call of one of the four functions below is also the time of calling the function. In particular, all parameters must already be specified at this point.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call__stdcall","title":"<code>CALL__stdcall</code>","text":"<p>Calls a function with <code>__stdcall</code> (Standard Call) calling convention. </p><pre><code>func void CALL__stdcall(var int adr)\n</code></pre> Parameters <ul> <li><code>var int adr</code>      Address of a function</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call__thiscall","title":"<code>CALL__thiscall</code>","text":"<p>Calls a function with <code>__thiscall</code> calling convention. Used with a member functions. </p><pre><code>func void CALL__thiscall(var int this, var int adr)\n</code></pre> Parameters <ul> <li><code>var int this</code>      Pointer to the owner class object passed as a <code>this</code> parameter</li> <li><code>var int adr</code>      Address of a function</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call__cdecl","title":"<code>CALL__cdecl</code>","text":"<p>Calls a function with <code>__cdecl</code> calling convention. Used with non-Windows API and non-class functions. </p><pre><code>func void CALL__cdecl (var int adr)\n</code></pre> Parameters <ul> <li><code>var int adr</code>      Address of a function</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call__fastcall","title":"<code>CALL__fastcall</code>","text":"<p>Calls a function with <code>__fastcall</code> calling convention. </p><pre><code>func void CALL__fastcall(var int ecx, var int edx, var int adr)\n</code></pre> Parameters <ul> <li><code>var int ecx</code>      First parameter of a function</li> <li><code>var int edx</code>      Second parameter of a function</li> <li><code>var int adr</code>      Address of a function</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#return-value","title":"Return Value","text":"<p>As soon as the function call has taken place, i.e. after step 2, the return value can be queried. The following functions interpret the return value (usually this is the content of EAX immediately after the call) in the manner suggested in the function name. The result is then returned in a manner usable in Daedalus.</p> <p>Note</p> <p>Some return values are not stored in the EAX. In that case the call of the special function <code>RetValIs</code> is required to get the return value.</p> <p>Folowing funcitons are provided: <code>CALL_RetValIsFloat</code>, <code>CALL_RetValIszString</code>, <code>CALL_RetValIsStruct</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_putretvalto","title":"<code>CALL_PutRetValTo</code>","text":"<p>Simply places the return value to the given address (mostly the address of a daedalus integer). Must be called before The Call function. </p><pre><code>func void CALL_PutRetValTo(var int adr)\n</code></pre> Parameters <ul> <li><code>var int adr</code>      Destination address of the return value</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalasint","title":"<code>CALL_RetValAsInt</code>","text":"<p>Retrieves an integer returned by the called function. </p><pre><code>func int CALL_RetValAsInt()\n</code></pre> Return value <p>The function returns an integer returned by the previously called engine function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalisfloat","title":"<code>CALL_RetValIsFloat</code>","text":"<p>Specifies that the return value is a float. Must be called before The Call function to allow getting the return value with <code>CALL_RetValAsFloat</code>. </p><pre><code>func void CALL_RetValIsFloat()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalasfloat","title":"<code>CALL_RetValAsFloat</code>","text":"<p>Retrieves a float returned by the called function. </p><pre><code>func int CALL_RetValAsFloat()\n</code></pre> Return value <p>The function returns a float returned by the previously called engine function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalasptr","title":"<code>CALL_RetValAsPtr</code>","text":"<p>Retrieves a pointer (<code>void*</code>) returned by the called function. </p><pre><code>func int CALL_RetValAsPtr()\n</code></pre> Return value <p>The function returns a pointer returned by the previously called engine function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalisstruct","title":"<code>CALL_RetValIsStruct</code>","text":"<p>Specifies that the return value is a Structure. Must be called before The Call function to allow getting the return value with <code>CALL_RetValAsStructPtr</code>. </p><pre><code>func void CALL_RetValIsStruct(var int size)\n</code></pre> Parameters <ul> <li><code>var int size</code>      Size of the returned structure in bytes</li> </ul> <p>Danger</p> <p>If the return value is a structure with a size larger than 32 bit, the space for the return value has to be allocated by the caller (this is us).The address to the allocated memory is expected on the stack as an additional parameter (pushed last).</p> <p>Warning</p> <p>It is in your responsibility to free the structure memory, when the return value is not needed any more.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalasstructptr","title":"<code>CALL_RetValAsStructPtr</code>","text":"<p>Retrieves a pointer to the structure returned by the called function and converts it to the instance. Can be used to make an assignment to an instance, for example an assignment to a <code>var zCVob</code> if the return value is a pointer to a <code>zCVob</code>. </p><pre><code>func MEMINT_HelperClass CALL_RetValAsStructPtr()\n</code></pre> Return value <p>The function returns an instance returned by the previously called engine function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvaliszstring","title":"<code>CALL_RetValIszString</code>","text":"<p>Specifies that the return value is a <code>zString</code> (20 bytes structure). Must be called before The Call function to allow getting the return value with <code>CALL_RetValAszStringPtr</code> and <code>CALL_RetValAszString</code>. </p><pre><code>func string CALL_RetValAszString()\n</code></pre> <p>Note</p> <p><code>CALL_RetValAszStringPtr</code> and <code>CALL_RetValAszString</code> are quite different and should not be confused. Using <code>CALL_RetValAszString</code> frees up memory that may still be needed. In a reverse with <code>CALL_RetValAszStringPtr</code> memory that is no longer needed is not freed and can cause memory leak.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalaszstringptr","title":"<code>CALL_RetValAszStringPtr</code>","text":"<p>Retrievs a <code>zString</code> pointer and converts it to the daedalus string. (don't frees the memory) </p><pre><code>func string CALL_RetValAszStringPtr()\n</code></pre> Return value <p>The function returns a daedalus string form a <code>zString</code> returned by the previously called engine function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#call_retvalaszstring","title":"<code>CALL_RetValAszString</code>","text":"<p>Retrievs a <code>zString</code> pointer and converts it to the daedalus string. (frees the memory) </p><pre><code>func string CALL_RetValAszString()\n</code></pre> Return value <p>The function returns a daedalus string form a <code>zString</code> returned by the previously called engine function.</p> Function author note <p>A <code>zString</code> is merely a special case of a structure, with the difference, that it is used as a primitive datatype. Nobody will be willing to use it as a pointer to some memory or an instance in Daedalus. This function copies the contents of the <code>zString</code> into a daedalus string and frees the <code>zString</code> afterwards.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/call/#apply-overlay-disposable","title":"Apply overlay (Disposable)","text":"<pre><code>// .text:0072D2C0:int __thiscall oCNpc::ApplyOverlay(class zSTRING const &amp;)\nfunc void example1(){\nconst int oCNpc__ApplyOverlay = 7525056; //0x72D2C0 (G2A)\nCALL_zStringPtrParam (\"HUMANS_MILITIA.MDS\");\nCALL__thiscall (MEM_InstToPtr (hero), oCNpc__ApplyOverlay);\n//We are not interested in the return value here.\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#get-time-as-string-disposable","title":"Get time as string (Disposable)","text":"<p>e.g. <code>\"7:30\"</code> for half past seven in the morning </p><pre><code>// .text:00780EC0:class zSTRING __thiscall oCWorldTimer::GetTimeString(void)\nfunc void example2(){\nconst int oCWorldTimer__GetTimeString = 7868096; //780EC0 (G2A)\nCALL_RetValIszString();\nCALL__thiscall (MEM_InstToPtr (MEM_WorldTimer), oCWorldTimer__GetTimeString );\nPrintDebug (CALL_RetValAszString());\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#get-the-sky-time-disposable","title":"Get the \"sky time\" (Disposable)","text":"<p>Sky time is a floating point value between 0 and 1 that jumps back from 1 to 0 at noon. </p><pre><code>// .text:00781240:float __thiscall oCWorldTimer::GetSkyTime(void)\nfunc int GetSkyTime() {\nconst int oCWorldTimer__GetSkyTime = 7868992; //0x781240\nCALL_RetValIsFloat();\nCALL__thiscall (MEM_InstToPtr (MEM_WorldTimer),\noCWorldTimer__GetSkyTime);\nreturn CALL_RetValAsFloat();\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/call/#delete-vob-recyclable","title":"Delete Vob (Recyclable)","text":"<p>Call of the <code>oCWorld.RemoveVob</code>. <code>MEM_DeleteVob</code> is an ikarus built-in function. </p><pre><code>func void MEM_DeleteVob(var int vobPtr) {\nvar int world; world = MEM_Game._zCSession_world;\nconst int call = 0;\nif (CALL_Begin(call)) {\n/* oCWorld.RemoveVob */\nCALL_IntParam(_@(vobPtr));\nCALL__thiscall(_@(world), MEMINT_SwitchG1G2(7171824, 7864512));\ncall = CALL_End();\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/","title":"Debug","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#debug","title":"Debug","text":"<p>A set of debugging and error-handling functions for mod development with Ikarus.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_checkversion","title":"<code>MEM_CheckVersion</code>","text":"<p>Checks if the version of Ikarus is the specified version or newer. </p><pre><code>func int MEM_CheckVersion(var int base, var int major, var int minor)\n</code></pre> Parameters <ul> <li><code>var int base</code>     Base version number</li> <li><code>var int major</code>     Major revision number</li> <li><code>var int minor</code>     Minor revision number</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the version of Ikarus is the specified version or newer, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_setshowdebug","title":"<code>MEM_SetShowDebug</code>","text":"<p>Sets the variable that is also toggled by the <code>toggle debug</code> command. As a result, messages outputted by <code>PrintDebug</code> are directed to the zSpy </p><pre><code>func void MEM_SetShowDebug(var int on)\n</code></pre> Parameters <ul> <li><code>var int on</code>      Specifies whether to turn on (<code>TRUE</code>) or off (<code>FALSE</code>) debug information.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_sendtospy","title":"<code>MEM_SendToSpy</code>","text":"<p>Sends a message to the debugging console. </p><pre><code>func void MEM_SendToSpy(var int errorType, var string text)\n</code></pre> Parameters <ul> <li><code>var int errorType</code>     Type of error (e.g., <code>zERR_TYPE_FAULT</code>, <code>zERR_TYPE_WARN</code>, <code>zERR_TYPE_INFO</code>)</li> <li><code>var string text</code>     The message to be sent.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_errorbox","title":"<code>MEM_ErrorBox</code>","text":"<p>Displays an error message in a message box. </p><pre><code>func void MEM_ErrorBox(var string text)\n</code></pre> Parameters <ul> <li><code>var string text</code>     The error message to be displayed.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_printstacktrace","title":"<code>MEM_PrintStackTrace</code>","text":"<p>Prints the stack trace. </p><pre><code>func void MEM_PrintStackTrace()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_error","title":"<code>MEM_Error</code>","text":"<p>Handles a fatal error, displaying the error message and printing the stack trace. </p><pre><code>func void MEM_Error(var string error)\n</code></pre> Parameters <ul> <li><code>var string error</code>     The error message.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_warn","title":"<code>MEM_Warn</code>","text":"<p>Handles a warning, displaying the warning message and printing the stack trace. </p><pre><code>func void MEM_Warn(var string warn)\n</code></pre> Parameters <ul> <li><code>var string warn</code>     The warning message.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_info","title":"<code>MEM_Info</code>","text":"<p>Handles an information message, printing it if enabled in the settings. </p><pre><code>func void MEM_Info(var string info)\n</code></pre> Parameters <ul> <li><code>var string info</code>     The information message.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_assertfail","title":"<code>MEM_AssertFail</code>","text":"<p>Handles an assertion failure, reporting the error message as a fatal error. </p><pre><code>func void MEM_AssertFail(var string assertFailText)\n</code></pre> Parameters <ul> <li><code>var string assertFailText</code>     The assertion failure message.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#mem_debug","title":"<code>MEM_Debug</code>","text":"<p>Freely conigurable debug chanell. See how to setup it in the Constants article. </p><pre><code>func void MEM_Debug(var string message)\n</code></pre> Parameters <ul> <li><code>var string message</code>     The debug message.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/debug/#memint_switchg1g2","title":"<code>MEMINT_SwitchG1G2</code>","text":"<p>Switches between values based on the game version. Used mainly to change addresses in multi-platform hooks or function calls. </p><pre><code>func int MEMINT_SwitchG1G2(var int g1Val, var int g2Val)\n</code></pre> Parameters <ul> <li><code>var int g1Val</code>      The value to return if the game version is Gothic 1.</li> <li><code>var int g2Val</code>     The value to return if the game version is Gothic 2.</li> </ul> <p>Return value</p> <p>The function returns an appropriate value based on the game version.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/","title":"Ini File Access","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#configuration-file-access","title":"Configuration file access","text":"<p>This part of Ikarus gives you access to <code>Gothic.ini</code> and loaded mod configuration files.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#read-functions","title":"Read functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getcommandline","title":"<code>MEM_GetCommandLine</code>","text":"<p>Returns the contents of the command line passed to Gothic. </p><pre><code>func string MEM_GetCommandLine()\n</code></pre> Return value <p>The function returns contents of the command line passed to Gothic. This could, for example, look like this:</p> <p><code>\"-TIME:7:35 -GAME:TEST_IKARUS.INI -ZREPARSE -ZWINDOW -ZLOG:5,S -DEVMODE -ZMAXFRAMERATE:30\"</code></p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getgothopt","title":"<code>MEM_GetGothOpt</code>","text":"<p>Searches the <code>Gothic.ini</code> for an option. </p><pre><code>func string MEM_GetGothOpt(var string sectionname, var string optionname)\n</code></pre> Parameters <ul> <li><code>var string sectionname</code>     Settings section like <code>[GAME]</code></li> <li><code>var string optionname</code>     One setting entry like <code>playLogoVideos</code></li> </ul> <p>Return value</p> <p>The function returns an option value as a string or empty string if option was not found.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getmodopt","title":"<code>MEM_GetModOpt</code>","text":"<p>Searches the loaded mod ini file for option. </p><pre><code>func void MEM_GetModOpt(var string sectionname, var string optionname)\n</code></pre> Parameters <ul> <li><code>var string sectionname</code>     Settings section like <code>[INFO]</code></li> <li><code>var string optionname</code>     One setting entry like <code>Title</code></li> </ul> <p>Return value</p> <p>The function returns an option value as a string or empty string if option was not found.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_gothoptsectionexists","title":"<code>MEM_GothOptSectionExists</code>","text":"<p>Checks whether a section exists in <code>Gothic.ini</code> </p><pre><code>func int MEM_GothOptSectionExists(var string sectionname)\n</code></pre> Parameters <ul> <li><code>var string sectionname</code>     Settings section like <code>[GAME]</code></li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if section exists <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_modoptsectionexists","title":"<code>MEM_ModOptSectionExists</code>","text":"<p>Checks whether a section exists in loaded mod ini file </p><pre><code>func int MEM_ModOptSectionExists(var string sectionname)\n</code></pre> Parameters <ul> <li><code>var string sectionname</code>     Settings section like <code>[INFO]</code></li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if section exists <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_gothoptexists","title":"<code>MEM_GothOptExists</code>","text":"<p>Checks whether an option exists in <code>Gothic.ini</code> </p><pre><code>func int MEM_GothOptExists(var string sectionname, var string optionname)\n</code></pre> Parameters <ul> <li><code>var string sectionname</code>     Settings section like <code>[GAME]</code></li> <li><code>var string optionname</code>     One setting entry like <code>playLogoVideos</code></li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if option in a section exist <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_modoptexists","title":"<code>MEM_ModOptExists</code>","text":"<p>Checks whether an option exists in loaded mod ini file </p><pre><code>func int MEM_ModOptExists(var string sectionname, var string optionname)\n</code></pre> Parameters <ul> <li><code>var string sectionname</code>     Settings section like <code>[INFO]</code></li> <li><code>var string optionname</code>     One setting entry like <code>Title</code></li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if option in a section exist <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#write-functions","title":"Write functions","text":"<p>Warning</p> <p>Mod configuration is never saved to disk, therefore no separate functions exist for writing to it.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setgothopt","title":"<code>MEM_SetGothOpt</code>","text":"<p>The option <code>option</code> in the section <code>section</code> is set to the <code>value</code>. If the section and/or option does not exist, it will be created. </p><pre><code>func void MEM_SetGothOpt(var string section, var string option, var string value)\n</code></pre> Parameters <ul> <li><code>var string section</code>     The section where the option should be located</li> <li><code>var string option</code>     Option to write/overwrite</li> <li><code>var string value</code>     Value to set the option to</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_applygothopt","title":"<code>MEM_ApplyGothOpt</code>","text":"<p>Applies the changes and saves the ini to disk </p><pre><code>func void MEM_ApplyGothOpt()\n</code></pre> <p>Tip</p> <p>If you introduce new options, it is best to follow certain practices. It is a good practice to name your options in a clear manner and place them in a section named the same as your mod. Do not place your mod options into the <code>[GAME]</code> or <code>[PERFORMANCE]</code> sections.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#key-functions","title":"Key functions","text":"<p>The <code>Gothic.ini</code> contains the assignment of physical keys (e.g. \"W\") to logical keys (e.g. \"keyUp\").</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getkey","title":"<code>MEM_GetKey</code>","text":"<p>Returns the primary key assigned to logical key. </p><pre><code>func int MEM_GetKey(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the logical key</li> </ul> <p>Return value</p> <p>The function returns key assigned to logical key</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getsecondarykey","title":"<code>MEM_GetSecondaryKey</code>","text":"<p>Returns a secondary key assigned to logical key. </p><pre><code>func int MEM_GetSecondaryKey(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the logical key</li> </ul> <p>Return value</p> <p>The function returns key assigned to logical key</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setkeys","title":"<code>MEM_SetKeys</code>","text":"<p>Sets keyboard keys of the logical key. </p><pre><code>func void MEM_SetKeys(var string name, var int primary, var int secondary)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the logical key</li> <li><code>var int primary</code>     Primary key to be assigned, can be taken from Ikarus_Const_G1 / Ikarus_Const_G2 file.</li> <li><code>var int secondary</code>     Secondary key to be assigned, can be taken from Ikarus_Const_G1 / Ikarus_Const_G2 file.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setkey","title":"<code>MEM_SetKey</code>","text":"<p>Sets the primary keyboard key of the logical key. </p><pre><code>func void MEM_SetKey(var string name, var int key)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the logical key</li> <li><code>var int key</code>     Primary key to be assigned, can be taken from Ikarus_Const_G1 / Ikarus_Const_G2 file.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setsecondarykey","title":"<code>MEM_SetSecondaryKey</code>","text":"<p>Sets the secondary keyboard key of the logical key. </p><pre><code>func void MEM_SetSecondaryKey(var string name, var int key)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the logical key</li> <li><code>var int key</code>     Secondary key to be assigned, can be taken from Ikarus_Const_G1 / Ikarus_Const_G2 file.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/","title":"Jumps and Loops","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#jumps-and-loops","title":"Jumps and Loops","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#jumps","title":"Jumps","text":"<p>Jumps in Ikarus are implemented by direct manipulation of the stack pointer, achieved with two lines of code. These lines enable the change of the current position within the parser stack, representing machine-level code generated during script compilation. By querying and setting this position, the execution flow can be redirected to a new location in the code.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#initialization","title":"Initialization","text":"<p>To ensure the correct functioning of this jump mechanism, it is crucial to execute the <code>MEM_InitLabels()</code> function once after loading a saved game. The recommended practice is to integrate this initialization function within <code>INIT_GLOBAL</code>. It's only after <code>MEM_InitLabels()</code> has been called that accessing <code>MEM_StackPos.position</code> becomes valid.</p> <pre><code>func void MEM_InitLabels()\n</code></pre> <p>Tip</p> <p>It's worth noting that <code>MEM_InitLabels</code> is also invoked by the <code>MEM_InitAll</code> function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#usage","title":"Usage","text":"<ul> <li>Label Initialization      Before attempting a jump, it's important to initialize the label to which the jump is intended. Forward jumps, where the jump point is encountered before the jump target, can be challenging. Label initialization looks like that:     <pre><code>// [...]\nvar int label;\nlabel = MEM_StackPos.position;\n// [...]\n</code></pre></li> <li>Actual jump      After initializing the label you could simply jump to it by setting <code>MEM_StackPos.position</code> to the label.     <pre><code>// [...]\nMEM_StackPos.position = label;\n// [...]\n</code></pre></li> </ul> <p>Jump flowchart </p><pre><code>flowchart TD\nA(Start) --&gt; B[\"var int label; \\n label = MEM_StackPos.position;\"];\nB --&gt; C{Your code}\nC --&gt;D[\"MEM_StackPos.position = label;\"];\nC --&gt; E(End)\nD --&gt; |Jump| B;</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#notes-and-warnings","title":"Notes and warnings","text":"<ul> <li> <p>Validity of Labels      Labels become invalid after saving and loading. Consequently, labels should be used immediately, and there is generally no reason to persist them for an extended period.</p> </li> <li> <p>Caution with Jumping      Jumping between different functions without a clear understanding of the code structure can lead to unexpected issues. Similarly, using labels without a thorough comprehension of their purpose may result in undesired consequences. It's crucial to exercise caution, especially when making assignments involving labels.</p> </li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#examples","title":"Examples","text":"Simple jump 'loop'Nested jump 'loop' <p>The following code outputs the numbers from 0 to 42:</p> <pre><code>func void foo() {\n/* Initialization */\nMEM_InitLabels();\nvar int count; count = 0;\n/* Record the execution position in label. */\nvar int label;\nlabel = MEM_StackPos.position;\n/* &lt;---- label now points here,\n    * i.e. to the position AFTER the assignment of label. */\nPrint (ConcatStrings (\"COUNT: \", IntToString (count)));\ncount += 1;\nif (count &lt;= 42) {\n/* Replace the execution position,\n        * with the \"&lt;-----\" the system then continues */\nMEM_StackPos.position = label;\n};\n/* Once 43 is reached, the \u201cloop\u201d is exited. */\n};\n</code></pre> <p>The following code should enumerate all pairs (x,y) with <code>0 &lt;= x &lt; max_x</code>, <code>0 &lt;= y &lt; max_y</code> </p><pre><code>func void printpairs(var int max_x, var int max_y)\n{\n// Initialize labels\nMEM_InitLabels();\n// PrintDebug should be used, i.e. activate debug output\nMEM_SetShowDebug (1);\nvar int x; var int y; x = 0;\n// while (x &lt; max_x)\nvar int x_loop; x_loop = MEM_StackPos.position;\nif (x &lt; max_x)\n{ y = 0;\n// while (y &lt; max_y) \nvar int y_loop; y_loop = MEM_StackPos.position;\nif (y &lt; max_y)\n{ var string out; out = \"(\";\nout = ConcatStrings (out, IntToString (x));\nout = ConcatStrings (out, \", \");\nout = ConcatStrings (out, IntToString (y));\nout = ConcatStrings (out, \")\");\nPrintDebug (out);\ny += 1;\n// continue y_loop \nMEM_StackPos.position = y_loop;\n};\nx += 1;\n// continue x_loop\nMEM_StackPos.position = x_loop;\n};\n};\n/*\n    Output of a call printpairs(4,2) would then be: \n    00:36 Info: 5 U: Skript: (0, 0) .... \n    00:36 Info: 5 U: Skript: (0, 1) .... \n    00:36 Info: 5 U: Skript: (1, 0) .... \n    00:36 Info: 5 U: Skript: (1, 1) .... \n    00:36 Info: 5 U: Skript: (2, 0) .... \n    00:36 Info: 5 U: Skript: (2, 1) .... \n    00:36 Info: 5 U: Skript: (3, 0) .... \n    00:36 Info: 5 U: Skript: (3, 1) .... \n*/\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#label-and-goto","title":"Label and Goto","text":"<p>Besides the normal Jupms Ikarus implements <code>MEM_Label</code> and <code>MEM_Goto</code> functions. They work similar to the stack manipulation with <code>var int label</code> but the interface is much more user-friendly and defineing new variables is not needed.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#mem_label","title":"<code>MEM_Label</code>","text":"<p>Function taht works like a <code>label = MEM_StackPos.position;</code>. You could jump to it with <code>MEM_Goto</code>. </p><pre><code>func void MEM_Label(var int lbl)\n</code></pre> Parameters <ul> <li><code>var int lbl</code>      Number of the label, used for nested loop or multible loops within one functon</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#mem_goto","title":"<code>MEM_Goto</code>","text":"<p>Function taht works like a <code>MEM_StackPos.position = label;</code>. Executes a jump to a <code>MEM_Label</code> with specified number. </p><pre><code>func void MEM_Goto(var int lbl)\n</code></pre> Parameters <ul> <li><code>var int lbl</code>      Number of the label, the function will jump to</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#usage_1","title":"Usage","text":"<p>Usage of Label and Goto is probably self-explanatory, since it is same as in the regular Ikarus Jump. But before using it reading the Notes and warnings of the Jumps is recomended.</p> <p>Label-Goto loop flowchart </p><pre><code>flowchart TD\nA(Start) --&gt; B[\"MEM_Label(0);\"];\nB --&gt; C{Your code}\nC --&gt;D[\"MEM_Goto(0);\"];\nC --&gt; E(End)\nD --&gt; |Jump| B;</code></pre> Label-Goto loop<pre><code>func void LabelGoto_test() {\nvar int i; MEM_Label(0);\nMEM_Debug(IntToString(i));\ni = i + 1;\nif(i &gt;= 4)\n{\nreturn;\n};\nMEM_Goto(0);\n};\n//  Results:\n//  Info:  0 Q:     Debug: 0\n//  Info:  0 Q:     Debug: 1\n//  Info:  0 Q:     Debug: 2\n//  Info:  0 Q:     Debug: 3\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#examples_1","title":"Examples","text":"Simple Label-Goto 'loop'Nested Label-Goto 'loop' <p>The following code outputs the numbers from 0 to 42:</p> <pre><code>func void foo() {\nvar int count; count = 0;\nMEM_Label(0);\n/* &lt;---- label now points here,\n    * i.e. to the position AFTER the assignment of label. */\nPrint (ConcatStrings (\"COUNT: \", IntToString (count)));\ncount += 1;\nif (count &lt;= 42) {\n// Jump to the MEM_Label\nMEM_Goto(0);\n};\n/* Once 43 is reached, the \u201cloop\u201d is exited. */\n};\n</code></pre> <p>The following code should enumerate all pairs (x,y) with <code>0 &lt;= x &lt; max_x</code>, <code>0 &lt;= y &lt; max_y</code> </p><pre><code>func void printpairs(var int max_x, var int max_y)\n{\n// PrintDebug should be used, i.e. activate debug output\nMEM_SetShowDebug (1);\nvar int x; var int y; x = 0;\n// while (x &lt; max_x)\nMEM_Label(0);\nif (x &lt; max_x)\n{ y = 0;\n// while (y &lt; max_y) \nMEM_Label(1);\nif (y &lt; max_y)\n{ var string out; out = \"(\";\nout = ConcatStrings (out, IntToString (x));\nout = ConcatStrings (out, \", \");\nout = ConcatStrings (out, IntToString (y));\nout = ConcatStrings (out, \")\");\nPrintDebug (out);\ny += 1;\nMEM_Goto(1);\n};\nx += 1;\nMEM_Goto(0);\n};\n};\n/*\n    Output of a call printpairs(4,2) would then be: \n    00:36 Info: 5 U: Skript: (0, 0) .... \n    00:36 Info: 5 U: Skript: (0, 1) .... \n    00:36 Info: 5 U: Skript: (1, 0) .... \n    00:36 Info: 5 U: Skript: (1, 1) .... \n    00:36 Info: 5 U: Skript: (2, 0) .... \n    00:36 Info: 5 U: Skript: (2, 1) .... \n    00:36 Info: 5 U: Skript: (3, 0) .... \n    00:36 Info: 5 U: Skript: (3, 1) .... \n*/\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#while-loop","title":"While loop","text":"<p>Ikarus also implements a while loop. Its syntax isn't as good as the loop from zParserExtedner, due to the daedalus limitations, but it works as a normal while loop that can be found in many programming languages.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#syntax","title":"Syntax","text":"<p>The Ikarus while loop consist of three things:</p> <ul> <li> <p>while function  That works like a while statement and start of the brace <code>while(var int b){</code>. </p><pre><code>func void while(var int b)\n</code></pre> </li> <li> <p>end constant  That works like an ending brace <code>}</code>. </p><pre><code>const int end = -72;\n</code></pre> </li> <li> <p>break and continue constant  These two constants works like a regular <code>break</code> and <code>continue</code> statements in C. </p><pre><code>const int break = -42;\nconst int continue = -23;\n</code></pre> </li> </ul> while loop<pre><code>func void while_test() {\nvar int value; value = 10;\nwhile(value &gt; 0); //{\nif (value == 8)\n{\ncontinue;\n};\nif (value == 2)\n{\nbreak;\n};\nend; //}\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#examples_2","title":"Examples","text":"Simple while loopNested while loop <p>The following code outputs the numbers from 0 to 42:</p> <pre><code>func void foo() {\nvar int count; count = 0;\nwhile(count &lt;= 42); //{\nPrint (ConcatStrings (\"COUNT: \", IntToString (count)));\ncount += 1;\nend; //}\n/* Once 43 is reached, the loop is exited. */\n}; </code></pre> <p>The following code should enumerate all pairs (x,y) with <code>0 &lt;= x &lt; max_x</code>, <code>0 &lt;= y &lt; max_y</code> </p><pre><code>func void printpairs(var int max_x, var int max_y)\n{\n// PrintDebug should be used, i.e. activate debug output\nMEM_SetShowDebug (1);\nvar int x; var int y; x = 0;\nwhile(x &lt; max_x); //{\ny = 0;\nwhile(y &lt; max_y); //{  \nvar string out; out = \"(\";\nout = ConcatStrings (out, IntToString (x));\nout = ConcatStrings (out, \", \");\nout = ConcatStrings (out, IntToString (y));\nout = ConcatStrings (out, \")\");\nPrintDebug (out);\ny += 1;\nend; //}\nx += 1;\nend; //}\n};\n/*\n    Output of a call printpairs(4,2) would then be: \n    00:36 Info: 5 U: Skript: (0, 0) .... \n    00:36 Info: 5 U: Skript: (0, 1) .... \n    00:36 Info: 5 U: Skript: (1, 0) .... \n    00:36 Info: 5 U: Skript: (1, 1) .... \n    00:36 Info: 5 U: Skript: (2, 0) .... \n    00:36 Info: 5 U: Skript: (2, 1) .... \n    00:36 Info: 5 U: Skript: (3, 0) .... \n    00:36 Info: 5 U: Skript: (3, 1) .... \n*/\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#repeat-loop","title":"Repeat loop","text":"<p>In addition Ikarus implements something called Repeat loop. </p>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#initialization_1","title":"Initialization","text":"<p>To use Repeat loop you must first call <code>MEM_InitRepeat()</code> function once after loading a saved game. The recommended practice is to integrate this initialization function within <code>INIT_GLOBAL</code>.</p> <pre><code>func void MEM_InitRepeat()\n</code></pre> <p>Tip</p> <p>It's worth noting that <code>MEM_InitRepeat</code> is also invoked by the <code>MEM_InitAll</code> function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#syntax_1","title":"Syntax","text":"<p>Repeat loop has a syntax very similar to the while loop. It also uses <code>end</code> constant as an ending brace. <code>break</code> and <code>continue</code> statements can be used within it as well. The main difference is the main loop function <code>Repeat</code> that has following properties:</p> <pre><code>func void Repeat(var int variable, var int limit)\n</code></pre> <ul> <li><code>var int variable</code>      A variable that increase with every loop iteration.</li> <li><code>var int limit</code>      A variable that defines the number of loop iterations. If <code>variable &gt;= limit</code> the loop is exited.</li> </ul> <p>Repeat loop flowchart </p><pre><code>flowchart TD\n    A(Start) --&gt; B[\"Repeat(i, limit)\"] \n    B --&gt; C{i &lt; limit}\n    C --&gt;|true| D[Command]\n    D --&gt; |i = i + 1| B\n    C --&gt; |false| E(End)</code></pre> Repeat loop<pre><code>func void Repeat_test() {\nRepeat(i, 4); var int i; //{\nMEM_Debug(IntToString(i));\nend; //}\n};\n//  Results:\n//  Info:  0 Q:     Debug: 0\n//  Info:  0 Q:     Debug: 1\n//  Info:  0 Q:     Debug: 2\n//  Info:  0 Q:     Debug: 3\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/jumps_loops/#examples_3","title":"Examples","text":"Simple Repeat loopNested Repeat loop <p>The following code outputs the numbers from 0 to 42:</p> <pre><code>func void foo() {\nRepeat(count, 43); var int count; //{\nPrint (ConcatStrings (\"COUNT: \", IntToString (count)));\nend; //}\n/* Once 43 is reached, the loop is exited. */\n}; </code></pre> <p>The following code should enumerate all pairs (x,y) with <code>0 &lt;= x &lt; max_x</code>, <code>0 &lt;= y &lt; max_y</code> </p><pre><code>func void printpairs(var int max_x, var int max_y)\n{\n// PrintDebug should be used, i.e. activate debug output\nMEM_SetShowDebug (1);\nvar int x; var int y; x = 0;\nRepeat(x, max_x); //{\ny = 0;\nRepeat(y, max_y); //{  \nvar string out; out = \"(\";\nout = ConcatStrings (out, IntToString (x));\nout = ConcatStrings (out, \", \");\nout = ConcatStrings (out, IntToString (y));\nout = ConcatStrings (out, \")\");\nPrintDebug (out);\nend; //}\nend; //}\n};\n/*\n    Output of a call printpairs(4,2) would then be: \n    00:36 Info: 5 U: Skript: (0, 0) .... \n    00:36 Info: 5 U: Skript: (0, 1) .... \n    00:36 Info: 5 U: Skript: (1, 0) .... \n    00:36 Info: 5 U: Skript: (1, 1) .... \n    00:36 Info: 5 U: Skript: (2, 0) .... \n    00:36 Info: 5 U: Skript: (2, 1) .... \n    00:36 Info: 5 U: Skript: (3, 0) .... \n    00:36 Info: 5 U: Skript: (3, 1) .... \n*/\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/","title":"Keyboard","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/#keyboard-interaction","title":"Keyboard interaction","text":"<p>This part of Ikarus implements function that make interaction with keyboard possible.</p> <p>Info</p> <p>Keyboard interaction is also implemented with gameKeyEvents.d</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/#functions","title":"Functions","text":"<p>Tip</p> <p>Different players use different keys for specific actions! However, it is possible to get key assigned to the action from Gothic.ini. See Ini access.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/#mem_keypressed","title":"<code>MEM_KeyPressed</code>","text":"<p>Checks if the key is hold right at the moment of function call. </p><pre><code>func int MEM_KeyPressed(var int key)\n</code></pre> Parameters <ul> <li><code>var int key</code>     Checked key</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the key is hold, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/#mem_keystate","title":"<code>MEM_KeyState</code>","text":"<p>Returns the state of the <code>key</code>. </p><pre><code>func int MEM_KeyState(var int key)\n</code></pre> Parameters <ul> <li><code>var int key</code>     Checked key</li> </ul> <p>Return value</p> <p>The function returns actual key state.</p> <p>Key states</p> <ul> <li><code>KEY_UP</code> - The key is not pressed and was not pressed before. (\"not pressed\")</li> <li><code>KEY_PRESSED</code> - The key is pressed and was not previously pressed. (\"new pressed\")</li> <li><code>KEY_HOLD</code> - The key is pressed and was also pressed before. (\"still pressed\")</li> <li><code>KEY_RELEASED</code> - The key is not pressed and was previously pressed. (\"let go\")</li> </ul> <p><code>KEY_PRESSED</code> or <code>KEY_RELEASED</code> will be returned if the state of the key has changed since the last query.</p> <p><code>KEY_UP</code> or <code>KEY_HOLD</code> are returned if the state has not changed.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/keyboard/#mem_insertkeyevent","title":"<code>MEM_InsertKeyEvent</code>","text":"<p>Makes the game think that the key was pressed. </p><pre><code>func void MEM_InsertKeyEvent(var int key)\n</code></pre> Parameters <ul> <li><code>var int key</code>     Key to be \"pressed\"</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/","title":"Memory Access","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#elementary-memory-access","title":"Elementary memory access","text":"<p>This part of Ikarus makes it possible to read and write memory as different data types - integers, strings, arrays of integers or strings and bytes.</p> <p>If <code>address &lt;= 0</code>, an error is thrown. Otherwise, an attempt is made to read or write at this address. If the address falls into invalid range, for example in a code segment, access violation will occur (Gothic crashes). In the case of string operations, it is also necessary that at the specified position a valid zString already exists.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#read-functions","title":"Read functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_readint","title":"<code>MEM_ReadInt</code>","text":"<p>Reads int from the <code>address</code>. </p><pre><code>func int MEM_ReadInt(var int address)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Memory address to read from</li> </ul> <p>Return value</p> <p>The function returns an integer value if the address is correct.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_readstring","title":"<code>MEM_ReadString</code>","text":"<p>Reads string from the <code>address</code>. </p><pre><code>func string MEM_ReadString(var int address)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Memory address to read from</li> </ul> <p>Return value</p> <p>The function returns string if the address is correct.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_readbyte","title":"<code>MEM_ReadByte</code>","text":"<p>Reads byte from the <code>address</code>. </p><pre><code>func int MEM_ReadByte(var int address)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Memory address to read from</li> </ul> <p>Return value</p> <p>The function returns byte value if the address is correct.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_readintarray","title":"<code>MEM_ReadIntArray</code>","text":"<p>Reads int from the array at the <code>arrayAddress</code>. </p><pre><code>func int MEM_ReadIntArray(var int arrayAddress, var int offset)\n</code></pre> Parameters <ul> <li><code>var int arrayAddress</code>     Memory address of array</li> <li><code>var int offset</code>     Array offset (array index)</li> </ul> <p>Return value</p> <p>The function returns integer value from the array if the address is correct.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_readstringarray","title":"<code>MEM_ReadStringArray</code>","text":"<p>Info</p> <p><code>MEM_ReadStringArray</code> has been already moved to the LeGo PermMem package.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_readbytearray","title":"<code>MEM_ReadByteArray</code>","text":"<p>Reads byte from the array at the <code>arrayAddress</code>. </p><pre><code>func int MEM_ReadByteArray(var int arrayAddress, var int offset)\n</code></pre> Parameters <ul> <li><code>var int arrayAddress</code>     Memory address of array</li> <li><code>var int offset</code>     Array offset (array index)</li> </ul> <p>Return value</p> <p>The function returns byte from the array if the address is correct.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#write-functions","title":"Write functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_writeint","title":"<code>MEM_WriteInt</code>","text":"<p>Writes int value in the <code>address</code>. </p><pre><code>func void MEM_WriteInt(var int address, var int value)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Memory address to write into</li> <li><code>var int value</code>     Integer value to write</li> </ul> Example <p>An example of using this function is the following Ikarus function, which turns debugging messages on and off: </p><pre><code>func void MEM_SetShowDebug(var int on)\n{\nMEM_WriteInt(showDebugAddress, on);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_writestring","title":"<code>MEM_WriteString</code>","text":"<p>Writes string in the <code>address</code>. </p><pre><code>func void MEM_WriteString(var int address, var string value)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Memory address to write into</li> <li><code>var int value</code>     String to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_writebyte","title":"<code>MEM_WriteByte</code>","text":"<p>Only the byte at address <code>address</code> is changed here, not a whole four-byte word. That is, the three subsequent bytes remain untouched. If <code>0 &lt;= val &lt; 256</code> does not apply in <code>MEM_WriteByte</code>, a warning is issued and val is trimmed accordingly. In particular, shouldn't be negative numbers are passed. </p><pre><code>func void MEM_WriteByte(var int address, var int value)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Memory address to write into</li> <li><code>var int value</code>     Byte to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_writeintarray","title":"<code>MEM_WriteIntArray</code>","text":"<p>Writes int value in the array at <code>arrayAddress</code>. </p><pre><code>func void MEM_WriteIntArray(var int arrayAddress, var int offset, var int value)\n</code></pre> Parameters <ul> <li><code>var int arrayAddress</code>     Memory address of array</li> <li><code>var int offset</code>     Array offset (array index)</li> <li><code>var int value</code>     Integer value to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_writestringarray","title":"<code>MEM_WriteStringArray</code>","text":"<p>Writes string value in the array at <code>arrayAddress</code>. </p><pre><code>func void MEM_WriteStringArray(var int arrayAddress, var int offset, var string value)\n</code></pre> Parameters <ul> <li><code>var int arrayAddress</code>     Memory address of array</li> <li><code>var int offset</code>     Array offset (array index)</li> <li><code>var string value</code>     String to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_access/#mem_writebytearray","title":"<code>MEM_WriteByteArray</code>","text":"<p>Writes byte value in the array at <code>arrayAddress</code>. </p><pre><code>func void MEM_WriteByteArray(var int arrayAddress, var int offset, var int value)\n</code></pre> Parameters <ul> <li><code>var int arrayAddress</code>     Memory address of array</li> <li><code>var int offset</code>     Array offset (array index)</li> <li><code>var int value</code>     Byte to write</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/","title":"Memory utility","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#memory-utility","title":"Memory utility","text":"<p>Ikarus utility functions, for memory management and manipulation.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_alloc","title":"<code>MEM_Alloc</code>","text":"<p>Allocates a specified amount of memory and returns a pointer to the allocated memory area. </p> <p>Danger</p> <p>Gothic does not and cannot retain a reference to this memory area or release it, even when destroying the session. Therefore, memory should only be reserved under certain conditions:</p> <ul> <li>It is guaranteed to exist and can be released again with <code>MEM_Free</code> after loading a save game.</li> <li>Gothic is aware of this memory area and independently releases it. </li> </ul> <p>It might be possible to create new objects with this function and permanently integrate them into the object structure of Gothic. However, extreme caution is advised, as object structures cannot be used, and manual handling is required.</p> <p>This function is well-suited for building small elements like list items and integrating them into existing lists. The memory allocated by this function is always initialized to zero. </p><pre><code>func int MEM_Alloc(var int amount)\n</code></pre> Parameters <ul> <li><code>var int amount</code>      The amount of bytes to allocate</li> </ul> <p>Return value</p> <p>The function returns a pointer to the allocated memory area.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_realloc","title":"<code>MEM_Realloc</code>","text":"<p>Allocates a memory area of \u200b\u200bsize <code>newsize</code> and returns a pointer to this memory area. The memory area from location <code>ptr</code> is released.</p> <p>If <code>newsize &gt;= oldsize</code>, the first <code>oldsize</code> bytes from the old memory area are transferred to the new one. The additional memory is initialized with zero.</p> <p>If <code>newsize &lt;= oldsize</code>, all bytes of the new memory area are initialized with the corresponding values \u200b\u200bof the old memory area.</p> <p>This function is intended to create an allocated memory area enlarge or reduce. Existing data remains naturally way received.  </p><pre><code>func int MEM_Realloc(var int ptr, var int oldsize, var int newsize)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>      The original pointer to the memory block</li> <li><code>var int oldsize</code>      The size of the original memory block</li> <li><code>var int newsize</code>      The size of the new memory block</li> </ul> <p>Return value</p> <p>The function returns a pointer to the modified memory area.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_free","title":"<code>MEM_Free</code>","text":"<p>Releases an allocated memory area. </p> <p>Danger</p> <p>Great caution is advised, especially when attempting to destroy engine objects, as no destructors are called!</p> <p>Releasing small things such as list elements can be done easily. </p><pre><code>func void MEM_Free(var int ptr)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>      Pointer to the released memory block</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_copy","title":"<code>MEM_Copy</code>","text":"<p>Copies a specified number of words from the source address to the destination address. </p><pre><code>func void MEM_Copy(var int src, var int dst, var int wordcount)\n</code></pre> Parameters <ul> <li><code>var int src</code>      The source address to copy from</li> <li><code>var int dst</code>      The destination address to copy to</li> <li><code>var int wordCount</code>      The number of words to copy</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_copywords","title":"<code>MEM_CopyWords</code>","text":"<p>Alias to <code>MEM_Copy</code>. Copies a specified number of words from the source address to the destination address. </p><pre><code>func void MEM_CopyWords(var int src, var int dst, var int wordcount) </code></pre> Parameters <ul> <li><code>var int src</code>      The source address to copy from</li> <li><code>var int dst</code>      The destination address to copy to</li> <li><code>var int wordCount</code>      The number of words to copy</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_copybytes","title":"<code>MEM_CopyBytes</code>","text":"<p>Copies a specified number of bytes from the source address to the destination address </p><pre><code>func void MEM_CopyBytes(var int src, var int dst, var int byteCount)\n</code></pre> Parameters <ul> <li><code>var int src</code>      The source address to copy from</li> <li><code>var int dst</code>      The destination address to copy to</li> <li><code>var int byteCount</code>      The number of bytes to copy</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_swap","title":"<code>MEM_Swap</code>","text":"<p>Swaps a specified number of words between the source address and the destination address. </p><pre><code>func void MEM_Swap(var int src, var int dst, var int wordCount)\n</code></pre> Parameters <ul> <li><code>var int src</code>      The source address to swap from</li> <li><code>var int dst</code>      The destination address to swap to</li> <li><code>var int wordCount</code>      The number of words to swap</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_swapwords","title":"<code>MEM_SwapWords</code>","text":"<p>Alias to <code>MEM_Swap</code>. Swaps a specified number of words between the source address and the destination address. </p><pre><code>func void MEM_SwapWords(var int src, var int dst, var int wordCount)\n</code></pre> Parameters <ul> <li><code>var int src</code>      The source address to swap from</li> <li><code>var int dst</code>      The destination address to swap to</li> <li><code>var int wordCount</code>      The number of words to swap</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_swapbytes","title":"<code>MEM_SwapBytes</code>","text":"<p>Swaps a specified number of bytes between the source address and the destination address. </p><pre><code>func void MEM_SwapBytes(var int src, var int dst, var int byteCount)\n</code></pre> Parameters <ul> <li><code>var int src</code>      The source address to swap from</li> <li><code>var int dst</code>      The destination address to swap to</li> <li><code>var int byteCount</code>      The number of bytes to swap</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_clear","title":"<code>MEM_Clear</code>","text":"<p>Sets a specified number of bytes in memory to zero. </p><pre><code>func void MEM_Clear(var int ptr, var int size)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>      The memory address to start clearing from</li> <li><code>var int size</code>      The number of bytes to clear</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_compare","title":"<code>MEM_Compare</code>","text":"<p>Compares a specified number of words between two memory blocks. </p><pre><code>func int MEM_Compare(var int ptr0, var int ptr1, var int wordCount)\n</code></pre> Parameters <ul> <li><code>var int ptr0</code>      The first memory block to compare</li> <li><code>var int ptr1</code>      The second memory block to compare</li> <li><code>var int wordCount</code>      The number of words to compare</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the memory blocks are equal, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_comparewords","title":"<code>MEM_CompareWords</code>","text":"<p>Alias to <code>MEM_Compare</code>. Compares a specified number of words between two memory blocks. </p><pre><code>func int MEM_CompareWords(var int ptr0, var int ptr1, var int wordCount)\n</code></pre> Parameters <ul> <li><code>var int ptr0</code>      The first memory block to compare</li> <li><code>var int ptr1</code>      The second memory block to compare</li> <li><code>var int wordCount</code>      The number of words to compare</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the memory blocks are equal, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/mem_utility/#mem_comparebytes","title":"<code>MEM_CompareBytes</code>","text":"<p>Compares a specified number of bytes between two memory blocks. </p><pre><code>func int MEM_CompareBytes(var int ptr1, var int ptr2, var int byteCount)\n</code></pre> Parameters <ul> <li><code>var int ptr0</code>      The first memory block to compare</li> <li><code>var int ptr1</code>      The second memory block to compare</li> <li><code>var int wordCount</code>      The number of bytes to compare</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the memory blocks are equal, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/menu_access/","title":"Access Menu Objects","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/menu_access/#access-menu-objects","title":"Access Menu Objects","text":"<p>These Ikarus functions are intended to provide and simplify access to menu items (e.g. in the character menu).</p> <p>Tip</p> <p>Some menus are generated every time they are used, while others are generated once and then kept. For example, a character menu is only available after it was opened for the first time, after that it is kept in memory. Depending on what you actually want to do, it can make sense to introduce changes in the menu scripts.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/menu_access/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/menu_access/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/menu_access/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/menu_access/#mem_getmenubystring","title":"<code>MEM_GetMenuByString</code>","text":"<pre><code>func int MEM_GetMenuByString(var string menuName)\n</code></pre> <p>Parameters</p> <ul> <li><code>var string menuName</code>     Name of the Gothic menu e.g. <code>MENU_STATUS</code></li> </ul> <p>Return value</p> <p>The function returns the address of the menu if a menu with this name exists, null otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/menu_access/#mem_getmenuitembystring","title":"<code>MEM_GetMenuItemByString</code>","text":"<pre><code>func int MEM_GetMenuItemByString(var string menuItemName)\n</code></pre> <p>Parameters</p> <ul> <li><code>var string menuItemName</code>     Name of the Gothic menu item e.g. <code>MENU_ITEM_PLAYERGUILD_TITLE</code></li> </ul> <p>Return value</p> <p>The function returns the address of the menu item if a menu item with this name exists, null otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/","title":"zCObjects","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#zcobjects","title":"zCObjects","text":"<p>Set of functions for working with <code>zCObject</code> and its subclasses instances.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#global-instances","title":"Global instances","text":"<p>Ikarus package introduces the following instances: </p> <pre><code>instance MEM_Game (oCGame);\ninstance MEM_World(oWorld);\ninstance MEM_Timer(zCTimer);\ninstance MEM_WorldTimer(oCWorldTimer);\ninstance MEM_Vobtree(zCTree);\ninstance MEM_InfoMan(oCInfoManager);\ninstance MEM_InformationMan (oCInformationManager);\ninstance MEM_Waynet(zCWaynet);\ninstance MEM_Camera(zCCamera);\ninstance MEM_SkyController(zCSkyController_Outdoor);\ninstance MEM_SpawnManager (oCSpawnManager);\ninstance MEM_GameMananger (CGameManager);\ninstance MEM_GameManager (CGameManager);\ninstance MEM_Parser(zCParser);\n</code></pre> <p>The classes used here all have one thing in common: there is a maximum of one object of them at the same time (e.g. there is not two worlds or two sky at the same time). </p> <p><code>MEM_InitGlobalInst</code> function sets the offsets of these instances to the corresponding unique object. While it has been called, all of the above instances can be used.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_initglobalinst","title":"<code>MEM_InitGlobalInst</code>","text":"<p>Initializes global instances of commonly used objects in the game (is called by the <code>MEM_InitAll</code> function). </p><pre><code>func void MEM_InitGlobalInst()\n</code></pre> <p>Warning</p> <p><code>MEM_InitGlobalInst</code> must be executed once after loading a savegame. The easiest way is do it is to call this function from <code>INIT_GLOBAL</code>.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#functions","title":"Functions","text":"About zCClassDef <p>For every class (derived from <code>zCObject</code>) there is an \"administrative object\" of type <code>zCClassDef</code>. This encapsulates some useful information about all objects in this class.</p> <pre><code>class zCClassDef {\nvar string className;            //zSTRING\nvar string baseClassName;        //zSTRING\nvar string scriptClassName;      //zSTRING\nvar int baseClassDef;            //zCClassDef*\nvar int createNewInstance;       //zCObject* ( *) (void) \nvar int createNewInstanceBackup; //zCObject* ( *) (void)\nvar int classFlags;              //zDWORD\nvar int classSize;               //zDWORD\nvar int numLivingObjects;\nvar int numCtorCalled;\nvar int hashTable;               //zCObject**\nvar int objectList_array;        //zCObject**\nvar int objectList_numAlloc;     //int\nvar int objectList_numInArray;   //int\nvar int bitfield;\n};\n</code></pre> <p>Full Ikarus definition of this class, with members decription can be found in <code>Misc.d</code> file. The class is same for G1 and G2A engines.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_getclassdef","title":"<code>MEM_GetClassDef</code>","text":"<p>Returns a pointer to the <code>zCClassDef</code> of the object. For more info see the About zCClassDef section above.</p> <p>Passing these functions a pointer that does not point to a zCObject will most likely result in a crash lead. </p> <p></p><pre><code>func int MEM_GetClassDef(var int objPtr)\n</code></pre> Parameters <ul> <li><code>var int objPtr</code>      A pointer to the object whose class definition is to be retrieved</li> </ul> <p>Return value</p> <p>The function returns a pointer to the <code>zCClassDef</code> of the object.</p> Example <p>This would return a pointer to the <code>zCClassDef</code> object that belongs to the <code>oCNpc</code> class. </p><pre><code>func int example1\n{\nvar int her; her = MEM_InstToPtr(hero);\nreturn MEM_GetClassDef(her);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_getclassname","title":"<code>MEM_GetClassName</code>","text":"<p>This function returns the name of the class to which an object belongs. </p><pre><code>func string MEM_GetClassName(var int objPtr)\n</code></pre> Parameters <ul> <li><code>var int objPtr</code>      A pointer to the object whose class name is to be retrieved</li> </ul> <p>Return value</p> <p>The function returns the objects class name as a string, if the object is invalid an empty string is returned.</p> Example <p>This would return a name of the <code>oCNpc</code> class as a string. </p><pre><code>func string example2\n{\nvar int her; her = MEM_InstToPtr(hero);\nreturn MEM_GetClassName(her);\n};\n// return: \"oCNpc\"\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_checkinheritance","title":"<code>MEM_CheckInheritance</code>","text":"<p>Checks if an object is derived from a specific class definition. </p><pre><code>func int MEM_CheckInheritance(var int objPtr, var int classDef)\n</code></pre> Parameters <ul> <li><code>var int objPtr</code>      A pointer to the object to be checked</li> <li><code>var int classDef</code>      A pointer to the class definition to check against</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the object is derived from the specified class definition, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#hlp_is_","title":"<code>Hlp_Is_*</code>","text":"<p>In addition <code>MEM_CheckInheritance</code> function has some overloads with hardcoded <code>classDef</code> parameter.</p> <pre><code>func int Hlp_Is_oCMobFire(var int ptr){};\nfunc int Hlp_Is_zCMover(var int ptr){};\nfunc int Hlp_Is_oCMob(var int ptr){};\nfunc int Hlp_Is_oCMobInter(var int ptr){};\nfunc int Hlp_Is_oCMobLockable(var int ptr){};\nfunc int Hlp_Is_oCMobContainer(var int ptr){};\nfunc int Hlp_Is_oCMobDoor(var int ptr){};\nfunc int Hlp_Is_oCMobBed(var int ptr){};\nfunc int Hlp_Is_oCMobSwitch(var int ptr){};\nfunc int Hlp_Is_oCMobWheel(var int ptr){};\nfunc int Hlp_Is_oCMobLadder(var int ptr){};\nfunc int Hlp_Is_oCNpc(var int ptr){};\nfunc int Hlp_Is_oCItem(var int ptr){};\nfunc int Hlp_Is_zCVobLight(var int ptr){};\n</code></pre> <p>The usage of these functions is probably obvious, they checks if the given object belongs to class given in the function name.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_insertvob","title":"<code>MEM_InsertVob</code>","text":"<p>Inserts a Vob with the visual <code>vis</code> at the waypoint <code>wp</code>. If the visual or waypoint does not exist, this is the behaviour this function undefined. </p> <p>Note</p> <p>The inserted Vob is even an <code>oCMob</code>, so it can be given a focus name, for example. But you can treat it like a <code>zCVob</code>), if you don't need the additional properties. </p> <p></p><pre><code>func int MEM_InsertVob(var string vis, var string wp)\n</code></pre> Parameters <ul> <li><code>var string vis</code>      Name of the inserted Vob visual (<code>\"FAKESCROLL.3DS\"</code>, <code>\"FIRE.PFX\"</code>, <code>\"SNA_BODY.ASC\"</code>, <code>\"CHESTSMALL_NW_POOR_LOCKED.MDS\"</code>, <code>\"ADD_PIRATEFLAG.MMS\"</code> etc.)</li> <li><code>var string wp</code>      Name of the waypoint to insert Vob on</li> </ul> <p>Return value</p> <p>The function returns a pointer to the created object.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_deletevob","title":"<code>MEM_DeleteVob</code>","text":"<p>Deletes a specific Vob form world. </p><pre><code>func void MEM_DeleteVob(var int vobPtr)\n</code></pre> Parameters <ul> <li><code>var int vobPtr</code>      Pointer to a <code>zCVob</code> object to be deleted</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_renamevob","title":"<code>MEM_RenameVob</code>","text":"<p>Renames the passed Vob to the <code>newName</code> that is also passed. </p> <p>The object becomes this first removed from the Vob-hashtable, then unnamed and then again inserted into the Vob-hashtable under a new name. </p><pre><code>func void MEM_RenameVob(var int vobPtr, var string newName)\n</code></pre> Parameters <ul> <li><code>var int vobPtr</code>      Pointer to a <code>zCVob</code> object to be renamed</li> <li><code>var string newName</code>      The new Name of the Vob</li> </ul> MEM_TriggerVobMEM_UntriggerVob"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_triggervob","title":"<code>MEM_TriggerVob</code>","text":"<p>Sends a trigger message to the Vob. </p><pre><code>func void MEM_TriggerVob(var int vobPtr)\n</code></pre> Parameters <ul> <li><code>var int vobPtr</code>      Pointer to a triggered <code>zCVob</code></li> </ul> <p>Danger</p> <p>If triggering the Vob has immediate effects (even before MEM_TriggerVob is exited), the name of the Vob is corrupted during this time. It is not advisable to rename, trigger again or destroy the object at this moment, the behavior in such cases is untested.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_untriggervob","title":"<code>MEM_UntriggerVob</code>","text":"<p>Sends an untrigger message to the Vob. </p><pre><code>func void MEM_TriggerVob(var int vobPtr)\n</code></pre> Parameters <ul> <li><code>var int vobPtr</code>      Pointer to an untriggered <code>zCVob</code></li> </ul> <p>Danger</p> <p>If untriggering the Vob has immediate effects (even before MEM_TriggerVob is exited), the name of the Vob is corrupted during this time. It is not advisable to rename, trigger again or destroy the object at this moment, the behavior in such cases is untested.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_searchvobbyname","title":"<code>MEM_SearchVobByName</code>","text":"<p>Returns the address of a <code>zCVob</code> named <code>str</code> if such a Vob exists. </p><pre><code>func int MEM_SearchVobByName(var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>      Name of searched <code>zCVob</code></li> </ul> <p>Return value</p> <p>The function returns a pointer to the <code>zCVob</code> if the object with the given name exist. <code>0</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_searchallvobsbyname","title":"<code>MEM_SearchAllVobsByName</code>","text":"<p>Variation of <code>MEM_SearchVobByName</code>. Creates a <code>zCArray</code> in which all pointers are to Vobs with the name <code>str</code>. If no Vob with the name exists, an empty <code>zCArray</code> is created. A pointer to the created <code>zCArray</code> is then returned. This can be evaluated, but should be released again with <code>MEM_ArrayFree</code> before the end of the frame (before the player can load) to avoid memory leaks. </p><pre><code>func int MEM_SearchAllVobsByName(var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>      Name of searched <code>zCVob</code></li> </ul> <p>Return value</p> <p>The function returns a pointer to the created <code>zCArray</code>, taht contains pointers to the all Vobs with the specified name. </p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_getbuffercrc32","title":"<code>MEM_GetBufferCRC32</code>","text":"<p>Calculates the CRC32 hash value from a byte array starting at the address specified by <code>buf</code> and having a length of <code>buflen</code>. </p><pre><code>func int MEM_GetBufferCRC32(var int buf, var int buflen)\n</code></pre> Parameters <ul> <li> <p><code>var int buf</code>      Address of a byte array, the hash calculation will begin from</p> </li> <li> <p><code>var int buflen</code>      The length of the byte array starting from the address specified by <code>buf</code></p> </li> </ul> <p>Return value</p> <p>The function returns the calculated CRC32 hash value.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/objects/#mem_getstringhash","title":"<code>MEM_GetStringHash</code>","text":"<p>Calculates the CRC32 hash value for a string. </p><pre><code>func int MEM_GetStringHash(var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>      A string for which the hash value is to be calculated</li> </ul> <p>Return value</p> <p>The function returns an integer representing the calculated hash value for the input string.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/","title":"Parser stuff","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#zcparser-related-functions","title":"<code>zCParser</code> related functions","text":"<p>This Ikarus part provides some useful functions to work with parser, its instances, symbols and stack.</p> <p>Danger</p> <p>Remember to always assign an instance to a correct class. If you assign an <code>oCNpc</code> pointer to <code>oCItem</code> class you won't be able to read any data from it.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_reinitparser","title":"<code>MEM_ReinitParser</code>","text":"<p>Parser operations are initialized with this function. </p><pre><code>func void MEM_ReinitParser()\n</code></pre> <p>Tip</p> <p>It's worth noting that <code>MEM_ReinitParser</code> is also invoked by the <code>MEM_InitAll</code> function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#pointers-and-instances","title":"Pointers and instances","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_ptrtoinst","title":"<code>MEM_PtrToInst</code>","text":"<p>Returns an instance pointed to by the pointer. If the pointer is null an error is thrown. </p><pre><code>func MEMINT_HelperClass MEM_PtrToInst(var int ptr)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>     Pointer to return an instance from</li> </ul> <p>Shortcut</p> <p>In addition there is a function <code>_^</code> with the same signature and functionality as <code>MEM_PtrToInst</code>. It is used as a shortcut, since the converting pointer to instance is commonly used while working with Ikarus.</p> <pre><code>func MEMINT_HelperClass _^ (var int ptr)\n</code></pre> Example <p>Following code </p><pre><code>var oCNpc her; her = MEM_PtrToInst(heroPtr);\n</code></pre> is equivalent to <pre><code>var oCNpc her; her = _^(heroPtr);\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_nulltoinst","title":"<code>MEM_NullToInst</code>","text":"<p>Returns an instance from a null pointer. </p><pre><code>func MEMINT_HelperClass MEM_NullToInst()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_assigninst","title":"<code>MEM_AssignInst</code>","text":"<p>Takes an instance from a pointer and assigns it to a given instance. If the pointer is null an error is thrown. </p><pre><code>func void MEM_AssignInst(var int inst, var int ptr)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>     Pointer to assign an instance from</li> <li><code>var int inst</code>     Instance to which the pointer will be assigned</li> </ul> Example <p>Following code </p><pre><code>var oCNpc inst;\nMEM_AssignInst (inst, ptr); </code></pre> is equivalent to <pre><code>var oCNpc inst;\ninst = MEM_PtrToInst(ptr);\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_assigninstnull","title":"<code>MEM_AssignInstNull</code>","text":"<p>Assigns null pointer to a given instance. </p><pre><code>func void MEM_AssignInstNull(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     Instance to which the null pointer will be assigned</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_insttoptr","title":"<code>MEM_InstToPtr</code>","text":"<p>Returns a pointer to given instance. </p><pre><code>func int MEM_InstToPtr(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     The instance to which the pointer is returned</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_instgetoffset","title":"<code>MEM_InstGetOffset</code>","text":"<p>Alias to <code>MEM_InstToPtr</code>. Returns a pointer to given instance. </p><pre><code>func int MEM_InstGetOffset(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     The instance to which the pointer is returned</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_cpyinst","title":"<code>MEM_CpyInst</code>","text":"<p>Returns a copy of a given instance </p><pre><code>func MEMINT_HelperClass MEM_CpyInst(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     Instance to copy</li> </ul> example <p>Following code </p><pre><code>selfCopy = MEM_CpyInst (self);\n</code></pre> is equivalent to <pre><code>selfCopy = MEM_PtrToInst (MEM_InstToPtr (self));\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#call-function","title":"Call function","text":"<p>You don't always know at compile time when you want to call which function. For example, if you want to call the condition function of a mob that the player has in focus, you are at a loss at compile time because you have no idea which mob the player will choose. Ikarus provides a way to call functions based on their name or symbol index. In the example of the mob, the name of the condition function can simply be looked up in the mob.</p> <p>Note</p> <p>The functions below also work for externals without any restrictions.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#passing-parameters","title":"Passing Parameters","text":"<p>If the function to be called has parameters, these must first be placed on the data stack. The parameters must be pushed in the correct order, from left to right. </p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_pushintparam","title":"<code>MEM_PushIntParam</code>","text":"<p>Passes an integer as a parameter to the called function. </p><pre><code>func void MEM_PushIntParam (var int param)\n</code></pre> Parameters <ul> <li><code>var int param</code>     Integer to pass as a function parameter</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_pushinstparam","title":"<code>MEM_PushInstParam</code>","text":"<p>Passes an instance as a parameter to the called function. </p><pre><code>func void MEM_PushInstParam (var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     Instance to pass as a function parameter</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_pushstringparam","title":"<code>MEM_PushStringParam</code>","text":"<p>Passes a string as a parameter to the called function. </p><pre><code>func void MEM_PushStringParam (var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>     String to pass as a function parameter</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#the-call","title":"The call","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_call","title":"<code>MEM_Call</code>","text":"<p>Calls a function. </p><pre><code>func void MEM_Call(var func fnc)\n</code></pre> Parameters <ul> <li><code>var func fnc</code>     Function to be called</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_callbyid","title":"<code>MEM_CallByID</code>","text":"<p>Calls a function by its ID. </p><pre><code>func void MEM_CallByID (var int symbID)\n</code></pre> Parameters <ul> <li><code>var int symbID</code>     The ID of the function to be called</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_callbyptr","title":"<code>MEM_CallByPtr</code>","text":"<p>Calls a function by its pointer. </p><pre><code>func void MEM_CallByPtr(var int ptr)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>     The pointer of the function to be called</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_callbyoffset","title":"<code>MEM_CallByOffset</code>","text":"<p>Calls a function by its offset. </p><pre><code>func void MEM_CallByOffset(var int offset)\n</code></pre> Parameters <ul> <li><code>var int offset</code>     The offset of the function to be called</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_callbystring","title":"<code>MEM_CallByString</code>","text":"<p>Calls a function by its name. </p><pre><code>func void MEM_CallByString (var string fnc)\n</code></pre> Parameters <ul> <li><code>var string fnc</code>     The name of the function IN CAPITAL LETTERS.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#return-value","title":"Return value","text":"<p>If a function has a return value, it should be fetched from the data stack after it is called, otherwise stack overflows can occur under unfavorable circumstances (aside from that, you may simply want the return value because it contains important information).</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_popintresult","title":"<code>MEM_PopIntResult</code>","text":"<p>Retrieves an integer returned by the called function. </p><pre><code>func int MEM_PopIntResult()\n</code></pre> Return value <p>The function returns an integer returned by the previously called script function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_popstringresult","title":"<code>MEM_PopStringResult</code>","text":"<p>Retrieves a daedalus string returned by the called function. </p><pre><code>func string MEM_PopStringResult()\n</code></pre> Return value <p>The function returns a string returned by the previously called script function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_popinstresult","title":"<code>MEM_PopInstResult</code>","text":"<p>Retrieves an instance returned by the called function. </p><pre><code>func MEMINT_HelperClass MEM_PopInstResult()\n</code></pre> Return value <p>The function returns an instance returned by the previously called script function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#function-stuff","title":"Function stuff","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getfuncid","title":"<code>MEM_GetFuncID</code>","text":"<p>Returns the ID of the given function. </p><pre><code>func int MEM_GetFuncID(var func fnc)\n</code></pre> Parameters <ul> <li><code>var func fnc</code>     The function whose ID is returned</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getfuncptr","title":"<code>MEM_GetFuncPtr</code>","text":"<p>Returns the pointer of the given function. </p><pre><code>func int MEM_GetFuncPtr(var func fnc)\n</code></pre> Parameters <ul> <li><code>var func fnc</code>     The function whose pointer is returned</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getfuncoffset","title":"<code>MEM_GetFuncOffset</code>","text":"<p>Returns the offset of the given function. </p><pre><code>func int MEM_GetFuncOffset(var func fnc)\n</code></pre> Parameters <ul> <li><code>var func fnc</code>     The function whose offset is returned</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getfuncidbyoffset","title":"<code>MEM_GetFuncIDByOffset</code>","text":"<p><code>MEM_GetFuncID</code>, but with an offset as a parameter. </p><pre><code>func int MEM_GetFuncIDByOffset(var int offset)\n</code></pre> Parameters <ul> <li><code>var int offset</code>     Offset of a function whose ID is returned</li> </ul> <p>Return value</p> <p>The function returns an ID of a function with a given offset.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_replacefunc","title":"<code>MEM_ReplaceFunc</code>","text":"<p>Replaces the <code>f1</code> function with <code>f2</code> function so if you call the first function, the second function is called. </p><pre><code>func void MEM_ReplaceFunc(var func f1, var func f2)\n</code></pre> Parameters <ul> <li><code>var func f1</code>     Function to replace</li> <li><code>var func f2</code>     Function called instead of <code>f1</code></li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#parser-stack","title":"Parser stack","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getframeboundary","title":"<code>MEM_GetFrameBoundary</code>","text":"<p>Returns the address/pointer to the boundary of a stack frame (ESP). </p><pre><code>func int MEM_GetFrameBoundary()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getcallerstackpos","title":"<code>MEM_GetCallerStackPos</code>","text":"<p>Retrieves the stack position (pop position) of the caller's caller (look at the example for better understanding). </p><pre><code>func int MEM_GetCallerStackPos()\n</code></pre> Return value <p>The function returns an integer representing the stack position of the caller's caller.</p> Example <p>After calling <code>B()</code> from within <code>A()</code>, when <code>MEM_GetCallerStackPos()</code> is invoked in function <code>B()</code>, it retrieves the stack position of the caller's caller, which is function <code>A()</code> in this case. Therefore, the variable <code>adr</code> will contain the stack position of function <code>A()</code>. </p><pre><code>func void A(){\nB();\n};\nfunc void B(){\nint adr; adr = MEM_GetCallerStackPos();\n// Now, 'adr' will contain the stack position of A.\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_setcallerstackpos","title":"<code>MEM_SetCallerStackPos</code>","text":"<p>Sets the stack position (pop position) of the caller's caller. </p><pre><code>func void MEM_SetCallerStackPos(var int popPos)\n</code></pre> Parameters <ul> <li><code>var int popPos</code>     An integer parameter representing the new stack position of the caller's caller</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#get-address","title":"Get address","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getaddress_init","title":"<code>MEM_GetAddress_Init</code>","text":"<p>Initializes the <code>MEM_GetIntAddress</code>, <code>MEM_GetFloatAddress</code> and <code>MEM_GetStringAddress</code> functions. </p><pre><code>func void MEM_GetAddress_Init()\n</code></pre> <p>Tip</p> <p>It's worth noting that <code>MEM_GetAddress_Init</code> is also invoked by the <code>MEM_InitAll</code> function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getintaddress","title":"<code>MEM_GetIntAddress</code>","text":"<p>Returns an address of a given integer. </p><pre><code>func int MEM_GetIntAddress(var int i)\n</code></pre> Parameters <ul> <li><code>var int i</code>     Integer whose address is returned</li> </ul> <p>Shortcut</p> <p>In addition there is a function <code>_@</code> with the same signature and functionality as <code>MEM_GetIntAddress</code>.</p> <pre><code>func int _@(var int i)\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getfloataddress","title":"<code>MEM_GetFloatAddress</code>","text":"<p>Returns an address of a given daedalus float. </p><pre><code>func int MEM_GetFloatAddress(var float f)\n</code></pre> Parameters <ul> <li><code>var float f</code>     Float whose address is returned</li> </ul> <p>Shortcut</p> <p>In addition there is a function <code>_@f</code> with the same signature and functionality as <code>MEM_GetFloatAddress</code>.</p> <pre><code>func int _@s(var string s)\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getstringaddress","title":"<code>MEM_GetStringAddress</code>","text":"<p>Returns an address of a given string. </p><pre><code>func int MEM_GetStringAddress(var string s)\n</code></pre> Parameters <ul> <li><code>var string s</code>     String whose address is returned</li> </ul> <p>Shortcut</p> <p>In addition there is a function <code>_@s</code> with the same signature and functionality as <code>MEM_GetStringAddress</code>.</p> <pre><code>func int _@s(var string s)\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#str_getaddressinit","title":"<code>STR_GetAddressInit</code>","text":"<p>Alias to <code>MEM_GetAddress_Init</code>, kept for downward compatibility. </p><pre><code>func void STR_GetAddressInit()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#str_getaddress","title":"<code>STR_GetAddress</code>","text":"<p>Function similar to <code>MEM_GetStringAddress</code>. There is a guarantee, that this function works initialized i.e. invokes <code>MEM_GetAddress_Init</code>, but the first time may only return an address of a copy of the string. </p><pre><code>func int STR_GetAddress(var string str)\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#static-arrays","title":"Static arrays","text":"<p>Accessing static arrays like this below is very tedious in Daedalus. </p><pre><code>var int myStaticArray[42];\n</code></pre> It is not possible to access <code>myStaticArray[i]</code> with a variable index i, but only with a constant. This changes with the following functions.  <p>Danger</p> <p>Neither function performs any kind of validity check. If the value passed is not an array or offsets are beyond the boundaries of the array passed, the behavior is undefined.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_initstatarrs","title":"<code>MEM_InitStatArrs</code>","text":"<p>Initializes static arrays read and write functions. </p><pre><code>func void MEM_InitStatArrs()\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_writestatarr","title":"<code>MEM_WriteStatArr</code>","text":"<p>Changes the value at the <code>offset</code> of a static integer-array. </p><pre><code>func void MEM_WriteStatArr (var int array, var int offset, var int value)\n</code></pre> Parameters <ul> <li><code>var int array</code>     Array which will be edited</li> <li><code>var int offset</code>     Array index at which value will be edited</li> <li><code>var int value</code>     The new value</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_readstatarr","title":"<code>MEM_ReadStatArr</code>","text":"<p>Reads the value at the specific offset of a static integer-array. </p><pre><code>func int MEM_ReadStatArr (var int array, var int offset)\n</code></pre> Parameters <ul> <li><code>var int array</code>     Array to get a value from </li> <li><code>var int offset</code>     Array index of the value to return</li> </ul> <p>Return value</p> <p>The function returns an integer value from the <code>offset</code> of a given static array.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_writestatstringarr","title":"<code>MEM_WriteStatStringArr</code>","text":"<p>Changes the value at the <code>offset</code> of a static string-array. </p><pre><code>func void MEM_WriteStatStringArr(var string array, var int offset, var string value)\n</code></pre> Parameters <ul> <li><code>var string array</code>     Array which will be edited</li> <li><code>var int offset</code>     Array index at which value will be edited</li> <li><code>var string value</code>     The new value</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_readstatstringarr","title":"<code>MEM_ReadStatStringArr</code>","text":"<p>Reads the value at the specific offset of a static string-array. </p><pre><code>func string MEM_ReadStatStringArr(var string array, var int offset)\n</code></pre> Parameters <ul> <li><code>var string array</code>     Array to get a value from </li> <li><code>var int offset</code>     Array index of the value to return</li> </ul> <p>Return value</p> <p>The function returns a string form the <code>offset</code> of a given static array.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#parser-symbol","title":"Parser symbol","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_setcurrparsersymb","title":"<code>MEM_SetCurrParserSymb</code>","text":"<p>Makes <code>currParserSymb</code> point to the symbol of the specified instance. </p><pre><code>func void MEM_SetCurrParserSymb (var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     Instance to whose symbol <code>currParserSymb</code> will be set</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#currparsersymb","title":"<code>currParserSymb</code>","text":"<p>An instance representing current parser symbol. </p><pre><code>INSTANCE currParserSymb (zCPar_Symbol);\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_findparsersymbol","title":"<code>MEM_FindParserSymbol</code>","text":"<p>Returns the index of the parser symbol with name <code>inst</code> if such a symbol exists. </p><pre><code>func int MEM_FindParserSymbol(var string inst)\n</code></pre> Parameters <ul> <li><code>var string inst</code>     Name of the symbol to be found</li> </ul> <p>Return value</p> <p>The function returns the index of the parser symbol with name <code>inst</code> if such a symbol exists. If non exists, a warning is issued and <code>-1</code> is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getsymbolindex","title":"<code>MEM_GetSymbolIndex</code>","text":"<p>Alias to <code>MEM_FindParserSymbol</code>. Returns the index of the parser symbol with name <code>inst</code> if such a symbol exists. </p><pre><code>func int MEM_GetSymbolIndex(var string inst)\n</code></pre> Parameters <ul> <li><code>var string inst</code>     Name of the symbol to be found</li> </ul> <p>Return value</p> <p>The function returns the index of the parser symbol with name <code>inst</code> if such a symbol exists. If non exists, a warning is issued and <code>-1</code> is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getparsersymbol","title":"<code>MEM_GetParserSymbol</code>","text":"<p>Looks for the parser symbol with the name <code>inst</code> and returns a pointer to the appropriate <code>zCPar_Symbol</code> structure. </p><pre><code>func int MEM_GetParserSymbol (var string inst)\n</code></pre> Parameters <ul> <li><code>var string inst</code>     Name of the symbol to be found</li> </ul> <p>Return value</p> <p>The function returns the appropriate <code>zCPar_Symbol</code> structure of the parser symbol with name <code>inst</code> if such a symbol exists. If non exists, a warning is issued and <code>0</code> is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getsymbol","title":"<code>MEM_GetSymbol</code>","text":"<p>Alias to <code>MEM_GetParserSymbol</code>. Looks for the parser symbol with the name <code>inst</code> and returns a pointer to the appropriate <code>zCPar_Symbol</code> structure. </p><pre><code>func int MEM_GetSymbol(var string inst)\n</code></pre> Parameters <ul> <li><code>var string inst</code>     Name of the symbol to be found</li> </ul> <p>Return value</p> <p>The function returns the appropriate <code>zCPar_Symbol</code> structure of the parser symbol with name <code>inst</code> if such a symbol exists. If non exists, a warning is issued and <code>0</code> is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/parser/#mem_getsymbolbyindex","title":"<code>MEM_GetSymbolByIndex</code>","text":"<p><code>MEM_GetParserSymbol</code>, but with ID (index) as a parameter. </p><pre><code>func int MEM_GetSymbolByIndex(var int id)\n</code></pre> Parameters <ul> <li><code>var string inst</code>     ID (index) of the symbol to be found</li> </ul> <p>Return value</p> <p>The function returns the appropriate <code>zCPar_Symbol</code> structure of the parser symbol with name <code>inst</code> if such a symbol exists. If non exists, a warning is issued and <code>0</code> is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/","title":"String operations","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/string/#string-operations","title":"String operations","text":"<p>Collection of Ikarus functions to manipulate and format strings.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_getcharat","title":"<code>STR_GetCharAt</code>","text":"<p>Returns the ASCII value of a character at a specific position in a string. </p><pre><code>func int STR_GetCharAt (var string str, var int pos)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> <li><code>var int pos</code>     The position of the character</li> </ul> <p>Return value</p> <p>The function returns the ASCII value of the character at the specified position.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_len","title":"<code>STR_Len</code>","text":"<p>Returns the length of a string. </p><pre><code>func int STR_Len (var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> </ul> <p>Return value</p> <p>The function returns the length of the string in characters.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_tochar","title":"<code>STR_toChar</code>","text":"<p>Converts a string to a pointer to its character array. </p><pre><code>func int STR_toChar (var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> </ul> <p>Return value</p> <p>The function returns a pointer to the character array representing the input string <code>str</code></p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_fromchar","title":"<code>STR_FromChar</code>","text":"<p>Converts a character array to a string. </p><pre><code>func string STR_FromChar(var int char)\n</code></pre> Parameters <ul> <li><code>var int char</code>     Pointer to the character array</li> </ul> <p>Return value</p> <p>The function returns a string representation of the character array.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_substr","title":"<code>STR_SubStr</code>","text":"<p>Extracts a substring from a given string. </p><pre><code>func string STR_SubStr (var string str, var int start, var int count)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> <li><code>var int start</code>     The starting position of the substring</li> <li><code>var int count</code>     The length of the substring</li> </ul> <p>Return value</p> <p>The function returns a substring, if the starting position is invalid an empty string is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_prefix","title":"<code>STR_Prefix</code>","text":"<p>Extracts a prefix of a given string, similar to <code>STR_SubStr</code>, but with the starting position set to the first character of the string. </p><pre><code>func string STR_Prefix (var string str, var int len)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> <li><code>var int count</code>     The length of the prefix</li> </ul> <p>Return value</p> <p>The function returns a prefix of the input string with the specified length.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_compare","title":"<code>STR_Compare</code>","text":"<p>Compares two strings lexicographically and returns a result indicating their relative order. </p><pre><code>func int STR_Compare(var string str1, var string str2)\n</code></pre> Parameters <ul> <li><code>var string str1</code>      The first string to compare</li> <li><code>var string str2</code>      The second string to compare</li> </ul> <p>Return Value</p> <p>The function returns an integer value representing the result of the comparison:</p> <ul> <li><code>STR_GREATER</code> (1): If <code>str1</code> comes lexicographically after <code>str2</code>.</li> <li><code>STR_EQUAL</code> (0): If <code>str1</code> is lexicographically equal to <code>str2</code>.</li> <li><code>STR_SMALLER</code> (-1): If <code>str1</code> comes lexicographically before <code>str2</code>.</li> </ul> Examples <p>The comparison is based on lexicographic order, which is the order of characters as they appear in the ASCII table. Uppercase letters come before lowercase letters.</p> <pre><code>int result1 = STR_Compare(\"A\", \"B\");\n// The 'result1' variable now contains STR_SMALLER\nint result2 = STR_Compare(\"ABC\", \"ABC\");\n// The 'result2' variable now contains STR_EQUAL\nint result3 = STR_Compare(\"AA\", \"A\");\n// The 'result3' variable now contains STR_GREATER\nint result4 = STR_Compare(\"BA\", \"BB\");\n// The 'result4' variable now contains STR_SMALLER\nint result5 = STR_Compare(\"B\", \"a\");\n// The 'result5' variable now contains STR_SMALLER\nint result6 = STR_Compare(\"A\", \"\");\n// The 'result6' variable now contains STR_GREATER\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_toint","title":"<code>STR_ToInt</code>","text":"<p>Converts a string to an integer. </p><pre><code>func int STR_ToInt (var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> </ul> <p>Return Value</p> <p>The function returns an integer value of the string, if a string is invalid (doesn't contain an integer) zero is returned.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_indexof","title":"<code>STR_IndexOf</code>","text":"<p>Searches for a substring <code>tok</code> within a given string and returns the index of the first occurrence of <code>tok</code>, taking into account upper and lower case letters. </p><pre><code>func int STR_IndexOf(var string str, var string tok)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The string in which to search for <code>tok</code>.</li> <li><code>var string tok</code>     The substring to search for within <code>str</code>.</li> </ul> <p>Return Value</p> <p>The function returns the index at which the first occurrence of <code>tok</code> begins within <code>str</code>. If <code>tok</code> is not found in <code>str</code>, the function returns -1.</p> Examples <pre><code>int index1 = STR_IndexOf(\"Hello World!\", \"Hell\");\n// The 'index1' variable now contains 0\nint index2 = STR_IndexOf(\"Hello World!\", \"World\");\n// The 'index2' variable now contains 6\nint index3 = STR_IndexOf(\"Hello World!\", \"Cake\");\n// The 'index3' variable now contains -1\nint index4 = STR_IndexOf(\"Hello World!\", \"\");\n// The 'index4' variable now contains 0\nint index5 = STR_IndexOf(\"Hello\", \"Hello World!\");\n// The 'index5' variable now contains -1\nint index6 = STR_IndexOf(\"hello Hell!\", \"Hell\");\n// The 'index6' variable now contains 6\nint index7 = STR_IndexOf(\"\", \"\");\n// The 'index7' variable now contains 0\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_splitcount","title":"<code>STR_SplitCount</code>","text":"<p>Counts the number of parts a string splits into when using a specified separator. </p><pre><code>func int STR_SplitCount(var string str, var string seperator)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string to be split.</li> <li><code>var string separator</code>     The separator character or string used to split the input string.</li> </ul> <p>Return Value</p> <p>The function returns a number of parts the input string splits into when using the specified separator.</p> Example <pre><code>string inputStr = \"This is a sentence.\";\nint count = STR_SplitCount(inputStr, \" \");\n// The 'count' variable now contains 4\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_split","title":"<code>STR_Split</code>","text":"<p>Splits a string into multiple substrings based on a specified separator and returns the substring at a specified offset. </p><pre><code>func string STR_Split(var string str, var string separator, var int offset)\n</code></pre> <p>Parameters</p> <ul> <li><code>var string str</code>     The input string to be split.</li> <li><code>var string separator</code>     The separator character or string used to split the input string.</li> <li><code>var int offset</code>     The index of the substring to be returned after splitting. The index is zero-based.</li> </ul> <p>Return Value</p> <p>The function returns a substring at the specified offset after splitting the input string. If the offset is greater than or equal to the number of parts generated by splitting, an empty string is returned.</p> Example <p></p><pre><code>func void foo() {\nstring inputStr = \"This is a sentence.\";\nstring tok1 = STR_Split(inputStr, \" \", 0); // This\nstring tok2 = STR_Split(inputStr, \" \", 1); // is\nstring tok3 = STR_Split(inputStr, \" \", 2); // a\nstring tok4 = STR_Split(inputStr, \" \", 3); // sentence\n};\n</code></pre> At the end of the function, <code>tok1</code> contains \"This\", <code>tok2</code> contains \"is\", <code>tok3</code> contains \"a\", and <code>tok4</code> contains \"sentence.\"."},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_upper","title":"<code>STR_Upper</code>","text":"<p>Converts a string to uppercase. </p><pre><code>func string STR_Upper(var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> </ul> <p>Return Value</p> <p>The function returns a copy of <code>str</code> with all uppercase letters converted to their corresponding uppercase letters.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/string/#str_lower","title":"<code>STR_Lower</code>","text":"<p>Converts a string to lowercase. </p><pre><code>func string STR_Lower(var string str)\n</code></pre> Parameters <ul> <li><code>var string str</code>     The input string</li> </ul> <p>Return Value</p> <p>The function returns a copy of <code>str</code> with all lowercase letters converted to their corresponding uppercase letters.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/","title":"Time and Benchmark","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#time-and-benchmark","title":"Time and Benchmark","text":"<p>Set of functions to time measurement and Benchmark.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#time-functions","title":"Time functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_getsystemtime","title":"<code>MEM_GetSystemTime</code>","text":"<p>Returns the elapsed time since Gothic started. </p><pre><code>func int MEM_GetSystemTime()\n</code></pre> Return value <p>The function returns the elapsed time since the start of Gothic in milliseconds. This value is used for timing measurements, in the <code>BenchmarkMS</code> functions.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_getperformancecounter","title":"<code>MEM_GetPerformanceCounter</code>","text":"<p>Call to the WinAPI <code>QueryPerformanceCounter</code> funciton. </p><pre><code>func int MEM_GetPerformanceCounter()\n</code></pre> Return value <p>The function returns a value representing the number of elapsed ticks since the system was started. This value is used for timing measurements, in the <code>BenchmarkPC</code> functions.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#benchmark-functions","title":"Benchmark functions","text":"<p>Tip</p> <p>For reliable results, avoid measuring a single run of a function; instead, measure the total duration of multiple runs (e.g., 1000). This is crucial, especially for very fast functions, as a single run can distort the measurement. Use <code>_N</code> benchmark functions to include a parameter specifying the number of runs for function <code>f</code>.</p> <p>Choose the parameter <code>n</code> to ensure meaningful results. If <code>n</code> executions take less than a millisecond, obtaining a return value in milliseconds has no sense. For very fast functions, the time spent in the benchmark function, not in <code>f</code>, significantly affects the measurement, falsifying the result. Reliable measurements are achievable only for functions with sufficient slowness.</p> <p>For reference, here is a timing for some operations (in nanoseconds, i.e., billionths of a second): </p><pre><code>- Function call (jumping back and forth): 30ns\n- Elementary calculation (e.g., i = i + 1): 130ns\n- Wld_IsTime: 200ns\n- MEM_ReadInt, MEM_WriteInt: 350ns\n- Hlp_StrCmp(\"Hello\", \"Hello\"): 500ns\n- MEM_InstToPtr: 1400ns\n- (small) Allocate and free memory: 9700ns\n- CALL__stdcall (in empty function): 29000ns\n- MEM_GetParserSymb: 280000ns\n\n- Iteration of the benchmark function: 300ns\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_benchmarkms","title":"<code>MEM_BenchmarkMS</code>","text":"<p>Benchmark of the execution time for a specified function. (Milliseconds) </p><pre><code>func int MEM_BenchmarkMS(var func f)\n</code></pre> Parameters <ul> <li><code>var func f</code>     Function to benchmark</li> </ul> <p>Return value</p> <p>The function returns the duration of a function execution in milliseconds.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_benchmarkmms","title":"<code>MEM_BenchmarkMMS</code>","text":"<p>Benchmark of the execution time for a specified function. (microseconds) </p><pre><code>func int MEM_BenchmarkMMS(var func f)\n</code></pre> Parameters <ul> <li><code>var func f</code>     Function to benchmark</li> </ul> <p>Return value</p> <p>The function returns the duration of a function execution in microseconds.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_benchmarkpc","title":"<code>MEM_BenchmarkPC</code>","text":"<p>Benchmark of the execution time for a specified function, using the Performancecounter. </p><pre><code>func int MEM_BenchmarkMS(var func f)\n</code></pre> Parameters <ul> <li><code>var func f</code>     Function to benchmark</li> </ul> <p>Return value</p> <p>The function returns the number of Performancecounter ticks the function needs.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_benchmarkms_n","title":"<code>MEM_BenchmarkMS_N</code>","text":"<p><code>MEM_BenchmarkMS</code>, but with the parameter to specify the number of function runs. </p><pre><code>func int MEM_BenchmarkMS_N(var func f, var int n)\n</code></pre> Parameters <ul> <li><code>var func f</code>     Function to benchmark</li> <li><code>var int n</code>     Number of runs</li> </ul> <p>Return value</p> <p>The function returns a summed duration of multiple (<code>n</code>) runs of the function in milliseconds.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_benchmarkmms_n","title":"<code>MEM_BenchmarkMMS_N</code>","text":"<p><code>MEM_BenchmarkMMS</code>, but with the parameter to specify the number of function runs. </p><pre><code>func int MEM_BenchmarkMMS_N(var func f, var int n)\n</code></pre> Parameters <ul> <li><code>var func f</code>     Function to benchmark</li> <li><code>var int n</code>     Number of runs</li> </ul> <p>Return value</p> <p>The function returns a summed duration of multiple (<code>n</code>) runs of the function in microseconds.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/time_benchmark/#mem_benchmarkpc_n","title":"<code>MEM_BenchmarkPC_N</code>","text":"<p><code>MEM_BenchmarkPC</code>, but with the parameter to specify the number of function runs. </p><pre><code>func int MEM_BenchmarkPC_N(var func f, var int n)\n</code></pre> Parameters <ul> <li><code>var func f</code>     Function to benchmark</li> <li><code>var int n</code>     Number of runs</li> </ul> <p>Return value</p> <p>The function returns a summed number of Performancecounter ticks needed to execute function multiple (<code>n</code>) times.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/","title":"Windows Utilities","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#windows-utilities","title":"Windows Utilities","text":"<p>This part of Ikarus implements some WinAPI functions that can be used directly from Gothic scripts.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#initialization","title":"Initialization","text":"<p>The best way to initialize all Ikarus functions is to call <code>MEM_InitAll()</code> in the <code>Init_Global()</code> initialization function. </p> <p>Warning</p> <p>If you want to use Ikarus in Gothic 1, it is best to define your own <code>Init_Global()</code> function and call it from every world initialization function.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#implementation","title":"Implementation","text":"<p> Ikarus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#loadlibrary","title":"<code>LoadLibrary</code>","text":"<p>Loads the specified module into the address space of the calling process. Full documentation here. </p><pre><code>func int LoadLibrary(var string lpFileName)\n</code></pre> Parameters <ul> <li><code>var string lpFileName</code>     Name of loaded module</li> </ul> <p>Return value</p> <p>The function returns a handle to the module.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#getprocaddress","title":"<code>GetProcAddress</code>","text":"<p>Retrieves the address from the specified dynamic-link library. Full documentation here. </p><pre><code>func int GetProcAddress(var int hModule, var string lpProcName)\n</code></pre> Parameters <ul> <li><code>var int hModule</code>     A handle to the DLL module that contains the function or variable. Can be obtained using the <code>LoadLibrary</code> function.</li> <li><code>var string lpProcName</code>     The function or variable name.</li> </ul> <p>Return value The function returns address of the function or variable.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#findkerneldllfunction","title":"<code>FindKernelDllFunction</code>","text":"<p>Uses <code>GetProcAddress</code> to find function inside the <code>KERNEL32.DLL</code> file. </p><pre><code>func int FindKernelDllFunction(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the looked function.</li> </ul> <p>Return value</p> <p>The function returns address of the function.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#virtualprotect","title":"<code>VirtualProtect</code>","text":"<p>Changes the protection on a region of committed pages in the virtual address space of the calling process. Full documentation here. </p><pre><code>func int VirtualProtect(var int lpAddress, var int dwSize, var int flNewProtect)\n</code></pre> Parameters <ul> <li><code>var int lpAddress</code>     The address of the starting page of the region of pages whose access protection attributes are to be changed.</li> <li><code>var int dwSize</code>     The size of the region whose access protection attributes are to be changed, in bytes.</li> <li><code>var int flNewProtect</code>     The memory protection option. All options can be found here.</li> </ul> <p>Return value</p> <p>The function returns <code>lpflOldProtectPtr</code> - a pointer to a variable that receives the previous access protection value.</p> <p>Author's comment:</p> <p>I made <code>lpflOldProtectPtr</code> the return value and ignored the return Value of VirtualProtect.</p>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#memoryprotectionoverride","title":"<code>MemoryProtectionOverride</code>","text":"<p>Alias to <code>VirtualProtect</code> but with predefined <code>PAGE_EXECUTE_READWRITE</code> protection option </p><pre><code>func void MemoryProtectionOverride(var int address, var int size)\n</code></pre> Parameters <ul> <li><code>var int address</code>     The address of the starting page of the region of pages whose access protection attributes are to be changed.</li> <li><code>var int size</code>     The size of the region whose access protection attributes are to be changed, in bytes.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#mem_messagebox","title":"<code>MEM_MessageBox</code>","text":"<p>Calls the WinAPI MessageBox function. </p><pre><code>func int MEM_MessageBox(var string txt, var string caption, var int type)\n</code></pre> Parameters <ul> <li><code>var string txt</code>     Content of the MessageBox.</li> <li><code>var string caption</code>     Header of MessageBox.</li> <li><code>var int type</code>     Type of MessageBox. All types listed here.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#mem_infobox","title":"<code>MEM_InfoBox</code>","text":"<p>Alias to <code>MEM_MessageBox</code> with \"Information:\" header and <code>MB_OK | MB_ICONINFORMATION</code> type. </p><pre><code>func void MEM_InfoBox(var string txt)\n</code></pre> Parameters <ul> <li><code>var string txt</code>     Content of the InfoBox.</li> </ul>"},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/ikarus/functions/win_utilities/#sleep","title":"<code>Sleep</code>","text":"<p>Following function calls the <code>Sleep</code> function from the <code>KERNEL32.DLL</code>. A documentation of this function can be found here. </p><pre><code>func void Sleep(var int ms) {\nvar int adr;\nadr = GetProcAddress(LoadLibrary(\"KERNEL32.DLL\"), \"Sleep\");\nCALL_IntParam(ms);\nCALL__stdcall(adr); // 0x007B47E6\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/","title":"LeGo","text":""},{"location":"zengin/scripts/extenders/lego/#lego","title":"LeGo","text":"<p>LeGo (LehonaGottfried) is a script packet built on top of Ikarus.</p> Contacts Author  Lehona, Gottfried &amp; contributors GitHub  LeGo Forum  LeGo <p>Note</p> <p>The code for LeGo is hosted on GitHub and LeGo has its very own documentation page. </p>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/","title":"Anim8","text":""},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8","title":"Anim8","text":"<p>This package allows int or float values to be \"animated\" over a period of time. It is possible to string several commands together and to set the type of movement. The new version of <code>PrintS</code> from Interface uses Anim8.</p>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Anim8</code> flag. </p><pre><code>LeGo_Init(LeGo_Anim8);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#implementation","title":"Implementation","text":"<p> Anim8.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_new","title":"<code>Anim8_New</code>","text":"<p>Creates a new Anim8 object that can be filled with commands. </p><pre><code>func int Anim8_New(var int initialValue, var int IsFloat)\n</code></pre> Parameters <ul> <li><code>var int initialValue</code>     The initial value to start animating from. Can be an integer, or an Ikarus float.</li> <li><code>var int IsFloat</code>     If the <code>initialValue</code> is an Ikarus float, this parameter must be set to <code>TRUE</code>. If it is an integer, it must be set to <code>FALSE</code>.</li> </ul> <p>Return value</p> <p>The function returns handle of the Anim8 object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_newext","title":"<code>Anim8_NewExt</code>","text":"<p>Creates a new Anim8 object with advanced options. Extends the <code>Anim8_New</code> function. </p><pre><code>func int Anim8_NewExt(var int value, var func handler, var int data, var int IsFloat)\n</code></pre> Parameters <ul> <li><code>var int value</code>     The initial value to start animating from. Can be an integer, or an Ikarus float.</li> <li><code>var func handler</code>     This function is called whenever the object is updated.      The signature of the functions depends on the <code>data</code> value: <code>data != 0</code>: <code>func void handler(var int data, var int value)</code>, <code>data == 0</code>: <code>func void handler(var int value)</code>.</li> <li><code>var int data</code>     Optional parameter to send an additional value to the <code>handler</code> function. If <code>data == 0</code>, it is ignored.</li> <li><code>var int IsFloat</code>     If the <code>initialValue</code> is an Ikarus float, this parameter must be set to <code>TRUE</code>. If it is an integer, it must be set to <code>FALSE</code>.</li> </ul> <p>Return value</p> <p>The function returns handle of the Anim8 object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_delete","title":"<code>Anim8_Delete</code>","text":"<p>Deletes an Anim8 object created with <code>Anim8_New</code>. </p><pre><code>func void Anim8_Delete(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_get","title":"<code>Anim8_Get</code>","text":"<p>Get current value of the object. </p><pre><code>func int Anim8_Get(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> </ul> <p>Return value</p> <p>The function returns value of the object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_set","title":"<code>Anim8_Set</code>","text":"<p>Sets the value of the object. </p><pre><code>func void Anim8_Set(var int handle, var int value)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> <li><code>var int value</code>     New value of the object</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_empty","title":"<code>Anim8_Empty</code>","text":"<p>Indicates whether the object is empty, i.e. has no more commands to process. </p><pre><code>func int Anim8_Empty(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if object is empty (has no more commands), <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_removeifempty","title":"<code>Anim8_RemoveIfEmpty</code>","text":"<p>If desired, Anim8 can automatically delete an object after it is empty. </p><pre><code>func void Anim8_RemoveIfEmpty(var int handle, var int on)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> <li><code>var int on</code> <code>TRUE</code>: enable, <code>FALSE</code>: disable</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_removedataifempty","title":"<code>Anim8_RemoveDataIfEmpty</code>","text":"<p>With <code>Anim8_NewExt</code> handler and data can be set. If this function is called with <code>TRUE</code>, <code>data</code> is taken as a handle and <code>delete(data)</code> is called if the object is empty. Works only if <code>Anim8_RemoveIfEmpty</code> is also activated. </p><pre><code>func void Anim8_RemoveDataIfEmpty(var int handle, var int on)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> <li><code>var int on</code> <code>TRUE</code>: enable, <code>FALSE</code>: disable</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_1","title":"<code>Anim8</code>","text":"<p>Packet core. Gives the object a new command to process. </p><pre><code>func void Anim8(var int handle, var int target, var int span, var int interpol)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> <li><code>var int target</code>     Target value of this command. When the object's value has reached this value, the command is considered completed and deleted.</li> <li><code>var int span</code>     Action duration in milliseconds</li> <li><code>var int interpol</code>     What form of movement is used (See constants for this)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8q","title":"<code>Anim8q</code>","text":"<p>As already mentioned above, Anim8 can also process several commands one after the other. While Anim8 completely resets the object and deletes all commands, Anim8q just appends a new command to the list. This will be processed as soon as the previous one is completed. </p><pre><code>func void Anim8q(var int handle, var int target, var int span, var int interpol)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> <li><code>var int target</code>     Target value of this command. When the object's value has reached this value, the command is considered completed and another one in the queue will start.</li> <li><code>var int span</code>     Action duration in milliseconds</li> <li><code>var int interpol</code>     What form of movement is used (See constants for this)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#anim8_callonremove","title":"<code>Anim8_CallOnRemove</code>","text":"<p>Registers a function to be called when the object is deleted (e.g. by <code>Anim8_RemoveIfEmpty</code>) </p><pre><code>func void Anim8_CallOnRemove(var int handle, var func dfnc)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle returned from <code>Anim8_New</code></li> <li><code>var func dfnc</code>     This function is called when the object is deleted</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/anim8/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/applications/anim8/#count-up-to-a-number","title":"Count up to a number","text":"<p>Count from 0 to 10 in 10 seconds. We use the <code>Print_Ext</code> function from Interface to display the text. </p><pre><code>func void Example1()\n{\n// First we create a handle to a text:\nvar int MyText; MyText = Print_Ext(20, 20, \"0\", Font_Screen, COL_White, -1);\n// After that we create a new, extended Anim8 object.\n// It gets a handler and the handle to the text as data:\nvar int MyAnim8; MyAnim8 = Anim8_NewExt(0, MyLoop1, MyText, FALSE); // Start value 1, MyLoop1 as handler, MyText as data and no float\n// Now the command to count to 10:\nAnim8(MyAnim8, 10, 10000, A8_Constant); // With MyAnim8 to 10 within 10000ms with constant motion.\n// So that the text and the Anim8 object are deleted after the process. \n// Now we have to do two more things:\nAnim8_RemoveIfEmpty(MyAnim8, TRUE);\nAnim8_RemoveDataIfEmpty(MyAnim8, TRUE);\n};\nfunc void MyLoop1(var int MyText, var int Number)\n{\nvar zCViewText t; t = _^(myText);\n// Now the text is set to the value of the Anim8 object:\nt.text = IntToString(Number);\n// As I said, everything is deleted fully automatically\n};\n</code></pre> A similar example can be found in the Interface examples."},{"location":"zengin/scripts/extenders/lego/applications/anim8/#moving-zcvob-in-loop","title":"Moving zCVob in loop","text":"<p>Now we make a vob constantly move back and forth, but without a mover. FrameFunctions are used for the loop: </p><pre><code>var zCVob MyVob;\nvar int MyVobAni;\nfunc void Example2()\n{\n// We use Ikarus to get a pointer to a known VOB:\nMyVob = MEM_PtrToInst(MEM_SearchVobByName(\"MYVOB\"));\n// There must be a vob with the appropriate name in the world for this.\n// Since the positions of a vob are floats, this time Anim8 must also use floats:\nMyVobAni = Anim8_New(MyVob.trafoObjToWorld[3], TRUE);\n// The X position of the vob serves as the starting value.\n// We will also move it along this axis.\n// Now start a loop that \"nudges\" the vob over and over again:\nFF_Apply(MyVobLoop);\n};\nfunc void MyVobLoop()\n{\n// We get the pointer to the VOB again\nMyVob = MEM_PtrToInst(MEM_SearchVobByName(\"MYVOB\"));\n// Whenever there are no more commands, we add new ones:\nif(Anim8_Empty(MyVobAni))\n{\n// First move by three meters:\nAnim8(MyVobAni, addf(MyVob.trafoObjToWorld[3], mkf(300)), 1000, A8_SlowEnd);\n// Then wait half a second:\nAnim8q(MyVobAni, 0, 500, A8_Wait);\n// And then back again:\nAnim8q(MyVobAni, MyVob.trafoObjToWorld[3], 1000, A8_SlowEnd);\n// And wait another half a second:\nAnim8q(MyVobAni, 0, 500, A8_Wait);\n// Note the 'q' in the follow-up commands.\n// While Anim8 completely resets the command list, i.e. starts again, Anim8q appends the command to the queue.\n// So you can tinker with a command sequence.\n};\n// Of course, we must set the \"animated\" value to the VOB itself\nMyVob.trafoObjToWorld[3] = Anim8_Get(MyVobAni);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/bars/","title":"Bars","text":""},{"location":"zengin/scripts/extenders/lego/applications/bars/#bars","title":"Bars","text":"<p>This package makes it very easy to add new bars, for e.g. stamina.</p>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> <li>View</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Bars</code> flag. </p><pre><code>LeGo_Init(LeGo_Bars);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#implementation","title":"Implementation","text":"<p> Bars.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#functions","title":"Functions","text":"<p>Note</p> <p>If the <code>GothicBar</code> prototype is selected as the initial type (<code>GothicBar@</code> as the constructor), the user's own bars are visually indistinguishable from those used in Gothic.</p>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_create","title":"<code>Bar_Create</code>","text":"<p>Creates a new bar from a constructor instance. </p><pre><code>func int Bar_Create(var int inst)\n</code></pre> <p>Parameters</p> <ul> <li><code>var int inst</code>     Constructor instance of <code>Bar</code> class</li> </ul> <p>Return value</p> <p>The function returns the address of the new bar, aka the handle.</p> Examples <p><code>var int bar; bar = Bar_Create(GothicBar@);</code></p> <pre><code>var int bar; bar = Bar_Create(GothicBar@); // Create a new bar\nBar_SetPercent(bar, 50);                   // And set the value to 50%\n</code></pre> <pre><code>func void Example_1()\n{\nvar int bar; bar = Bar_Create(GothicBar@); // Create a new bar\nBar_SetPercent(bar, 50);                   // And set the value to 50%\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_delete","title":"<code>Bar_Delete</code>","text":"<p>Deletes a bar from the screen and from memory.  </p><pre><code>func void Bar_Delete(var int bar)\n</code></pre> <p>Parameters</p> <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_setmax","title":"<code>Bar_SetMax</code>","text":"<p>Changes a bar's maximum value but does not update its bar length (only <code>Bar_SetPercent</code>, <code>Bar_SetPromille</code> and <code>Bar_SetValue</code>) </p><pre><code>func void Bar_SetMax(var int bar, var int max)\n</code></pre> Parameters <ul> <li> <p><code>var int bar</code>     Handle returned from <code>Bar_Create</code></p> </li> <li> <p><code>var int max</code>     New maximum value</p> </li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_setvalue","title":"<code>Bar_SetValue</code>","text":"<p>Sets the value of the bar. </p><pre><code>func void Bar_SetValue(var int bar, var int val)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int val</code>     New value of the bar</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_setpercent","title":"<code>Bar_SetPercent</code>","text":"<p>Sets the value of the bar but as a percentage (0..100). </p><pre><code>func void Bar_SetPercent(var int bar, var int perc)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int perc</code>     New value of the bar in percent</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_setpromille","title":"<code>Bar_SetPromille</code>","text":"<p>Sets the value of the bar but per mille (0..1000). </p><pre><code>func void Bar_SetPromille(var int bar, var int pro)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int pro</code>     New value of the bar in per mille</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_hide","title":"<code>Bar_Hide</code>","text":"<p>Hides a bar. It will not be deleted.  </p><pre><code>func void Bar_Hide(var int bar)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_show","title":"<code>Bar_Show</code>","text":"<p>Displays a bar again after using <code>Bar_Hide</code>.  </p><pre><code>func void Bar_Show(var int bar)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_moveto","title":"<code>Bar_MoveTo</code>","text":"<p>Move the bar to virtual position.  </p><pre><code>func void Bar_MoveTo(var int bar, var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int x</code>     New horizontal position in virtual coordinates</li> <li><code>var int y</code>     New vertical position in virtual coordinates</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_movetopxl","title":"<code>Bar_MoveToPxl</code>","text":"<p>Move the bar to pixel position.  </p><pre><code>func void Bar_MoveToPxl(var int bar, var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int x</code>     New horizontal position in pixels</li> <li><code>var int y</code>     New vertical position in pixels</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_setalpha","title":"<code>Bar_SetAlpha</code>","text":"<p>Sets the transparency of the bar. </p><pre><code>func void Bar_SetAlpha(var int bar, var int alpha)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int alpha</code>     Transparency value (0..255) </li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_setbartexture","title":"<code>Bar_SetBarTexture</code>","text":"<p>Sets the foreground texture of the bar. </p><pre><code>func void Bar_SetBarTexture(var int bar, var string barTex)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var string barTex</code>     The new foreground texture</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_setbacktexture","title":"<code>Bar_SetBackTexture</code>","text":"<p>Sets the background texture of the bar. </p><pre><code>func void Bar_SetBackTexture(var int bar, var string backTex)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var string backTex</code>     The new background texture</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_resize","title":"<code>Bar_Resize</code>","text":"<p>Resize an existing bar. </p><pre><code>func void Bar_Resize(var int bar, var int width, var int height)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int width</code>     New width in virtual coordinates</li> <li><code>var int height</code>     New height in virtual coordinates</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#bar_resizepxl","title":"<code>Bar_ResizePxl</code>","text":"<p>Resize existing bar (in pixels). </p><pre><code>func void Bar_ResizePxl(var int bar, var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int bar</code>     Handle returned from <code>Bar_Create</code></li> <li><code>var int x</code>     New width in pixels</li> <li><code>var int y</code>     New height in pixels</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#examples","title":"Examples","text":"<p>Note</p> <p>The bars assume a certain basic understanding of the PermMem module. </p>"},{"location":"zengin/scripts/extenders/lego/applications/bars/#a-dedicated-experience-bar","title":"A dedicated experience bar","text":"<p>Bars implement the <code>Bar</code> class. It looks like this: </p><pre><code>class Bar\n{\nvar int x;          // X position on the screen (middle of the bar)\nvar int y;          // Y position on the screen (middle of the bar)\nvar int barTop;     // Top/bottom margin\nvar int barLeft;    // Left/right margin\nvar int width;      // Bar width\nvar int height;     // Bar height\nvar string backTex; // Background texture\nvar string barTex;  // Actual bar texture\nvar int value;      // Current value\nvar int valueMax;   // Maximum value\n};\n</code></pre> The <code>GothicBar</code> prototype is a bar, which mimics the standard Gothic status bar. <pre><code>prototype GothicBar(Bar)\n{\nx = Print_Screen[PS_X] / 2;\ny = Print_Screen[PS_Y] - 20;\nbarTop = 3;\nbarLeft = 7;\nwidth = 180;\nheight = 20;\nbackTex = \"Bar_Back.tga\";\nbarTex = \"Bar_Misc.tga\";\nvalue = 100;\nvalueMax = 100;\n};\n</code></pre> <p>It is much easier to set up a new instance using this prototype. <code>GothicBar</code> without modifications can be found as the <code>GothicBar@</code> instance, which we used to create the bar in the example above. <code>GothicBar</code> is located in the middle of the screen and looks exactly like the Gothic underwater bar. </p><pre><code>// Instance created from \ninstance Bar_1(GothicBar)\n{\nx = 100;\ny = 20;\n};\nfunc void Example_1()\n{\n// Example_1 could e.g. be called in Init_Global\nFF_ApplyOnce(Loop_1);\n};\nfunc void Loop_1()\n{\n// Example_1 gets this loop running.\n// Here the bar should be constructed once\n// and then adapted to the EXP of the hero:\nvar int MyBar;\nif(!Hlp_IsValidHandle(MyBar))\n{\nMyBar = Bar_Create(Bar_1); // Our Bar_1\n};\n// The rest is probably self-explanatory:\nBar_SetMax(MyBar, hero.exp_next);\nBar_SetValue(MyBar, hero.exp);\n};\n</code></pre> <p>Note</p> <p>This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website.</p>"},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/","title":"Bloodsplats","text":""},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#bloodsplats","title":"Bloodsplats","text":"<p>If this package is activated, red blood splatters will appear on the screen when the hero takes damage. For this, the damage perception for the hero is redirected to <code>_B_HeroDamage()</code>. To use the Bloodsplats, the enclosed textures must be available. Also, the VFX \"HERO_HURT\" (also included) should be entered in the <code>VfxInst.d</code> to create an even better hit effect. All textures used here are from CGTextures.com. If you use Bloodsplats in your modification, this site must be noted in the credits.</p> <p>Tip</p> <p>See user constants to edit behavior of this packet.</p>"},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> <li>View</li> <li>Random</li> <li>Anim8</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Bloodsplats</code> flag. </p><pre><code>LeGo_Init(LeGo_Bloodsplats);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#implementation","title":"Implementation","text":"<p> Bloodsplats.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#bloodsplat","title":"<code>Bloodsplat</code>","text":"<p>Puts a blood splatter on the screen. </p><pre><code>func void Bloodsplat(var int damage)\n</code></pre> Parameters <ul> <li><code>var int damage</code>     The damage (affects the size of the splatter)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#bloodsplats_rage","title":"<code>Bloodsplats_Rage</code>","text":"<p>Pretty pointless feature that smears the entire screen. </p><pre><code>func void Bloodsplats_Rage()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/bloodsplats/#npc_getpercfunc","title":"<code>Npc_GetPercFunc</code>","text":"<p><code>oCNpc::GetPerceptionFunc</code> engine function wraper </p><pre><code>func int Npc_GetPercFunc(var C_Npc npc, var int type)\n</code></pre> Parameters <ul> <li><code>var C_NPC npc</code>     NPC whose percepcion is checked</li> <li><code>var int type</code>     Checked perception type (form <code>Constant.d</code>)</li> </ul> <p>Return value</p> <p>The function returns the state of NPCs selected perception.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/","title":"Buffs","text":""},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buffs","title":"Buffs","text":"<p>This package allows you to easily create status effects that can affect any NPC. Status effects on the hero are displayed graphically in a bar.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> <li>FrameFunctions</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Buffs</code> flag. </p><pre><code>LeGo_Init(LeGo_Buffs);\n</code></pre> <p>Warning</p> <p>This package is still experimental and not included in the <code>LeGo_All</code> initialization flag.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#implementation","title":"Implementation","text":"<p> Buffs.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_apply","title":"<code>Buff_Apply</code>","text":"<p>Applies a status effect to an NPC. </p><pre><code>func int Buff_Apply(var C_NPC npc, var int buff)\n</code></pre> Parameters <ul> <li> <p><code>var C_NPC npc</code>     NPC to be affected by this effect</p> </li> <li> <p><code>var int buff</code>     The instance of the effect to apply to the NPC</p> </li> </ul> <p>Return value</p> <p>The function returns the handle of the buff, which was just generated.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_applyunique","title":"<code>Buff_ApplyUnique</code>","text":"<p><code>Buff_Apply</code>, but nothing happens if a status effect of that kind is already on the NPC. </p><pre><code>func int Buff_ApplyUnique(var C_NPC npc, var int buff)\n</code></pre> Parameters <ul> <li> <p><code>var C_NPC npc</code>     NPC to be affected by this effect</p> </li> <li> <p><code>var int buff</code>     The instance of the effect to apply to the NPC</p> </li> </ul> <p>Return value</p> <p>The function returns the handle of the buff, which was just generated or <code>0</code> if the buff is already applied on the NPC.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_applyorrefresh","title":"<code>Buff_ApplyOrRefresh</code>","text":"<p><code>Buff_Apply</code>, but if a status effect of this type is already affecting the NPC, the duration will be reset. </p><pre><code>func int Buff_ApplyOrRefresh(var C_NPC n, var int buff)\n</code></pre> Parameters <ul> <li> <p><code>var C_NPC npc</code>     NPC to be affected by this effect</p> </li> <li> <p><code>var int buff</code>     The instance of the effect to apply to the NPC</p> </li> </ul> <p>Return value</p> <p>The function returns the handle of the buff, which was just generated or refreshed.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_refresh","title":"<code>Buff_Refresh</code>","text":"<p>Resets the duration of the buff. </p><pre><code>func void Buff_Refresh(var int buffHandle)\n</code></pre> Parameters <ul> <li><code>var int buffHandle</code>     Handle of the buff to refresh</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_remove","title":"<code>Buff_Remove</code>","text":"<p>Removes the buff from the all NPCs. </p><pre><code>func void Buff_Remove(var int buffHandle)\n</code></pre> Parameters <ul> <li><code>var int buffHandle</code>     Handle of the buff to remove</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_removeall","title":"<code>Buff_RemoveAll</code>","text":"<p>Removes the buffs form the NPC. </p><pre><code>func void Buff_RemoveAll(var C_NPC npc, var int buffInstance)\n</code></pre> Parameters <ul> <li><code>var C_NPC npc</code>     NPC whose buff should be removed</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_getnpc","title":"<code>Buff_GetNpc</code>","text":"<p>Returns a pointer to the NPC, which is affected by the buff. </p><pre><code>func int Buff_GetNpc(var int buffHandle)\n</code></pre> Parameters <ul> <li><code>var int buffHandle</code>     Handle of the buff</li> </ul> <p>Return value</p> <p>The function returns a pointer to the NPC, which is affected by the buff.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#buff_has","title":"<code>Buff_Has</code>","text":"<p>Checks if the NPC already has an effect applied. </p><pre><code>func int Buff_Has(var C_NPC npc, var int buff)\n</code></pre> Parameters <ul> <li> <p><code>var C_NPC npc</code>     Checked NPC</p> </li> <li> <p><code>var int buff</code>     The instance of the effect</p> </li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the NPC has an effect applied. <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#save_getfuncid","title":"<code>SAVE_GetFuncID</code>","text":"<p>Same as <code>MEM_GetFuncID</code> but gets the current instance. </p><pre><code>func int SAVE_GetFuncID(var func f)\n</code></pre> Parameters <p><code>var func f</code>     Function whose ID is got</p> <p>Return value</p> <p>The function returns the ID of given function.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#lcbuff-class","title":"lCBuff class","text":"<p>The buffs package implements an <code>lCBuff</code> class, which looks like this:</p> <pre><code>class lCBuff\n{\nvar string name;    // buff name \nvar int buffType;   // GOOD / NEUTRAL / BAD | 1 / 0 / -1\nvar int targetID;   // NPC that is currently affected by this buff\nvar int durationMS; // buff duration in milliseconds\nvar int tickMS;     // tick duration in milliseconds, first tick occurs at tickMS milliseconds\nvar int nextTickNr; // e.g. before the first tick this will be 0; OBSOLETE, remove when possible\nvar int OnApply; var int OnTick;\nvar int OnRemoved;\nvar string buffTex;  // associated texture - currently only used for buffs applied on the hero\n// var int originID; // Who casted/created this buff?\n// Internal, no need to set during instance construction\nvar int _startedTime;\nvar int _endTime;    // Not rendundant with durationMS because buffs can be refreshed\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/buffs/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/applications/buffs/#delayed-poison","title":"Delayed poison","text":"<pre><code>instance deadly_poison(lCBuff)\n{\nname = \"Deadly poison\";\nbufftype = BUFF_BAD;\ndurationMS = 10*1000; // 10 seconds long\ntickMS = 1000;        // Every second\nbuffTex = \"POISON.TGA\";\n};\n</code></pre> <p>Damage should also be added: </p><pre><code>func void deadly_poison_damage(var int buffHandle)\n{\nvar int ptr; ptr = Buff_GetNpc(buffHandle);\nif (!ptr) { return; }; // Can happen if e.g. the world was changed\nvar C_NPC npc; npc = _^(ptr);\nNpc_ChangeAttribute(npc, ATR_HITPOINTS, -3); // 3 damage\n};\n</code></pre> For complicated technical reasons we use the function <code>SAVE_GetFuncID</code> instead of <code>MEM_GetFuncID</code>. <pre><code>instance deadly_poison(lCBuff)\n{\nname = \"Deadly poison\";\nbufftype = BUFF_BAD;\ndurationMS = 10 * 1000; //10 seconds long\ntickMS = 1000; // Every second\nonTick = SAVE_GetFuncID(deadly_poison_damage); // The damage should be applied every second\nbuffTex = \"POISON.TGA\";\n};\n</code></pre> <p>For example, if this buff is now applied to the hero, by calling <code>Buff_Apply(hero, deadly_poison)</code>, he loses a total of 30 HP over 10 seconds.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/","title":"Buttons","text":""},{"location":"zengin/scripts/extenders/lego/applications/buttons/#buttons","title":"Buttons","text":"<p>This package extends the handling of the mouse and allows creating rectangular buttons, which react to mouse (hover) entry and exit as well as a mouse click.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> <li>View</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Buttons</code> flag. </p><pre><code>LeGo_Init(LeGo_Buttons);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#implementation","title":"Implementation","text":"<p> Buffs.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_create","title":"<code>Button_Create</code>","text":"<p>Creates a button. It is initially hidden (not visible and does not react to the mouse). The three callback functions have the following signature <code>void f(int handle)</code>. </p><pre><code>func int Button_Create(var int posx, var int posy, var int width, var int height, var string tex, var func on_enter, var func on_leave, var func on_click)\n</code></pre> Parameters <ul> <li><code>var int posx</code>     The horizontal position of the button in virtual coordinates</li> <li><code>var int posy</code>     The vertical position of the button in virtual coordinates</li> <li><code>var int width</code>     Width of the button in virtual coordinates</li> <li><code>var int height</code>     Height of the button in virtual coordinates</li> <li><code>var string tex</code>     Name of the button texture</li> <li><code>var func on_enter</code>     This function is called when the mouse enters the button</li> <li><code>var func on_leave</code>     This function is called when the mouse leaves the button</li> <li><code>var func on_click</code>     This function is called when the user performs a mouse click on the button (left mouse button)</li> </ul> <p>Return value</p> <p>The function returns a handle to created button.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_createpxl","title":"<code>Button_CreatePxl</code>","text":"<p><code>Button_Create</code> with pixels instead of virtual coordinates. </p><pre><code>func int Button_CreatePxl(var int posx, var int posy, var int width, var int height, var string tex, var func on_enter, var func on_leave, var func on_click)\n</code></pre> Parameters <ul> <li><code>var int posx</code>     The horizontal position of the button in pixels</li> <li><code>var int posy</code>     The vertical position of the button in pixels</li> <li><code>var int width</code>     Width of the button in pixels</li> <li><code>var int height</code>     Height of the button in pixels</li> <li><code>var string tex</code>     Name of the button texture</li> <li><code>var func on_enter</code>     This function is called when the mouse enters the button</li> <li><code>var func on_leave</code>     This function is called when the mouse leaves the button</li> <li><code>var func on_click</code>     This function is called when the user performs a mouse click on the button (left mouse button)</li> </ul> <p>Return value</p> <p>The function returns a handle to created button.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_delete","title":"<code>Button_Delete</code>","text":"<p>Completely deletes a button. </p><pre><code>func void Button_Delete(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_show","title":"<code>Button_Show</code>","text":"<p>Shows the button and makes it respond to the mouse. </p><pre><code>func void Button_Show(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_hide","title":"<code>Button_Hide</code>","text":"<p>Hides the button and disables it, so it is no longer responding to the mouse. </p><pre><code>func void Button_Hide(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_settexture","title":"<code>Button_SetTexture</code>","text":"<p>Sets the texture of the button. </p><pre><code>func void Button_SetTexture(var int hndl, var string tex)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> <li><code>var string tex</code>     Name of the new texture</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_setcaption","title":"<code>Button_SetCaption</code>","text":"<p>Displays a centred text on the button. </p><pre><code>func void Button_SetCaption(var int hndl, var string caption, var string font)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> <li><code>var string caption</code>     The text to be displayed</li> <li><code>var string font</code>     The font in which the text should be displayed</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_createmouseover","title":"<code>Button_CreateMouseover</code>","text":"<p>Attaches a mouseover box to the cursor. </p><pre><code>func void Button_CreateMouseover(var string text, var string font)\n</code></pre> Parameters <ul> <li><code>var string text</code>     The text in the mouseover box</li> <li><code>var string font</code>     The font of the text</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_deletemouseover","title":"<code>Button_DeleteMouseover</code>","text":"<p>Deletes the mouseover box. </p><pre><code>func void Button_DeleteMouseover()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_activate","title":"<code>Button_Activate</code>","text":"<p>Activates the button, so it reacts to the mouse. Does not change the visibility. </p><pre><code>func void Button_Activate(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_deactivate","title":"<code>Button_Deactivate</code>","text":"<p>Disables the button, so it no longer reacts to the mouse. </p><pre><code>func void Button_Deactivate(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_setuserdata","title":"<code>Button_SetUserData</code>","text":"<p>Sets the user data of the button, an integer, to give the button individual information. </p><pre><code>func void Button_SetUserData(var int hndl, var int data)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> <li><code>var int data</code>     Individual integer of the button (part of the internal <code>_Button</code> class)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_getuserdata","title":"<code>Button_GetUserData</code>","text":"<p>Gets the user data of the button. </p><pre><code>func int Button_GetUserData(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul> <p>Return value</p> <p>The function returns the user data of the button.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_getstate","title":"<code>Button_GetState</code>","text":"<p>Gets the status of the button as a bit field. See User Constants. </p><pre><code>func int Button_GetState(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul> <p>Return value</p> <p>The function returns the status of the button.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_move","title":"<code>Button_Move</code>","text":"<p>Moves the button by the given value in pixels. <code>posx = posx + nposx</code> </p><pre><code>func void Button_Move(var int hndl, var int nposx, var int nposy)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> <li><code>var int nposx</code>     X-axis shift in pixels</li> <li><code>var int nposy</code>     Y-axis shift in pixels</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_movevrt","title":"<code>Button_MoveVrt</code>","text":"<p>Moves the button by the given value in virtual coordinates. <code>posx = posx + nposx</code> </p><pre><code>func void Button_Move(var int hndl, var int nposx, var int nposy)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> <li><code>var int nposx</code>     X-axis shift in virtual coordinates</li> <li><code>var int nposy</code>     Y-axis shift in virtual coordinates</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_moveto","title":"<code>Button_MoveTo</code>","text":"<p>Moves a button to the given position in pixels. <code>posx = nposx</code> </p><pre><code>func void Button_MoveVrt(var int hndl, var int nposx, var int nposy)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> <li><code>var int nposx</code>     New horizontal position in pixels</li> <li><code>var int nposy</code>     New vertical position in pixels</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_movetovrt","title":"<code>Button_MoveToVrt</code>","text":"<p>Moves a button to the given position in virtual coordinates. <code>posx = nvposx</code> </p><pre><code>func void Button_MoveVrt(var int hndl, var int nvposx, var int nvposy)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> <li><code>var int nvposx</code>     New horizontal position in virtual coordinates</li> <li><code>var int nvposy</code>     New vertical position in virtual coordinates</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_getviewhandle","title":"<code>Button_GetViewHandle</code>","text":"<p>Returns the button's <code>zCView</code> as a handle. </p><pre><code>func int Button_GetViewHandle(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul> <p>Return value</p> <p>The function returns the button's <code>zCView</code> as a handle.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_getviewptr","title":"<code>Button_GetViewPtr</code>","text":"<p>Returns the button's <code>zCView</code> as a pointer. </p><pre><code>func int Button_GetViewPtr(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul> <p>Return value</p> <p>The function returns the button's <code>zCView</code> as a pointer.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_getview","title":"<code>Button_GetView</code>","text":"<p>Returns the button's <code>zCView</code> as an object. </p><pre><code>func zCView Button_GetView(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul> <p>Return value</p> <p>The function returns the button's <code>zCView</code> as an object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/buttons/#button_getcaptionptr","title":"<code>Button_GetCaptionPtr</code>","text":"<p>Returns the pointer to the text of the button. </p><pre><code>func int Button_GetCaptionPtr(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle returned from <code>Button_Create</code></li> </ul> <p>Return value</p> <p>The function returns the pointer to the text of the button.</p>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/","title":"Console Commands","text":""},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#console-commands","title":"Console Commands","text":"<p>This package allows you to create new console commands.</p>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_ConsoleCommands</code> flag. </p><pre><code>LeGo_Init(LeGo_ConsoleCommands);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#implementation","title":"Implementation","text":"<p> ConsoleCommands.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#cc_register","title":"<code>CC_Register</code>","text":"<p>Registers a new console command. </p><pre><code>func void CC_Register(var func f, var string cmdPrefix, var string description)\n</code></pre> Parameters <ul> <li><code>var func f</code>     This function is executed when the <code>cmdPrefix</code> command is entered in the console. The function signature is <code>func string f(var string p0)</code>. The string passed is everything that was specified in the console after the actual command. The return value is then displayed in the console.</li> <li><code>var string cmdPrefix</code>     This is a command, which can be entered in the console.</li> <li><code>var string description</code>     This text appears next to the command (in zSpy) when you use the <code>help</code> command in the console.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#cc_remove","title":"<code>CC_Remove</code>","text":"<p>Removes a function from the console commands. </p><pre><code>func void CC_Remove(var func f)\n</code></pre> Parameters <ul> <li><code>var func f</code>     This function will be removed, i.e. the associated command will no longer work.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#cc_active","title":"<code>CC_Active</code>","text":"<p>Checks whether the function passed is already part of a console command. </p><pre><code>func int CC_Active(var func f)\n</code></pre> Parameters <ul> <li><code>var func f</code>     Function being checked</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if there is a corresponding function, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/applications/console_commands/#basic-command-example","title":"Basic command example","text":"<p>As a basic example - let us create a version command, which prints a version of our modification. Firstly, we declare a constant <code>string</code> variable to hold the version string to be shown. </p><pre><code>const string Mod_Version = \"My mod version 0.1alpha\";\n</code></pre> Next we create the command function.  <p>Note</p> <p>Notice the correct function signature. If you do not adhere to the correct function signature, the command will crash the game.</p> <p></p><pre><code>// This function is called by our console\nfunc string CC_ModVersion(var string param)\n{\nreturn Mod_Version;\n};\n</code></pre> We then have to register the functions. For convenience, I created a new <code>RegisterConsoleFunctions</code> function to initialize all console commands. The function is really simple. <pre><code>func void RegisterConsoleFunctions()\n{\nCC_Register (CC_ModVersion, \"version\", \"Version of my amazing mod.\");\n};\n</code></pre> Lastly, we have to call this function from <code>INIT_GLOBAL</code> function. <pre><code>func void INIT_GLOBAL()\n{\n// will be called for every world (from INIT_&lt;LevelName&gt;)\nGame_InitGerman();\n// Ikarus initialization\nMEM_InitAll();\n// LeGo initialization\nLeGo_Init(LeGo_ConsoleCommands);\n// Here we register all of our commands\nRegisterConsoleFunctions();\n// the rest of the code \n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/","title":"Cursor","text":""},{"location":"zengin/scripts/extenders/lego/applications/cursor/#cursor","title":"Cursor","text":"<p>This package implements Gothic in-game mouse cursor support. To visually display the cursor there is a <code>Cursor.tga</code> file in the resources, but the texture can be changed in user constants.</p> <p>Warning</p> <p>The cursor only works if the mouse is activated in the Gothic settings. It can be done directly from the scripts. See the Ini file access.</p>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> <li>FrameFunctions</li> <li>View</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Cursor</code> flag. </p><pre><code>LeGo_Init(LeGo_Cursor);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#implementation","title":"Implementation","text":"<p> Cursor.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#variables","title":"Variables","text":"<ul> <li><code>var int Cursor_X</code>     Always contains the X coordinate of the mouse cursor.</li> <li><code>var int Cursor_Y</code>     Always contains the Y coordinate of the mouse cursor.</li> <li><code>var float Cursor_RelX</code>     Always contains the relative X coordinate of the mouse cursor as an Ikarus float.</li> <li><code>var float Cursor_RelY</code>     Always contains the relative Y coordinate of the mouse cursor as an Ikarus float.</li> <li><code>var int Cursor_Wheel</code>     Variable containing the value of the mouse wheel.</li> <li><code>var int Cursor_Left</code>     Variable that always contains the KeyState of the left mouse button.</li> <li><code>var int Cursor_Mid</code>     Variable that always contains the KeyState of the middle mouse button.</li> <li><code>var int Cursor_Right</code>     Variable that always contains the KeyState of the right mouse button.</li> <li><code>var int Cursor_Event</code>     An event handler that can send information about the mouse cursor. It can be used with all functions of the EventHandler package.</li> <li><code>var int Cursor_NoEngine</code>     Variable that can prevent the engine from working. If is set to <code>TRUE</code> the engine no longer reacts to mouse movements.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/cursor/#cursor_hide","title":"<code>Cursor_Hide</code>","text":"<p>Hides the displayed mouse cursor. </p><pre><code>func void Cursor_Hide()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#cursor_show","title":"<code>Cursor_Show</code>","text":"<p>Shows the mouse cursor. </p><pre><code>func void Cursor_Show()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#setmouseenabled","title":"<code>SetMouseEnabled</code>","text":"<p>Can manually enable or disable the mouse. </p><pre><code>func void SetMouseEnabled(var int enabled)\n</code></pre> Parameters <ul> <li><code>var int enabled</code> <code>TRUE</code> - Mouse activated</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/applications/cursor/#click-a-button","title":"Click a button","text":"<p>We use a View to display a button to be clicked. The FrameFunctions take care of the loop to check whether a click was made. </p><pre><code>var int Button;\nfunc void Example1()\n{\n// We show the cursor and at the same time a button to be clicked:\nCursor_Show();\n// New View:\nButton = View_CreatePxl(5, 5, 125, 50);\nView_SetTexture(Button, \"BUTTONTEX.TGA\");\nView_Open(Button);\n// Optionally, mouse can be switched off for the engine:\nCursor_NoEngine = true; // -&gt; The engine then no longer reacts to movements, so the camera does not move either\n// Enable loop function:\nFF_ApplyOnce(Button_Click);\n};\nfunc void Button_Click()\n{\nif(Cursor_Left != KEY_PRESSED) { return; }; // Exit the function if the left mouse button was not pressed\nif(Cursor_X &gt;= 5 &amp;&amp; Cursor_X &lt;= 125\n&amp;&amp; Cursor_Y &gt;= 5 &amp;&amp; Cursor_Y &lt;= 50) // Simply take over the coordinates of the view\n{ // Here the button was clicked.\n// Remove button and end loop:\nView_Close(Button);\nView_Delete(Button);\nButton = 0;\n// Allow the engine to continue working:\nCursor_NoEngine = false;\nFF_Remove(Button_Click);\n// Hide the mouse:\nCursor_Hide();\n};\n};\n</code></pre> <p>This also can be done by the Buttons package instead of View.</p>"},{"location":"zengin/scripts/extenders/lego/applications/cursor/#event-handler","title":"Event handler","text":"<p>Since LeGo 2.2 there is also an event handler (<code>var int Cursor_Event</code>) in the cursor package. This example briefly explains how it works: </p><pre><code>func void Example2()\n{\n// We register MyCursorListener as the handler/listener of the Cursor_Event:\nEvent_Add(Cursor_Event, MyCursorListener);\n// From now on, MyCursorListener will be called whenever the cursor has something to report.\n};\nfunc void MyCursorListener(var int state)\n{\n// The rest is self-explanatory:\nif(state == CUR_WheelUp)\n{\nPrintS(\"Wheel up!\");\n};\nif(state == CUR_WheelDown)\n{\nPrintS(\"Wheel down!\");\n};\nif(state == CUR_LeftClick)\n{\nPrintS(\"Leftclick!\");\n};\nif(state == CUR_RightClick)\n{\nPrintS(\"Rightclick!\");\n};\nif(state == CUR_MidClick)\n{\nPrintS(\"Wheelclick!\");\n};\n};\n</code></pre> Constants used in the example can be found in the user constants."},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/","title":"Dialoggestures","text":""},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#dialoggestures","title":"Dialoggestures","text":"<p>This package can modify the NPCs' gestures during dialogue to better bring out emotions.</p>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#dependencies","title":"Dependencies","text":"<ul> <li>AI_Function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#implementation","title":"Implementation","text":"<p> Dialoggestures.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#diag","title":"<code>DIAG</code>","text":"<p>With this function the dialog gestures for all NPCs can be overridden. To understand the principle, it is recommended to take a look at the examples. </p> <p>The full name of the animation can be described as follows: </p><pre><code>DIAG_Prefix + aniName + DIAG_Suffix + ((rand() % (max - (min - 1))) + min).ToString(\"00\");\n</code></pre> <code>DIAG_Prefix</code> and <code>DIAG_Suffix</code> are user constants. <p></p><pre><code>func void DIAG(var string AniName, var int Min, var int Max)\n</code></pre> Parameters <ul> <li><code>var string AniName</code>     The new dialogue gesture</li> <li><code>var int Min</code>     Lowest animation number</li> <li><code>var int Max</code>     Highest animation number</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#diag_reset","title":"<code>DIAG_Reset</code>","text":"<p>Resets the dialog gestures to the default. </p><pre><code>func void DIAG_Reset()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#diag_setani","title":"<code>DIAG_SetAni</code>","text":"<p>Sets animation directly. </p><pre><code>func void DIAG_SetAni(var string AniName)\n</code></pre> Parameters <ul> <li><code>var string AniName</code>     Animation name</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#diag_setminmax","title":"<code>DIAG_SetMinMax</code>","text":"<p>Sets animation numbers directly. </p><pre><code>func void DIAG_SetMinMax(var int min, var int max)\n</code></pre> Parameters <ul> <li><code>var int min</code>     Lowest animation number</li> <li><code>var int max</code>     Highest animation number</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/dialoggestures/#examples","title":"Examples","text":"<p>Note</p> <p>See Examples in the Trialoge article.</p>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/","title":"Focusnames","text":""},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#focusnames","title":"Focusnames","text":"<p>This package colors the focus names of the NPCs in appropriate colors according to the behavior defined below (alpha values are taken into account). Also affects monsters. (Mobs/Items get Color_Neutral)</p>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#dependencies","title":"Dependencies","text":"<ul> <li>Interface</li> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Focusnames</code> flag. </p><pre><code>LeGo_Init(LeGo_Focusnames);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#implementation","title":"Implementation","text":"<p> Focusnames.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#usage","title":"Usage","text":"<p>If you want to change colors for any behavior edit the following functions directly in <code>Focusnames.d</code> file.</p>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#focusnames_color_friendly","title":"<code>Focusnames_Color_Friendly</code>","text":"<pre><code>func int Focusnames_Color_Friendly()\n{\nreturn RGBA(0, 255, 0, 255); // Green\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#focusnames_color_neutral","title":"<code>Focusnames_Color_Neutral</code>","text":"<pre><code>func int Focusnames_Color_Neutral()\n{\nreturn RGBA(255, 255, 255, 255); // White\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#focusnames_color_angry","title":"<code>Focusnames_Color_Angry</code>","text":"<pre><code>func int Focusnames_Color_Angry()\n{\nreturn RGBA(255, 180, 0, 255); // Orange\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/focusnames/#focusnames_color_hostile","title":"<code>Focusnames_Color_Hostile</code>","text":"<pre><code>func int Focusnames_Color_Hostile()\n{\nreturn RGBA(255, 0, 0, 255); // Red\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/","title":"Gamestate","text":""},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#gamestate","title":"Gamestate","text":"<p>Gamestate package allows to check for different game states (game start, game load or level change).</p>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#dependencies","title":"Dependencies","text":"<ul> <li>EventHandler</li> <li>Saves</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Gamestate</code> flag. </p><pre><code>LeGo_Init(LeGo_Gamestate);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#implementation","title":"Implementation","text":"<p> Gamestate.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#gamestate_addlistener","title":"<code>Gamestate_AddListener</code>","text":"<p>Adds a listener/handler to the game-state event. </p><pre><code>func void Gamestate_AddListener(var func listener)\n</code></pre> Parameters <ul> <li><code>var func listener</code>     This function will be called on a game-state change. The current game-state is passed as a parameter.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#gamestate_removelistener","title":"<code>Gamestate_RemoveListener</code>","text":"<p>Removes game-state listener. </p><pre><code>func void Gamestate_RemoveListener(var func listener)\n</code></pre> Parameters <ul> <li><code>var func listener</code>     Listener function to be removed.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#examples","title":"Examples","text":"<p>There are now two possibilities. Everything can be done directly into the <code>Init_Global</code>, or with EventHandler.</p>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#init_global","title":"Init_Global","text":"<pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame) {\nMEM_Info(\"New game started.\");\n}\nelse if(Gamestate == Gamestate_Loaded)\n{\nMEM_Info(\"Game loaded.\");\n}\nelse if(Gamestate == Gamestate_WorldChange)\n{\nMEM_Info(\"Worldshift.\");\n}\nelse\n{\nMEM_Info(\"I don't pass.\");\n};\n};\n</code></pre> <p>It can also be done like that: </p><pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame)\n{\nFF_Apply(MyLoop);\nFF_Apply(My2ndLoop);\n};\n};\n</code></pre> This would have the same effect as: <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nFF_ApplyOnce(MyLoop);\nFF_ApplyOnce(My2ndLoop);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/gamestate/#eventhandler","title":"EventHandler","text":"<pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nGamestate_AddListener(MyGamestateListener);\n};\nfunc void MyGamestateListener(var int state)\n{\nif(state == Gamestate_NewGame)\n{\nMEM_Info(\"New game started.\");\n}\nelse if(state == Gamestate_Loaded)\n{\nMEM_Info(\"Game loaded.\");\n}\nelse if(state == Gamestate_WorldChange)\n{\nMEM_Info(\"Worldshift.\");\n}\nelse\n{\nMEM_Info(\"I don't pass.\");\n};\n};\n</code></pre> This is the same as the <code>Init_Global</code> example, but it may look more elegant to some.  <p>Note</p> <p>This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website.</p>"},{"location":"zengin/scripts/extenders/lego/applications/names/","title":"Names","text":""},{"location":"zengin/scripts/extenders/lego/applications/names/#names","title":"Names","text":"<p>Allows the user to change NPC name e.g. after he shows up.</p>"},{"location":"zengin/scripts/extenders/lego/applications/names/#dependencies","title":"Dependencies","text":"<ul> <li>Talents</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/names/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/applications/names/#implementation","title":"Implementation","text":"<p> Names.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/names/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/names/#setname","title":"<code>SetName</code>","text":"<p>Should be set in InitGlobal(). </p><pre><code>func void SetName(var C_NPC npc, var string name)\n</code></pre> Parameters <ul> <li><code>var C_NPC npc</code>     The NPC to be named</li> <li><code>var string name</code>     The name of the NPC</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/names/#showname","title":"<code>ShowName</code>","text":"<p>Permanently displays the name set by <code>SetName</code> function above the npc. </p><pre><code>func void ShowName(var C_NPC npc)\n</code></pre> Parameters <ul> <li><code>var C_NPC npc</code>     The NPC whose name should be shown</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/names/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/applications/names/#show-the-name-of-an-npc-later","title":"Show the name of an NPC later","text":"<pre><code>instance PAL_100_Friend(C_NPC)\n{\nname = \"Paladin\";\n// [...]\n};\nfunc void Init_Global()\n{\nSetName(PAL_100_Friend, \"Arto\");\n};\n</code></pre> At the start of the game, the name \"Paladin\" is displayed above <code>PAL_100_Friend</code>. <p>If <code>ShowName(PAL_100_Friend);</code> is used during a dialogue, the name \"Arto\" is permanently visible above the npc.</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/","title":"Render","text":""},{"location":"zengin/scripts/extenders/lego/applications/render/#render","title":"Render","text":"<p>With this package items can be rendered on the screen. Since items are rendered independently of the normal views, textures that are 'below' the items must also be managed by this package, this behaviour is managed by the priority system. The view with the highest priority is always rendered first, so it is at the bottom. In theory, any .3DS model can be rendered if you just create a suitable item script.</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/#dependencies","title":"Dependencies","text":"<ul> <li>List</li> <li>View</li> <li>PermMem</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/render/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Render</code> flag. </p><pre><code>LeGo_Init(LeGo_Render);\n</code></pre> <p>Warning</p> <p>This package is still experimental and not included in <code>LeGo_All</code> initialization flag.</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/#implementation","title":"Implementation","text":"<p> Render.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/render/#render_additemprio","title":"<code>Render_AddItemPrio</code>","text":"<p>Generates the render of an item, with a manually specified priority. </p><pre><code>func int Render_AddItemPrio(var int itemInst, var int x1, var int y1, var int x2, var int y2, var int priority)\n</code></pre> Parameters <ul> <li><code>var int itemInst</code>     The instance of the item to render</li> <li><code>var int x1</code> <code>var int y1</code>     The top left coordinate of the view</li> <li><code>var int x2</code> <code>var int y2</code>     The bottom right coordinate of the view</li> <li><code>var int priority</code>     The priority of this render object</li> </ul> <p>Return value</p> <p>The function returns a handle of the render object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/#render_additem","title":"<code>Render_AddItem</code>","text":"<p>Generates the render of an item, with priority set to <code>0</code>. </p><pre><code>func int Render_AddItem(var int itemInst, var int x1, var int y1, var int x2, var int y2)\n</code></pre> Parameters <ul> <li><code>var int itemInst</code>     The instance of the item to render</li> <li><code>var int x1</code> <code>var int y1</code>     The top left coordinate of the view</li> <li><code>var int x2</code> <code>var int y2</code>     The bottom right coordinate of the view</li> </ul> <p>Return value</p> <p>The function returns a handle of the render object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/#render_addviewprio","title":"<code>Render_AddViewPrio</code>","text":"<p>Generates the render of a View, with a manually specified priority. </p><pre><code>func int Render_AddViewPrio(var int view, var int priority)\n</code></pre> Parameters <ul> <li><code>var int view</code>     A handle to a View</li> <li><code>var int priority</code>     The priority of this render object</li> </ul> <p>Return value</p> <p>The function returns a handle of the render object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/#render_addview","title":"<code>Render_AddView</code>","text":"<p>Generates the render of a View, with priority set to <code>0</code>. </p><pre><code>func int Render_AddView(var int view)\n</code></pre> Parameters <ul> <li><code>var int view</code>     A handle to a View</li> </ul> <p>Return value</p> <p>The function returns a handle of the render object.</p>"},{"location":"zengin/scripts/extenders/lego/applications/render/#render_openview","title":"<code>Render_OpenView</code>","text":"<p>Opens a render object. Only open render objects are displayed. </p><pre><code>func void Render_OpenView(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a render object</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/render/#render_closeview","title":"<code>Render_CloseView</code>","text":"<p>Closes a render object. Only open render objects are displayed. </p><pre><code>func void Render_CloseView(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a render object</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/render/#render_remove","title":"<code>Render_Remove</code>","text":"<p>Deletes a render object. The associated view is deleted automatically. </p><pre><code>func void Render_Remove(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a render object</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/saves/","title":"Saves","text":""},{"location":"zengin/scripts/extenders/lego/applications/saves/#saves","title":"Saves","text":"<p>Offers an open file stream that can read/write variables on save/load. It is used by PermMem, so you don't need to address it manually anymore.</p>"},{"location":"zengin/scripts/extenders/lego/applications/saves/#dependencies","title":"Dependencies","text":"<ul> <li>BinaryMachines</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/saves/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Saves</code> flag. </p><pre><code>LeGo_Init(LeGo_Saves);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/saves/#implementation","title":"Implementation","text":"<p> Saves.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/saves/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/saves/#bw_savegame","title":"<code>BW_Savegame</code>","text":"<p>Custom function. It creates a stream to its own memory file, this can be filled with the <code>BW_*</code> functions from the BinaryMachines. </p><pre><code>func void BW_Savegame()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/saves/#br_savegame","title":"<code>BR_Savegame</code>","text":"<p>Custom function. It opens a stream to a previously saved memory file, which can be read from the BinaryMachines using the <code>BR_*</code> functions. </p><pre><code>func void BR_Savegame()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/saves/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/applications/saves/#save-a-high-score-list","title":"Save a high score list","text":"<pre><code>var string MyScoreList[10];\n</code></pre> <p>Since strings are not saved by the game by default, we use the functions from <code>Saves.d</code> to create an additional memory file that only belongs to us. At the top the Saves.d file has two functions: <code>BW_Savegame</code> and <code>BR_Savegame</code>. BinaryMachines functions are used to save or read the file, we don't need to do anything else than to use them here, the rest is done by <code>Saves.d</code> completely by itself. Therefore, we only modify these two functions.</p> <pre><code>func void BW_Savegame() {\n// Save high score list\nBW_String(MyScoreList[0]);\nBW_String(MyScoreList[1]);\nBW_String(MyScoreList[2]);\nBW_String(MyScoreList[3]);\nBW_String(MyScoreList[4]);\nBW_String(MyScoreList[5]);\nBW_String(MyScoreList[6]);\nBW_String(MyScoreList[7]);\nBW_String(MyScoreList[8]);\nBW_String(MyScoreList[9]);\n};\nfunc void BR_Savegame() {\n// Load high score list\nMyScoreList[0] = BR_String();\nMyScoreList[1] = BR_String();\nMyScoreList[2] = BR_String();\nMyScoreList[3] = BR_String();\nMyScoreList[4] = BR_String();\nMyScoreList[5] = BR_String();\nMyScoreList[6] = BR_String();\nMyScoreList[7] = BR_String();\nMyScoreList[8] = BR_String();\nMyScoreList[9] = BR_String();\n};\n</code></pre> <p>Tip</p> <p>Since LeGo 2.0, such things can be implemented much more elegantly with PermMem.</p>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/","title":"Trialoge","text":""},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#trialoge","title":"Trialoge","text":"<p>This package allows you to create conversations with any number of NPCs and control the camera during the dialog.</p>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#dependencies","title":"Dependencies","text":"<ul> <li>AI_Function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Trialoge</code> flag. </p><pre><code>LeGo_Init(LeGo_Trialoge);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#implementation","title":"Implementation","text":"<p> Trialoge.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#equipweapon","title":"<code>EquipWeapon</code>","text":"<p>Sektenspinner's function. Makes NPC equip a weapon. </p><pre><code>func void EquipWeapon(var C_NPC slf, var int ItemInstance)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC to have a weapon equipped</li> <li><code>var int ItemInstance</code>     Weapon instance ID to be equipped</li> </ul> <p>Configuration</p> <p><code>const int EquipWeapon_TogglesEquip = 1</code></p> <p>Above constant configures the behaviour of the function when trying to equip an already equipped weapon:</p> <ul> <li><code>0</code> - <code>EquipWeapon</code> will do nothing</li> <li><code>1</code> - <code>EquipWeapon</code> will unequip this weapon</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#npc_getarmor","title":"<code>Npc_GetArmor</code>","text":"<p>Returns NPC's equipped armor. </p><pre><code>func int Npc_GetArmor(var C_NPC slf)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC to get the armor from</li> </ul> <p>Return value</p> <p>The function returns instance of armor worn by the NPC.</p>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#npc_getmeleeweapon","title":"<code>Npc_GetMeleeWeapon</code>","text":"<p>Returns NPC's equipped melee weapon. </p><pre><code>func int Npc_GetMeleeWeapon(var C_NPC slf)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC to get the weapon from</li> </ul> <p>Return value</p> <p>The function returns instance ID of melee weapon equipped by the NPC.</p>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#npc_getrangedweapon","title":"<code>Npc_GetRangedWeapon</code>","text":"<p>Returns NPC's equipped ranged weapon. </p><pre><code>func int Npc_GetRangedWeapon(var c_npc slf)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC to get the weapon from</li> </ul> <p>Return value</p> <p>The function returns instance ID of ranged weapon equipped by the NPC.</p>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#npc_tradeitem","title":"<code>Npc_TradeItem</code>","text":"<p>Swaps NPCs equipped weapon. </p><pre><code>func void Npc_TradeItem(var c_npc slf, var int itm0, var int itm1) </code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC to perform operation on</li> <li><code>var int itm0</code>     instance ID of item to remove</li> <li><code>var int itm1</code>     instance ID of item to create and equip</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#diacam_update","title":"<code>DiaCAM_Update</code>","text":"<p>Sektenspinner's function that updates the dialogue camera. (Used internally.) </p><pre><code>func void DiaCAM_Update()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#diacam_disable","title":"<code>DiaCAM_Disable</code>","text":"<p>Completely disable the dialogue cameras. </p><pre><code>func void DiaCAM_Disable()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#diacam_enable","title":"<code>DiaCAM_Enable</code>","text":"<p>Resets the dialogue cameras to the default settings. </p><pre><code>func void DiaCAM_Enable()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#tria_wait","title":"<code>TRIA_Wait</code>","text":"<p>Makes <code>self</code> and <code>other</code> wait for each other, e.g. for <code>AI_GotoWP</code> actions for synchronization.  </p><pre><code>func void TRIA_Wait()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#tria_invite","title":"<code>TRIA_Invite</code>","text":"<p>Invites an NPC into a conversation. Must be called before <code>TRIA_Start</code>. </p><pre><code>func void TRIA_Invite(var C_NPC slf)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     The invited NPC</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#tria_start","title":"<code>TRIA_Start</code>","text":"<p>Starts trialogues. Before that, all NPCs should be invited by <code>TRIA_Invite</code>. </p><pre><code>func void TRIA_Start()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#tria_barrier","title":"<code>TRIA_Barrier</code>","text":"<p>Similar to <code>TRIA_Wait</code> but applies to all participating NPCs. </p><pre><code>func void TRIA_Barrier()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#tria_next","title":"<code>TRIA_Next</code>","text":"<p>Sets the called npc to <code>self</code>. </p><pre><code>func void TRIA_Next(var C_NPC n0)\n</code></pre> Parameters <ul> <li><code>var C_NPC n0</code>     NPC to set to <code>self</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#tria_cam","title":"<code>TRIA_Cam</code>","text":"<p>Starts a tracking shot.  </p><pre><code>func void TRIA_Cam(var string evt)\n</code></pre> Parameters <ul> <li><code>var string evt</code>     The name of the tracking shot in Spacer. If <code>\"\"</code> is passed, the running trace shot will be aborted.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#tria_finish","title":"<code>TRIA_Finish</code>","text":"<p>Ends an ongoing trialogue. Must always be called at the end, otherwise no further trialogues can be started. </p><pre><code>func void TRIA_Finish()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/applications/trialoge/#a-simple-trialogue","title":"A Simple Trialogue","text":"<p>The following conversation is resolved via the trialogues:</p> <ol> <li>Arto: I'm sorry Hero, but you can't pass here.</li> <li>Hero: Why not?</li> <li>Horka: The city has been closed.</li> <li>Hero: I have some gold with me, can we trade?</li> <li>Squelto: No. We are not open to bribery.</li> <li>Hero: Sure?</li> <li>Arto: I have to ask you to leave now.</li> <li>Hero: Well... <pre><code>instance TRIA_Test (C_INFO)\n{\nnpc         = PAL_100_Friend;\nnr          = 10;\ncondition   = TRIA_Test_condition;\ninformation = TRIA_Test_info;\nimportant   = FALSE;\npermanent   = 1;\ndescription = \"TRIALOGTEST\";\n};\nfunc int TRIA_Test_condition()\n{\nreturn TRUE;\n};\nfunc void TRIA_Test_info()\n{\nvar C_NPC Arto; Arto       = Hlp_GetNpc(PAL_100_Friend); // He is the owner of dialogue\nvar C_NPC Horka; Horka     = Hlp_GetNpc(PAL_101_Horka);\nvar C_NPC Squelto; Squelto = Hlp_GetNpc(PAL_102_Squelto);\nTRIA_Invite(Horka);   // Invite Horka into this dialogue\nTRIA_Invite(Squelto); // Invite Squelto into this dialog\nTRIA_Start();         // Start the conversation\n// The hero and Arto do not have to/may not be invited. They are in dialogue anyway.\n// Hero now talks to Arto (self = Arto, other = Hero)\nTRIA_Next(Arto);\nDIAG_Reset();\nAI_Output (self, other, \"TRIA_TEST_00\"); //Sorry hero, but you can't pass here.\n// Hero now talks to Horka (self = Horka, other = Hero)\nTRIA_Next(Horka);\nAI_Output (other, self, \"TRIA_TEST_01\"); //Why not?\nAI_GotoNpc(self, other);\nAI_TurnToNpc(other, self);\nAI_Output (self, other, \"TRIA_TEST_02\"); //The city has been closed.\n// Hero looks around conspiratorially during the next sentence\nDIAG(\"Nervous\", 1, 2);\nAI_Output (other, self, \"TRIA_TEST_03\"); //I have some gold with me, can we trade?\n// Hero should now move normally again\nDIAG_Reset();\n// Start tracking shot\nTRIA_Cam(\"CAMERASTART\");\n// Hero now talks to Squelto (self = Squelto, other = Hero)\nTRIA_Next(Squelto);\nAI_TurnToNpc(other, self);\nDIAG(\"No\", 0, 1);\nAI_Output (self, other, \"TRIA_TEST_04\"); //No. We are not open to bribery.\n// Hero talks to Arto again (self = Arto, other = Hero)\nTRIA_Next(Arto);\n// Hero should now articulate questioningly\nDIAG(\"NotSure\", 0, 1);\nAI_Output (other, self, \"TRIA_TEST_05\"); //Sure?\nAI_TurnToNpc(other, self);\n// tracking shot end\nTRIA_Cam(\"\");\n// Arto should react angrily\nDIAG(\"Angry\", 0, 4);\nAI_Output (self, other, \"TRIA_TEST_06\"); //I have to ask you to leave now\n// Hero should now move normally again\nDIAG_Reset();\nAI_Output (other, self, \"TRIA_TEST_07\"); //Well...\nTRIA_Finish(); // End\n};\n</code></pre></li> </ol> <p>Note</p> <p>In addition, here are still Dialoggestures used.</p>"},{"location":"zengin/scripts/extenders/lego/tools/ai_function/","title":"AI_Function","text":""},{"location":"zengin/scripts/extenders/lego/tools/ai_function/#ai_function","title":"AI_Function","text":"<p>This package allows time-delayed functions to be called by enqueuing the functions in the AI queue of the NPC in question. This can be very useful in writing cutscenes on engine or implementing new routines.</p>"},{"location":"zengin/scripts/extenders/lego/tools/ai_function/#dependencies","title":"Dependencies","text":"<ul> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/ai_function/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_AI_Function</code> flag. </p><pre><code>LeGo_Init(LeGo_AI_Function);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/ai_function/#implementation","title":"Implementation","text":"<p> AI_Function.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/ai_function/#functions","title":"Functions","text":"<p>The script function <code>function</code> is called with a delay: it joins the AI queue of <code>slf</code>. </p><pre><code>func void AI_Function(var C_NPC slf, var func function)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC in whose AI queue the function is queued</li> <li><code>var func function</code>     Name of function to be queued</li> </ul> <p>Additionally, there are some overloads of <code>AI_Function</code>, which allow to call functions with parameters. </p><pre><code>func void AI_Function_I  (var C_NPC slf, var func function, var int    param) {}; // Int\nfunc void AI_Function_N  (var C_NPC slf, var func function, var int    param) {}; // Instance (e.g. NPC)\nfunc void AI_Function_S  (var C_NPC slf, var func function, var string param) {}; // String\nfunc void AI_Function_II (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Int, Int\nfunc void AI_Function_NN (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Instance, Instance\nfunc void AI_Function_SS (var C_NPC slf, var func function, var string param1, var string param2) {}; // String, String\nfunc void AI_Function_IS (var C_NPC slf, var func function, var int    param1, var string param2) {}; // Int, String\nfunc void AI_Function_SI (var C_NPC slf, var func function, var string param1, var int    param2) {}; // String, Int\nfunc void AI_Function_NS (var C_NPC slf, var func function, var int    param1, var string param2) {}; // Instance, String\nfunc void AI_Function_SN (var C_NPC slf, var func function, var string param1, var int    param2) {}; // String, Istance\nfunc void AI_Function_IN (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Int, Instance\nfunc void AI_Function_NI (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Instance, Int\n</code></pre> Functions with more than two parameters cannot be called, but parameters can be passed indirectly via global variables. <p>In the called function, <code>self</code> can be accessed as follows: </p><pre><code>var oCNpc slf; slf = _^(ECX);\n</code></pre> <p>Info</p> <p>From LeGo 2.7.2 the global instance <code>self</code> is provided correctly and can be used directly.</p>"},{"location":"zengin/scripts/extenders/lego/tools/ai_function/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/ai_function/#enqueueing-a-simple-function","title":"Enqueueing a simple function","text":"<p>Before a function is called, any Npc should first complete its AI queue.</p> <p>Here the hero is supposed to run to a waypoint, and only when he has arrived is to start a tracking shot. </p><pre><code>func void Example1() {\nNpc_ClearAIQueue(hero);\nAI_GotoWP(hero, \"MYWAYPOINT\");\nAI_Function_S(hero, Wld_SendTrigger, \"CAMERASTART\");\n};\n</code></pre> As soon as the hero has reached the waypoint, <code>Wld_SendTrigger(\"CAMERASTART\");</code> is called."},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/","title":"BinaryMachines","text":""},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#binarymachines","title":"BinaryMachines","text":"<p>This package allows you to create and write your own files anywhere in the file system.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#implementation","title":"Implementation","text":"<p> BinaryMachines.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#binarywriter","title":"BinaryWriter","text":""},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_newfile","title":"<code>BW_NewFile</code>","text":"<p>Creates the file with the <code>file</code> name and opens a stream. Doesn't work if a stream is already open. </p><pre><code>func int BW_NewFile(var string file)\n</code></pre> Parameters <ul> <li><code>var string file</code>     Name of created file</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the file is successfully created and initialized, <code>FALSE</code>is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_close","title":"<code>BW_Close</code>","text":"<p>Closes the current write stream. </p><pre><code>func void BW_Close()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw","title":"<code>BW</code>","text":"<p>Writes <code>length</code> bytes from the <code>data</code> to the stream, maximum 4 bytes. </p><pre><code>func void BW(var int data, var int length)\n</code></pre> Parameters <ul> <li><code>var int data</code>     Value of bytes</li> <li><code>var int length</code>     Number of bytes</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_int","title":"<code>BW_Int</code>","text":"<p>Writes 4 bytes from the <code>data</code> to the stream. Same as <code>BW(data, 4)</code>. </p><pre><code>func void BW_Int(var int data)\n</code></pre> Parameters <ul> <li><code>var int data</code>     Integer value to write</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_char","title":"<code>BW_Char</code>","text":"<p>Writes the first character from the <code>data</code> to the stream. Same as <code>BW(Str_GetCharAt(data, 0), 1)</code>. </p><pre><code>func void BW_Char(var string data)\n</code></pre> Parameters <ul> <li><code>var string data</code>     Char to write</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_string","title":"<code>BW_String</code>","text":"<p>Writes the <code>data</code> terminated with <code>\\0</code> to the stream. </p><pre><code>func void BW_String(var string data)\n</code></pre> Parameters <ul> <li><code>var string data</code>     String to write</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_byte","title":"<code>BW_Byte</code>","text":"<p>Writes a byte from the <code>data</code> to the stream. Same as <code>BW(data, 1)</code>. </p><pre><code>func void BW_Byte(var int data)\n</code></pre> Parameters <ul> <li><code>var int data</code>     Byte value to write</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_bytes","title":"<code>BW_Bytes</code>","text":"<p>Writes <code>length</code> of bytes from the pointer <code>dataPtr</code> to the stream. </p><pre><code>func void BW_Bytes(var int dataPtr, var int length)\n</code></pre> Parameters <ul> <li><code>var int dataPtr</code>     Pointer of data to write</li> <li><code>var int length</code>     Number of bytes</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_text","title":"<code>BW_Text</code>","text":"<p>Writes the string to the stream without terminating it. So it can no longer be read. </p><pre><code>func void BW_Text(var string data)\n</code></pre> Parameters <ul> <li><code>var string data</code>     Text to write</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#bw_nextline","title":"<code>BW_NextLine</code>","text":"<p>Writes a paragraph to the stream. </p><pre><code>func void BW_NextLine()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#binaryreader","title":"BinaryReader","text":""},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_openfile","title":"<code>BR_OpenFile</code>","text":"<p>Opens the file with the <code>file</code> name and opens a stream. Doesn't work if a stream is already open. </p><pre><code>func int BR_OpenFile(var string file)\n</code></pre> Parameters <ul> <li><code>var string file</code>     File to be opened</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the file is successfully opened and initialized, <code>FALSE</code>is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_close","title":"<code>BR_Close</code>","text":"<p>Closes the current read stream. </p><pre><code>func void BR_Close()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br","title":"<code>BR</code>","text":"<p>Reads bytes from the stream. </p><pre><code>func int BR(var int length)\n</code></pre> Parameters <ul> <li><code>var int length</code>     Number of bytes to read (maximum 4)</li> </ul> <p>Return value</p> <p>The function returns the value of read bytes.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_int","title":"<code>BR_Int</code>","text":"<p>Reads 4 bytes from the stream. Same as <code>BR(4)</code>. </p><pre><code>func int BR_Int()\n</code></pre> Return value <p>The function returns the read integer.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_char","title":"<code>BR_Char</code>","text":"<p>Reads a character from the stream. Same as <code>BR(1)</code>. </p><pre><code>func string BR_Char()\n</code></pre> Return value <p>The function returns the read character as a <code>string</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_string","title":"<code>BR_String</code>","text":"<p>Reads a string terminated by <code>\\0</code> from the stream. </p><pre><code>func string BR_String()\n</code></pre> Return value <p>The function returns the read string.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_byte","title":"<code>BR_Byte</code>","text":"<p>Reads a byte from the stream. </p><pre><code>func int BR_Byte()\n</code></pre> Return value <p>The function returns the read byte.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_bytes","title":"<code>BR_Bytes</code>","text":"<p>Reads bytes from the stream. </p><pre><code>func int BR_Bytes(var int length)\n</code></pre> Parameters <ul> <li><code>var int length</code>     Number of bytes to read</li> </ul> <p>Return value</p> <p>The function returns a pointer to the read bytes.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_textline","title":"<code>BR_TextLine</code>","text":"<p>Reads a line from the stream. </p><pre><code>func string BR_TextLine()\n</code></pre> Return value <p>The function returns the read line.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_text","title":"<code>BR_Text</code>","text":"<p>Reads a string of the given length from a stream. </p><pre><code>func string BR_Text(var int length)\n</code></pre> Parameters <ul> <li><code>var int length</code>     Number of characters to read</li> </ul> <p>Return value</p> <p>The function returns the read string.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#br_nextline","title":"<code>BR_NextLine</code>","text":"<p>Changes the read position to the next paragraph, created with <code>BW_NextLine</code> </p><pre><code>func void BR_NextLine()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#enginecalls","title":"Enginecalls","text":""},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#win_getlasterror","title":"<code>WIN_GetLastError</code>","text":"<p>Call of a Win32 API <code>GetLastError</code> function </p><pre><code>func int WIN_GetLastError()\n</code></pre> Return value <p>The function returns calling thread's last-error code.</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#win_createfile","title":"<code>WIN_CreateFile</code>","text":"<p>Call of a Win32 API <code>CreateFileA</code> function </p><pre><code>func int WIN_CreateFile(var string lpFileName,var int dwDesiredAccess,var int dwShareMode,var int lpSecurityAttributes,var int dwCreationDisposition,var int dwFlagsAndAttributes,var int hTemplateFile)\n</code></pre> Parameters <p>Full description of parameters can be found here</p> <p>Return value</p> <p>Information about return value can be found here</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#win_writefile","title":"<code>WIN_WriteFile</code>","text":"<p>Call of a Win32 API <code>WriteFile</code> function </p><pre><code>func void WIN_WriteFile(var int hFile,var int lpBuffer,var int nNumberOfBytesToWrite,var int lpNumberOfBytesWritten,var int lpOverlapped)\n</code></pre> Parameters <p>Full description of parameters can be found here</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#win_readfile","title":"<code>WIN_ReadFile</code>","text":"<p>Call of a Win32 API <code>ReadFile</code> function </p><pre><code>func void WIN_ReadFile(var int hFile,var int lpBuffer,var int nNumberOfBytesToRead,var int lpNumberOfBytesRead,var int lpOverlapped)\n</code></pre> Parameters <p>Full description of parameters can be found here</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#win_closehandle","title":"<code>WIN_CloseHandle</code>","text":"<p>Call of a Win32 API <code>CloseHandle</code> function </p><pre><code>func void WIN_CloseHandle(var int hObject)\n</code></pre> Parameters <p>Full description of parameters can be found here</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#win_getfilesize","title":"<code>WIN_GetFileSize</code>","text":"<p>Call of a Win32 API <code>GetFileSize</code> function </p><pre><code>func int WIN_GetFileSize(var int hFile,var int lpFileSizeHigh)\n</code></pre> Parameters <p>Full description of parameters can be found here</p> <p>Return value</p> <p>Information about return value can be found here</p>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#constants","title":"Constants","text":"<p>In addition there are some constants defined for use with the specific engine calls. </p><pre><code>const int CREATE_ALWAYS = 2;\nconst int OPEN_EXISTING = 3;\nconst int GENERIC_ALL = 1073741824;\nconst int GENERIC_READ = -2147483648;\nconst int FILE_SHARE_READ = 1;\nconst int FILE_SHARE_WRITE = 2;\nconst int FILE_SHARE_DELETE = 4;\nconst int FILE_ATTRIBUTE_NORMAL = 128;\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#save-and-load-variables","title":"Save and load variables","text":"<pre><code>const string filename = \"System\\MySave.sav\";\nvar string s0; // string\nvar int    i1; // int\nvar int    b2; // byte\nvar string c3; // char\nfunc void SaveMyData() {\nif(BW_NewFile(filename))  // Create a new file:\n{ BW_String(s0);\nBW_Int(i1);\nBW_Byte(b2);\nBW_Char(c3);          // Save stuff..\nBW_Close();           // ..and close.\n};\n};\nfunc void LoadMyData() {\nif(BR_OpenFile(filename)) // Try to open file:\n{ s0 = BR_String();\ni1 = BR_Int();\nb2 = BR_Byte();\nc3 = BR_Char();       // Read in values..\nBR_Close();           // ..and close.\n}\nelse {\nSaveMyData();         // Otherwise create a save file.\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#congratulate-the-player","title":"Congratulate the player","text":"<pre><code>func void Certificate(var string Username, var int Score) {\nvar string filename; filename = ConcatStrings(Username, \"'s Certificate.txt\");\nBW_NewFile(filename); // Username + \"s Certificate.txt\". The file is then in the Gothic directory.\nBW_Text(\"Congratulations \"); BW_Text(Username);\nBW_TextLine(\"!\");\nBW_Text(\"You have reached \");\nBW_Text(IntToString(Score)); // Not BW_Int!\nBW_TextLine(\" Points in this fun game.\");\nBW_NextLine();\nBW_Text(\"Best regards, Author\");\nBW_Close();\n/*\n       When calling:  Certificate(\"Player\", 1000);\n       a file with the name 'Player's Certificate.txt' would come out which would contain the following:\n        Congratulations Player\n        You have reached 1000 Points in this fun game.\n        Best regards, Author\n    */\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/binary_machines/#the-location-of-an-npcs","title":"The location of an NPCs","text":"<pre><code>func void BW_NpcPosition(var C_NPC slf) {\nvar int ptr; ptr = MEM_Alloc(60);                // 16 * 4\nMEM_CopyBytes(MEM_InstToPtr(slf) + 60, ptr, 60); // Copy slf.trafoObjToWorld\nBW_Bytes(ptr, 60);                               // Writes the 60 copied bytes\nMEM_Free(ptr);                                   // And clean up..\n};\nfunc void BR_NpcPosition(var C_NPC slf) {\nvar int ptr; ptr = BR_Bytes(60);                 // Read 60 bytes\nMEM_CopyBytes(ptr, MEM_InstToPtr(slf) + 60, 60); // Paste back into slf\nMEM_Free(ptr);                                   // And clean up again..\n};\n/*\n   Normal use:\n     BW_NewFile(file);\n     BW_NpcPosition(hero);\n     BW_Close();\n*/\n</code></pre> <p>Note</p> <p>Examples originally written by Gottfried and posted on World of Gothic forum.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/","title":"EventHandler","text":""},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventhandler","title":"EventHandler","text":"<p>This package allows to create new events and trigger them at desired times. The Gamestate package already uses it.</p> <p>Warning</p> <p>The EventHandler requires some basic understanding of the PermMem. The documentation can be found here.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_EventHandler</code> flag. </p><pre><code>LeGo_Init(LeGo_EventHandler);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#implementation","title":"Implementation","text":"<p> EventHandler.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_create","title":"<code>Event_Create</code>","text":"<p>Creates a new event and returns a handle to it. </p><pre><code>func int Event_Create()\n</code></pre> Return value <p>The function returns a new PermMem handle to an event.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_delete","title":"<code>Event_Delete</code>","text":"<p>Alias to PermMem <code>delete</code>. Cleans up the handle. </p><pre><code>func void Event_Delete(var int event)\n</code></pre> Parameters <ul> <li><code>var int event</code>     Handle returned from <code>Event_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_empty","title":"<code>Event_Empty</code>","text":"<p>Checks whether the event is \"empty\", i.e. nothing will happen after its execution. </p><pre><code>func int Event_Empty(var int event)\n</code></pre> Parameters <ul> <li><code>var int event</code>     Handle returned from <code>Event_Create</code></li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if event is empty, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_has","title":"<code>Event_Has</code>","text":"<p>Checks if <code>function</code> is added to the event. </p><pre><code>func int Event_Has(var int event, var func function)\n</code></pre> Parameters <ul> <li><code>var int event</code>     Handle returned from <code>Event_Create</code></li> <li><code>var func function</code>     Checked function</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if function is added, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_add","title":"<code>Event_Add</code>","text":"<p>Adds an event handler function. The handler is called after running <code>Event_Execute</code>. </p><pre><code>func void Event_Add(var int event, var func function)\n</code></pre> Parameters <ul> <li><code>var int event</code>     Handle returned from <code>Event_Create</code></li> <li><code>var func function</code>     Function to be added</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_addonce","title":"<code>Event_AddOnce</code>","text":"<p><code>Event_Add</code> but checks if the handler function is already added, to prevent duplicates. </p><pre><code>func void Event_AddOnce(var int event, var func function)\n</code></pre> Parameters <ul> <li><code>var int event</code>     Handle returned from <code>Event_Create</code></li> <li><code>var func function</code>     Function to be added</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_remove","title":"<code>Event_Remove</code>","text":"<p>Removes the event handler <code>function</code> from the event. </p><pre><code>func void Event_Remove(var int event, var func function)\n</code></pre> Parameters <ul> <li><code>var int event</code>     Handle returned from <code>Event_Create</code></li> <li><code>var func function</code>     Function to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#event_execute","title":"<code>Event_Execute</code>","text":"<p>Core of the package. Calls all functions registered via <code>Event_Add</code> and <code>Event_AddOnce</code>. </p><pre><code>func void Event_Execute(var int event, var int data)\n</code></pre> Parameters <ul> <li><code>var int event</code>     Handle returned from <code>Event_Create</code></li> <li><code>var int data</code>     Int parameter passed to all executed functions</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#ptr-functions","title":"Ptr functions","text":"<p>Tip</p> <p>The pointer functions are used internally by the previous functions. If you created an event with <code>Event_Create</code> use functions without <code>Ptr</code> in the name, but if you created event with <code>EventPtr_Create</code> use only <code>Ptr</code> functions. The normal user will probably never need the pointer versions, however the choice, which one to use is yours. </p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_create","title":"<code>EventPtr_Create</code>","text":"<p>Creates a new event and returns a pointer to it. </p><pre><code>func int EventPtr_Create()\n</code></pre> Return value <p>The function returns a new PermMem pointer to an event.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_delete","title":"<code>EventPtr_Delete</code>","text":"<p>Alias to PermMem <code>free</code>. Cleans up the pointer. </p><pre><code>func void EventPtr_Delete(var int eventPtr)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_empty","title":"<code>EventPtr_Empty</code>","text":"<p>Checks whether the event is \"empty\", i.e. nothing will happen after its execution. </p><pre><code>func int EventPtr_Empty(var int eventPtr)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if empty, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_has","title":"<code>EventPtr_Has</code>","text":"<p>Checks if <code>function</code> is added to an event. </p><pre><code>func int EventPtr_Has(var int eventPtr, var func function)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var func function</code>     Checked function</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if function is added, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_hasi","title":"<code>EventPtr_HasI</code>","text":"<p><code>EventPtr_Has</code> but with function ID instead of pointer. Used mainly internally. </p><pre><code>func int EventPtr_HasI(var int eventPtr, var int id)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var int id</code>     ID of checked function</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if function is added, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_add","title":"<code>EventPtr_Add</code>","text":"<p>Adds an event handler function. The handler is called after running <code>EventPtr_Execute</code>.  </p><pre><code>func void EventPtr_Add(var int eventPtr, var func function)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var func function</code>     Function to be added</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_addi","title":"<code>EventPtr_AddI</code>","text":"<p><code>EventPtr_Add</code> but with function ID instead of pointer. Used mainly internally. </p><pre><code>func void EventPtr_AddI(var int eventPtr, var int id)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var int id</code>     ID of function to be added</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_addonce","title":"<code>EventPtr_AddOnce</code>","text":"<p><code>Event_Add</code> but checks if function is already added, to prevent duplicates. </p><pre><code>func void EventPtr_AddOnce(var int eventPtr, var func function)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var func function</code>     Function to be added</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_addoncei","title":"<code>EventPtr_AddOnceI</code>","text":"<p><code>EventPtr_AddI</code> but checks if function is already added, to prevent duplicates. </p><pre><code>func void EventPtr_AddOnceI(var int eventPtr, var int id)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var int id</code>     ID of function to be added</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_remove","title":"<code>EventPtr_Remove</code>","text":"<p>Removes a function from the event's call list. </p><pre><code>func void EventPtr_Remove(var int eventPtr, var func function)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var func function</code>     Function to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_removei","title":"<code>EventPtr_RemoveI</code>","text":"<p><code>EventPtr_Remove</code> but with function ID instead of pointer. Used mainly internally. </p><pre><code>func void EventPtr_RemoveI(var int eventPtr, var int id)\n</code></pre> Parameters <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var int id</code>     ID of function to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#eventptr_execute","title":"<code>EventPtr_Execute</code>","text":"<p>Core of the package. Calls all functions registered via <code>EventPtr_Add</code> and <code>EventPtr_AddOnce</code>. </p><pre><code>func void EventPtr_Execute(var int eventPtr, var int data)\n</code></pre> <ul> <li><code>var int eventPtr</code>     Pointer returned from <code>EventPtr_Create</code></li> <li><code>var int data</code>     Int parameter passed to all executed functions</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/event_handler/#examples","title":"Examples","text":"<p>Note</p> <p>This article has no built-in examples, but the best way to understand how EventHandler works is reading source code of the Gamestate package.</p>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/","title":"FrameFunctions","text":""},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#framefunctions","title":"FrameFunctions","text":"<p>The FrameFunctions package allows to call any number of functions called on every frame, or every specified time delay.</p>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> <li>PermMem</li> <li>HookEngine</li> <li>Timer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_FrameFunctions</code> flag. </p><pre><code>LeGo_Init(LeGo_FrameFunctions);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#implementation","title":"Implementation","text":"<p> FrameFunctions.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_apply","title":"<code>FF_Apply</code>","text":"<p>Adds the Daedalus function <code>function</code> to the running FrameFunctions list. <code>function</code> is called each frame. </p><pre><code>func void FF_Apply(var func function)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applygt","title":"<code>FF_ApplyGT</code>","text":"<p>Adds the Daedalus function <code>function</code> to the running FrameFunctions list. <code>function</code> is called every frame except when the game is paused. </p><pre><code>func void FF_ApplyGT(var func function)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applydata","title":"<code>FF_ApplyData</code>","text":"<p>Adds the Daedalus function <code>function</code> to the running FrameFunctions list. The integer parameter <code>data</code> is passed to the function <code>function</code>.  </p><pre><code>func void FF_ApplyData(var func function, var int data)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function.</li> <li><code>var int data</code>     Value passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyext","title":"<code>FF_ApplyExt</code>","text":"<p>Adds the Daedalus function <code>function</code> to the running FrameFunctions list. The function <code>function</code> is called every <code>delay</code> milliseconds, and it runs only <code>cycles</code> number of times. </p><pre><code>func void FF_ApplyExt(var func function, var int delay, var int cycles)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> <li><code>var int delay</code>     Delay between calls in milliseconds (0 = every frame)</li> <li><code>var int cycles</code>     How many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyextgt","title":"<code>FF_ApplyExtGT</code>","text":"<p>Adds the Daedalus function <code>function</code> to the running FrameFunctions list. The function <code>function</code> is called every <code>delay</code> milliseconds, and it runs only <code>cycles</code> number of times. Gets called only when the game is not paused. </p><pre><code>func void FF_ApplyExtGT(var func function, var int delay, var int cycles)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> <li><code>var int delay</code>     Delay between calls in milliseconds (0 = every frame)</li> <li><code>var int cycles</code>     How many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyextdata","title":"<code>FF_ApplyExtData</code>","text":"<p>Adds the Daedalus function <code>function</code> to the running FrameFunctions list. The function <code>function</code> is called every <code>delay</code> milliseconds, and it runs only <code>cycles</code> number of times. The integer parameter <code>data</code> is passed to the function <code>function</code>.  </p><pre><code>func void FF_ApplyExtData(var func function, var int delay, var int cycles, var int data)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function.</li> <li><code>var int delay</code>     Delay between calls in milliseconds (0 = every frame)</li> <li><code>var int cycles</code>     How many times should the function be called (-1 = endless)</li> <li><code>var int data</code>     Value passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyextdatagt","title":"<code>FF_ApplyExtDataGT</code>","text":"<p>Adds the Daedalus function <code>function</code> to the running FrameFunctions list. The function <code>function</code> is called every <code>delay</code> milliseconds, and it runs only <code>cycles</code> number of times. The integer parameter <code>data</code> is passed to the function <code>function</code>. Gets called only when the game is not paused. </p><pre><code>func void FF_ApplyExtData(var func function, var int delay, var int cycles, var int data)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function.</li> <li><code>var int delay</code>     Delay between calls in milliseconds (0 = every frame)</li> <li><code>var int cycles</code>     How many times should the function be called (-1 = endless)</li> <li><code>var int data</code>     Value passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyonce","title":"<code>FF_ApplyOnce</code>","text":"<p>Alias to FF_Apply, which only adds the function once, even after multiple calls. </p><pre><code>func void FF_ApplyOnce(var func function)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyoncegt","title":"<code>FF_ApplyOnceGT</code>","text":"<p>Alias to FF_ApplyGT, which only adds the function once, even after multiple calls. Loop doesn't run if the game is paused. </p><pre><code>func voidoften FF_ApplyOnceGT(var func function)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyoncedata","title":"<code>FF_ApplyOnceData</code>","text":"<p>Alias to FF_ApplyData, which only adds the function with the specified parameter once, even after multiple calls. </p><pre><code>func void FF_ApplyOnceData(var func function, var int data)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function.</li> <li><code>var int data</code>     Value passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyonceext","title":"<code>FF_ApplyOnceExt</code>","text":"<p>Alias to FF_ApplyExt, which adds the function only once, after repeated calls. </p><pre><code>func void FF_ApplyOnceExt(var func function, var int delay, var int cycles)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> <li><code>var int delay</code>     Delay between calls in milliseconds (0 = every frame)</li> <li><code>var int cycles</code>     How many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyonceextgt","title":"<code>FF_ApplyOnceExtGT</code>","text":"<p>Alias to FF_ApplyExtGT, which adds the function only once after repeated calls. Loop doesn't run if the game is paused. </p><pre><code>func void FF_ApplyOnceExtGT(var func function, var int delay, var int cycles)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> <li><code>var int delay</code>     Delay between calls in milliseconds (0 = every frame)</li> <li><code>var int cycles</code>     How many times should the function be called (-1 = endless)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_applyonceextdata","title":"<code>FF_ApplyOnceExtData</code>","text":"<p>Alias to FF_ApplyExtData, which adds the function with the specified parameter only once, after repeated calls. </p><pre><code>func void FF_ApplyOnceExtData(var func function, var int delay, var int cycles, var int data)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> <li><code>var int delay</code>     Delay between calls in milliseconds (0 = every frame)</li> <li><code>var int cycles</code>     How many times should the function be called (-1 = endless)</li> <li><code>var int data</code>     Value passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_active","title":"<code>FF_Active</code>","text":"<p>Checks whether the <code>function</code> is active. </p><pre><code>func int FF_Active(var func function)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> </ul> <p>Return value The function returns <code>TRUE</code> if the function is active, <code>FALSE</code> if it is not.</p>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_activedata","title":"<code>FF_ActiveData</code>","text":"<p>Checks whether the <code>function</code> with the specified <code>data</code> is active. </p><pre><code>func int FF_ActiveData(var func function, var int data)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the function</li> <li><code>var int data</code>      Value previously passed to the function</li> </ul> <p>Return value The function returns <code>TRUE</code> if the function is active, <code>FALSE</code> if it is not.</p>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_remove","title":"<code>FF_Remove</code>","text":"<p>Stops a specific FrameFunction. </p><pre><code>func void FF_Remove(var func function)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the stopped function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_removeall","title":"<code>FF_RemoveAll</code>","text":"<p>Stops all intsnces of a specific FrameFunction. </p><pre><code>func void FF_RemoveAll(var func function)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the stopped function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#ff_removedata","title":"<code>FF_RemoveData</code>","text":"<p>Stops a specific FrameFunction, with the specified value (see <code>FF_ApplyExtData</code> ). </p><pre><code>func void FF_RemoveData(var func function, var int data)\n</code></pre> Parameters <ul> <li><code>var func function</code>     Name of the stopped function</li> <li><code>var int data</code>     Value previously passed to the function as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#a-function-called-every-frame","title":"A function called every frame","text":"<p>In this example function <code>MyFunc</code> will be executed on every frame. </p><pre><code>func void Example1()\n{\nFF_Apply(MyFunc);\n};\nfunc void MyFunc() {};\n</code></pre> After the <code>Example1</code> function is executed the function <code>MyFunc</code> is called on every frame. <p>The easiest and best way to run a function from the beginning is to call <code>FF-Apply</code> directly in the <code>Init_Global</code> (under <code>LeGo_Init</code>), there is a small problem: If the game is loaded, <code>Init_Global</code> is called a second time, the function is added to the list again and is therefore always called twice.</p> <p>To avoid this effect, you should check whether the function is already active: </p><pre><code>func void Example1()\n{\nif(!FF_Active(MyFunc))\n{\nFF_Apply(MyFunc);\n};\n};\n</code></pre> <p>However, since LeGo version 2.2 there is an even more pleasant method to do this: </p><pre><code>func void Example1()\n{\nFF_ApplyOnce(MyFunc);\n};\n</code></pre> <code>FF_ApplyOnce</code> function already implements the check for function activity."},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#calling-delayed-function","title":"Calling delayed function","text":"<p>Create a function, that is called once after 3 seconds. </p><pre><code>func void Example2()\n{\nFF_ApplyExt(MyFunc2, 3000, 1); // 3000 ms = 3 s, this function is called only once\n};\nfunc void MyFunc2() {};\n</code></pre> <p>There is also a <code>Once</code> variant of this function, that prevents adding it twice into the frame function list. </p><pre><code>func void Example2()\n{\nFF_ApplyOnceExt(MyFunc2, 3000, 1);\n};\n</code></pre> <p>Note</p> <p><code>FF_ApplyExt(MyFunc, 0, -1)</code> is the same as <code>FF_Apply(MyFunc)</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/frame_functions/#framefunction-with-timer","title":"FrameFunction with Timer","text":"<p>Since LeGo 2.2, FrameFunctions package uses the Timer package, so it is possible to pause FrameFunctions at will: </p><pre><code>func void Example3()\n{\nFF_ApplyOnceExt(MyFunc3, 4000, 2);\n};\nfunc void MyFunc3()\n{\nTimer_SetPaused(!Timer_GetPaused());\n};\n</code></pre> This would pause the timer after 4 seconds and let it continue after 8 seconds.  <p>Warning</p> <p>Because the timer doesn't run, the frame function execution is stopped as well. This script won't work. If the timer is to be paused, it must be paused outside FrameFunctions.</p> <p>Note</p> <p>This is translation of article originally written by Gottfried and Lehona and hosted on LeGo's official documentation website.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/","title":"Hashtables","text":""},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#hashtables","title":"Hashtables","text":"<p>Hashtables package is an implementation of hashtables in Gothic. Currently (version 2.8.0) only integers are supported as keys. The Hashtables grow automatically.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_PermMem</code> flag. </p><pre><code>LeGo_Init(LeGo_PermMem);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#implementation","title":"Implementation","text":"<p> Hashtable.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_createsized","title":"<code>HT_CreateSized</code>","text":"<p>Generates a hashtable of the specified size. </p><pre><code>func int HT_CreateSized(var int size)\n</code></pre> Parameters <ul> <li><code>var int size</code>     Size of the hashtable to be created</li> </ul> <p>Return value</p> <p>The function returns a handle to the created hashtable.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_create","title":"<code>HT_Create</code>","text":"<p>Generates a standard size hashtable. </p><pre><code>func int HT_Create()\n</code></pre> Return value <p>The function returns a handle to the created hashtable.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_insert","title":"<code>HT_Insert</code>","text":"<p>Inserts a value into the Hashtable. </p><pre><code>func void HT_Insert(var int handle, var int val, var int key)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var int val</code>     The value to be inserted</li> <li><code>var int key</code>     The key associated with the value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_resize","title":"<code>HT_Resize</code>","text":"<p>Changes the size of the hashtable (usually not necessary as it happens automatically). </p><pre><code>func void HT_Resize(var int handle, var int size)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var int size</code>     The new size of the hashtable</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_get","title":"<code>HT_Get</code>","text":"<p>Reads a value from the hashtable. </p><pre><code>func int HT_Get(var int handle, var int key)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var int key</code>     The key whose value is to be read</li> </ul> <p>Return value</p> <p>The function returns the value associated with the key.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_has","title":"<code>HT_Has</code>","text":"<p>Checks if the key already exist in hashtable. </p><pre><code>func int HT_Has(var int handle, var int key)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var int key</code>     The key to be checked  Return value</li> </ul> <p>The function returns <code>TRUE</code> if the key exist, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_remove","title":"<code>HT_Remove</code>","text":"<p>Removes a key from the hashtable. </p><pre><code>func void HT_Remove(var int handle, var int key)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var int key</code>     The key to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_change","title":"<code>HT_Change</code>","text":"<p>Changes the value of a key already existing in the hashtable. </p><pre><code>func void HT_Change(var int handle, var int val, var int key)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var int val</code>     The new value</li> <li><code>var int key</code>     The key whose value is to be changed</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_insertorchange","title":"<code>HT_InsertOrChange</code>","text":"<p>Inserts a value into the Hashtable, or changes the value if the key already exist into hashtable. </p><pre><code>func void HT_InsertOrChange(var int handle, var int val, var int key)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var int val</code>     The new value</li> <li><code>var int key</code>     The key whose value is to be changed or associated with the value.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_getnumber","title":"<code>HT_GetNumber</code>","text":"<p>Returns the number of entries in a hashtable. </p><pre><code>func int HT_GetNumber(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> </ul> <p>Return value</p> <p>The function returns the number of entries in the hashtable.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_foreach","title":"<code>HT_ForEach</code>","text":"<p>Performs a function for each value pair in the hashtable. </p><pre><code>func void HT_ForEach(var int handle, var func fnc)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     Handle of a hashtable</li> <li><code>var func fnc</code>     A function with signature void <code>(int key, int val)</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#ht_destroy","title":"<code>HT_Destroy</code>","text":"<p>Deletes the hashtable. </p><pre><code>func void HT_Destroy(var int handle)\n</code></pre> Parameters <ul> <li><code>var int handle</code>     The handle of the hashtable to be deleted</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/hashtables/#simple-operations","title":"Simple operations","text":"<pre><code>func void PrintKeyValuePair(var int key, var int val)\n{\nPrint(ConcatStrings(ConcatStrings(\"Key: \", IntToString(key)), ConcatStrings(\", Value: \", IntToString(val))));\n};\nfunc void exapmle()\n{\n// Create a new hashtable\nvar int hashtableHandle; hashtableHandle = HT_Create();\n// Insert values into the hashtable\nHT_Insert(hashtableHandle, 42, 1);\nHT_Insert(hashtableHandle, 23, 2);\nHT_Insert(hashtableHandle, 56, 3);\n// Get a value from the hashtable\nvar int value; value = HT_Get(hashtableHandle, 2);\nPrint(ConcatStrings(\"Value associated with key 2: \", IntToString(value)));\n// Check if a key exists in the hashtable\nif (HT_Has(hashtableHandle, 3))\n{\nPrint(\"Key 3 exists in the hashtable.\");\n}\nelse\n{\nPrint(\"Key 3 does not exist in the hashtable.\");\n};\n// Remove a key from the hashtable\nHT_Remove(hashtableHandle, 1);\n// Change the value associated with a key\nHT_Change(hashtableHandle, 99, 3);\n// Insert a value or change it if the key exists\nHT_InsertOrChange(hashtableHandle, 123, 4);\n// Get the number of entries in the hashtable\nvar int numEntries; numEntries = HT_GetNumber(hashtableHandle);\nPrint(ConcatStrings(\"Number of entries in the hashtable: \", IntToString(numEntries)));\n// Iterate through the hashtable and print key-value pairs\n// Function from top of the example is used here\nHT_ForEach(hashtableHandle, PrintKeyValuePair);\n// Destroy the hashtable\nHT_Destroy(hashtableHandle);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/","title":"HookDaedalus","text":""},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#hookdaedalus","title":"HookDaedalus","text":"<p>This package allows hooking daedalus functions. The principle is similar HookEngine. We have a function (hooked function) into which we would like to hook another function (hook function).</p> <p>Tip</p> <p>Having to hook a Daedalus function should be pretty rare, because you can simply adjust the corresponding function. However, it may become necessary in some contexts.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#implementation","title":"Implementation","text":"<p> HookDaedalus.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#hookdaedalusfunc","title":"<code>HookDaedalusFunc</code>","text":"<p>Hooks the function. </p><pre><code>func void HookDaedalusFunc(var func hooked, var func hook)\n</code></pre> Parameters <ul> <li><code>var func hooked</code>     Hooked function</li> <li><code>var func hook</code>     Hook function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#hookdaedalusfuncf","title":"<code>HookDaedalusFuncF</code>","text":"<p>Alias to the <code>HookDaedalusFunc</code> function. </p><pre><code>func void HookDaedalusFuncF(var func hooked, var func hook)\n</code></pre> Parameters <ul> <li><code>var func hooked</code>     Hooked function</li> <li><code>var func hook</code>     Hook function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#hookdaedalusfunci","title":"<code>HookDaedalusFuncI</code>","text":"<p><code>HookDaedalusFunc</code> but with function ID. </p><pre><code>func void HookDaedalusFuncI(var int hookedID, var int hookID)\n</code></pre> Parameters <ul> <li><code>var int hookedID</code>     ID of hooked function</li> <li><code>var int hookID</code>     ID of hook function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#hookdaedalusfuncs","title":"<code>HookDaedalusFuncS</code>","text":"<p><code>HookDaedalusFunc</code> but with function name. </p><pre><code>func void HookDaedalusFuncS(var string hookedName, var string hookName)\n</code></pre> Parameters <ul> <li><code>var string hookedName</code>     Name of hooked function</li> <li><code>var string hookName</code>     Name of hook function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#ishookd","title":"<code>IsHookD</code>","text":"<p>Checks whether a function is already hooking another. Each function can be hooked any number of times, but each function can only hook one other. </p><pre><code>func int IsHookD(var int funcID)\n</code></pre> Parameters <ul> <li><code>var int funcID</code>     Symbol index of a hook function</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the function is already hooking another, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#continuecall","title":"<code>ContinueCall</code>","text":"<p>Continues the program run with the original function. </p><pre><code>func void ContinueCall()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#passargumenti","title":"<code>PassArgumentI</code>","text":"<p>Passes an integer as an argument to the original function. Must be called before <code>ContinueCall</code>. </p><pre><code>func void PassArgumentI(var int i)\n</code></pre> Parameters <ul> <li><code>var int i</code>      Integer argument to forward</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#passarguments","title":"<code>PassArgumentS</code>","text":"<p>Passes a string as an argument to the original function. Must be called before <code>ContinueCall</code>. </p><pre><code>func void PassArgumentS(var string s)\n</code></pre> Parameters <ul> <li><code>var string s</code>      String argument to forward</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#passargumentn","title":"<code>PassArgumentN</code>","text":"<p>Passes an instance as an argument to the original function. Must be called before <code>ContinueCall</code>. </p><pre><code>func void PassArgumentN(var instance n)\n</code></pre> Parameters <ul> <li><code>var instance n</code>      Instance argument to forward</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#hook-before-function","title":"Hook before function","text":"<p>We have a hook: </p><pre><code>HookDaedalusFunc(hooked, hook);\n</code></pre> The functions can look like that: <pre><code>func void hooked() {\nPrint(\"Orginal function\");\n};\nfunc void hook() {\nPrint(\"Our hook\");\nContinueCall();\n};\n</code></pre> The results should look like that <pre><code>Our hook\nOrginal function\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#hook-after-function","title":"Hook after function","text":"<p>We have the same hook: </p><pre><code>HookDaedalusFunc(hooked, hook);\n</code></pre> The functions are also similar, but the <code>ContinueCall();</code> is called first: <pre><code>func void hooked() {\nPrint(\"Orginal function\");\n};\nfunc void hook() {\nContinueCall();\nPrint(\"Our hook\");\n};\n</code></pre> The results should look like that: <pre><code>Orginal function\nOur hook\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#arguments-and-return-values","title":"Arguments and return values","text":"<p>If a function to be hooked expects parameters or returns a value, our hooking function should conform to that. </p><pre><code>func int hooked(var int i) {\nPrint(\"Orginal function\");\nreturn i+1;\n};\nfunc int hook(var int i) {\nPrint(\"Our hook\");\nPassArgumentI(i);\nContinueCall();\n};\n</code></pre> In this case, we may not return the value at the end of the hook because the returned value will just stay on the stack. However, we shouldn't give up on calling <code>PassArgumentI(i)</code> to ensure that it is still on top of the stack when the program continues with hooked."},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#manipulation-of-arguments-and-return-values","title":"Manipulation of arguments and return values","text":"<p>We can also manipulate arguments and return values with our hook. </p><pre><code>func int hook(var int i) {\nPrint(\"Our hook\");\nPassArgumentI(i+1);     // add 1\nContinueCall();\ni = MEM_PopIntResult();\ni *= 2;                 // Multiply by 2\nreturn i;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_dae/#multiple-hooks","title":"Multiple hooks","text":"<p>A function can be hooked any number of times, but each function can only hook one. New hooks are always inserted after the previous one. The following example illustrates this quite well. </p><pre><code>HookDaedalusFunc(a, b); // B hooks A\nHookDaedalusFunc(a, c); // C hooks A to B\nHookDaedalusFunc(a, d); // D hooks A to C\nHookDaedalusFunc(c, b); // Ignored because B is already hooking a function\nvar int i; i = a(1);\n// Hooked function\nfunc int a(var int i) {\nMEM_Info(ConcatStrings(\"---  A: \", IntToString(i)));\nreturn i+1;\n};\n// First hook function:\n// Replaces `a` because the program run is not continued with ContinueCall\nfunc int b(var int i) {\nMEM_Info(ConcatStrings(\"  -- B: \", IntToString(i)));\nreturn i;\n};\n// Second hook function:\n// Increments the argument before ContinueCall and then decrements the return value\nfunc int c(var int i) {\nMEM_Info(ConcatStrings(\" -&gt; C: \", IntToString(i)));\npassArgumentI(i+1);\nContinueCall();\ni = MEM_PopIntResult();\ni -= 1;\nMEM_Info(ConcatStrings(\" &lt;- C: \", IntToString(i)));\nreturn i;\n};\n// Third hook function:\n// Increments the argument before ContinueCall and then decrements the return value\nfunc int d(var int i) {\nMEM_Info(ConcatStrings(\"-&gt; D: \", IntToString(i)));\npassArgumentI(i+1);\nContinueCall();\ni = MEM_PopIntResult();\ni -= 1;\nMEM_Info(ConcatStrings(\"&lt;- D: \", IntToString(i)));\nreturn i;\n};\n// Output:\n// -&gt; D: 1\n//  -&gt; C: 2\n//   -- B: 3\n//  &lt;- C: 2\n// &lt;- D: 1\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/","title":"HookEngine","text":""},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#hookengine","title":"HookEngine","text":"<p>This package allows you to hook anywhere in an engine function to run your own Daedalus code.</p> <p>Tip</p> <p>Zerxes has provided a list of all engine functions for G2, including the number of bytes to fill in for <code>oldInstr</code>. This list can be found here. This should make it possible for everyone to use the HookEngine effectively without IDA. </p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#implementation","title":"Implementation","text":"<p> HookEngine.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#hookengine_1","title":"<code>HookEngine</code>","text":"<p>Attaches a function to an engine function address. </p><pre><code>func void HookEngine(var int address, var int oldInstr, var string function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function to which the function should be attached.</li> <li><code>var int oldInstr</code>     The length in bytes of the instruction to be found at <code>address</code>, at least 5 bytes. Can be seen in IDA.</li> <li><code>var string function</code>     Name of Daedalus function to be called.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#hookengines","title":"<code>HookEngineS</code>","text":"<p>Alias to the <code>HookEngine</code> function. </p><pre><code>func void HookEngineS(var int address, var int oldInstr, var string function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function to which the function should be attached.</li> <li><code>var int oldInstr</code>     The length in bytes of the instruction to be found at <code>address</code>, at least 5 bytes. Can be seen in IDA.</li> <li><code>var string function</code>     Name of Daedalus function to be called.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#hookenginei","title":"<code>HookEngineI</code>","text":"<p>Alias to <code>HookEngine</code> with funcID. </p><pre><code>func void HookEngineI(var int address, var int oldInstr, var int funcID)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function to which the function should be attached.</li> <li><code>var int oldInstr</code>     The length in bytes of the instruction to be found at <code>address</code>, at least 5 bytes. Can be seen in IDA.</li> <li><code>var int funcID</code>     ID of Daedalus function to be called.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#hookenginef","title":"<code>HookEngineF</code>","text":"<p>Alias to <code>HookEngine</code> with <code>func</code> parameter. </p><pre><code>func void HookEngineF(var int address, var int oldInstr, var func function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function to which the function should be attached.</li> <li><code>var int oldInstr</code>     The length in bytes of the instruction to be found at <code>address</code>, at least 5 bytes. Can be seen in IDA.</li> <li><code>var func function</code>     Daedalus function to be called.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#ishooked","title":"<code>IsHooked</code>","text":"<p>Checks if a hook is already present at a given address. </p><pre><code>func var int IsHooked(var int address)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function.</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the hook already exists at the address, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#ishook","title":"<code>IsHook</code>","text":"<p>Checks if a hook with a certain function is already present at an address. </p><pre><code>func var int IsHook(var int address, var string function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function.</li> <li><code>var string function</code>     Name of a function.</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the hook already exists at the address, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#ishooki","title":"<code>IsHookI</code>","text":"<p>Alias to <code>IsHook</code> with a funcID as parameter. </p><pre><code>func var int IsHookI(var int address, var int funcID)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function.</li> <li><code>var int funcID</code>     ID of a function.</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the hook already exists at the address, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#ishookf","title":"<code>IsHookF</code>","text":"<p>Alias to <code>IsHook</code> with a function as parameter. </p><pre><code>func var int IsHookF(var int address, var func function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function.</li> <li><code>var func function</code>     Daedalus function.</li> </ul> <p>Return value <code>func</code> parameter The function returns <code>TRUE</code> if the hook already exists at the address, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#removehook","title":"<code>RemoveHook</code>","text":"<p>Removes a function from a hook so that it is no longer called. </p><pre><code>func void RemoveHook(var int address, var int oldInstr, var string function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function to which the function should be attached.</li> <li><code>var int oldInstr</code>     The length in bytes of the instruction to be found at <code>address</code>, at least 5 bytes. Can be seen in IDA.</li> <li><code>var string function</code>     Name of Daedalus function that should no longer be called.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#removehooki","title":"<code>RemoveHookI</code>","text":"<p>Alias to <code>RemoveHook</code> with funcID. </p><pre><code>func void RemoveHook(var int address, var int oldInstr, var int funcID)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function to which the function should be attached.</li> <li><code>var int oldInstr</code>     The length in bytes of the instruction to be found at <code>address</code>, at least 5 bytes. Can be seen in IDA.</li> <li><code>var int funcID</code>     ID of Daedalus function that should no longer be called.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#removehookf","title":"<code>RemoveHookF</code>","text":"<p>Alias for <code>RemoveHook</code> with <code>func</code> parameter. </p><pre><code>func void RemoveHook(var int address, var int oldInstr, var func function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of an engine function to which the function should be attached.</li> <li><code>var int oldInstr</code>     The length in bytes of the instruction to be found at <code>address</code>, at least 5 bytes. Can be seen in IDA.</li> <li><code>var func function</code>     Daedalus function that should no longer be called.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#replaceenginefunc","title":"<code>ReplaceEngineFunc</code>","text":"<p>Replaces an engine function with a Daedalus function. </p><pre><code>func void ReplaceEngineFunc(var int address, var int thiscall_numparams, var string replaceFunc)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of the engine function to be replaced.</li> <li><code>var int thiscall_numparams</code>     Number of parameters passed to the engine function, if it is a stdcall or thiscall (otherwise 0).</li> <li><code>var string replaceFunc</code>     Name of a Daedalus function to be called instead.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#replaceenginefunci","title":"<code>ReplaceEngineFuncI</code>","text":"<p>Alias to <code>ReplaceEngineFunc</code> with funcID. </p><pre><code>func void ReplaceEngineFunc(var int address, var int thiscall_numparams, var int funcID)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of the engine function to be replaced.</li> <li><code>var int thiscall_numparams</code>     Number of parameters passed to the engine function, if it is a stdcall or thiscall (otherwise 0).</li> <li><code>var int funcID</code>     ID of a Daedalus function to be called instead.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#replaceenginefuncf","title":"<code>ReplaceEngineFuncF</code>","text":"<p>Alias to <code>ReplaceEngineFunc</code> with func parameter. </p><pre><code>func void ReplaceEngineFunc(var int address, var int thiscall_numparams, var func function)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of the engine function to be replaced.</li> <li><code>var int thiscall_numparams</code>     Number of parameters passed to the engine function, if it is a stdcall or thiscall (otherwise 0).</li> <li><code>var func function</code>     Daedalus function to be called instead.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#disableenginefunc","title":"<code>DisableEngineFunc</code>","text":"<p>Makes sure that an engine function is simply skipped. This is very delicate and will not always work so easily. </p><pre><code>func void DisableEngineFunc(var int address, var int thiscall_numparams)\n</code></pre> Parameters <ul> <li><code>var int address</code>     Address of the engine function to be skipped.</li> <li><code>var int thiscall_numparams</code>     Number of parameters passed to the engine function, if it is a stdcall or thiscall (otherwise 0).</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#hook_returnfalse","title":"<code>Hook_ReturnFalse</code>","text":"<p>Simple function to replace <code>return FALSE</code> in hook. </p><pre><code>func void Hook_ReturnFalse()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#hook_returntrue","title":"<code>Hook_ReturnTrue</code>","text":"<p>Simple function to replace <code>return TRUE</code> in hook. </p><pre><code>func void Hook_ReturnTrue()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/hook_engine/#registers","title":"Registers","text":"<p>In addition the HookEngine package implement x86 32-bit registers that can be used to access hooked function parameters.</p> <pre><code>var int EAX;\nvar int ECX;\nvar int EDX;\nvar int EBX;\nvar int ESP;\nvar int EBP;\nvar int ESI;\nvar int EDI;    </code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/int64/","title":"Int64","text":""},{"location":"zengin/scripts/extenders/lego/tools/int64/#int64","title":"Int64","text":"<p>Int64 implements basic arithmetic for 64-bit integers based on machine code (hence the function signatures are also in machine code style). Furthermore, Int64 offers the constructor <code>int64@</code> for Int64 objects, but mk64 expects a pointer, not a handle.</p>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#implementation","title":"Implementation","text":"<p> Int64.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/int64/#mk64","title":"<code>mk64</code>","text":"<p>Writes <code>lo</code> and <code>hi</code> in one place (dest). Makes Int64, <code>hi</code> has to be <code>-1</code> for negative 32bit <code>lo</code>. </p><pre><code>func void mk64(var int dest, var int hi, var int lo)\n</code></pre> Parameters <ul> <li><code>var int dest</code>     A pointer to an Int64 object or just 8 bytes of free memory.</li> <li><code>var int hi</code>     High part of integer.</li> <li><code>var int lo</code>     Low part of integer.</li> </ul> Examples <p>Function looks like that: </p><pre><code>    func void mk64(var int dest, var int lo, var int hi) {\nMEM_WriteInt(dest, lo);\nMEM_WriteInt(dest+4, hi);\n};\n</code></pre> So if you want to get <code>9876543210</code> low part should be set to <code>1286608618</code> and the high part to <code>2</code> <pre><code>var int ptr; ptr = MEM_Alloc(8);\nvar int low; low = 1286608618;\nvar int high; high = 2;\nmk64(ptr, low, high);\n// ...\nMEM_Free(ptr);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#neg64","title":"<code>neg64</code>","text":"<p>Negates the integer: <code>*dest &lt;- -(*dest)</code> </p><pre><code>func void neg64(var int dest)\n</code></pre> Parameters <ul> <li><code>var int dest</code>     A pointer to an Int64 object or just 8 bytes of free memory.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#add64","title":"<code>add64</code>","text":"<p>Adds <code>src</code> to <code>dest</code>: <code>*dest &lt;- *dest + *src</code> </p><pre><code>func void add64(var int dest, var int src)\n</code></pre> Parameters <ul> <li><code>var int dest</code>     A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>var int src</code>     A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#sub64","title":"<code>sub64</code>","text":"<p>Subtracts <code>src</code> from <code>dest</code>: <code>*dest &lt;- *dest - *src</code> </p><pre><code>func void sub64(var int dest, var int src)\n</code></pre> Parameters <ul> <li><code>var int dest</code>     A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>var int src</code>     A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#mul64","title":"<code>mul64</code>","text":"<p>Multiplies <code>dest</code> by <code>src</code>: <code>*dest &lt;- (*dest) * (*src)</code> </p><pre><code>func void mul64(var int dest, var int src)\n</code></pre> Parameters <ul> <li><code>var int dest</code>     A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>var int src</code>     A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/int64/#div64","title":"<code>div64</code>","text":"<p>Divides <code>dest</code> by <code>src</code>: <code>*dest &lt;- *dest / *src</code> </p><pre><code>func void mul64(var int dest, var int src)\n</code></pre> Parameters <ul> <li><code>var int dest</code>     A pointer to an Int64 object or just 8 bytes of free memory. Will be changed.</li> <li><code>var int src</code>     A pointer to an Int64 object. Will not change.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/","title":"Interface","text":""},{"location":"zengin/scripts/extenders/lego/tools/interface/#interface","title":"Interface","text":"<p>This package offers a lot of useful functions to work with the 2D interface.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#dependencies","title":"Dependencies","text":"<ul> <li>AI_Function</li> <li>Anim8</li> <li>HookEngine</li> <li>PermMem</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Interface</code> and <code>LeGo_PrintS</code> flag. </p><pre><code>LeGo_Init(LeGo_Interface | LeGo_PrintS);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#implementation","title":"Implementation","text":"<p> Interface.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/interface/#sysgettime","title":"<code>sysGetTime</code>","text":"<p>Better alternative for <code>MEM_GetSysTime()</code> from Ikarus. </p><pre><code>func int sysGetTime()\n</code></pre> Return value <p>The function returns elapsed time since game (system) startup.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#rgba","title":"<code>RGBA</code>","text":"<p>Generates a full <code>zColor</code>. </p><pre><code>func int RGBA(var int r, var int g, var int b, var int a)\n</code></pre> Parameters <ul> <li><code>var int r</code>     Red channel value (0..255)</li> <li><code>var int g</code>     Green channel value (0..255)</li> <li><code>var int b</code>     Blue channel value (0..255)</li> <li><code>var int a</code>     Alpha (0..255, 0 = invisible)</li> </ul> <p>Return value</p> <p>The function returns a <code>zColor</code> object.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#changealpha","title":"<code>ChangeAlpha</code>","text":"<p>Overrides the alpha value of a given <code>zColor</code>. </p><pre><code>func int ChangeAlpha(var int zCol, var int a)\n</code></pre> Parameters <ul> <li><code>var int zCol</code> <code>zColor</code> to modify</li> <li><code>var int a</code>     New alpha value</li> </ul> <p>Return value</p> <p>The function returns a modified <code>zColor</code> object.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#getalpha","title":"<code>GetAlpha</code>","text":"<p>Returns the alpha value of a given <code>zColor</code>. </p><pre><code>func int GetAlpha(var int zCol)\n</code></pre> Parameters <ul> <li><code>var int zCol</code> <code>zColor</code> to get alpha from</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_createtext","title":"<code>Print_CreateText</code>","text":"<p>Creates a new <code>zCViewText</code> on the screen with PermMem that can be freely edited. </p><pre><code>func int Print_CreateText(var string text, var string font)\n</code></pre> Parameters <ul> <li><code>var string text</code>     The text of the <code>zCViewText</code></li> <li><code>var string font</code>     Font of text</li> </ul> <p>Return value</p> <p>The function returns a handle to <code>zCViewText</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_createtextptr","title":"<code>Print_CreateTextPtr</code>","text":"<p><code>Print_CreateText</code> but returns pointer to <code>zCViewText</code> instead of handle. </p><pre><code>func int Print_CreateTextPtr(var string text, var string font)\n</code></pre> Parameters <ul> <li><code>var string text</code>     The text of the <code>zCViewText</code></li> <li><code>var string font</code>     Font of text</li> </ul> <p>Return value</p> <p>The function returns a pointer to <code>zCViewText</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_createtextptrcolored","title":"<code>Print_CreateTextPtrColored</code>","text":"<p><code>Print_CreateTextPtr</code> but with additional parameter to chose color of text. </p><pre><code>func int Print_CreateTextPtrColored(var string text, var string font, var int color)\n</code></pre> Parameters <ul> <li><code>var string text</code>     The text of the <code>zCViewText</code></li> <li><code>var string font</code>     Font of text</li> <li><code>var int color</code> <code>zColor</code> e.g. generated with RGBA function</li> </ul> <p>Return value</p> <p>The function returns a pointer to <code>zCViewText</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_gettext","title":"<code>Print_GetText</code>","text":"<p>Returns <code>zCViewText</code> instance from handle. </p><pre><code>func zCViewText Print_GetText(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle to <code>zCViewText</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_gettextptr","title":"<code>Print_GetTextPtr</code>","text":"<p>Returns <code>zCViewText</code> pointer from handle. </p><pre><code>func int Print_GetTextPtr(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle to <code>zCViewText</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_deletetext","title":"<code>Print_DeleteText</code>","text":"<p>Removes a <code>zCViewText</code> from the screen. </p><pre><code>func void Print_DeleteText(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle to <code>zCViewText</code> (form <code>Print_CreateText</code> or <code>Print_Ext</code>)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_setalpha","title":"<code>Print_SetAlpha</code>","text":"<p>Changes the alpha value of a given <code>zCViewText</code>. </p><pre><code>func void Print_SetAlpha(var int hndl, var int a)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Handle to <code>zCViewText</code></li> <li><code>var int a</code>     New alpha value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#printptr_setalpha","title":"<code>PrintPtr_SetAlpha</code>","text":"<p><code>Print_SetAlpha</code> but with pointer to <code>zCViewText</code> instead of handle. </p><pre><code>func void PrintPtr_SetAlpha(var int ptr, var int a)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>     Pointer to <code>zCViewText</code></li> <li><code>var int a</code>     New alpha value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_getscreensize","title":"<code>Print_GetScreenSize</code>","text":"<p>Writes the current resolution to the Print_Screen array and the current aspect ratio to Print_Ratio variable. </p><pre><code>func void Print_GetScreenSize()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_screen","title":"<code>Print_Screen</code>","text":"<p>An int array holding the current resolution. (Filled by <code>Print_GetScreenSize</code>) </p><pre><code>int Print_Screen[2];\n</code></pre> <ul> <li> <p><code>Print_Screen[PS_X]</code> is the horizontal resolution</p> </li> <li> <p><code>Print_Screen[PS_Y]</code> is the vertical resolution</p> </li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_ratio","title":"<code>Print_Ratio</code>","text":"<p>A float variable that holds the current aspect ratio. (Filled by <code>Print_GetScreenSize</code>) </p><pre><code>int Print_Ratio;\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#ps_vmax","title":"<code>PS_VMax</code>","text":"<p>An int constant that holds the highest possible value of a virtual coordinate. </p><pre><code>const int PS_VMax = 8192;\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_tovirtual","title":"<code>Print_ToVirtual</code>","text":"<p>Convents pixel position to a virtual position. </p><pre><code>func int Print_ToVirtual(var int pxl, var int dim)\n</code></pre> Parameters <ul> <li><code>var int pxl</code>     Pixel position to convert</li> <li><code>var int dim</code>     PS_X or PS_Y (see <code>Print_Screen</code>)</li> </ul> <p>Return value</p> <p>The function returns a virtual position of a given pixel position.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_tovirtualf","title":"<code>Print_ToVirtualF</code>","text":"<p><code>Print_ToVirtual</code> but returns Ikarus float value instead of integer. </p><pre><code>func int Print_ToVirtualF(var int pxl, var int dim)\n</code></pre> Parameters <ul> <li><code>var int pxl</code>     Pixel position to convert</li> <li><code>var int dim</code>     PS_X or PS_Y (see <code>Print_Screen</code>)</li> </ul> <p>Return value</p> <p>The function returns a virtual position of a given pixel position as Ikarus float.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_topixel","title":"<code>Print_ToPixel</code>","text":"<p>Convents virtual position to a pixel position. </p><pre><code>func int Print_ToPixel(var int vrt, var int dim)\n</code></pre> Parameters <ul> <li><code>var int vrt</code>     Virtual position to convert</li> <li><code>var int dim</code>     PS_X or PS_Y (see <code>Print_Screen</code>)</li> </ul> <p>Return value</p> <p>The function returns a pixel position of a given virtual position.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_topixelf","title":"<code>Print_ToPixelF</code>","text":"<p><code>Print_ToPixel</code> but returns Ikarus float value instead of integer. </p><pre><code>func int Print_ToPixelF(var int vrt, var int dim)\n</code></pre> Parameters <ul> <li><code>var int vrt</code>     Virtual position to convert</li> <li><code>var int dim</code>     PS_X or PS_Y (see <code>Print_Screen</code>)</li> </ul> <p>Return value</p> <p>The function returns a pixel position of a given virtual position as Ikarus float.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_toratio","title":"<code>Print_ToRatio</code>","text":"<p>Gets the size in the specified dimension in ratioed by the screen. </p><pre><code>func int Print_ToRatio(var int size, var int dim)\n</code></pre> Parameters <ul> <li><code>var int size</code>     Size to convert</li> <li><code>var int dim</code>     PS_X or PS_Y (see <code>Print_Screen</code>)</li> </ul> <p>Return value</p> <p>The function returns size correctly calculated to the ratio.</p> Example <p>If you have a view and the view you need to be a square of 400 units, you would do: </p><pre><code>height = Print_ToRatio(400, PS_Y);\nwidth = 400;\n</code></pre> This is because width is always the max in virtual coordinates - 8192 virtual points and the height has a different height based on the ratio, this function calculates it for you. <p><code>PS_X</code> can be used in function, if you already have the height but need the width in the correct ratio.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_toradian","title":"<code>Print_ToRadian</code>","text":"<p>Converts angle in degrees to radians. </p><pre><code>func int Print_ToRadian(var int angle)\n</code></pre> Parameters <ul> <li><code>var int angle</code>     Angle in degrees</li> </ul> <p>Return value</p> <p>The function returns calculated angle in radians.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_todegree","title":"<code>Print_ToDegree</code>","text":"<p>Converts angle in radians to degrees. </p><pre><code>func int Print_ToDegree(var int angle)\n</code></pre> Parameters <ul> <li><code>var int angle</code>     Angle in radians</li> </ul> <p>Return value</p> <p>The function returns calculated angle in degrees.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_getfontptr","title":"<code>Print_GetFontPtr</code>","text":"<p>Returns a pointer to a <code>zCFont</code> by its name. </p><pre><code>func int Print_GetFontPtr(var string font)\n</code></pre> Parameters <ul> <li><code>var string font</code>     Name of font</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_getfontname","title":"<code>Print_GetFontName</code>","text":"<p>Returns a name of a <code>zCFont</code> from its pointer. </p><pre><code>func string Print_GetFontName(var int fontPtr)\n</code></pre> Parameters <ul> <li><code>var int fontPtr</code>     Pointer to font</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_getstringwidth","title":"<code>Print_GetStringWidth</code>","text":"<p>Returns the width of a string in pixels. </p><pre><code>func int Print_GetStringWidth(var string s, var string font)\n</code></pre> Parameters <ul> <li><code>var string s</code>     Measured string</li> <li><code>var string font</code>     Name of font</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_getstringwidthptr","title":"<code>Print_GetStringWidthPtr</code>","text":"<p><code>Print_GetStringWidth</code> but with <code>zCFont</code> pointer instead of name. </p><pre><code>func int Print_GetStringWidthPtr(var string s, var int font)\n</code></pre> Parameters <ul> <li><code>var string s</code>     Measured string</li> <li><code>var int font</code> <code>zCFont</code> pointer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_getfontheight","title":"<code>Print_GetFontHeight</code>","text":"<p>Returns the height of a string in pixels. </p><pre><code>func int Print_GetFontHeight(var string font)\n</code></pre> Parameters <ul> <li><code>var string font</code>     Name of font</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_ext","title":"<code>Print_Ext</code>","text":"<p>Like the external <code>PrintScreen</code>, writes a text on the screen, but with more options. </p><pre><code>func int Print_Ext(var int x, var int y, var string text, var string font, var int color, var int time)\n</code></pre> Parameters <ul> <li><code>var int x</code>     X coordinate on the screen (virtual)</li> <li><code>var int y</code>     Y coordinate on the screen (virtual)</li> <li><code>var string text</code>     Displayed text</li> <li><code>var string font</code>     Name of font</li> <li><code>var int color</code> <code>zColor</code> e.g. generated with RGBA function</li> <li><code>var int time</code>     display time in milliseconds (-1 = permanent)</li> </ul> <p>Return value</p> <p>If <code>time == -1</code>, a valid handle is returned. If <code>time != -1</code>, the print is only volatile and no handle is returned.</p> Example <pre><code>func void Example1()\n{\n//           x, y, text,   font,        color,                time\nPrint_ExtPxl(2, 2, \"Text\", FONT_Screen, RGBA(255, 0, 0, 128), 500);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_extpxl","title":"<code>Print_ExtPxl</code>","text":"<p><code>Print_Ext</code> but with pixel coordinates instead of virtual. </p><pre><code>func int Print_ExtPxl(var int x, var int y, var string text, var string font, var int color, var int time)\n</code></pre> Parameters <ul> <li><code>var int x</code>     X coordinate on the screen (pixel)</li> <li><code>var int y</code>     Y coordinate on the screen (pixel)</li> <li><code>var string text</code>     Displayed text</li> <li><code>var string font</code>     Name of font</li> <li><code>var int color</code> <code>zColor</code> e.g. generated with RGBA function</li> <li><code>var int time</code>     display time in milliseconds (-1 = permanent)</li> </ul> <p>Return value</p> <p>If <code>time == -1</code>, a valid handle is returned. If <code>time != -1</code>, the print is only volatile and no handle is returned.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_longestline","title":"<code>Print_LongestLine</code>","text":"<p>Returns the longest line from <code>text</code> as a string, using default line separator tilde <code>~</code>. </p><pre><code>func string Print_LongestLine(var string text, var string font)\n</code></pre> Parameters <ul> <li><code>var string text</code>     Measured text</li> <li><code>var string font</code>     Name of font</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_longestlineext","title":"<code>Print_LongestLineExt</code>","text":"<p>Returns the longest line from <code>text</code> as a string, but you specify new line separator. </p><pre><code>func string Print_LongestLineExt(var string text, var string font, var string separator)\n</code></pre> Parameters <ul> <li><code>var string text</code>     Measured text</li> <li><code>var string font</code>     Name of font</li> <li><code>var string separator</code>     New line separator</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_longestlinelength","title":"<code>Print_LongestLineLength</code>","text":"<p>Returns the longest line width in pixels, using default line separator tilde <code>~</code>. </p><pre><code>func int Print_LongestLineLength(var string text, var string font)\n</code></pre> Parameters <ul> <li><code>var string text</code>     Measured text</li> <li><code>var string font</code>     Name of font</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_longestlinelengthext","title":"<code>Print_LongestLineLengthExt</code>","text":"<p>Returns the longest line width in pixels, but allows you to specify new line separator. </p><pre><code>func int Print_LongestLineLengthExt(var string text, var string font, var string separator)\n</code></pre> Parameters <ul> <li><code>var string text</code>     Measured text</li> <li><code>var string font</code>     Name of font</li> <li><code>var string separator</code>     New line separator</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_textfield","title":"<code>Print_TextField</code>","text":"<p>Creates a text field (view with text) using virtual coordinates. </p><pre><code>func int Print_TextField(var int x, var int y, var string text, var string font, var int height)\n</code></pre> Parameters <ul> <li><code>var int x</code>     X coordinate (virtual)</li> <li><code>var int y</code>     Y coordinate (virtual)</li> <li><code>var string text</code>     Text to be printed</li> <li><code>var string font</code>     Name of font</li> <li><code>var int height</code>     A specific line <code>height</code></li> </ul> <p>Return value</p> <p>The function returns a text field pointer. Here is how it is used: </p><pre><code>var zCView view; view = get(viewHndl);\nview.textLines_next = Print_TextField(x, y, text, FONT, fontHeight);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_textfieldpxl","title":"<code>Print_TextFieldPxl</code>","text":"<p><code>Print_TextField</code> but with pixel coordinates. </p><pre><code>func int Print_TextFieldPxl(var int x, var int y, var string text, var string font)\n</code></pre> Parameters <ul> <li><code>var int x</code>     X coordinate (pixel)</li> <li><code>var int y</code>     Y coordinate (pixel)</li> <li><code>var string text</code>     Text to be printed</li> <li><code>var string font</code>     Name of font</li> </ul> <p>Return value</p> <p>The function returns a text field pointer. Look at the <code>Print_TextField</code> return value to see an example.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#print_textfieldcolored","title":"<code>Print_TextFieldColored</code>","text":"<p><code>Print_TextField</code> but you specify the color of text. </p><pre><code>func int Print_TextFieldColored(var int x, var int y, var string text, var string font, var int height, var int color)\n</code></pre> Parameters <ul> <li><code>var int x</code>     X coordinate (virtual)</li> <li><code>var int y</code>     Y coordinate (virtual)</li> <li><code>var string text</code>     Text to be printed</li> <li><code>var string font</code>     Name of font</li> <li><code>var int height</code>     A specific line <code>height</code></li> <li><code>var int color</code> <code>zColor</code> e.g. generated with RGBA function</li> </ul> <p>Return value</p> <p>The function returns a text field pointer. Look at the <code>Print_TextField</code> return value to see an example.</p>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#prints","title":"<code>PrintS</code>","text":"<p>Same function as the external <code>Print</code>, but with smooth animations. The effect can be changed as desired with the user constants. </p><pre><code>func void PrintS(var string txt)\n</code></pre> Parameters <ul> <li><code>var string txt</code>     Printed text</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#prints_ext","title":"<code>PrintS_Ext</code>","text":"<p><code>PrintS</code> but with an additional parameter to choose the color of the text. </p><pre><code>func void PrintS_Ext(var string txt, var int color)\n</code></pre> Parameters <ul> <li><code>var string txt</code>     Printed text</li> <li><code>var int color</code> <code>zColor</code> e.g. generated with RGBA function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#ai_prints","title":"<code>AI_PrintS</code>","text":"<p>Version of <code>PrintS</code> that enqueue in given NPCs AI queue. </p><pre><code>func void AI_PrintS(var c_npc slf, var string txt)\n</code></pre> Parameters <ul> <li><code>var c_npc slf</code>     NPC to whose AI queue the function is enqueued</li> <li><code>var string txt</code>     Printed text</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#ai_prints_ext","title":"<code>AI_PrintS_Ext</code>","text":"<p>Version of <code>PrintS_Ext</code> that enqueue in given NPCs AI queue. </p><pre><code>func void AI_PrintS_Ext(var c_npc slf, var string txt, var int color)\n</code></pre> Parameters <ul> <li><code>var c_npc slf</code>     NPC to whose AI queue the function is enqueued</li> <li><code>var string txt</code>     Printed text</li> <li><code>var int color</code> <code>zColor</code> e.g. generated with RGBA function</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/interface/#manage-a-print-via-zcviewtext","title":"Manage a print via zCViewText","text":"<p>It is also possible to create the text only via Print_CreateText and set it yourself. In this example, a text should fly over the image from left to right and be deleted again. The movement is handled by Anim8: </p><pre><code>var int MyText;\nvar int MyAnim8;\nfunc void PrintMyScrollingText(var string text) {\nMyText = Print_CreateText(text, FONT_Screen); // We create an empty text item with the font FONT_Screen\nvar zCViewText MyTextObject; MyTextObject = Print_GetText(MyText); // Now we get the empty text item in a zCViewText\nMyTextObject.posx = 1;      // adjust position\nMyTextObject.posy = 1;      // ATTENTION: These values are virtual, i.e.: 0 = far left, 8192 = far right (i.e. no pixel specification)\n// (But if I prefer to have pixel coordinates I could use e.g. Print_ToVirtual)\nMyTextObject.timed = false; // The text should not be timed (not disappear)\n// Anim8 will animate a text\n// First we need a new Anim8 object:\nMyAnim8 = Anim8_New(1, false); // Start position is 1 and this value is not a float\nAnim8(MyAnim8, 8192, 2000, A8_Constant); // Target Position is 8192, Duration is 2000 milliseconds, and Movement Form is Constant\n// Now all we need is a loop that matches the x value of the text to the value of Anim8:\nFF_Apply(ScrollMyText);\n};\nfunc void ScrollMyText() {\nvar zCViewText MyTextObject; MyTextObject = Print_GetText(MyText); // Get the text as an object again\n// And now compare the values:\nMyTextObject.posx = Anim8_Get(MyAnim8);\n// When Anim8 is done with that, we end the loop and delete the text:\nif(Anim8_Empty(MyAnim8)) {\nPrint_DeleteText(MyText);\nFF_Remove(ScrollMyText);\n// The Anim8 object must of course also be deleted. We don't need it anymore.\nAnim8_Delete(MyAnim8);\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/interface/#manage-a-print-via-zcviewtext-with-lego-22","title":"Manage a print via zCViewText with LeGo 2.2+","text":"<p>In those days it was perhaps pleasant, but today it is no longer. Anim8 has seen a few improvements with LeGo 2.2 that make it much easier to create the same effect: </p><pre><code>var int MyText;\nvar int MyAnim8;\nfunc void PrintMyScrollingText(var string text) {\n// Create and set text:\nMyText = Print_CreateText(text, FONT_Screen);\nvar zCViewText MyTextObject; MyTextObject = Print_GetText(MyText);\nMyTextObject.posx = 1;\nMyTextObject.posy = 1;\nMyTextObject.timed = false;\n// But now comes the trick: We use Anim8_NewExt, this allows us to set a \"Handler\" and \"Data\".\nMyAnim8 = Anim8_NewExt(1, ScrollMyText, MyText, false);\n// ScrollMyText is passed as the handler and MyText as the data.\n// In concrete terms, this means: ScrollMyText is always called\n// when Anim8 has recalculated the position.\n// Pass data and the new position as parameters. Let's see how it goes.\n// Set the animation again as usual:\nAnim8(MyAnim8, 8192, 2000, A8_Constant);\n// And this time no FrameFunction.\n// Instead, we tell Anim8 to clean up by itself when it's done:\nAnim8_RemoveIfEmpty(MyAnim8, true);\n// The text should also disappear by itself:\nAnim8_RemoveDataIfEmpty(MyAnim8, true);\n// Since MyText is a handle, this will work.\n// If MyText were a pointer, RemoveDataIfEmpty should not be activated, it would lead to an error message.\n};\nfunc void ScrollMyText(var int MyText, var int Position) {\n// Get the text as an object again\nvar zCViewText MyTextObject; MyTextObject = Print_GetText(MyText);\n// And now compare the values:\nMyTextObject.posx = Position;\n// Since Anim8 does the deleting itself, we don't have to worry about that.\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/item_helper/","title":"ItemHelper","text":""},{"location":"zengin/scripts/extenders/lego/tools/item_helper/#itemhelper","title":"ItemHelper","text":"<p>This package is very simple - it retrieves a <code>oCItem</code> pointer from an <code>C_ITEM</code> instance valid for the current world and session.</p> <p>Warning</p> <p>Make sure every world has waypoint with name <code>TOT</code> (\"dead\" in German). Ikarus &amp; LeGo need this waypoint to spawn helper NPCs. This is especially important in Gothic 1 since G1 vanilla worlds do not have the <code>TOT</code> waypoint.</p>"},{"location":"zengin/scripts/extenders/lego/tools/item_helper/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/item_helper/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/item_helper/#implementation","title":"Implementation","text":"<p> ItemHelper.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/item_helper/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/item_helper/#itm_getptr","title":"<code>Itm_GetPtr</code>","text":"<pre><code>func int Itm_GetPtr(var int instance)\n</code></pre> Parameters <ul> <li><code>var int instance</code> <code>C_ITEM</code> instance to get the pointer of</li> </ul> <p>Return value The function returns <code>oCItem</code> pointer of the <code>C_ITEM</code> instance.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/","title":"List","text":""},{"location":"zengin/scripts/extenders/lego/tools/list/#list","title":"List","text":"<p>The List package is a collection of functions designed to simplify the handling of <code>zCList</code> and <code>zCListSort</code> lists in daedalus. It offers a range of functions for creating, manipulating, and querying lists.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#implementation","title":"Implementation","text":"<p> List.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#functions","title":"Functions","text":"<p>Note</p> <p>All functions, expect <code>List_Compare</code> come with an additional \"S\" at the end for objects of type <code>zCListSort</code>. (Example: <code>List_NodeS</code> .) Unlike most LeGo packages, pointers are used here, not handles! </p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_create","title":"<code>List_Create</code>","text":"<p>Creates a list with an initial value. </p><pre><code>func int List_Create(var int data)\n</code></pre> Parameters <ul> <li><code>var int data</code>     The value of the first list element.</li> </ul> <p>Return value</p> <p>The function returns a pointer to the created list.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_add","title":"<code>List_Add</code>","text":"<p>Appends a value to the end of the list. </p><pre><code>func void List_Add(var int list, var int data)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int data</code>     The value to be appended.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_addfront","title":"<code>List_AddFront</code>","text":"<p>Adds a value before the first element of the list. </p><pre><code>func void List_AddFront(var int list, var int data)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int data</code>     The value to be appended.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_addoffset","title":"<code>List_AddOffset</code>","text":"<p>Inserts a value between two list elements. </p><pre><code>func void List_AddOffset(var int list, var int offset, var int data)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int offset</code>     The number of the list element after which the value is inserted.</li> <li><code>var int data</code>     The value to be appended.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_set","title":"<code>List_Set</code>","text":"<p>Sets a list element to a specific value. </p><pre><code>func void List_Set(var int node, var int data)\n</code></pre> Parameters <ul> <li><code>var int node</code>     Pointer to a list element.</li> <li><code>var int data</code>     The value to be written into the list element.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_get","title":"<code>List_Get</code>","text":"<p>Retrieves the value of a list element. </p><pre><code>func int List_Get(var int list, var int nr)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int nr</code>     The number of the list element.</li> </ul> <p>Return value</p> <p>The function returns the value of the specified list element.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_node","title":"<code>List_Node</code>","text":"<p>Returns a pointer to a list element. </p><pre><code>func int List_Node(var int list, var int nr)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int nr</code>     The number of a list element.</li> </ul> <p>Return value</p> <p>The function returns a pointer to the specified list element.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_length","title":"<code>List_Length</code>","text":"<p>Returns the length of the list (number of all elements). </p><pre><code>func int List_Length(var int list)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> </ul> <p>Return value</p> <p>The function returns the number of elements in the list.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_haslength","title":"<code>List_HasLength</code>","text":"<p>Checks if the list has the specified length. </p><pre><code>func int List_HasLength(var int list, var int length)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int length</code>     The desired length.</li> </ul> <p>Return value</p> <p>The function returns a boolean value indicating whether the list has the specified length or not.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_end","title":"<code>List_End</code>","text":"<p>Returns the last list element of the list. </p><pre><code>func int List_End(var int list)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> </ul> <p>Return value</p> <p>The function returns a pointer to the last list element.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_concat","title":"<code>List_Concat</code>","text":"<p>Concatenates two lists. </p><pre><code>func void List_Concat(var int list, var int list2)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The first list.</li> <li><code>var int list2</code>     The second list. Its beginning is appended to the end of the first list.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_contains","title":"<code>List_Contains</code>","text":"<p>Returns the last list element with a specific value. </p><pre><code>func int List_Contains(var int list, var int data)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int data</code>     The value to search for.</li> </ul> <p>Return value</p> <p>The function returns the number of the last list element with the value <code>data</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_for","title":"<code>List_For</code>","text":"<p>Calls a function for each list element, passing a pointer to the list element as a parameter. </p><pre><code>func void List_For(var int list, var string function)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var string function</code>     Name of a function to be called for each list element (<code>void handler(var int node)</code>).</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_forf","title":"<code>List_ForF</code>","text":"<p>Similar to <code>List_For</code>, but with a function parameter instead of a string. </p><pre><code>func void ListForF(var int list, var func function)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var func function</code>     The function to be called for each list element (<code>void handler(var int node)</code>).</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_fori","title":"<code>List_ForI</code>","text":"<p>Similar to <code>List_For</code>, but with a function parameter instead of a string. </p><pre><code>func void List_ForI(var int list, var int funcID)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int funcID</code>     ID of a function to be called for each list element (<code>void handler(var int node)</code>).</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_delete","title":"<code>List_Delete</code>","text":"<p>Deletes a list element. All subsequent elements shift position. </p><pre><code>func void List_Delete(var int list, var int nr)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> <li><code>var int nr</code>     The number of the list element to be deleted.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_destroy","title":"<code>List_Destroy</code>","text":"<p>Destroys the entire list. </p><pre><code>func void List_Destroy(var int list)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be destroyed.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_toarray","title":"<code>List_ToArray</code>","text":"<p>Returns a pointer to a memory area containing all values of the list. </p><pre><code>func int List_ToArray(var int list)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list to be used.</li> </ul> <p>Return value</p> <p>The function returns a memory area containing all the values of the list.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_movedown","title":"<code>List_MoveDown</code>","text":"<p>Moves the specified list node down by one position in the list. </p><pre><code>func void List_MoveDown(var int list, var int node)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list in which the node is located.</li> <li><code>var int node</code>     The node to be moved down.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_moveup","title":"<code>List_MoveUp</code>","text":"<p>Moves the specified list node up by one position in the list. </p><pre><code>func void List_MoveUp(var int list, var int node)\n</code></pre> Parameters <ul> <li><code>var int list</code>     The list in which the node is located.</li> <li><code>var int node</code>     The node to be moved up.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_insertsorted","title":"<code>List_InsertSorted</code>","text":"<p>Inserts a value into a sorted list while preserving the sort order.</p> <p></p><pre><code>func void List_InsertSorted(var int list, var int data, var func compare)\n</code></pre> Parameters: <ul> <li><code>var int list</code>     The list to insert the value into.</li> <li><code>var int data</code>     The value to be inserted.</li> <li><code>var func compare</code>     A comparison function used to determine the sort order.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_compare","title":"<code>List_Compare</code>","text":"<pre><code>func int List_Compare(var int data1, var int data2, var func compare)\n</code></pre> Parameters: <ul> <li><code>var int data1</code>     The first integer value.</li> <li><code>var int data2</code>     The second integer value.</li> <li><code>var func compare</code>     One of comparsion functions. Return value</li> </ul> <p>The function returns the return value of specified comparsion funtion.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#comparison-functions","title":"Comparison Functions","text":"<p>The following comparison functions can be used as the <code>compare</code> parameter in the <code>List_InsertSorted</code> and <code>List_Compare</code> function:</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_cmpascending","title":"<code>List_CmpAscending</code>","text":"<p>Compares two integer values in ascending order. </p><pre><code>func int List_CmpAscending(var int data1, var int data2)\n</code></pre> Parameters: <ul> <li><code>var int data1</code>     The first integer value.</li> <li><code>var int data2</code>     The second integer value.</li> </ul> <p>Return Value:</p> <p>The function returns <code>TRUE</code> if <code>data1</code> is greater than <code>data2</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_cmpdescending","title":"<code>List_CmpDescending</code>","text":"<p>Compares two integer values in descending order. </p><pre><code>func int List_CmpDescending(var int data1, var int data2)\n</code></pre> Parameters: <ul> <li><code>var int data1</code>     The first integer value.</li> <li><code>var int data2</code>     The second integer value.</li> </ul> <p>Return Value:</p> <p>The function returns <code>TRUE</code> if <code>data1</code> is less than <code>data2</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_cmpascendingunsigned","title":"<code>List_CmpAscendingUnsigned</code>","text":"<p>Compares two unsigned integer values in ascending order. </p><pre><code>func int List_CmpAscendingUnsigned(var int data1, var int data2)\n</code></pre> Parameters: <ul> <li><code>var int data1</code>     The first unsigned integer value.</li> <li><code>var int data2</code>     The second unsigned integer value.</li> </ul> <p>Return Value:</p> <p>The function returns <code>TRUE</code> if <code>data1</code> is greater than <code>data2</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/list/#list_cmpdescendingunsigned","title":"<code>List_CmpDescendingUnsigned</code>","text":"<p>Compares two unsigned integer values in descending order. </p><pre><code>func int List_CmpDescendingUnsigned(var int data1, var int data2)\n</code></pre> Parameters: <ul> <li><code>var int data1</code>     The first unsigned integer value.</li> <li><code>var int data2</code>     The second unsigned integer value.</li> </ul> <p>Return Value:</p> <p>The function returns <code>TRUE</code> if <code>data1</code> is less than <code>data2</code>, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/locals/","title":"Locals","text":""},{"location":"zengin/scripts/extenders/lego/tools/locals/#locals","title":"Locals","text":"<p>Daedalus doesn't offer any local variables, which can quickly lead to problems with recursive functions. The Locals package allows variables to be saved temporarily on a pseudo-stack. Locals is a very specific package. People who work normally with Daedalus will probably never need it. There is also the <code>final</code> function, which can be used to emulate something similar to the <code>final</code> clause in Java.</p>"},{"location":"zengin/scripts/extenders/lego/tools/locals/#dependencies","title":"Dependencies","text":"<ul> <li>StringBuilder</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/locals/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/locals/#implementation","title":"Implementation","text":"<p> Locals.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/locals/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/locals/#locals_1","title":"<code>Locals</code>","text":"<p>All that has to be done to enable the <code>Locals</code> is to write this function at the beginning of the function that should receive \"real\" local variables. </p><pre><code>func void locals()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/locals/#final","title":"<code>Final</code>","text":"<p>It is hard to explain how to use it, but very easy to understand once you've seen an example. </p><pre><code>func int Final()\n</code></pre> Example <p>With <code>final()</code> it is very easy to emulate Java's <code>final</code> clause, i.e. a block of code can be specified, which is executed after this function is exited, regardless of when or where the function is exited. </p><pre><code>func void testFinal()\n{\nif (final())\n{\nMEM_InfoBox(\"Final was called.\");\n};\nMEM_InfoBox(\"This will appear before Final\");\n};\n</code></pre> Few lines of code say more than a thousand words."},{"location":"zengin/scripts/extenders/lego/tools/misc/","title":"Misc","text":""},{"location":"zengin/scripts/extenders/lego/tools/misc/#misc","title":"Misc","text":"<p>The Misc package introduces various helper functions that did not fit into any other package.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#dependencies","title":"Dependencies","text":"<ul> <li>Floats</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#implementation","title":"Implementation","text":"<p> Misc.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#constants","title":"Constants","text":"<p>Misc package implements the <code>phi</code> constant </p><pre><code>const int phi = 1070141312; // PI/2\n</code></pre> whitch is actualy <code>pi</code> divided by 2 saved as an ikarus float.  <p>Decimal: <code>1.5707...</code></p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/misc/#atan2f","title":"<code>atan2f</code>","text":"<p>Calculates the arcus tangent of an angle between the origin and (x, y) point. </p><pre><code>func int atan2f(var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int x</code>     X-coordinate</li> <li><code>var int y</code>     Y-coordinate</li> </ul> <p>Return value</p> <p>The function returns arcus tangent in radians as Ikarus <code>float</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#sin","title":"<code>sin</code>","text":"<p>Calculates the sine of an angle given in radians. </p><pre><code>func int sin(var int angle)\n</code></pre> Parameters <ul> <li><code>var int angle</code>     The angle in radians as a Ikarus <code>float</code></li> </ul> <p>Return value</p> <p>The function returns sine of the angle as Ikarus <code>float</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#cos","title":"<code>cos</code>","text":"<p>Calculates the cosine of an angle given in radians. </p><pre><code>func int cos(var int angle)\n</code></pre> Parameters <ul> <li><code>var int angle</code>     The angle in radians as a Ikarus <code>float</code></li> </ul> <p>Return value</p> <p>The function returns cosine of the angle as Ikarus <code>float</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#tan","title":"<code>tan</code>","text":"<p>Calculates the tangent of an angle given in radians. </p><pre><code>func int tan(var int angle)\n</code></pre> Parameters <ul> <li><code>var int angle</code>     The angle in radians as a Ikarus <code>float</code></li> </ul> <p>Return value</p> <p>The function returns tangent of the angle as Ikarus <code>float</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#asin","title":"<code>asin</code>","text":"<p>Calculates the arcus sine. </p><pre><code>func int asin(var int sine)\n</code></pre> Parameters <ul> <li><code>var int sine</code>     The sine of an angle as a Ikarus <code>float</code></li> </ul> <p>Return value</p> <p>The function returns arcus sine of the angle as Ikarus <code>float</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#acos","title":"<code>acos</code>","text":"<p>Calculates the arcus cosine </p><pre><code>func int acos(var int cosine)\n</code></pre> Parameters <ul> <li><code>var int cosine</code>     The cosine of an angle as a Ikarus <code>float</code></li> </ul> <p>Return value</p> <p>The function returns arcus cosine of the angle as Ikarus <code>float</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#distance2d","title":"<code>distance2D</code>","text":"<p>Calculates the distance between two points on a two-dimensional plane. </p><pre><code>func int distance2D(var int x1, var int x2, var int y1, var int y2)\n</code></pre> Parameters <ul> <li><code>var int x1</code>     X-coordinate of the first point</li> <li><code>var int x2</code>     X-coordinate of the second point</li> <li><code>var int y1</code>     Y-coordinate of the first point</li> <li><code>var int y2</code>     Y-coordinate of the second point</li> </ul> <p>Return value</p> <p>The function returns the distance between the two points.</p>"},{"location":"zengin/scripts/extenders/lego/tools/misc/#distance2df","title":"<code>distance2Df</code>","text":"<p>Calculates the distance between two points on a two-dimensional plane but parameters and return values are Ikarus <code>floats</code>. </p><pre><code>func int distance2Df(var int x1, var int x2, var int y1, var int y2)\n</code></pre> Parameters <ul> <li><code>var int x1</code>     X-coordinate of the first point</li> <li><code>var int x2</code>     X-coordinate of the second point</li> <li><code>var int y1</code>     Y-coordinate of the first point</li> <li><code>var int y2</code>     Y-coordinate of the second point</li> </ul> <p>Return value</p> <p>The function returns the distance between the two points as Ikarus <code>float</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/","title":"PermMem","text":""},{"location":"zengin/scripts/extenders/lego/tools/permmem/#permmem","title":"PermMem","text":"<p>PermMem is a powerful package that allows classes (or instances) to be used permanently even after loading or restarting by saving them to the ASCII <code>.ZEN</code> archive in the savegame directory. PermMem manages handles that are used to access instances, and provides various functions to manipulate these handles and instances.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#dependencies","title":"Dependencies","text":"<ul> <li>Saves</li> <li>Locals</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_PermMem</code> flag. </p><pre><code>LeGo_Init(LeGo_PermMem);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#implementation","title":"Implementation","text":"<p> PermMem.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/permmem/#new","title":"<code>new</code>","text":"<p>Creates a handle to a new instance of <code>inst</code>. </p><pre><code>func int new(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     A valid instance. Used as \"constructor\" </li> </ul> <p>Return value</p> <p>The function returns a new, valid PermMem handle.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#create","title":"<code>create</code>","text":"<p>Similar to <code>new</code>, but here a pointer is returned directly and not a handle. Caution! Not managed by PermMem! </p><pre><code>func int create(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     A valid instance. Used as \"constructor\" </li> </ul> <p>Return value</p> <p>The function returns a pointer to the new instance.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#wrap","title":"<code>wrap</code>","text":"<p>\"Wraps\" a handle \"around\" a pointer so that the pointer can be used with any function that expects handles. Only conditionally managed by PermMem.  </p><pre><code>func int wrap(var int inst, var int ptr)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     A valid instance. Determines the type of the handle</li> <li><code>var int ptr</code>     Pointer to wrap </li> </ul> <p>Return value</p> <p>The function returns a handle with <code>ptr</code> as content.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#clear","title":"<code>clear</code>","text":"<p>Cleans the handle. After that it is invalid.  </p><pre><code>func void clear(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Valid PermMem handle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#release","title":"<code>release</code>","text":"<p>Frees the handle. The reserved memory is not deleted, the handle becomes invalid.  </p><pre><code>func void release(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Valid PermMem handle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#delete","title":"<code>delete</code>","text":"<p>Cleans the handle just like <code>clear</code>, only the destructor is also called.  </p><pre><code>func void delete(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Valid PermMem handle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#free","title":"<code>free</code>","text":"<p>Similar to <code>delete</code>, only here a pointer is destroyed and not a handle. Caution! Not managed by PermMem! </p><pre><code>func void free(var int ptr, var int inst)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>     The pointer to be cleaned</li> <li><code>var int inst</code>     Instance used in <code>create</code> function.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#get","title":"<code>get</code>","text":"<p>Returns the instance of the handle.  </p><pre><code>func instance get(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Valid PermMem handle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#getptr","title":"<code>getPtr</code>","text":"<p>Returns a pointer to instance of handle.  </p><pre><code>func int getPtr(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Valid PermMem handle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#setptr","title":"<code>setPtr</code>","text":"<p>Sets the pointer of a handle.  </p><pre><code>func void setPtr(var int hndl, var int ptr)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Valid PermMem handle</li> <li><code>var int ptr</code>     New pointer for handle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#getinst","title":"<code>getInst</code>","text":"<p>Returns the instance used to create the given handle in <code>new</code> function. </p><pre><code>func int getInst(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     Valid PermMem handle</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#numhandles","title":"<code>numHandles</code>","text":"<p>Returns the number of handles managed by PermMem. </p><pre><code>func int numHandles()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#sizeof","title":"<code>sizeof</code>","text":"<p>Gets the size of the given instance's class. </p><pre><code>func int sizeof(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     Any instance</li> </ul> <p>Return value</p> <p>The function returns the size of a given instance's class in bytes.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#hlp_isvalidhandle","title":"<code>Hlp_IsValidHandle</code>","text":"<p>Indicates whether the handle exists and is managed by PermMem.  </p><pre><code>func int Hlp_IsValidHandle(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>     PermMem's handle</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the handle is valid (managed by PermMem), <code>FALSE</code> is returned otherwise.</p> Example <p>The example function that use <code>Hlp_IsValidHandle</code> is <code>Bar_SetMax</code> form LeGo Bars package. The function first checks if the handle is valid, then gets the instance and changes its parameters.</p> <pre><code>func void Bar_SetMax(var int bar, var int max) {\nif(!Hlp_IsValidHandle(bar)) { return; };\nvar _bar b; b = get(bar);\nb.valMax = max;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#foreachhndl","title":"<code>foreachHndl</code>","text":"<p>Executes a function for each handle of an instance.  </p><pre><code>func void foreachHndl(var int inst, var func fnc)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     The function is called for this instance </li> <li><code>var int inst</code>     This function is called. The signature is <code>function(int handle)</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#hashndl","title":"<code>hasHndl</code>","text":"<p>Checks if PermMem has a handle of this instance.  </p><pre><code>func int hasHndl(var int inst)\n</code></pre> Parameters <ul> <li><code>var int inst</code>     Instance to be checked </li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the PermMem has a handle of this instance, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#mem_readstringarray","title":"<code>MEM_ReadStringArray</code>","text":"<p>Function moved to PermMem form Ikarus. Reads string from the array at the <code>arrayAddress</code>.  </p><pre><code>func string MEM_ReadStringArray(var int arrayAddress, var int index)\n</code></pre> Parameters <ul> <li><code>var int arrayAddress</code>     Memory address of array</li> <li><code>var int offset</code>     Array offset (array index)</li> </ul> <p>Return value</p> <p>The function returns string from the array if the address is correct.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_exists","title":"<code>PM_Exists</code>","text":"<p>Checks if the specified field already exists in the archive. (used with archiver/unarchiver) </p><pre><code>func int PM_Exists(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the field exists in the archive, <code>FALSE</code> is returned otherwise. </p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#archiver","title":"Archiver","text":""},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_saveint","title":"<code>PM_SaveInt</code>","text":"<p>Saves an integer to the archive. </p><pre><code>func void PM_SaveInt (var string name, var int val)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int val</code>      Value of the saved integer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_savefloat","title":"<code>PM_SaveFloat</code>","text":"<p>Saves a daedalus float to the archive. </p><pre><code>func void PM_SaveFloat (var string name, var int flt)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int flt</code>      Value of the saved float</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_savestring","title":"<code>PM_SaveString</code>","text":"<p>Saves a string to the archive. </p><pre><code>func void PM_SaveString (var string name, var string val)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var string val</code>      Saved string</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_savefuncid","title":"<code>PM_SaveFuncID</code>","text":"<p>Saves a function ID to the archive. </p><pre><code>func void PM_SaveFuncID(var string name, var int fnc)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int fnc</code>      Saved function ID</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_savefuncoffset","title":"<code>PM_SaveFuncOffset</code>","text":"<p>Saves a function offset to the archive. </p><pre><code>func void PM_SaveFuncOffset(var string name, var int fnc)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int fnc</code>      Saved function offset</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_savefuncptr","title":"<code>PM_SaveFuncPtr</code>","text":"<p>Saves a function pointer to the archive. </p><pre><code>func void PM_SaveFuncPtr(var string name, var int fnc)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int fnc</code>      Saved function pointer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_saveclassptr","title":"<code>PM_SaveClassPtr</code>","text":"<p>Saves a pointer of a class to the archive. </p><pre><code>func void PM_SaveClassPtr(var string name, var int ptr, var string className)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int ptr</code>     Saved pointer</li> <li><code>var string className</code>     Name of the class of stored pointer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_saveclass","title":"<code>PM_SaveClass</code>","text":"<p>Saves a class like <code>PM_SaveClassPtr</code>. </p><pre><code>func void PM_SaveClass(var string name, var int ptr, var string className)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int ptr</code>     Saved class pointer</li> <li><code>var string className</code>     Name of the class of stored pointer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_saveintarray","title":"<code>PM_SaveIntArray</code>","text":"<p>Saves an array of integers. </p><pre><code>func void PM_SaveIntArray(var string name, var int ptr, var int elements)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int ptr</code>     Pointer to the array</li> <li><code>var int elements</code>     Number of elements in array</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_savestringarray","title":"<code>PM_SaveStringArray</code>","text":"<p>Saves an array of integers. </p><pre><code>func void PM_SaveStringArray(var string name, var int ptr, var int elements)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the field in saved archive</li> <li><code>var int ptr</code>     Pointer to the array</li> <li><code>var int elements</code>     Number of elements in array</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#unarchiver","title":"Unarchiver","text":""},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_load","title":"<code>PM_Load</code>","text":"<p>Universal function to load integers, floats, class pointers and int arrays. </p><pre><code>func int PM_Load(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul> <p>Return value The function returns the data existing in the archive at the given field.</p>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadint","title":"<code>PM_LoadInt</code>","text":"<p>Returns an integer stored in the archive. </p><pre><code>func int PM_LoadInt(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadfloat","title":"<code>PM_LoadFloat</code>","text":"<p>Returns a daedalus float stored in the archive. </p><pre><code>func int PM_LoadFloat(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadstring","title":"<code>PM_LoadString</code>","text":"<p>Returns a string stored in the archive. </p><pre><code>func string PM_LoadString(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadfuncid","title":"<code>PM_LoadFuncID</code>","text":"<p>Returns a function ID stored in the archive. </p><pre><code>func int PM_LoadFuncID(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadfuncoffset","title":"<code>PM_LoadFuncOffset</code>","text":"<p>Returns a function offset stored in the archive. </p><pre><code>func int PM_LoadFuncOffset(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadfuncptr","title":"<code>PM_LoadFuncPtr</code>","text":"<p>Returns a function pointer stored in the archive. </p><pre><code>func int PM_LoadFuncPtr(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadclassptr","title":"<code>PM_LoadClassPtr</code>","text":"<p>Returns a class pointer stored in the archive. </p><pre><code>func int PM_LoadClassPtr(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadclass","title":"<code>PM_LoadClass</code>","text":"<p>Loads a pointer to the class from the archive to <code>destPtr</code>. </p><pre><code>func void PM_LoadClass(var string name, var int destPtr)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> <li><code>var int destPtr</code>     Destination pointer, the address to where it will deserialize the saved data</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadarray","title":"<code>PM_LoadArray</code>","text":"<p>Returns a pointer to array stored in the archive. </p><pre><code>func int PM_LoadArray(var string name)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadarraytoptr","title":"<code>PM_LoadArrayToPtr</code>","text":"<p>Loads a pointer to array from the archive to <code>destPtr</code>. </p><pre><code>func void PM_LoadArrayToPtr(var string name, var int destPtr)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> <li><code>var int destPtr</code>     Destination pointer, the address to where it will deserialize the saved data</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/permmem/#pm_loadtoptr","title":"<code>PM_LoadToPtr</code>","text":"<p>Universal function to load array or class pointer from the archive to <code>destPtr</code>. </p><pre><code>func void PM_LoadToPtr(var string name, var int destPtr)\n</code></pre> Parameters <ul> <li><code>var string name</code>     Name of the loaded field</li> <li><code>var int destPtr</code>     Destination pointer, the address to where it will deserialize the saved data</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/","title":"Queue","text":""},{"location":"zengin/scripts/extenders/lego/tools/queue/#queue","title":"Queue","text":"<p>This package is an implementation of the Queue data structure and a queue for function calls.</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#implementation","title":"Implementation","text":"<p> Queue.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#queue_1","title":"Queue","text":""},{"location":"zengin/scripts/extenders/lego/tools/queue/#q_create","title":"<code>Q_Create</code>","text":"<p>Creates a new queue and returns a handle to it. </p><pre><code>func int Q_Create()\n</code></pre> Return value <p>The function returns a handle to a queue.</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#q_enqueue","title":"<code>Q_Enqueue</code>","text":"<p>Appends an integer to the back of the queue </p><pre><code>func void Q_Enqueue(var int queue, var int value)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a queue</li> <li><code>var int value</code>     The value to be appended to the queue</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#q_isempty","title":"<code>Q_IsEmpty</code>","text":"<p>Checks if the queue is empty. </p><pre><code>func int Q_IsEmpty(var int queue)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a queue</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the queue is empty, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#q_advance","title":"<code>Q_Advance</code>","text":"<p>Removes the oldest value from the queue and returns it. </p><pre><code>func int Q_Advance(var int queue)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a queue</li> </ul> <p>Return value</p> <p>The function returns the oldest value in the queue.</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#q_peek","title":"<code>Q_Peek</code>","text":"<p>Returns the oldest value in the queue without removing it. </p><pre><code>func int Q_Peek(var int queue)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a queue</li> </ul> <p>Return value</p> <p>The function returns the oldest value in the queue.</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#q_for","title":"<code>Q_For</code>","text":"<p>Function with the <code>funcID</code> is called with every element of the list as parameter. The list element is passed to the function as a <code>zCList</code> pointer. </p><pre><code>func void Q_For(var int queue, var int funcID)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a queue</li> <li><code>var int funcID</code>     ID of function that is executed for all values in the queue (signature: <code>void (zCList*)</code>)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#q_forf","title":"<code>Q_ForF</code>","text":"<p>Like <code>Q_For</code>, but with function as a parameter instead of a function ID. </p><pre><code>func void Q_ForF(var int queue, var func f)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a queue</li> <li><code>var func f</code>     This function is executed for all values in the queue (signature: <code>void (zCList*)</code>)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#callbackqueue","title":"CallbackQueue","text":""},{"location":"zengin/scripts/extenders/lego/tools/queue/#cq_create","title":"<code>CQ_Create</code>","text":"<p>Creates a new callback queue and returns a handle to it. </p><pre><code>func int CQ_Create()\n</code></pre> Return value <p>The function returns a handle to a callback queue.</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#cq_enqueuenodata","title":"<code>CQ_EnqueueNoData</code>","text":"<p>Appends a function to the callback queue. </p><pre><code>func void CQ_EnqueueNoData(var int queue, var func function)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a callback queue</li> <li><code>var func function</code>     A function with no return value, expecting no parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#cq_enqueuedata","title":"<code>CQ_EnqueueData</code>","text":"<p>Appends a function together with a value to the callback queue. </p><pre><code>func void CQ_EnqueueData(var int queue, var func function, var int data)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a callback queue</li> <li><code>var func function</code>     A function with no return value, expecting an integer as a parameter.</li> <li><code>var int data</code>     When calling <code>function</code>, this value is passed as a parameter</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#cq_enqueue","title":"<code>CQ_Enqueue</code>","text":"<p>Appends a function together with an optional value to the callback queue. This function should not usually be used. Use <code>CQ_EnqueueData</code> and <code>CQ_EnqueueNoData</code> instead. </p><pre><code>func void CQ_Enqueue(var int queue, var int funcID, var int data, var int hasData)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a callback queue</li> <li><code>var int funcID</code>     The function ID of a function to be appended to the callback queue.</li> <li><code>var int data</code>     If hasData is not 0, this value is passed to the associated function.</li> <li><code>var int hasData</code>     Must be 0 if the function does not expect an integer as a parameter, otherwise not 0.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#cq_isempty","title":"<code>CQ_IsEmpty</code>","text":"<p>Checks if no function is in the callback queue. </p><pre><code>func int CQ_IsEmpty(var int queue)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a callback queue</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the callback queue is empty, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#cq_advance","title":"<code>CQ_Advance</code>","text":"<p>Executes the foremost function of the callback queue and removes it from the callback queue. </p><pre><code>func void CQ_Advance(var int queue)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a callback queue</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/queue/#cq_exhaust","title":"<code>CQ_Exhaust</code>","text":"<p>Executes all functions contained in the callback queue. </p><pre><code>func void CQ_Exhaust(var int queue)\n</code></pre> Parameters <ul> <li><code>var int queue</code>     Handle of a callback queue</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/random/","title":"Random","text":""},{"location":"zengin/scripts/extenders/lego/tools/random/#random","title":"Random","text":"<p>Provides more random randomization than <code>Hlp_Random()</code> function.</p>"},{"location":"zengin/scripts/extenders/lego/tools/random/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/random/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Random</code> flag. </p><pre><code>LeGo_Init(LeGo_Random);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/random/#implementation","title":"Implementation","text":"<p> Random.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/random/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/random/#r_next","title":"<code>r_Next</code>","text":"<p>Returns a random number. </p><pre><code>func int r_Next()\n</code></pre> Return value <p>The function returns a random number.</p>"},{"location":"zengin/scripts/extenders/lego/tools/random/#r_max","title":"<code>r_Max</code>","text":"<p>Returns a random number from 0 to <code>max</code>. </p><pre><code>func int r_Max(var int max)\n</code></pre> Parameters <ul> <li><code>var int max</code>     Maximum value of number</li> </ul> <p>Return value</p> <p>The function returns a random number from 0 to 'max'.</p>"},{"location":"zengin/scripts/extenders/lego/tools/random/#r_minmax","title":"<code>r_MinMax</code>","text":"<p>Returns a random number from 'min' to 'max'. </p><pre><code>func int r_MinMax(var int min, var int max)\n</code></pre> Parameters <ul> <li><code>var int max</code>     Maximum value of number</li> <li><code>var int min</code>     Minimum value of number</li> </ul> <p>Return value</p> <p>The function returns a random number from <code>min</code> to <code>max</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/random/#r_init","title":"<code>r_Init</code>","text":"<p>Initializes the random number generator. Happens optionally in <code>LeGo_Init</code>. </p><pre><code>func void r_Init(var int seed)\n</code></pre> Parameters <ul> <li><code>var int seed</code>     The initializing value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/random/#r_defaultinit","title":"<code>r_DefaultInit</code>","text":"<p>Initializes the random number generator based on the current time. </p><pre><code>func void r_DefaultInit()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/","title":"StringBuilder","text":""},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#stringbuilder","title":"StringBuilder","text":"<p>The StringBuilder is a package, designed to easily concatenate multiple elements into a string (without <code>ConcatStrings</code> and <code>IntToString</code>).</p> <p>All created StringBuilders are transient. All functions starting from <code>SB_InitBuffer</code>, including it, use the active StringBuilder set with <code>SB_New</code> or <code>SB_Use</code>, so there is no <code>var int stringBuilder</code> parameter in functions. A look at the example explains what I mean.</p> <p>Warning</p> <p>The StringBuilder works with pointers, not handles like many other LeGo packages.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#initialization","title":"Initialization","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#implementation","title":"Implementation","text":"<p> StringBuilder.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_new","title":"<code>SB_New</code>","text":"<p>Creates and returns a new <code>StringBuilder</code>. At the same time, this new <code>StringBuilder</code> is set as active. (See <code>SB_Use</code>.)  </p><pre><code>func int SB_New()\n</code></pre> Return value <p>The function returns a pointer to a new <code>StringBuilder</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_use","title":"<code>SB_Use</code>","text":"<p>Marks this <code>StringBuilder</code> as active. It can now be used with the functions. </p><pre><code>func void SB_Use(var int sb)\n</code></pre> Parameters <ul> <li><code>var int sb</code>     Pointer to a <code>StringBuilder</code>, returned from <code>SB_New</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_get","title":"<code>SB_Get</code>","text":"<p>Returns the active <code>StringBuilder</code>.  </p><pre><code>func int SB_Get()\n</code></pre> Return value <p>The function returns the active <code>StringBuilder</code> object - last set with <code>SB_Use</code> or just created with <code>SB_New</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_initbuffer","title":"<code>SB_InitBuffer</code>","text":"<p>If the size of the resulting string is already known, the buffer can be set manually. This is usually not necessary. </p><pre><code>func void SB_InitBuffer(var int size)\n</code></pre> Parameters <ul> <li><code>var int size</code>     Size in bytes. Warning! Only works if the <code>StringBuilder</code> has been newly created! </li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_clear","title":"<code>SB_Clear</code>","text":"<p>Empties the current <code>StringBuilder</code>. It is not destroyed in the process, so it can be used again. If the object has a buffer allocated, the buffer is freed. </p><pre><code>func void SB_Clear()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_release","title":"<code>SB_Release</code>","text":"<p>Releases the current stream of the <code>StringBuilder</code>. The <code>StringBuilder</code> is destroyed, and the stream can be obtained via <code>SB_GetStream</code>. </p><pre><code>func void SB_Release()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_destroy","title":"<code>SB_Destroy</code>","text":"<p>Completely destroys the <code>StringBuilder</code>.  </p><pre><code>func void SB_Destroy()\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_tostring","title":"<code>SB_ToString</code>","text":"<p>Returns a copy of the stream as a string.  </p><pre><code>func string SB_ToString()\n</code></pre> Return value <p>The function returns the copy of the active <code>StringBuilder</code> as a string. If the <code>StringBuilder</code> object doesn't have a buffer allocated, an empty string is returned.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_tostream","title":"<code>SB_ToStream</code>","text":"<p>Returns a copy of the stream in raw format. </p><pre><code>func int SB_ToStream()\n</code></pre> Return value <p>The function returns a copy of the stream in raw format (<code>char[]</code>)</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_getstream","title":"<code>SB_GetStream</code>","text":"<p>Doesn't copy the stream, but returns it as it is. </p><pre><code>func int SB_GetStream()\n</code></pre> Return value <p>The function returns the stream as it is. <code>SB_Destroy</code> or <code>SB_Clear</code> destroy the returned pointer.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_length","title":"<code>SB_Length</code>","text":"<p>Returns the current length of the stream. Similar to <code>STR_Len</code> from Ikarus . </p><pre><code>func int SB_Length()\n</code></pre> Return value <p>The function returns the current length of the active <code>StringBuilder</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb_setlength","title":"<code>SB_SetLength</code>","text":"<p>Sets the length of the stream. When increasing, zero bytes are appended. </p><pre><code>func void SB_SetLength(var int length)\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#stream-operations","title":"Stream operations","text":""},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sb","title":"<code>SB</code>","text":"<p>Appends a string, to the active <code>StringBuilder</code>. </p><pre><code>func void SB(var string s)\n</code></pre> Parameters <ul> <li><code>var string s</code>     The appended string</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sbi","title":"<code>SBi</code>","text":"<p>Appends an integer in text form, to the active <code>StringBuilder</code>. </p><pre><code>func void SBi(var int i)\n</code></pre> Parameters <ul> <li><code>var int i</code>     The appended integer</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sbc","title":"<code>SBc</code>","text":"<p>Appends a byte, to the active <code>StringBuilder</code>. (e.g. 82 for 'R' - An ASCII table can be quickly found) </p><pre><code>func void SBc(var int c)\n</code></pre> Parameters <ul> <li><code>var int c</code>     The appended byte (ASCII table character)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sbraw","title":"<code>SBraw</code>","text":"<p>Appends a raw bytes array, to the active <code>StringBuilder</code>. </p><pre><code>func void SBraw(var int ptr, var int len)\n</code></pre> Parameters <ul> <li><code>var int ptr</code>     Pointer to the appended array</li> <li><code>var int len</code>     Length of an array</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sbflt","title":"<code>SBflt</code>","text":"<p>Appends a Daedalus float in text form, to the active <code>StringBuilder</code>. </p><pre><code>func void SBflt(var float x)\n</code></pre> Parameters <ul> <li><code>var float x</code>     The appended Daedalus float value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sbf","title":"<code>SBf</code>","text":"<p>Appends an Ikarus float in text form, to the active <code>StringBuilder</code>. </p><pre><code>func void SBf(var int x)\n</code></pre> Parameters <ul> <li><code>var float x</code>     The appended Ikarus float value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#sbw","title":"<code>SBw</code>","text":"<p>Appends a 4-byte raw data (interpreted as an integer <code>x</code>), to the active <code>StringBuilder</code>. </p><pre><code>func void SBw(var int x)\n</code></pre> Parameters <ul> <li><code>var int i</code>     The appended value</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#independent-functions","title":"Independent Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#str_escape","title":"<code>STR_Escape</code>","text":"<p>Makes escape sequences out of non-writable characters. For example, newline character <code>\\n</code> becomes <code>\\\\n</code>, tab character <code>\\t</code> becomes <code>\\\\t</code>, etc. </p><pre><code>func string STR_Escape(var string s0)\n</code></pre> Parameters <ul> <li><code>var string s0</code>     The string to be added escape sequences</li> </ul> <p>Return value</p> <p>The function returns a new string with escape sequences added for special characters.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#str_unescape","title":"<code>STR_Unescape</code>","text":"<p>Counterpart to <code>STR_Escape</code>. Escape sequences like <code>\\n</code>, <code>\\r</code> or <code>\\t</code> are converted back.  </p><pre><code>func string STR_Unescape(var string s0)\n</code></pre> Parameters <ul> <li><code>var string s0</code>     The string to be removed escape sequences</li> </ul> <p>Return value</p> <p>The function returns a new string with escape sequences replaced by their corresponding characters.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#str_startswith","title":"<code>STR_StartsWith</code>","text":"<p>Checks if the input string <code>s</code> starts with the specified prefix string. </p><pre><code>func int STR_StartsWith(var string str, var string start) </code></pre> Parameters <ul> <li><code>var string str</code>     The string to be checked</li> <li><code>var string start</code>     The searched prefix</li> </ul> <p>Return value</p> <p>The function returns <code>TRUE</code> if the string starts with the prefix, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#additional-functions","title":"Additional Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#buildstringsymbolsarray","title":"<code>BuildStringSymbolsArray</code>","text":"<p>Creates an array of all string symbols found in the parser's string table. </p><pre><code>func int BuildStringSymbolsArray()\n</code></pre> Return value <p>The function returns created array.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#getstringsymbolbyaddr","title":"<code>GetStringSymbolByAddr</code>","text":"<p>Retrieves the symbol at the specified address from the string table. </p><pre><code>func int BuildStringSymbolsArray()\n</code></pre> Return value <p>The function returns a parser symbol at the given address.</p>"},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#basic-functionality","title":"Basic functionality","text":"<p>This is how function that builds a string looks without <code>StringBuilder</code>: </p><pre><code>func void PrintMyNumbers(var int x0, var int x1, var int x2) {\nvar string res;\nres = ConcatStrings(IntToString(x0), \", \");\nres = ConcatStrings(res, IntToString(x1));\nres = ConcatStrings(res, \", \");\nres = ConcatStrings(res, IntToString(x2));\nPrintS(res);\n};\n</code></pre> And now the function that uses <code>StringBulider</code>: <pre><code>func void PrintMyNumbers(var int x0, var int x1, var int x2) {\nvar int s; s = SB_New();  // Create StringBuilder\nSBi(x0);                  // Append Int\nSB (\", \");                // Append string\nSBi(x1);                  // Append Int\nSB (\", \");                // Append string\nSBi(x2);                  // Append Int\nPrintS(SB_ToString());    // Get output as a string\nSB_Destroy();             // Destroy StringBuilder\n};\n</code></pre> Looks much more pleasant, right? But why do we create a StringBuilder and then not use it? The idea is the following: A StringBuilder is created with <code>SB_New()</code> and set as the active StringBuilder in the background. The package only supports one StringBuilder at a time, which will keep the pointer in case we want to use another StringBuilder in between."},{"location":"zengin/scripts/extenders/lego/tools/string_builder/#multiple-stringbuilders","title":"Multiple StringBuilders","text":"<p>Simple example. We want to fill two StringBuilders at the same time and then return them combined: </p><pre><code>func string Example2() {\n// Create two StringBuilders:\nvar int s0; s0 = SB_New();\nvar int s1; s1 = SB_New();\n// Set the first StringBuilder as active and fill it.\nSB_Use(s0);\nSB(\"Hello \");\nSB(\"World!\");\n// Set the second StringBuilder as active and fill it.\nSB_Use(s1);\nSB(\"This is \");\nSB(\"the hero speaking!\");\n// Now we want to combine the two StringBuilders.\n// The system doesn't actually provide for such an operation, but it can still be done using a helper string\nvar string str; str = SB_ToString(); // This string now says \u201cThis is the hero speaking!\u201d\nSB_Use(s0);\nSB(\" \");\nSB(str);\nstr = SB_ToString(); // Now \"Hello world! This is the hero speaking!\" are in the string.\n// The rest is already known, we destroy StringBuilders\nSB_Destroy();\nSB_Use(s1);\nSB_Destroy();\nreturn str;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/talents/","title":"Talents","text":""},{"location":"zengin/scripts/extenders/lego/tools/talents/#talents","title":"Talents","text":"<p>The Talents package does two things:</p> <ol> <li>save any number of values for a specific NPC (effectively AIVar array extension).</li> <li>identify NPC by unique ID.</li> </ol> <p>Talents package uses one free AIVar variables, the default is AIVar with the index 89 that can be customized in <code>Userconst.d</code> the <code>AIV_TALENT</code> constant.</p>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_PermMem</code> flag. </p><pre><code>LeGo_Init(LeGo_PermMem);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#implementation","title":"Implementation","text":"<p> Talents.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/talents/#npc_getid","title":"<code>Npc_GetID</code>","text":"<p>Returns unique ID specific for provided NPC.</p> <p></p><pre><code>func int Npc_GetID(var C_NPC slf)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC to get ID</li> </ul> <p>Return value</p> <p>The function returns NPCs unique ID.</p>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#npc_findbyid","title":"<code>Npc_FindByID</code>","text":"<p>Finds the NPC pointer of an NPC with the given ID. </p><pre><code>func int Npc_FindByID(var int ID)\n</code></pre> Parameters <ul> <li><code>var int ID</code>     NPC ID</li> </ul> <p>Return value</p> <p>The function returns NPC pointer.</p>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#tal_createtalent","title":"<code>TAL_CreateTalent</code>","text":"<p>Creates a talent into which you can later save a value for every NPC (just like <code>AI_Var</code>). </p><pre><code>func int TAL_CreateTalent()\n</code></pre> Return value <p>The function returns value that can be later used as a talent ID.</p>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#tal_setvalue","title":"<code>TAL_SetValue</code>","text":"<p>Sets a new value to the specified talent. </p><pre><code>func void TAL_SetValue(var C_NPC npc, var int talent, var int value)\n</code></pre> Parameters <ul> <li><code>var C_NPC npc</code>     Set the talent value for this NPC</li> <li><code>var int talent</code>     Talent ID</li> <li><code>var int value</code>     Value to be set</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/talents/#tal_getvalue","title":"<code>TAL_GetValue</code>","text":"<p>Returns the value of a saved talent for specified NPC. </p><pre><code>func int TAL_GetValue(var C_NPC npc, var int talent)\n</code></pre> Parameters <ul> <li><code>var C_NPC npc</code>     Get the talent value from this NPC</li> <li><code>var int talent</code>     Talent ID</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/timer/","title":"Timer","text":""},{"location":"zengin/scripts/extenders/lego/tools/timer/#timer","title":"Timer","text":"<p>Timer is a better alternative to the timers that Gothic offers. The FrameFunctions and Anim8 packages are already based on it. It isn't possible to modify the current time, as this would only cause difficulties.</p>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#dependencies","title":"Dependencies","text":"<p>N/A</p>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_Timer</code> flag. </p><pre><code>LeGo_Init(LeGo_Timer);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#implementation","title":"Implementation","text":"<p> Timer.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/timer/#timer_1","title":"<code>Timer</code>","text":"<p>Returns the current playing time. If a new game is started, the time is 0. It is measured in milliseconds. </p><pre><code>func int Timer()\n</code></pre> Return value <p>The function returns current playing time in milliseconds.</p>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#timergt","title":"<code>TimerGT</code>","text":"<p>Returns the current game time, but the timer is paused when the game is paused (in the menu or status screen). </p><pre><code>func int TimerGT()\n</code></pre> Return value <p>The function returns current playing time in milliseconds, but without measuring time when game is paused.</p>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#timerf","title":"<code>TimerF</code>","text":"<p>Alias to <code>Timer</code> function that returns the time as an Ikarus float value. </p><pre><code>func int TimerF()\n</code></pre> Return value <p>The function returns current playing time as an Ikarus float value.</p>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#timer_setpause","title":"<code>Timer_SetPause</code>","text":"<p>Pauses the timer (and thus all FrameFunctions and running animations). </p><pre><code>func void Timer_SetPause(var int on)\n</code></pre> Parameters <ul> <li><code>var int on</code>     Pause on/off</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#timer_setpauseinmenu","title":"<code>Timer_SetPauseInMenu</code>","text":"<p>The timer can automatically pause when the game is paused. (status screen, main menu...) </p><pre><code>func void Timer_SetPauseInMenu(var int on)\n</code></pre> Parameters <ul> <li><code>var int on</code>     Automatic pause on/off</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/timer/#timer_ispaused","title":"<code>Timer_IsPaused</code>","text":"<p>This can be used to query whether the timer is paused. </p><pre><code>func int Timer_IsPaused()\n</code></pre> Return value <p>The function returns <code>TRUE</code> if the timer is paused, <code>FALSE</code> is returned otherwise.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/","title":"View","text":""},{"location":"zengin/scripts/extenders/lego/tools/view/#view","title":"View","text":"<p>This package can create textures on the screen and work with them in an extended manner.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#dependencies","title":"Dependencies","text":"<ul> <li>PermMem</li> <li>Interface</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#initialization","title":"Initialization","text":"<p>Initialize with <code>LeGo_View</code> flag. </p><pre><code>LeGo_Init(LeGo_View);\n</code></pre>"},{"location":"zengin/scripts/extenders/lego/tools/view/#implementation","title":"Implementation","text":"<p> View.d on GitHub</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#functions","title":"Functions","text":""},{"location":"zengin/scripts/extenders/lego/tools/view/#view_create","title":"<code>View_Create</code>","text":"<p>Creates a <code>zCView</code> with virtual coordinates. </p><pre><code>func int View_Create(var int x1, var int y1, var int x2, var int y2) </code></pre> Parameters <ul> <li><code>var int x1</code>/<code>var int y1</code>      Top-left corner coordinates (virtual)</li> <li><code>var int x2</code>/<code>var int y2</code>      Bottom-right corner coordinates (virtual)</li> </ul> <p>Return value</p> <p>The function returns a PermMem handle to a <code>zCView</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_createpxl","title":"<code>View_CreatePxl</code>","text":"<p>Alias for <code>View_Create</code> using pixel coordinates. </p><pre><code>func int View_CreatePxl(var int x1, var int y1, var int x2, var int y2) </code></pre> Parameters <ul> <li><code>var int x1</code>/<code>var int y1</code>      Top-left corner coordinates (pixel)</li> <li><code>var int x2</code>/<code>var int y2</code>      Bottom-right corner coordinates (pixel)</li> </ul> <p>Return value</p> <p>The function returns a PermMem handle to a <code>zCView</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_createcenter","title":"<code>View_CreateCenter</code>","text":"<p>Creates a <code>zCView</code> with virtual coordinates centered. </p><pre><code>func int View_CreateCenter(var int x, var int y, var int width, var int height)\n</code></pre> Parameters <ul> <li><code>var int x</code>      Horizontal position</li> <li><code>var int y</code>      Vertical position</li> <li><code>var int width</code>      Width of the view</li> <li><code>var int height</code>      Height of the view</li> </ul> <p>Return value</p> <p>The function returns a PermMem handle to a <code>zCView</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_createcenterpxl","title":"<code>View_CreateCenterPxl</code>","text":"<p>Alias for <code>View_CreateCenter</code> using pixel coordinates. </p><pre><code>func int View_CreateCenterPxl(var int x, var int y, var int width, var int height)\n</code></pre> Parameters <ul> <li><code>var int x</code>      Horizontal position</li> <li><code>var int y</code>      Vertical position</li> <li><code>var int width</code>      Width of the view</li> <li><code>var int height</code>      Height of the view</li> </ul> <p>Return value</p> <p>The function returns a PermMem handle to a <code>zCView</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_get","title":"<code>View_Get</code>","text":"<p>Alias for <code>get</code> form PermMem. </p><pre><code>zCView View_Get(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_getptr","title":"<code>View_GetPtr</code>","text":"<p>Alias for <code>getPtr</code> form PermMem. </p><pre><code>func int View_GetPtr(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_render","title":"<code>View_Render</code>","text":"<p>Renders a <code>zCView</code>. Should be used sparingly, as it works only in specific cases. </p><pre><code>func void View_Render(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_settexture","title":"<code>View_SetTexture</code>","text":"<p>Assigns a texture to a view. The key function of this package. </p><pre><code>func void View_SetTexture(var int hndl, var string texture)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var string texture</code>      Filename of a texture</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_gettexture","title":"<code>View_GetTexture</code>","text":"<p>Gets the name of a previously assigned texture. </p><pre><code>func string View_GetTexture(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul> <p>Return value</p> <p>The function returns the previously assigned texture.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_setcolor","title":"<code>View_SetColor</code>","text":"<p>Sets the color of a view. </p><pre><code>func void View_SetColor(var int hndl, var int color)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int color</code>      zColor, can be created with RGBA</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_getcolor","title":"<code>View_GetColor</code>","text":"<p>Gets the color of a view. </p><pre><code>func int View_GetColor(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul> <p>Return value</p> <p>The function returns the full zColor.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_open","title":"<code>View_Open</code>","text":"<p>Opens a view. It will be displayed on the screen. </p><pre><code>func void View_Open(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_close","title":"<code>View_Close</code>","text":"<p>Closes a view. It disappears from the screen but can still be used. </p><pre><code>func void View_Close(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_delete","title":"<code>View_Delete</code>","text":"<p>Alias for <code>delete</code>. </p><pre><code>`zCView` View_Delete(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_resize","title":"<code>View_Resize</code>","text":"<p>Scales a view to a virtual size. The top-left position of the view remains fixed. </p><pre><code>func void View_Resize(var int hndl, var int width, var int height)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int width</code>      New width of the view</li> <li><code>var int height</code>      New height of the view</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_resizepxl","title":"<code>View_ResizePxl</code>","text":"<p>Alias for <code>View_Resize</code> using pixel coordinates. </p><pre><code>func void View_ResizePxl(var int hndl, var int width, var int height)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int width</code>      New width of the view</li> <li><code>var int height</code>      New height of the view</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_move","title":"<code>View_Move</code>","text":"<p>Moves the view by virtual units. </p><pre><code>func void View_Move(var int hndl, var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int x</code>      Shift left/right</li> <li><code>var int y</code>      Shift up/down</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_movepxl","title":"<code>View_MovePxl</code>","text":"<p>Alias for <code>View_Move</code> using pixel coordinates. </p><pre><code>func void View_MovePxl(var int hndl, var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int x</code>      Shift left/right</li> <li><code>var int y</code>      Shift up/down</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_moveto","title":"<code>View_MoveTo</code>","text":"<p>Moves the top-left corner of the view to a virtual position. </p><pre><code>func void View_MoveTo(var int hndl, var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int x</code>      New horizontal position (-1 for no change)</li> <li><code>var int y</code>      New vertical position (-1 for no change)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_movetopxl","title":"<code>View_MoveToPxl</code>","text":"<p>Alias for <code>View_MoveTo</code> using pixel coordinates. </p><pre><code>func void View_MoveToPxl(var int hndl, var int x, var int y)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int x</code>      New horizontal position (-1 for no change)</li> <li><code>var int y</code>      New vertical position (-1 for no change)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_addtext","title":"<code>View_AddText</code>","text":"<p>Adds a text line to the view. The position is virtual and relative to the view's position. If the view is moved, the text moves as well. </p><pre><code>func void View_AddText(var int hndl, var int x, var int y, var string text, var string font)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>      Handle created with <code>View_Create</code></li> <li><code>var int x</code>      Horizontal position</li> <li><code>var int y</code>      Vertical position</li> <li><code>var string text</code>      Added text</li> <li><code>var string font</code>      Used Font</li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_deletetext","title":"<code>View_DeleteText</code>","text":"<p>Removes all text added with <code>View_AddText</code>. </p><pre><code>func void View_DeleteText(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>        Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#view_top","title":"<code>View_Top</code>","text":"<p>Places the view above all others. </p><pre><code>func void View_Top(var int hndl)\n</code></pre> Parameters <ul> <li><code>var int hndl</code>        Handle created with <code>View_Create</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/tools/view/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/lego/tools/view/#display-a-texture-on-the-screen","title":"Display a texture on the screen","text":"<p>Here a texture should be displayed over the entire screen: </p><pre><code>func void Example1() {\nvar int View; View = View_Create(0, 0, PS_VMax, PS_VMax); // Virtual coordinates\nView_SetTexture(View, \"MyTexture.tga\"); // Assign a texture to the view\n// display the view on the screen:\nView_Open(View);\n};\n</code></pre> <p>This would mean that the texture would be permanently visible on the screen (even after loading/saving/restarting). If we want it to disappear we have to use either <code>View_Delete</code> or <code>View_Close</code>.</p>"},{"location":"zengin/scripts/extenders/lego/tools/view/#display-a-texture-with-pixel-coordinates","title":"Display a texture with pixel coordinates","text":"<p>Now a texture should be displayed at the top right and be 256 x 256 pixels in size: </p><pre><code>func void Example2() {\nPrint_GetScreenSize();\nvar int View;\nView = View_CreatePxl(Print_Screen[PS_X] - 256, 0, Print_Screen[PS_X], 256); // Pixel coordinates\nView_SetTexture(View, \"MYTEXTURE.TGA\");\nView_Open(View);\n};\n</code></pre> <p>To get the size of the screen we use the interface package.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/","title":"User constants","text":""},{"location":"zengin/scripts/extenders/lego/various/userconstants/#user-constants","title":"User constants","text":"<p>All constants that the user can either use or even change freely are defined in Userconst.d file.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#read-only","title":"Read only","text":"<p>These constants may only be used, not changed.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#anim8","title":"Anim8","text":"<p>These constants are used by Anim8 and Anim8q.</p> <ul> <li><code>const int A8_Constant</code>     Constant movement speed</li> <li><code>const int A8_SlowEnd</code>     Evenly decelerated movement</li> <li><code>const int A8_SlowStart</code>     Evenly accelerated movement</li> <li><code>const int A8_Wait</code>     Do nothing. The target value is ignored here</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#buttons","title":"Buttons","text":"<p>The following bit masks can be applied to the status of a button:</p> <ul> <li><code>const int BUTTON_ACTIVE</code>     The button is active, it reacts to the mouse</li> <li><code>const int BUTTON_ENTERED</code>     The mouse is \"within\" the button</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#interface","title":"Interface","text":"<p>Dimensions</p> <ul> <li><code>const int PS_X</code> and <code>const int PS_Y</code>     Use with <code>Print_Screen</code> or <code>Print_ToVirtual</code> functions</li> <li><code>const int PS_VMax</code>     Highest possible value of a virtual coordinate</li> </ul> <p>Colors</p> <p>16 basic colors that can be used as <code>zColor</code> parameters</p> <ul> <li><code>const int COL_Aqua</code></li> <li><code>const int COL_Black</code></li> <li><code>const int COL_Blue</code></li> <li><code>const int COL_Fuchsia</code></li> <li><code>const int COL_Gray</code></li> <li><code>const int COL_Green</code></li> <li><code>const int COL_Lime</code></li> <li><code>const int COL_Maroon</code></li> <li><code>const int COL_Navy</code></li> <li><code>const int COL_Olive</code></li> <li><code>const int COL_Purple</code></li> <li><code>const int COL_Red</code></li> <li><code>const int COL_Silver</code></li> <li><code>const int COL_Teal</code></li> <li><code>const int COL_White</code></li> <li><code>const int COL_Yellow</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#gamestate","title":"Gamestate","text":"<p>Gamestate can assume these values:</p> <ul> <li><code>const int Gamestate_NewGame</code>     New game started</li> <li><code>const int Gamestate_Loaded</code>     A game has been loaded</li> <li><code>const int Gamestate_WorldChange</code>     The world has changed</li> <li><code>const int Gamestate_Saving</code>     The game is saved</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#cursor","title":"Cursor","text":"<p>These constants are sent with <code>Cursor_Event</code>:</p> <ul> <li><code>const int CUR_LeftClick</code>     The left mouse button was pressed</li> <li><code>const int CUR_RightClick</code>     The right mouse button was pressed</li> <li><code>const int CUR_MidClick</code>     The middle mouse button was pressed</li> <li><code>const int CUR_WheelUp</code>     Mouse wheel up</li> <li><code>const int CUR_WheelDown</code>     Mouse wheel down</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#modifiable","title":"Modifiable","text":"<p>These constants are often used by packages and may be changed freely.</p>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#bloodsplats","title":"Bloodsplats","text":"<ul> <li><code>const int BLOODSPLAT_NUM</code>     Maximum number on screen</li> <li><code>const int BLOODSPLAT_TEX</code>     Highest Texture ID (<code>\"BLOODSPLAT\" + texID + \".TGA\"</code>)</li> <li><code>const int BLOODSPLAT_DAM</code>     Texture size damage multiplier (<code>damage * 2</code><code>Bloodsplat_Dam</code>)</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#cursor_1","title":"Cursor","text":"<ul> <li><code>const string Cursor_Texture</code>     This texture is used to display the cursor (default: \"CURSOR.TGA\")</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#interface_1","title":"Interface","text":"<ul> <li><code>const string Print_LineSeperator</code>     Text boxes can be printed in multiple lines. This character separates the lines from each other.</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#prints","title":"PrintS","text":"<p>All position and size information is completely virtual:</p> <ul> <li><code>const int PF_PrintX</code>     Start position on the X axis</li> <li><code>const int PF_PrintY</code>     Start position on the Y axis</li> <li><code>const int PF_TextHeight</code>     Space between individual lines</li> </ul> <p>The times are given in ms:</p> <ul> <li><code>const int PF_FadeInTime</code>     Time to fade in the text</li> <li><code>const int PF_FadeOutTime</code>     Time to fade out the text</li> <li><code>const int PF_MoveYTime</code>     Time needed to \"slip down\"</li> <li><code>const int PF_WaitTime</code>     Time during which the print is fully visible</li> </ul> <p>The font can be modified:</p> <ul> <li><code>const string PF_Font</code>     Default: <code>FONT_OLD_10_WHITE.TGA</code></li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#talents","title":"Talents","text":"<ul> <li><code>const int AIV_TALENT</code>     Used AIVar</li> </ul>"},{"location":"zengin/scripts/extenders/lego/various/userconstants/#dialoggestures","title":"Dialoggestures","text":"<ul> <li><code>const string DIAG_Prefix</code>     Animation prefix (\"DG_\")</li> <li><code>const string DIAG_Suffix</code>     Animation suffix (\"_\")</li> </ul>"},{"location":"zengin/scripts/extenders/standalone/","title":"Standalone Scripts","text":""},{"location":"zengin/scripts/extenders/standalone/#standalone-scripts","title":"Standalone Scripts","text":"<p>Over the years Gothic modders have created many useful features to use with Zengin scripts. This section contains documentation for some scripts that are \"standalone\", meaning they are not part of larger packages, but are often small features to make modders lives easier.</p>"},{"location":"zengin/scripts/extenders/standalone/#script-bins","title":"Script Bins","text":"<p>A few people came up with the idea of collecting scripts scattered on the forums, which resulted in the so-called Script Bins.</p> <p>Warning</p> <p>Script bins aren't updated frequently, so for the latest updates and new scripts also check the ScriptBin WoG thread.</p>"},{"location":"zengin/scripts/extenders/standalone/#wog-script-bin","title":"WoG Script Bin","text":"<p>Script bin made by Kirides containing scripts from German WoG forum.</p> <p>https://apps.kirides.de/wog-script-bin/</p>"},{"location":"zengin/scripts/extenders/standalone/#scriptbin-github-repository","title":"ScriptBin GitHub repository","text":"<p>Lehona has created a GitHub repository that contains scripts from some of the modders.</p> <p>https://github.com/Lehona/ScriptBin</p>"},{"location":"zengin/scripts/extenders/standalone/gameKeyEvents/","title":"gameKeyEvents","text":""},{"location":"zengin/scripts/extenders/standalone/gameKeyEvents/#gamekeyevents","title":"gameKeyEvents","text":"<p>Quick overview</p> <p>Author: mud-freak Platform: G1, G2NotR Category: Engine, Keys</p> <p>gameKeyEvents.d is a script, which handles key events with the <code>oCGame::HandleEvent</code> hook. Better alternative for <code>FrameFunction</code> with <code>MEM_KeyState</code> with which you don't have to check whether any menu is opened or player is in dialogue or can move etc.</p> Author's description <p>I looked up the address within <code>oCGame::HandleEvent</code>. I made it into a universally usable script for Gothic 1 and Gothic 2.</p> <p>One could argue now that this is not much different from a <code>FrameFunction</code> with <code>MEM_KeyState</code>. The difference is that this approach saves the extra work of checking if any menu is open, whether the player is in a dialog, whether the player may move, etc. Also this function is \"event driven\", meaning it is really only called when a key is pressed/held instead of every frame in vain. So it's arguably more performant.</p>"},{"location":"zengin/scripts/extenders/standalone/gameKeyEvents/#dependencies","title":"Dependencies","text":"<ul> <li>Ikarus</li> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/standalone/gameKeyEvents/#initialization","title":"Initialization","text":"<p>Call <code>Game_KeyEventInit()</code> in the <code>Init_Global()</code> or other initialization function. </p><pre><code>Game_KeyEventInit();\n</code></pre>"},{"location":"zengin/scripts/extenders/standalone/gameKeyEvents/#implementation","title":"Implementation","text":"<p> gameKeyEvents.d on WoG forum</p>"},{"location":"zengin/scripts/extenders/standalone/gameKeyEvents/#usage","title":"Usage","text":"<p>To add a key pressing detection edit the main function <code>Game_KeyEvent</code>. </p><pre><code>func int Game_KeyEvent(var int key, var int pressed) {\nif (key == KEY_LBRACKET) &amp;&amp; (pressed) {\n// Here enter your code.\nreturn TRUE;\n};\nreturn FALSE;\n};\n</code></pre> <ul> <li>To change detected key rename <code>KEY_LBRACKET</code> to your own key e.g. taken from Ikarus constants.</li> <li>To detect pressing a key leave <code>(pressed)</code> unchanged but if you want to detect holding change it to <code>(!pressed)</code>. That's because  <p>pressed is FALSE: key is held, pressed is TRUE: key press onset</p> </li> <li>To run code when a key is pressed, paste it or call a function where the comment is.</li> <li>To detect more than one key add <code>else if</code>.</li> </ul>"},{"location":"zengin/scripts/extenders/standalone/setBarPositions/","title":"setBarPositions","text":""},{"location":"zengin/scripts/extenders/standalone/setBarPositions/#setbarpositions","title":"setBarPositions","text":"<p>Quick overview</p> <p>Author: mud-freak Platform: G1, G2NotR Category: Engine, Interface</p> <p>setBarPositions.d is a script that allows changing position of original gothic bars (HP, Mana, Swim, focus). Changes are directly in the engine, so bars are normally scaled.</p>"},{"location":"zengin/scripts/extenders/standalone/setBarPositions/#dependencies","title":"Dependencies","text":"<ul> <li>Ikarus</li> <li>HookEngine</li> </ul>"},{"location":"zengin/scripts/extenders/standalone/setBarPositions/#initialization","title":"Initialization","text":"<p>Call it in the <code>Init_Global()</code> or other initialization function. Set the <code>manaAlwaysOn</code> and <code>swimAlwaysOn</code> to TRUE/FALSE. </p><pre><code>SetBarPositions_Init(manaAlwaysOn, swimAlwaysOn);\n</code></pre>"},{"location":"zengin/scripts/extenders/standalone/setBarPositions/#implementation","title":"Implementation","text":"<p> setBarPositions.d on WoG forum</p>"},{"location":"zengin/scripts/extenders/standalone/setBarPositions/#usage","title":"Usage","text":"<p>To change positions of bars edit the main function <code>SetBarPosition</code>. Look at the examples to see how you can adjust it to your preferences. </p><pre><code>func int SetBarPosition(var int barPtr) {\nvar oCViewStatusBar bar; bar = _^(barPtr);\nvar int x; var int y;\nif (barPtr == MEM_Game.hpBar) {\n// Original\nx = Print_ToVirtual(10, PS_X);                                // 10 px from the left\ny = PS_VMax - Print_ToVirtual(10 + bar.zCView_psizey, PS_Y);  // 10 px from the bottom\n} else if (barPtr == MEM_Game.manaBar) {\n// Original\nx = PS_VMax - Print_ToVirtual(10 + bar.zCView_psizex, PS_X);  // 10 px from the right\ny = PS_VMax - Print_ToVirtual(10 + bar.zCView_psizey, PS_Y);  // 10 px from the bottom\n} else if (barPtr == MEM_Game.swimBar) {\n// Original\nx = (PS_VMax - bar.zCView_vsizex) / 2;                        // Centered\ny = PS_VMax - Print_ToVirtual(10 + bar.zCView_psizey, PS_Y);  // 10 px from the bottom\n} else if (barPtr == MEM_Game.focusBar) {\n// Original\nx = (PS_VMax - bar.zCView_vsizex) / 2;                        // Centered\ny = Print_ToVirtual(10, PS_Y);                                // 10 px from the top\n};\nreturn x | (y &lt;&lt; 14);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/standalone/setBarPositions/#examples","title":"Examples","text":""},{"location":"zengin/scripts/extenders/standalone/setBarPositions/#all-bars-on-the-left-side","title":"All bars on the left side","text":"<pre><code>/*\n * EXAMPLE: Stacked on the left\n */\nfunc int SetBarPosition(var int barPtr) {\nvar oCViewStatusBar bar; bar = _^(barPtr);\nvar int x; var int y;\nif (barPtr == MEM_Game.hpBar) {\nx = Print_ToVirtual(10, PS_X);\ny = PS_VMax - Print_ToVirtual(6 + 3 * (4 + bar.zCView_psizey), PS_Y);\n} else if (barPtr == MEM_Game.manaBar) {\nx = Print_ToVirtual(10, PS_X);\ny = PS_VMax - Print_ToVirtual(6 + 2 * (4 + bar.zCView_psizey), PS_Y);\n} else if (barPtr == MEM_Game.swimBar) {\nx = Print_ToVirtual(10, PS_X);\ny = PS_VMax - Print_ToVirtual(6 + 1 * (4 + bar.zCView_psizey), PS_Y);\n} else if (barPtr == MEM_Game.focusBar) {\n// Original\nx = (PS_VMax - bar.zCView_vsizex) / 2;                        // Centered\ny = Print_ToVirtual(10, PS_Y);                                // 10 px from the top\n};\nreturn x | (y &lt;&lt; 14);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/","title":"zParserExtender","text":""},{"location":"zengin/scripts/extenders/zparserextender/#zparserextender","title":"zParserExtender","text":"<p>zParserExtender extends ZenGins parser and adds many useful features. It significantly extends the functionality of scripts with added functionality and new external functions. It also enhances script compilation, allowing to compile OU files directly with the game and allowing for runtime script injection. Since the Union version <code>1.0m</code> zParserExtender is fully integrated in Union itself.</p> <p>Note</p> <p>This is mostly a translation of the original release post</p> Contacts Author  Gratt GitHub  zParserExtender Forum  zParserExtender"},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/","title":"C_Trigger class","text":""},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/#trigger-functions-and-the-c_trigger-class","title":"Trigger functions and the <code>C_Trigger</code> class","text":"<p>zParserExtender also implements cyclical functions called triggers - not to be confused with triggers in ZEN files, similar to a part of the functionality implemented in LeGo AI_Functions. These functions are called independently after a specified period of time. These triggers can also store user information. Up to 16 int variables can be stored in each trigger as well as <code>self</code>, <code>other</code> and <code>victim</code> instances.</p>"},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/#class-definition","title":"Class definition","text":"<p>To define a trigger, the <code>C_Trigger</code> class is used:</p> <pre><code>/// Union zPraserExtender Trigger class\nclass C_Trigger\n{\nvar int Delay; // defines the frequency (in miliseconds) at which the function will be called.\nvar int Enabled; // determines if the trigger is active. If the value is equal to zero, the trigger is destroyed.\nvar int AIVariables[16]; // user data, which can be set independently when creating trigger (yes, you can write there absolutely everything you want).\n// Hidden variable members\n/*\n        - Func   - The function that the trigger will call.\n        - Self   - The NPC that will be placed in `self` when the function is called.\n        - Other  - An NPC that will be placed in `other` when the function is called.\n        - Victim - The NPC that will be placed in `victim` when the function is called.\n    */\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/#creating-instances","title":"Creating instances","text":"<p>There are two external functions that are used to create <code>C_Trigger</code> instance.</p> <pre><code>// function returns a trigger with no NPC (self, other or victim) bound to it\nfunc C_Trigger AI_StartTriggerScript(   var string funcName,\nvar int delay) {};\n// function is extended, if certain participants need to be assigned to it\nfunc C_Trigger AI_StartTriggerScriptEx( var string funcName,\nvar int delay,\nvar C_Npc slf,\nvar C_Npc oth,\nvar C_Npc vct) {};\n</code></pre> <p>Both of these functions return an instance of <code>C_Trigger</code> instance. You can of course configure the instance after its creation. You can, for example, fill in the <code>AIVariables</code> with relevant data. The trigger function has the required signature if 'func int f()'. It must return a value indicating the state of the loop. If the function returns <code>LOOP_END</code> the trigger will be stopped and the instance deleted. If <code>LOOP_CONTINUE</code> is returned, the function will be called again after <code>Delay</code> ms have passed.</p>"},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/#poison-example","title":"Poison example","text":"<pre><code>// Implement a trigger to simulate the effect of poison debuff:\n// Let's create a trigger on function `c_loop` with a call interval of 1 second.\n// When the function is called, the instance hero will be placed in self (although it can be any other NPC if desired).\n// The rest of the instances are left null (not used).\nvar C_Trigger trigger;\ntrigger = AI_StartTriggerScriptEx(\"c_loop\", 1000, hero, null, null);\ntrigger.AIVariables[0] = 15; // how many times the function should be called\ntrigger.AIVariables[1] = 5;  // how much damage to deal each iteration\n</code></pre> <p>The trigger function</p> <pre><code>func int c_loop()\n{\n// Create a loop end check, if the number of\n// available iterations has reached 0. If it did\n// we stop the trigger by returning the LOOP_END value.\nif (SelfTrigger.AIVariables[0] &lt;= 0)\n{\nreturn Loop_end;\n};\nSelfTrigger.Delay -= 20;         // Accelerate loop each call by 20 ms\nSelfTrigger.AIVariables[0] -= 1; // Reduce number of remaining repeats\nself.Attribute[ATR_HITPOINTS] -= SelfTrigger.AIVariables[1]; // Take health from self\nreturn LOOP_CONTINUE;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/#trigger-scope","title":"Trigger scope","text":"<p>Triggers can be divided into two types:</p> <ul> <li>Global trigger ( AI_StartTriggerScript ) trigger created using this function works in all worlds. A trigger is considered global by default if neither <code>self</code> nor <code>other</code> nor <code>victim</code> has been provided for it.</li> <li>Local trigger ( AI_StartTriggerScriptEx) trigger created with this function only works in the world in which it was created. A trigger is considered local if it has been presented with at least one NPC in <code>self</code>, <code>other</code> or <code>victim</code> (not null). If you want to create a trigger without linking it to any NPC, it is recommended to simply pass hero as <code>self</code> to the trigger.</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/#saving","title":"Saving","text":"<p>The plugin creates a new save archive to save the information of the triggers that does not conflict with any of the built-in save files.</p>"},{"location":"zengin/scripts/extenders/zparserextender/classes/c_trigger/#searching","title":"Searching","text":"<p>To search for a specific trigger, for example by NPC, the trigger external functions can be used.</p> <pre><code>// This way you can disable all triggers running on the `hero` instance\nvar C_Trigger trigget = FirstTrigger;\nvar C_Trigger trigget_saved;\nwhile (!Hlp_IsNULL(trigget))\n{\ntrigget_saved = trigger;\ntrigger = AI_GetNextTriggerBySelf(hero);\ntrigget_saved.Enabled = false;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/","title":"Engine classes","text":""},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#engine-classes","title":"Engine classes","text":"<p>zParserExtender implements various proxy classes that can be used to access game world objects.</p> <p>Warning</p> <p>It is not recommended to implement complex mechanics using these classes and functions. They are present as a simple backup option for accessing game world objects and for quick fixes.</p>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_vob","title":"C_VOB","text":"<p>This class represents basic pointer to a game world object.</p>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_color","title":"C_Color","text":"<p>Represents color in the RGBA format </p><pre><code>class C_Color\n{\nvar int R; // red channel value\nvar int G; // green channel value\nvar int B; // blue channel value\nvar int A; // alpha channel value\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#zvec3","title":"zVEC3","text":"<p>Represents 3D position in the world (float version for internal functions) </p><pre><code>class zVEC3\n{\nvar float X; // X coordinate\nvar float Y; // Y coordinate\nvar float Z; // Z coordinate\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_position","title":"C_Position","text":"<p>Represents 3D position in the world </p><pre><code>class C_Position\n{\nvar int X; // X coordinate\nvar int Y; // Y coordinate\nvar int Z; // Z coordinate\n};\n</code></pre> Externals: <pre><code>/// Returns the current position of the object in the world\n/// \n/// @param vob vob to ge the position of\n/// @return C_Position instace - position of the VOB\nfunc C_Position Vob_GetVobPosition( var C_Vob vob ) {};\n/// Sets the current position of the object in the world\n/// \n/// @param vob vob to get the position of\n/// @param pos new position of the vob\nfunc void Vob_SetVobPosition( var C_Vob vob, var C_Position pos ) {};\n</code></pre> <p>Note</p> <p>The following classes define properties of <code>C_VOB</code> objects or classes derived from it.</p>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_vob_data","title":"C_VOB_DATA","text":"<p>Represents universal <code>zCVob</code> class </p><pre><code>class C_VOB_DATA\n{\nvar string Name;              // object name\nvar float VisualAlpha;        // object's transparency 0.0 - 1.0\nvar int ShowVisual;           // display the mode\nvar int DrawBBox3D;           // show objects bounding box\nvar int VisualAlphaEnabled;   // enables objects transparency\nvar int PhysicsEnabled;       // enables object's physics\nvar int IgnoredByTraceRay;    // allow any object collisions\nvar int CollDetectionStatic;  // allow collision with static world polygons\nvar int CollDetectionDynamic; // allow collision with dynamic world objects\nvar int CastDynShadow;        // display shadow of the object\nvar int LightColorStatDirty;  // allow static liging of the object\nvar int LightColorDynDirty;   // allow dynamic lighing of the object\nvar int SleepingMode;         // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only)\nvar int DontWriteIntoArchive; // turns of the serialization of this object to the save file \n};\n</code></pre> Externals: <pre><code>/// Returns the universal data of the zCVob object\n///\n/// @param vob VOB to get the position of\n/// @return general vob data C_Vob_Data\nfunc C_Vob_Data Vob_GetVobData( var C_Vob vob ) {};\n/// Sets the universal data to a zCVob object\n///\n/// @param vob VOB to get the position of\n/// @param data general vob data C_Vob_Data\nfunc void Vob_SetVobData( var C_Vob vob, var C_Vob_Data data ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_light_data","title":"C_LIGHT_DATA","text":"<p>Represents <code>zCVobLight</code> objects </p><pre><code>class C_LIGHT_DATA\n{\nvar int R;                // red light intensity\nvar int G;                // green light intensity\nvar int B;                // blue light intensity\nvar int Range;            // radius\nvar int RangeInv;         // \nvar int RangeBackup;      // \nvar int RangeAniActFrame; // current light animation frame for the radius\nvar int RangeAniFPS;      // speed of light animation for the radius\nvar int ColorAniActFrame; // current light animation frame for colour\nvar int ColorAniFPS;      // speed of light animation for colour\nvar int SpotConeAngleDeg; // angle of cone light source\nvar int IsStatic;         // whether the source is static\nvar int RangeAniSmooth;   // [UNUSED]\nvar int RangeAniLoop;     // [UNUSED]\nvar int ColorAniSmooth;   // allows soft transitions between colours\nvar int ColorAniLoop;     // [UNUSED]\nvar int IsTurnedOn;       // whether the light source is on\nvar int LightQuality;     // source quality (when statically compiling light) (0 - high, 1 - medium, 2 - low)\nvar int LightType;        // type of source (at static light compilation) (0 - point, 1 - cone)\n};\n</code></pre> Externals: <pre><code>/// Returns zCVobLight object data\n///\n/// @param vobLight vobLight object\n/// @return C_Light_Data of the light\nfunc C_Light_Data Vob_GetLightData( var C_Vob vobLight ) {};\n/// Sets the data of a zCVobLight object\n///\n/// @param vobLight object to apply the light data to\n/// @param data C_Light_Data light data to be set\nfunc void Vob_SetLightData( var C_Vob vobLight, var C_Light_Data data ) {};\n/// Clears the list of animation colours for the light source\n///\n/// @param vobLight light vob\nfunc void Vob_ClearLightAniList( var C_Vob vobLight ) {};\n/// Adds a color to the colour list\n///\n/// @param vobLight object to apply the colour to\n/// @param col colour to be applied\nfunc void Vob_AddLightAniColor( var C_Vob vobLight, var C_Color col ) {};\n/// Adds a color to the colour list\n///\n/// @param vobLight object to apply the colour to\n/// @param r red colour channel\n/// @param g green colour channel \n/// @param b blue colour channel\nfunc void Vob_AddLightAniColorRGB(  var C_Vob vobLight,\nvar int r,\nvar int g,\nvar int b ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_mob_data","title":"C_MOB_DATA","text":"<p>Represents  data for the used oCMOB object </p><pre><code>class C_MOB_DATA\n{\nvar string VisibleName;     // name shown above the object\nvar int Hitpoints;          // number of hitpoints\nvar int Damage;             // damage the object can cause\nvar int IsDestroyed;        // if the object is destroyed\nvar int Moveable;           // whether the object can be moved\nvar int Takeable;           // whether the object can be taken\nvar int FocusOverride;      // if the object will redefine focus in combat mode\nvar int SndMat;             // object's material (0 - wood, 1 - stone, 2 - metal, 3 - skin, 4 - clay, 5 - glass)\nvar string VisualDestroyed; // model when the object is destroyed\nvar string OwnerStr;        // name of the instance of the owner of the object\nvar string OwnerGuildStr;   // name of the guild of the object\nvar int Owner;              // instance of the owner\nvar int OwnerGuild;         // guild instance\nvar int FocusNameIndex;     // the script string of the displayed name\n};\n</code></pre> <pre><code>/// Returns the data of the oCMOB object\n///\n/// @param mob oCMOB object\n/// @return mob data\nfunc C_Mob_Data Vob_GetMobData( var C_Vob mob ) {};\n/// Sets the data of the oCMOB object\n///\n/// @param mob oCMOB object\n/// @param data C_Mob_Data to be set \nfunc void Vob_SetMobData( var C_Vob mob, var C_Mob_Data data ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_mobinter_data","title":"C_MOBINTER_DATA","text":"<p>Represents data for the interactive object <code>oCMobInter</code> </p><pre><code>class C_MOBINTER_DATA\n{\nvar string TriggerTarget;   // object name which will be triggered by OnTrigger\nvar string UseWithItem;     // name of the object instance that is needed for interaction\nvar string Sceme;           // name of the scene that corresponds to the object and character animations\nvar string ConditionFunc;   // scripting condition under which the interaction can be performed\nvar string OnStateFuncName; // the name pattern of the functions that will be called when the object changes the state\nvar int State;              // the current state of the object\nvar int State_num;          // number of object's states\nvar int State_target        // current state of the object\nvar int Rewind;             // prohibits object updating\nvar int MobStateAni;        // current animation of the object\nvar int NpcStateAni;        // current character animation\n};\n</code></pre> <pre><code>/// Returns the data of the oCMobInter object\n///\n/// @param mobInter oCMobInter object\n/// @return MobInter_Data of the object\nfunc MobInter_Data Vob_GetMobInterData( var C_Vob mobInter ) {};\n/// Sets the data of the oCMobInter object\n///\n/// @param mobInter oCMobInter object\n/// @param data MobInter_Data of the object\nfunc void Vob_SetMobInterData( var C_Vob mobInter, var C_MobInter_Data data ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/classes/helperclasses/#c_moblockable_data","title":"C_MOBLOCKABLE_DATA","text":"<p>Represents data for the locked interactive object <code>oCMobLockable</code> </p><pre><code>class C_MOBLOCKABLE_DATA\n{\nvar int Locked;         // whether the object is locked\nvar int AutoOpen;       // [UNUSED]\nvar int PickLockNr;     // current rotation number \nvar string KeyInstance; // key instance name for the object\nvar string PickLockStr; // combination to open the object (\"LRRLR\")\n};\n</code></pre> <pre><code>/// Returns the data of the oCMobLockable object\n///\n/// @param mobLock oCMobLockable object\n/// @param data MobInter_Data of the object\nfunc C_MobLockable_Data Vob_GetMobInterData( var C_Vob mobLock ) {};\n/// Sets the data of the oCMobLockable object\n///\n/// @param mobLock oCMobLockable object\n/// @param data C_MobLockable_Data of the object\nfunc void Vob_SetMobInterData( var C_Vob mobLock, var C_MobLockable_Data data ) {};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/","title":"Daedalus Injection","text":""},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/#daedalus-injection","title":"Daedalus Injection","text":"<p>Script injection is a process of injecting Daedalus scripts on runtime without the need to recompile the scripts. This is essential for Union plugins that need to alter the scripts in a certain way, either for hotfixes or just for testing scripts without the need to recompile the whole <code>.dat</code> file.</p> <p>To inject a script, simply put a <code>.d</code> or <code>.src</code> file in <code>Gothic/System/Autorun</code> directory and run the game.</p> <p>Tip</p> <p>Automatic injection does not extend to nested directories in the Autorun directory directly, but you can put a <code>.src</code> file into <code>Autorun</code> directory and the rest into a subdirectory to keep a cleaner structure.</p> <p>Scripts in subdirectories can be accessed in two ways</p> <ol> <li>They are specified in a <code>.src</code> file</li> <li>The script file is an API script</li> </ol>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/#api-script","title":"API script","text":"<p>API scripts are <code>.d</code> files placed in <code>Autorun</code> subdirectories and are used as a dependency. It is assumed that the API script is not called on its own (or from a <code>.src</code>) file, but is called using the dependency keyword <code>After</code> in one of the injected script files' META block.</p> <p>These scripts are meant to contain ready-made solution that need to be used by many other scripts as a dependency.</p> <p>Warning</p> <p>If the file specified in the <code>After</code> tag in the META block does not exist, the current file will not be parsed and injected since the dependency is missing, and it would fail. Due to this it is best to ship the dependency in the Autorun directory even if it comes from a different plugin.</p>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/hooks/","title":"Hooking","text":""},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/hooks/#hooking-daedalus","title":"Hooking Daedalus","text":"<p>Daedalus hooking is one of the most powerful features of this plugin. Hooking is a mechanism that allows you to replace any scripted object with a new one. To do this, you must define a new object with the same type, name and in the same namespace.</p> <p>Hook/replacement will be performed only if the <code>MergeMode</code> setting is set to true for the current script in the META block or in the parameter of the same name in the <code>.ini</code> file of the mod.</p> <p>Warning</p> <p>If you forget to turn on the <code>MergeMode</code>, the compilation will fail with the redefinition error.</p> <p>When an object (instance, function or variable) is hooked/replaced, the original one is available under the same name with the <code>_old</code> suffix (<code>PC_Hero</code> -&gt; <code>PC_Hero_old</code>). This allows you to refer to the old object.</p>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/hooks/#function-hook-example","title":"Function hook example","text":"<pre><code>func void ZS_Attack_Loop()\n{\n// if the enemy is a player and has no weapon, then\n// also sheath the weapon.\nif (Npc_IsPlayer(other) &amp;&amp; !Npc_HasReadiedWeapon(other))\n{\nreturn LOOP_END;\n};\n// otherwise call the original function\nreturn ZS_Attack_Loop_Old();\n};\n</code></pre> <p>This kind of substitution works for instances and variables too.</p> <p>Warning</p> <p>While hooking an instances, you have to take care not to call the prototype. Prototype should be always changed back to the original class.</p> <p></p>This is wrong<pre><code>instance pc_hero(Npc_Default)\n{\npc_hero_old();\nname = \"Pepe\";\n};\n</code></pre> This leads to a double call of <code>prototype Npc_Default</code> which is considered an unsafe practice with undefined behaviour.  <p>The correct way is to call it like this: </p><pre><code>instance pc_hero(C_NPC) // no prototype Npc_Default\n{\npc_hero_old();\nname = \"Pepe\";\n};  </code></pre> This way the prototype is called in the original function <code>pc_hero_old()</code> and not for the second time when creating the new hooked instance."},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/hooks/#dialogue-hook-example","title":"Dialogue hook example","text":"<p>The hooking mechanism is designed to introduce new dialogues into the game as well as replacing old ones with hooks. The scripter can create new merchants, quests, dialogues, as well as attach svm phrases to them.</p> <p>All new or replaced dialogues will immediately become available, including from saves. In the event that new dialogs are disabled (plugin or script removed), the engine will continue to keep them in the save file, which will allow the dialogs to return at any time with the same state they were in the last time.</p> <p>Warning</p> <p>Currently not working as intended (I think). The old dialogue is still used and as a result you will end up with both the old and the new dialogue (unless you edit the old condition function).</p> <pre><code>instance DIA_XARDAS_HELLO(C_INFO)\n{\nDIA_XARDAS_HELLO_old();\nimportant = FALSE;\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/meta/","title":"META block","text":""},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/meta/#meta-block","title":"META block","text":"<p>The META block is optional. If it is specified, it has to be the very first thing in the file without any indent or a comment above it.</p> <p>Syntax: </p><pre><code>META\n{\nParser // specifies into which compiled file the scripts are going to be injected\n/*\n        Code    Name              DAT file\n        ---     ------            -------\n        Game    parser            Gothic.dat\n        SFX     parserSoundFX     SFX.dat\n        PFX     parserParticleFX  ParticleFX.dat\n        VFX     parserVisualFX    VisualFX.dat\n        Camera  parserCamera      Camera.dat\n        Menu    parserMenu        Menu.dat\n        Music   parserMusic       Music.dat\n    */\nMergeMode   // 0 - if confilct occurs = comilation error, 1 - if conflict occurs = hook\nEngine      // comma separated list of engines for which the scripts will be injected \n/*\n        Code  Engine          Human readable name\n        ---   -----           -----------------------\n        G1    Gothic I        Gothic I Classic\n        G1A   Gothic Sequel   Gothic I Addon &lt;3\n        G2    Gothic II       Gothic II Classic\n        G2A   Gothic II NoTR  Gothic II Addon\n    */\nNativeWhile // use native while\nNamespace   // namespace of this script file\nUsing       // comma separated list of namespaces, that are considered local for this script file\nMod         // specify for which mod should this code be injected\nAfter       // comma separated list of scripts, after which this script should be parsed\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/other/","title":"Other features","text":""},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/other/#other-functions-of-the-extender","title":"Other functions of the extender","text":""},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/other/#ini-parameters","title":"ini parameters","text":"<p>The choice of ini file depends on how the game was launched. If it was launched from Gothic.exe, then the parameters will be read from <code>SystemPack.ini</code>. If it was launched through GothicStarter.exe, then they will be read from the ini of the mod.</p> <pre><code>[zParserExtender]\nLoadScript(obsolete) =\n;specifies a parser-script format script to run the scripts. The parameter is currently invalid.\nMergeMode = True\n;specifies whether injections will produce hooks.\nCompileDat = False\n;Determines if a copy of DAT file which has been modified by injection will be created.\nCompileOU = False\n;determines if a copy of an injection-modified OU file will be created.\nNativeWhile = False\n;Determines if a WHILE loop will be compiled. Defaults to False (for Ninja compatibility).\nMessagesLevel = 1\n;sets the output level. The higher the level, the more information will be printed to the debug console.\nStringIndexingMode = -1\n;defines string indexing mode (see string indexing). Default value is -1.\n;Default   = -1 - The default mode for the moment is Repair mode.\n;Disabled  =  0 - Do nothing with the indices.\n;TopSymbol =  1 - The plugin finds the uppermost unnamed string and sets a counter for it.\n;Repair    =  2 - The plugin goes through the whole string table and, if the indexing order is broken, puts the correct names. The counter is set on the basis of the search.\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/other/#marvin-console-commands","title":"MARVIN console commands","text":"<p>zParserExtender adds console commands that save copies of the <code>.dat</code> files with the injected code.</p> <p>Warning</p> <p>If the mod uses Ikarus, the <code>CompileDat</code> option (in the <code>.ini</code> file) should be used since a fatal error may occur whe using the command.</p> <pre><code>Parser SaveDat OU        - exports OU.Edited.bin\nParser SaveDat Game      - exports Gothic.Edited.dat\nParser SaveDat SFX       - exports SFX.Edited.dat\nParser SaveDat PFX       - exports ParticleFX.Edited.dat\nParser SaveDat VFX       - exports VisualFX.Edited.dat\nParser SaveDat Camera    - exports Camera.Edited.dat\nParser SaveDat Menu      - exports Menu.Edited.dat\nParser SaveDat Music     - exports Music.Edited.dat\nParser Export Stringlist - exports the full string table to Scripts\\Exports\\StringList.d\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/other/#launch-options","title":"Launch options","text":"<p>Command line parameters can be passed to the game's exe via the command line or using GothicStarter_Mod.</p> <pre><code>zReparse_OU     - parses and creates OU.bin\nzReparse_Game   - parses and creates Gothic.dat\nzReparse_SFX    - parses and creates SFX.dat\nzReparse_PFX    - parses and creates ParticleFX.dat\nzReparse_VFX    - parses and creates VisualFX.dat\nzReparse_Camera - parses and creates Camera.dat\nzReparse_Menu   - parses and creates Menu.dat\nzReparse_Music  - parses and creates Music.dat\n</code></pre> <p>Note</p> <p>If you want to compile OU, you also have to include the Game parameter</p> <p>-zReparse_Game -zReparse_OU</p>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/other/#const-array-access","title":"Const array access","text":"<p>The original zParser doesn't allow direct access to <code>const string</code> arrays. zParserExtender allows you to do so.</p> <p>Example: </p><pre><code>func event GameInit()\n{\nHlp_MessageBox(TXT_INV_CAT[4]); // Prints \"Artifacts\"\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/daedalus_injection/other/#other-engine-fixes","title":"Other engine fixes","text":"<ol> <li>When creating an item instance, the instance is placed into the global <code>item</code> instance</li> <li>On DAT file load, the engine restores the original symbol hierarchy</li> <li>When loading a save, the engine now skips unknown symbols, instead of crashing</li> </ol>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/","title":"Sign post example","text":""},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#sign-post-teleportation","title":"Sign post teleportation","text":"<p>This is a short \"problem-solving\" example, where we try to demonstrate the power of Daedalus injection using zParserExtender. GaroK asked me if there is a way to teleport to all the sign posts in Khorinis to gather information for a Gothic wiki article. The goal is to introduce a function that will teleport you to every signpost in Khorinis with the press of a button.</p>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#the-problem","title":"The problem","text":"<p>In ZenGin you can teleport to named game objects with the <code>goto vob {vobname}</code> command. But since the signposts do not have a vobname defined, I had to figure out a different approach.</p>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#ascii-zen","title":"ASCII ZEN","text":"<p>We want to get all the signposts position from Khorinis. The game world was loaded into one of the available world editor, I found one of the signposts and noted the <code>visual</code> which dictates the model of the in-game object <code>nw_misc_sign_01.3DS</code>. Alternatively, you can find the standard vanilla objects from both games on this website. Next, the world was saved as a <code>ASCII ZEN</code> format. This allows us to write a macro to search for all instances of objects with a specific visual and extract the position vector.</p> One signpost object<pre><code>[% oCMOB:zCVob 47105 317]\npack=int:0\npresetName=string:\nbbox3DWS=rawFloat:7564.8291 127.361191 -80.5309067 7611.52441 377.422913 1.67681122 trafoOSToWSRot=raw:73e1673f9c4ec33b15efd8be4465d7bba0fe7f3f30ea7137e5edd83eecaa353bb7e2673f\ntrafoOSToWSPos=vec3:7588.17627 252.391052 -39.4283791\nvobName=string:\nvisual=string:NW_MISC_SIGN_01.3DS\nshowVisual=bool:1\nvisualCamAlign=enum:0\nvisualAniMode=enum:0\nvisualAniModeStrength=float:0\nvobFarClipZScale=float:1\ncdStatic=bool:1\ncdDyn=bool:1\nstaticVob=bool:1\ndynShadow=enum:0\nzbias=int:0\nisAmbient=bool:0\n[visual zCProgMeshProto 53505 318]\n[]\n[ai % 0 0]\n[]\nfocusName=string:MOBNAME_INCITY02\nhitpoints=int:10\ndamage=int:0\nmoveable=bool:0\ntakeable=bool:0\nfocusOverride=bool:0\nsoundMaterial=enum:0\nvisualDestroyed=string:\nowner=string:\nownerGuild=string:\nisDestroyed=bool:0\n[]\n</code></pre> <p>Tip</p> <p>You can also see that the <code>focusName</code> has a <code>MOBNAME_INCITY02</code> string constant. This constant is defined in the scripts and its content is used as the focus name. </p><pre><code>const string MOBNAME_INCITY02 = \"To Marketplace\";\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/examples/signposts/#the-injectable-script","title":"The injectable script","text":"<p>As it is an injectable script, we have to specify the <code>META</code> tag. Lets tell zParseExtender to insert this code into the game parser. </p><pre><code>META\n{\nParser = Game\n};\n</code></pre> We want to teleport the player and for this we will need the <code>C_Position</code> and <code>C_Vob_Data</code> classes. <pre><code>class C_Position\n{\nvar int X; // X coordinate\nvar int Y; // Y coordinate\nvar int Z; // Z coordinate\n};\nclass C_VOB_DATA\n{\nvar string Name;              // object name\nvar float VisualAlpha;        // object's transparency 0.0 - 1.0\nvar int ShowVisual;           // display the mode\nvar int DrawBBox3D;           // show objects bounding box\nvar int VisualAlphaEnabled;   // enables objects transparency\nvar int PhysicsEnabled;       // enables object's physics\nvar int IgnoredByTraceRay;    // allow any object collisions\nvar int CollDetectionStatic;  // allow collision with static world polygons\nvar int CollDetectionDynamic; // allow collision with dynamic world objects\nvar int CastDynShadow;        // display shadow of the object\nvar int LightColorStatDirty;  // allow static liging of the object\nvar int LightColorDynDirty;   // allow dynamic lighing of the object\nvar int SleepingMode;         // sets object's activity mode (0 - inactive, 1 - active, 2 - AI only)\nvar int DontWriteIntoArchive; // turns of the serialization of this object to the save file \n};\n</code></pre> It turns out there is 54 instances of objects with the desired visual. Let us define <code>const int NUM_OF_SIGNS = 54</code> and a <code>const int MAX_COORDS = 3 * NUM_OF_SIGNS</code> - we will store 3 times 54 integers - for every signpost a <code>x</code>, <code>y</code> and <code>z</code> coordinate. And lastly a <code>const int</code> array containing all the positions. <pre><code>// Number of signs we want to jump to\nconst int NUM_OF_SIGNS = 54;\nconst int MAX_COORDS = 3 * NUM_OF_SIGNS;\nconst int sign_coordinates[MAX_COORDS] = {\n11974,  309,   6815,\n12024,  310,   6778,\n12411,  1668,  -22495,\n19491,  1281,  1669,\n19563,  1281,  1687,\n20294,  2058,  12487,\n20324,  2058,  12419,\n21917,  2900,  -22751,\n2600,   -57,   -4351,\n26695,  2419,  4308,\n26770,  2418,  4319,\n26978,  2937,  6130,\n27015,  2936,  6104,\n27049,  2937,  6159,\n2964,   2142,  14424,\n31383,  3896,  4699,\n31427,  3896,  4640,\n35368,  3870,  -4374,\n35435,  3870,  -4355,\n35437,  3871,  -4399,\n36205,  3333,  -27186,\n37774,  3875,  -501,\n37812,  3874,  -469,\n37849,  3874,  -512,\n38291,  3732,  -6699,\n39276,  3926,  -3357,\n39307,  3924,  -3313,\n39351,  3924,  -3359,\n39435,  4350,  10902,\n39458,  4350,  10827,\n40932,  3861,  -3054,\n42454,  2838,  -19437,\n5297,   387,   -2145,\n5358,   387,   -2184,\n5362,   387,   -2128,\n54006,  1723,  -10316,\n54035,  1723,  -10387,\n551,    -62,   -1820,\n61080,  2132,  -11622,\n61155,  2132,  -11625,\n6408,   392,   3598,\n6432,   393,   3652,\n7000,   387,   -1482,\n73439,  3341,  -11307,\n7588,   252,   -39,\n7590,   252,   -109,\n7642,   253,   -83,\n7713,   387,   -4782,\n7758,   386,   -4775,\n7776,   388,   -4811,\n8154,   1206,  -17022,\n8855,   395,   -2402,\n9704,   393,   5129,\n9738,   392,   5108\n};\n</code></pre> Next define a built in event <code>GameLoop</code> function, to check for a pressed key. If the key <code>U</code> is pressed, the <code>jump_to_sign</code> function is called. <pre><code>// check for pressed U button every frame\nfunc event GameLoop()\n{\n// if U is toggled, run the function\nif (Hlp_KeyToggled(KEY_U))\n{\njump_to_sign();\n};\n};\n</code></pre> <p>Let's look at the <code>jump_to_sign</code> function now. This function is called on every <code>U</code> key press and goes through all the signposts and teleports the player to them. At the start of the function we check if the index is not out of bounds and if it is, sets it back to 0 and starts over. </p><pre><code>    // if we reached the end, start over\nif (tp_index &gt;= NUM_OF_SIGNS)\n{\ntp_index = 0;\n};\n</code></pre> Notice the use of <code>Str_Format</code> function for the formatted output. <pre><code>// give information to the player\nPrint(Str_Format(\"Sign %i/%i\", tp_index+1, NUM_OF_SIGNS));\nvar C_Position pos;  pos  = Vob_GetVobPosition(hero);\nvar C_Vob_Data data; data = Vob_GetVobData(hero);\n</code></pre> Daedalus does not allow array access with variables (only constants and literals). To access the coordinate array we use a selection of parser functions. Firstly we get the game parser ID. Then we can use the <code>Par_GetSymbolValueIntArray</code> to access the <code>sign_coordinates</code> array and assign the coordinates to the <code>pos</code> variable. <pre><code>// get parser ID for the GAME parser\nvar int game_par_id; game_par_id = Par_GetParserID(\"game\");\n// get parser ID of the array\nvar int arr_id; arr_id = Par_GetSymbolID(game_par_id ,\"sign_coordinates\");\n// access the coordinates from above array\npos.x = Par_GetSymbolValueIntArray(game_par_id ,arr_id ,tp_index * 3    ); pos.y = Par_GetSymbolValueIntArray(game_par_id ,arr_id ,tp_index * 3 + 1);\npos.z = Par_GetSymbolValueIntArray(game_par_id ,arr_id ,tp_index * 3 + 2);\n</code></pre> And now comes the big trick. If you try to just change the position the dynamic and static collision is going to stop you at the first wall, tree or a mountain. To disable it, we can use the <code>C_Vob_Data</code> helper class, get players data, and disable both the static a dynamic collision. First we create a backup of the values just so we can restore them back after the teleport. <pre><code>// backup original collision detection\nvar int dyn;   dyn = data.CollDetectionDynamic;\nvar int stat; stat = data.CollDetectionStatic;\n// turn off collision detection \ndata.CollDetectionDynamic = 0;\ndata.CollDetectionStatic  = 0;\n</code></pre> Let us apply the changed data to the player and edit the position. <pre><code>// apply the edited data to player\nVob_SetVobData(hero, data);\n// move the player \nVob_SetVobPosition(hero, pos);\n</code></pre> Restore the collision detection data from the backup we made and set it. <pre><code>// restore collision detection\ndata.CollDetectionDynamic = dyn;\ndata.CollDetectionStatic  = stat;\n// apply the edited data to player\nVob_SetVobData(hero, data);\n</code></pre> Finally, we advance the index to jump to another signpost. <pre><code>// advance the index\ntp_index += 1;\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/","title":"AI functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai---functions-for-working-with-ai","title":"AI - functions for working with AI","text":"<p>Functions to work with the new <code>C_Trigger</code> class and NPC's AI queue.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_callscript","title":"AI_CallScript","text":"<p>Adds a <code>funcName</code> function call to the AI queue</p> <pre><code>func void AI_CallScript(var string funcName,\nvar C_NPC slf,\nvar C_NPC oth) {};\n</code></pre> <ul> <li><code>funcName</code> - name of the function to be called</li> <li><code>slf</code> - will be inserted into global <code>self</code> instance</li> <li><code>oth</code> - will be inserted into global <code>other</code> instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_starttriggerscript","title":"AI_startTriggerScript","text":"<p>Creates a trigger script that calls function <code>funcName</code> once every <code>interval</code> in milliseconds</p> <pre><code>func C_Trigger AI_startTriggerScript(var string funcName, var int interval) {};\n</code></pre> <ul> <li><code>funcName</code> - name of the function to be called</li> <li><code>interval</code> - call period in milliseconds</li> <li><code>return</code> - created C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_starttriggerscriptex","title":"AI_startTriggerScriptEx","text":"<p>Extended version call - Creates a trigger script, that calls function <code>funcName</code> once every <code>interval</code> in milliseconds also updates the <code>self</code>, <code>other</code> and <code>victim</code> global instances based on <code>slf</code>, <code>oth</code> and <code>vct</code> parameters respectively</p> <pre><code>func C_Trigger AI_startTriggerScriptEx( var string funcName,\nvar int interval,\nvar C_NPC slf,\nvar C_NPC oth,\nvar C_NPC vct) {};\n</code></pre> <ul> <li><code>funcName</code> - name of the function to be called</li> <li><code>interval</code> - call period in milliseconds</li> <li><code>slf</code> - will be inserted into global <code>self</code> instance</li> <li><code>oth</code> - will be inserted into global <code>other</code> instance</li> <li><code>vct</code> - will be inserted into global <code>victim</code> instance</li> <li><code>return</code> - created C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerbyid","title":"AI_GetTriggerByID","text":"<p>Returns a C_Trigger instance from the array of active triggers by the array index <code>ID</code></p> <pre><code>func C_Trigger AI_GetTriggerByID(var int ID) {};\n</code></pre> <ul> <li><code>ID</code> - array id</li> <li><code>return</code> - active C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggersnum","title":"AI_GetTriggersNum","text":"<p>Returns the number of active C_Trigger scripts</p> <pre><code>func int AI_GetTriggersNum() {};\n</code></pre> <ul> <li><code>return</code> - number of active C_Trigger scripts</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggernpc","title":"AI_GetTriggerNPC","text":"<p>Returns the npc associated with the C_Trigger script based on the ID selfID   = 0; otherID  = 1; victimID = 2;</p> <pre><code>func C_NPC AI_GetTriggerNPC(var C_Trigger trigger, var int npcID) {};\n</code></pre> <ul> <li><code>trigger</code> - C_Trigger script</li> <li><code>npcID</code> - NPC id</li> <li><code>return</code> - active C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerfunc","title":"AI_GetTriggerFunc","text":"<p>Returns the function associated with the specified C_Trigger</p> <pre><code>func func AI_GetTriggerFunc(var C_Trigger trigger) {};\n</code></pre> <ul> <li><code>trigger</code> - C_Trigger script</li> <li><code>return</code> - trigger function</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_gettriggerfuncname","title":"AI_GetTriggerFuncName","text":"<p>Returns the function name of a function associated with the specified C_Trigger</p> <pre><code>func string AI_GetTriggerFuncName(var C_Trigger trigger) {};\n</code></pre> <ul> <li><code>trigger</code> - C_Trigger script</li> <li><code>return</code> - active C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyfunc","title":"Ai_GetNextTriggerByFunc","text":"<p>Returns the next trigger in the active trigger array based on the trigger function, starting on the <code>startTrigger</code> trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByFunc(var C_Trigger startTrigger, var func function) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>function</code> - function to be matched</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyfuncname","title":"Ai_GetNextTriggerByFuncName","text":"<p>Returns the next trigger in the active trigger array based on the trigger function name, starting on the <code>startTrigger</code> trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByFuncName(var C_Trigger startTrigger, var string functionName) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>functionName</code> - name of a function to be matched</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyself","title":"Ai_GetNextTriggerBySelf","text":"<p>Returns the next trigger in the active trigger array based on the <code>self</code> trigger parameter, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerBySelf(var C_Trigger startTrigger, var C_NPC self) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>self</code> - C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyother","title":"Ai_GetNextTriggerByOther","text":"<p>Returns the next trigger in the active trigger array based on the <code>other</code> trigger parameter, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByOther(var C_Trigger startTrigger, var C_NPC other) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>other</code> - C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbyvictim","title":"Ai_GetNextTriggerByVictim","text":"<p>Returns the next trigger in the active trigger array based on the <code>victim</code> trigger parameter, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func C_Trigger Ai_GetNextTriggerByVictim( var C_Trigger startTrigger, var C_NPC victim ) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>victim</code> - C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/ai/#ai_getnexttriggerbynpcs","title":"Ai_GetNextTriggerByNPCs","text":"<p>Returns the next trigger in the active trigger array based on all the NPCs set in the trigger script <code>self</code>, <code>other</code> and <code>victim</code>, starting on the <code>startTrigger</code> instance set in the trigger</p> <pre><code>func c_trigger Ai_GetNextTriggerByNPCs( var C_Trigger startTrigger,\nvar C_NPC self,\nvar C_NPC other,\nvar C_NPC victim) {};\n</code></pre> <ul> <li><code>startTrigger</code> - C_Trigger script to start the search from</li> <li><code>self</code> - self C_NPC instance</li> <li><code>other</code> - other C_NPC instance</li> <li><code>victim</code> - victim C_NPC instance</li> <li><code>return</code> - C_Trigger instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/","title":"CAST functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast---data-type-conversion-functions","title":"CAST - data type conversion functions","text":"<p>External functions for data type conversion and pointer casting.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertoinstance","title":"Cast_PointerToInstance","text":"<p>Converts memory address (pointer) to an instance</p> <pre><code>func instance Cast_PointerToInstance(var int address) {};\n</code></pre> <ul> <li><code>address</code> - object pointer</li> <li><code>return</code> - instance of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instancetopointer","title":"Cast_InstanceToPointer","text":"<p>Converts instance to a memory address (pointer)</p> <pre><code>func int Cast_InstanceToPointer( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object instance</li> <li><code>return</code> - memory address (pointer) of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertonpc","title":"Cast_PointerToNpc","text":"<p>Casts memory address (pointer) to an NPC</p> <pre><code>func C_NPC Cast_PointerToNpc( var int address) {};\n</code></pre> <ul> <li><code>address</code> - npc pointer</li> <li><code>return</code> - NPC instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_pointertoitem","title":"Cast_PointerToItem","text":"<p>Casts memory address (pointer) to an Item</p> <pre><code>func C_ITEM Cast_PointerToItem( var int address) {};\n</code></pre> <ul> <li><code>address</code> - item pointer</li> <li><code>return</code> - Item instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceisnpc","title":"Cast_InstanceIsNpc","text":"<p>Checks whether object is an NPC</p> <pre><code>func int Cast_InstanceIsNpc( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object to check</li> <li><code>return</code> - <code>TRUE</code> or <code>FALSE</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceisitem","title":"Cast_InstanceIsItem","text":"<p>Checks whether object is an Item</p> <pre><code>func int Cast_InstanceIsItem( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object to check</li> <li><code>return</code> - <code>TRUE</code> or <code>FALSE</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_instanceismob","title":"Cast_InstanceIsMob","text":"<p>Checks whether object is an MOB</p> <pre><code>func int Cast_InstanceIsMob( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - object to check</li> <li><code>return</code> - <code>TRUE</code> or <code>FALSE</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getinstanceindex","title":"Cast_GetInstanceIndex","text":"<p>Returns symbolID of the object, returns -1 when not found</p> <pre><code>func int Cast_GetInstanceIndex( var instance object) {};\n</code></pre> <ul> <li><code>object</code> - instance of an object</li> <li><code>return</code> - symbol table index, -1 when not found</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getclassid","title":"Cast_GetClassID","text":"<p>Returns the class identifier of a class by its name</p> <pre><code>func int Cast_GetClassID( var string className ) {};\n</code></pre> <ul> <li><code>className</code> - name of the class</li> <li><code>return</code> - class identifier</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_getvobclassid","title":"Cast_GetVobClassID","text":"<p>Returns class identifier of the zCObject vob class</p> <pre><code>func int Cast_GetVobClassID( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - object instance</li> <li><code>return</code> - class zCObject identifier</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/cast/#cast_checkvobclassid","title":"Cast_CheckVobClassID","text":"<p>Checks if the classId class is the parent class of the object</p> <pre><code>func int Cast_CheckVobClassID( var int classId, var instance object ) {};\n</code></pre> <ul> <li><code>classId</code> - class identifier, from Cast_GetClassID function</li> <li><code>object</code> - object instance</li> <li><code>return</code> - class zCObject identifier</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/events_vars/","title":"Event functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/events_vars/#event-functions-and-variables","title":"Event functions and variables","text":"<p>On top of external functions, zParserExtender also adds these event functions and constants.</p> <pre><code>/// Every event function with this name is exectued once every frame\nfunc event GameLoop() {};\n/// Every event function with this name is exectued once on game init\nfunc event GameInit() {};\n/// empty instance\nconst instance null;\n/// not a number floating point constant\nconst float NaN;\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/","title":"HLP functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp---help-functions","title":"HLP - help functions","text":"<p>Helper functions generally used for safety checks, to get specific information from the engine or to interface with the configuration <code>.ini</code> files.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_hasfocusvob","title":"Hlp_HasFocusVob","text":"<p>Returns <code>TRUE</code>, if a specified NPC has a Vob in focus</p> <pre><code>func int Hlp_HasFocusVob( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> <li><code>return</code> - <code>TRUE</code> if npc has a focus Vob, <code>FALSE</code> if it does not</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getfocusvob","title":"Hlp_GetFocusVob","text":"<p>Returns NPC's focus Vob</p> <pre><code>func instance Hlp_GetFocusVob( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> <li><code>return</code> - focus vob</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getfocusvobname","title":"Hlp_GetFocusVobName","text":"<p>Returns the name of NPC's focus vob</p> <pre><code>func string Hlp_GetFocusVobName( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> <li><code>return</code> - focus vob name</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getstringlength","title":"Hlp_GetStringLength","text":"<p>Returns the length of a specified string</p> <pre><code>func int Hlp_GetStringLength( var string str ) {};\n</code></pre> <ul> <li><code>return</code> - length of <code>str</code></li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#isnan","title":"IsNAN","text":"<p>Checks whether floating point number is valid</p> <pre><code>func int IsNAN( var float value ) {};\n</code></pre> <ul> <li><code>return</code> - <code>TRUE</code> if <code>value</code> is NaN, <code>FALSE</code> if <code>value</code> is a valid floating point number</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_keytoggled","title":"Hlp_KeyToggled","text":"<p>Checks whether <code>key</code> is toggled</p> <pre><code>func int Hlp_KeyToggled( var int key ) {};\n</code></pre> <ul> <li><code>key</code> - key code</li> <li><code>return</code> - <code>TRUE</code> if key is toggled, <code>FALSE</code> if key is not toggled</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_keypressed","title":"Hlp_KeyPressed","text":"<p>Checks whether <code>key</code> is pressed</p> <pre><code>func int Hlp_KeyPressed( var int key ) {};\n</code></pre> <ul> <li><code>key</code> - key code</li> <li><code>return</code> - <code>TRUE</code> if key is pressed, <code>FALSE</code> if key is not pressed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_logicalkeytoggled","title":"Hlp_LogicalKeyToggled","text":"<p>Checks whether logical <code>key</code> is toggled</p> <pre><code>func int Hlp_LogicalKeyToggled( var int key ) {};\n</code></pre> <ul> <li><code>key</code> - key code</li> <li><code>return</code> - <code>TRUE</code> if key is toggled, <code>FALSE</code> if key is not toggled</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_gameonpause","title":"Hlp_GameOnPause","text":"<p>Checks whether the game is paused</p> <pre><code>func int Hlp_GameOnPause() {};\n</code></pre> <ul> <li><code>return</code> - <code>TRUE</code> if the game is paused, <code>FALSE</code> if the game is not paused</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_messagebox","title":"Hlp_MessageBox","text":"<p>Opens a message box with a specified message</p> <pre><code>func void Hlp_MessageBox( var string message ) {};\n</code></pre> <ul> <li><code>message</code> - message to be printed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_printconsole","title":"Hlp_PrintConsole","text":"<p>Prints a message to the Union debug console</p> <pre><code>func void Hlp_PrintConsole(var string message) {};\n</code></pre> <ul> <li><code>message</code> - message to be printed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_optionisexists","title":"Hlp_OptionIsExists","text":"<p>Checks whether the <code>entry</code> in <code>section</code> in <code>.ini</code> file <code>optName</code> exists</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func int Hlp_OptionIsExists(var string optName, var string section, var string entry) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[GAME]</code></li> <li><code>entry</code> - one setting entry like <code>playLogoVideos</code></li> <li><code>return</code> - <code>TRUE</code> if the option exists, <code>FALSE</code> if the option does not exist</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionint","title":"Hlp_ReadOptionInt","text":"<p>Read an integer value from specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func int Hlp_ReadOptionInt(var string optName, var string section, var string entry, var int default) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[GAME]</code></li> <li><code>entry</code> - one setting entry like <code>playLogoVideos</code></li> <li><code>default</code> - default value - if the value is empty</li> <li><code>return</code> - the option value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionfloat","title":"Hlp_ReadOptionFloat","text":"<p>Read a floating point value from specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func float Hlp_ReadOptionFloat(var string optName, var string section, var string entry, var float default) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>default</code> - default value - if the value is empty</li> <li><code>return</code> - the option value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_readoptionstring","title":"Hlp_ReadOptionString","text":"<p>Read a string value from specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func string Hlp_ReadOptionString(var string optName, var string section, var string entry, var string default) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>default</code> - default value - if the value is empty</li> <li><code>return</code> - the option value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionint","title":"Hlp_WriteOptionInt","text":"<p>Writes an integer value to specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func void Hlp_WriteOptionInt(var string optName, var string section, var string entry, var int value) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>value</code> - value to be written</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionfloat","title":"Hlp_WriteOptionFloat","text":"<p>Writes a floating point value to specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func void Hlp_WriteOptionFloat(var string optName, var string section, var string entry, var float value) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>value</code> - value to be written</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_writeoptionstring","title":"Hlp_WriteOptionString","text":"<p>Writes a string value to specified <code>.ini</code> file, section and entry.</p> <p><code>optName</code> values</p> <ul> <li><code>\"Gothic\"</code></li> <li><code>\"Mod\"</code></li> <li><code>\"SystemPack\"</code></li> </ul> <pre><code>func void Hlp_WriteOptionString(var string optName, var string section, var string entry, var string value) {};\n</code></pre> <ul> <li><code>optName</code> - the <code>.ini</code> file</li> <li><code>section</code> - settings section like <code>[INTERFACE]</code></li> <li><code>entry</code> - one setting entry like <code>scale</code></li> <li><code>value</code> - value to be written</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_getsteampersonalname","title":"Hlp_GetSteamPersonalName","text":"<p>Returns the name of the current Steam user Returns empty string when not run with Steam</p> <pre><code>func string Hlp_GetSteamPersonalName() {};\n</code></pre> <ul> <li><code>return</code> - string containing the Steam username, or an empty string</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/hlp/#hlp_doevent","title":"Hlp_DoEvent","text":"<p>Calls every event function with the name <code>funcName</code>.</p> <pre><code>func void Hlp_DoEvent(var string funcName) {};\n</code></pre> <ul> <li><code>funcName</code> - name of the event function to be called (all of them).</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/","title":"Log functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log-functions","title":"Log functions","text":"<p>As discussed on Inside Gothic, vanilla Gothic has no way of getting the status of a quest. These functions implement that functionality.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log_gettopicstatus","title":"Log_GetTopicStatus","text":"<p>Returns the status of diary topic</p> <ul> <li><code>-1</code> - Not found</li> <li><code>0</code> - Free</li> <li><code>1</code> - Running</li> <li><code>2</code> - Success</li> <li><code>3</code> - Failure</li> <li><code>4</code> - Obsolete</li> </ul> <pre><code>func int Log_GetTopicStatus(var string topic) {};\n</code></pre> <ul> <li><code>topic</code> - name of the topic</li> <li><code>return</code> - topic status</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/log/#log_gettopicsection","title":"Log_GetTopicSection","text":"<p>Returns the topic the diary topic is in</p> <ul> <li><code>-1</code> - Not found</li> <li><code>0</code> - Missions</li> <li><code>1</code> - Notes</li> <li><code>2</code> - All</li> </ul> <pre><code>func int Log_GetTopicSection(var string topic) {};\n</code></pre> <ul> <li><code>topic</code> - name of the topic</li> <li><code>return</code> - topic section</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/","title":"MDL functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl---model-functions","title":"MDL - model functions","text":"<p>Functions to tweak animation and other model related settings.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_getanimationindex","title":"Mdl_GetAnimationIndex","text":"<p>Returns animation's index for specified NPC based on animation's name</p> <pre><code>func int Mdl_GetAnimationIndex( var C_NPC npc, var string ani_name ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_name</code> - name of the animation in uppercase</li> <li><code>return</code> - animation index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_getanimationname","title":"Mdl_GetAnimationName","text":"<p>Returns animation's name for specified NPC based on animation's index</p> <pre><code>func string Mdl_GetAnimationName( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>return</code> - animation name</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_animationisexists","title":"Mdl_AnimationIsExists","text":"<p>Checks whether animation exists</p> <pre><code>func int Mdl_AnimationIsExists( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>return</code> - animation name</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_animationisactive","title":"Mdl_AnimationIsActive","text":"<p>Checks whether animation is active (whether it is currently played)</p> <pre><code>func int Mdl_AnimationIsActive( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>return</code> - <code>TRUE</code> if the animation is playing, <code>FALSE</code> if it is not playing</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setallanimationsfps","title":"Mdl_SetAllAnimationsFPS","text":"<p>Set framerate for all animations</p> <pre><code>func void Mdl_SetAllAnimationsFPS( var C_NPC npc, var float fps ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>fps</code> - framerate</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetallanimationsfps","title":"Mdl_ResetAllAnimationsFPS","text":"<p>Reset framerate for all animations to default value</p> <pre><code>func void Mdl_ResetAllAnimationsFPS( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setanimationfps","title":"Mdl_SetAnimationFPS","text":"<p>Set framerate for animation specified by animation index</p> <pre><code>func void Mdl_SetAnimationFPS( var C_NPC npc, var int ani_index, var float fps ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> <li><code>fps</code> - framerate</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetanimationfps","title":"Mdl_ResetAnimationFPS","text":"<p>Reset framerate to default for animation specified by animation index</p> <pre><code>func void Mdl_ResetAnimationFPS( var C_NPC npc, var int ani_index ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC with the animation</li> <li><code>ani_index</code> - animation index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setvisible","title":"Mdl_SetVisible","text":"<p>Set NPCs visibility</p> <pre><code>func void Mdl_SetVisible( var C_NPC npc, var int isVisible ) {};\n</code></pre> <ul> <li><code>npc</code> - specified NPC</li> <li><code>isVisible</code> - <code>TRUE</code> - visible, <code>FALSE</code> - invisible</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_applyoverlaymds_atfirst","title":"Mdl_ApplyOverlayMds_AtFirst","text":"<p>Applies or moves existing overlay to the top of the list</p> <pre><code>func void Mdl_ApplyOverlayMds_AtFirst( var string mdsName ) {};\n</code></pre> <ul> <li><code>mdsName</code> - name of the overlay</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_setnpcspeedmultiplier","title":"Mdl_SetNpcSpeedMultiplier","text":"<p>Sets a multiplier for animation speed 1.0 = 100% speed (normal speed)</p> <pre><code>func void Mdl_SetNpcSpeedMultiplier( var C_Npc npc, var float multiplier ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>multiplier</code> - speed of the animation</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mdl/#mdl_resetnpcspeedmultiplier","title":"Mdl_ResetNpcSpeedMultiplier","text":"<p>Resets the animation speed of an NPC</p> <pre><code>func void Mdl_ResetNpcSpeedMultiplier( var C_Npc npc ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/","title":"Menu function","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#menu-function","title":"Menu function","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#menu_searchitems","title":"Menu_SearchItems","text":"<p>Find all C_MenuItem object instances by the mask and automatically places them in the current menu instance</p> <pre><code>func void Menu_SearchItems( var string mask ) {};\n</code></pre> <ul> <li><code>mask</code> - regex like mask for searching</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/menu/#example","title":"Example","text":"<p>This function is used in the Union Menu API script. In this script the <code>Menu_SearchItems</code> external is used to collect all Union menu scripts that are placed into the Union &amp; Plugins menu that will appear in the game if you use any of the plugins that use this feature.  </p> Usage of Menu_SearchItems external function<pre><code>instance MENU_OPT_UNION(C_MENU_DEF)\n{\nMenu_SearchItems(\"MENUITEM_UNION_AUTO_*\");\nMENU_OPT_UNION_PY = 1200;\nbackpic           = MENU_BACK_PIC;\nitems[0]          = \"UNION_MENUITEM_TITLE\";\nitems[100]        = \"UNION_MENUITEM_BACK\";\ndefaultoutgame    = 0;\ndefaultingame     = 0;\nFlags             = Flags | MENU_SHOW_INFO;\n};\n</code></pre> <p>In this case all instances are of the name <code>MENUITEM_UNION_AUTO_*</code> where <code>*</code> is a wildcard that can be substituted with anything. The plugin will search the scripts and find all instances (in the case of zGamePad it is <code>MenuItem_Union_Auto_zGamePad</code>)</p> <p>This example comes from the <code>zUnionMenu.d</code> injectable API script that is part of the zGamePad plugin, GitHub link.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/","title":"MOB functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob---interactive-object-functions","title":"MOB - interactive object functions","text":"<p>Functions to manipulate interactive objects like destroying MOBs, setting lockpick combination and such.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_destroy","title":"Mob_Destroy","text":"<p>Marks oCMOB as destroyed, changes the visual to visualDestroyed (if present).</p> <pre><code>func void Mob_Destroy( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMOB to be destroyed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_removeitem","title":"Mob_RemoveItem","text":"<p>Removes an item from a oCMobContainer</p> <pre><code>func void Mob_RemoveItem( var instance object, var int item ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_removeitems","title":"Mob_RemoveItems","text":"<p>Removes specified number of items from a oCMobContainer</p> <pre><code>func void Mob_RemoveItems( var instance object, var int item, var int cnt ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be removed</li> <li><code>cnt</code> - number of items to be removed</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_insertitem","title":"Mob_InsertItem","text":"<p>Inserts an item into a oCMobContainer</p> <pre><code>func void Mob_InsertItem( var instance object, var int item ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be inserted</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_insertitems","title":"Mob_InsertItems","text":"<p>Inserts specified number of items into a oCMobContainer</p> <pre><code>func void Mob_InsertItems( var instance object, var int item, var int cnt ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>item</code> - item to be inserted</li> <li><code>cnt</code> - number of items to be inserted</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_getlockcombination","title":"Mob_GetLockCombination","text":"<p>Returns a lock combination of a oCMobContainer</p> <pre><code>func string Mob_GetLockCombination( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>return</code> - lock combination</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setlockcombination","title":"Mob_SetLockCombination","text":"<p>Sets a lock combination to a oCMobContainer</p> <pre><code>func void Mob_SetLockCombination( var instance object, var string comb ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobContainer object</li> <li><code>comb</code> - lock combination</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_islocked","title":"Mob_IsLocked","text":"<p>Returns <code>TRUE</code> if the object is locked</p> <pre><code>func int Mob_IsLocked( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>return</code> - <code>TRUE</code> if locked, <code>FALSE</code> if unlocked</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setlocked","title":"Mob_SetLocked","text":"<p>Set the lock status of the object</p> <pre><code>func void Mob_SetLocked( var instance object, var int locked ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>locked</code> - lock or unlock the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_getkeyinstance","title":"Mob_GetKeyInstance","text":"<p>Returns the key instance, that unlocks the object</p> <pre><code>func instance Mob_GetKeyInstance( var instance object ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>return</code> - the key C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/mob/#mob_setkeyinstance","title":"Mob_SetKeyInstance","text":"<p>Stets the key instance, that unlocks the object</p> <pre><code>func void Mob_SetKeyInstance( var instance object, var int key ) {};\n</code></pre> <ul> <li><code>object</code> - oCMobLockable object</li> <li><code>key</code> - the key C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/","title":"NPC functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc---character-functions","title":"NPC - character functions","text":"<p>NPC related functions.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_setashero","title":"Npc_SetAsHero","text":"<p>Changes players character to specified <code>npc</code></p> <pre><code>func void Npc_SetAsHero( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC to be set as players character</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventory","title":"Npc_OpenInventory","text":"<p>Opens NPCs main inventory</p> <pre><code>func void Npc_OpenInventory( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventorysteal","title":"Npc_OpenInventorySteal","text":"<p>Opens the steal inventory of <code>npc</code>'s focus NPC</p> <pre><code>func void Npc_OpenInventorySteal( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_openinventorytrade","title":"Npc_OpenInventoryTrade","text":"<p>Start the trading dialogue with specified NPC</p> <pre><code>func void Npc_OpenInventoryTrade( var C_NPC npc ) {};\n</code></pre> <ul> <li><code>npc</code> - NPC</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getlefthanditem","title":"Npc_GetLeftHandItem","text":"<p>Returns an item in NPC's left hand slot</p> <pre><code>func C_Item Npc_GetLeftHandItem( var C_Npc npc ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>return</code> - found C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getrighthanditem","title":"Npc_GetRightHandItem","text":"<p>Returns an item in NPC's right hand slot</p> <pre><code>func C_Item Npc_GetRightHandItem( var C_Npc npc ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>return</code> - found C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_getslotitem","title":"Npc_GetSlotItem","text":"<p>Returns an item from a slot with the slotName</p> <pre><code>func C_Item Npc_GetSlotItem( var C_Npc npc, var string slotName ) {};\n</code></pre> <ul> <li><code>npc</code> - npc to be affected</li> <li><code>slotName</code> - name of the slot</li> <li><code>return</code> - found C_ITEM instance</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_putinslot","title":"Npc_PutInSlot","text":"<p>Places an instance of the oCVom class (including items and NPCs) object into the slotName of the NPC The copyInInv parameter determines whether a copy of the object should remain in the character's inventory</p> <pre><code>func void Npc_PutInSlot(var C_Npc npc, var string slotName, var instance object, var int copyInInv) {};\n</code></pre> <ul> <li><code>npc</code> - npc to remove the item from</li> <li><code>slotName</code> - name of the slot from which to remove the item</li> <li><code>object</code> - object to be inserted into the slot</li> <li><code>copyInInv</code> - should a copy of the object stay in character inventory</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/npc/#npc_removefromslot","title":"Npc_RemoveFromSlot","text":"<p>Removes an object from the slotName of the NPC. The dropIt parameter in Gothic 2 defines, whether object should drop out of the slot. In Gothic 1, this parameter is reserved and must be 0.</p> <pre><code>func void Npc_RemoveFromSlot(var C_Npc npc, var string slotName, var int dropIt) {};\n</code></pre> <ul> <li><code>npc</code> - npc to remove the item from</li> <li><code>slotName</code> - name of the slot from which to remove the item</li> <li><code>dropIt</code> - should the object be dropped</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/","title":"PAR functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par---functions-for-parser-manipulation","title":"PAR - functions for parser manipulation","text":"<p>Parser functions are used to manipulate the parsers. Retrieve SymbolID, access arrays and such.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getparserid","title":"Par_GetParserID","text":"<p>Returns a parser ID of the parser with a <code>parName</code> name</p> <p>Parser names:</p> <ul> <li><code>\"Game\"</code></li> <li><code>\"SFX\"</code></li> <li><code>\"PFX\"</code></li> <li><code>\"VFX\"</code></li> <li><code>\"Camera\"</code></li> <li><code>\"Menu\"</code></li> <li><code>\"Music\"</code></li> </ul> <pre><code>func int Par_GetParserID(var string parName) {};\n</code></pre> <ul> <li><code>parName</code> - parser name</li> <li><code>return</code> - parser ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolid","title":"Par_GetSymbolID","text":"<p>Returns symbol ID for the symbol specified by its name</p> <pre><code>func int Par_GetSymbolID(var int parId, var string symName) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbollength","title":"Par_GetSymbolLength","text":"<p>Returns symbol length (number of elements)</p> <pre><code>func int Par_GetSymbolLength(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol length</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueint","title":"Par_GetSymbolValueInt","text":"<p>Returns the integer value of specified symbol</p> <pre><code>func int Par_GetSymbolValueInt(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluefloat","title":"Par_GetSymbolValueFloat","text":"<p>Returns the float value of specified symbol</p> <pre><code>func float Par_GetSymbolValueFloat(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluestring","title":"Par_GetSymbolValueString","text":"<p>Returns the string value of specified symbol</p> <pre><code>func string Par_GetSymbolValueString(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueinstance","title":"Par_GetSymbolValueInstance","text":"<p>Returns the instance value of specified symbol</p> <pre><code>func instance Par_GetSymbolValueInstance(var int parId, var int symId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>return</code> - symbol value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvalueintarray","title":"Par_GetSymbolValueIntArray","text":"<p>Returns the value of specified integer array at the <code>arrayID</code> index</p> <pre><code>func int Par_GetSymbolValueIntArray(var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>arrayID</code> - array index</li> <li><code>return</code> - value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluefloatarray","title":"Par_GetSymbolValueFloatArray","text":"<p>Returns the value of specified float array at the <code>arrayID</code> index</p> <pre><code>func float Par_GetSymbolValueFloatArray(var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>arrayID</code> - array index</li> <li><code>return</code> - value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_getsymbolvaluestringarray","title":"Par_GetSymbolValueStringArray","text":"<p>Returns the value of specified string array at the <code>arrayID</code> index</p> <pre><code>func string Par_GetSymbolValueStringArray(var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>parID</code> - parser ID</li> <li><code>symName</code> - symbol name</li> <li><code>arrayID</code> - array index</li> <li><code>return</code> - value</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueint","title":"Par_SetSymbolValueInt","text":"<p>Sets a new integer value to specified symbol</p> <pre><code>func void Par_SetSymbolValueInt(var int value, var int parId, var int symId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluefloat","title":"Par_SetSymbolValueFloat","text":"<p>Sets a new float value to specified symbol</p> <pre><code>func void Par_SetSymbolValueFloat(var float value, var int parId, var int symId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluestring","title":"Par_SetSymbolValueString","text":"<p>Sets a new string value to specified symbol</p> <pre><code>func void Par_SetSymbolValueString(var string value, var int parId, var int symId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueinstance","title":"Par_SetSymbolValueInstance","text":"<p>Sets a new instance value to specified symbol</p> <pre><code>func void Par_SetSymbolValueInstance(var instance value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvalueintarray","title":"Par_SetSymbolValueIntArray","text":"<p>Sets a new integer value to specified integer array symbol</p> <pre><code>func void Par_SetSymbolValueIntArray(var int value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> <li><code>arrayId</code> - array index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluefloatarray","title":"Par_SetSymbolValueFloatArray","text":"<p>Sets a new float value to specified float array symbol</p> <pre><code>func void Par_SetSymbolValueFloatArray(var float value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> <li><code>arrayId</code> - array index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/par/#par_setsymbolvaluestringarray","title":"Par_SetSymbolValueStringArray","text":"<p>Sets a new string value to specified string array symbol</p> <pre><code>func void Par_SetSymbolValueStringArray(var string value, var int parId, var int symId, var int arrayId) {};\n</code></pre> <ul> <li><code>value</code> - value to be set</li> <li><code>parID</code> - parser ID</li> <li><code>symId</code> - symbol ID</li> <li><code>arrayId</code> - array index</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/","title":"String functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#string-functions","title":"String functions","text":"<p>Functions to manipulate and format strings.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_format","title":"Str_Format","text":"<p>Returns formatted string using format specifiers</p> <p>Format specifiers:</p> <ul> <li><code>%s</code> - inserts a string</li> <li><code>%i</code> - inserts an integer number</li> <li><code>%x</code> - inserts an integer in hexadecimal</li> <li><code>%f</code> - inserts a floating point number</li> <li><code>%b</code> - inserts a logical expression</li> <li><code>%p</code> - inserts a pointer</li> </ul> <pre><code>func string Str_Format( var string format, ... ) {};\n</code></pre> <ul> <li><code>return</code> - formatted string</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#examples","title":"Examples","text":"<p>Very powerful function, can be used to streamline strings used in the scripts as well as optimize them for translations.</p> <p>Define constants containing the string with format specifiers. </p><pre><code>const string MENU_SAVE = \"Slot %i - press ENTER to save in this slot.\";\nconst string MENU_LOAD = \"Slot %i - press ENTER to load saved game.\";\n</code></pre> Then define two format functions as such: <pre><code>func string GetSaveSlotString (var int number)\n{\nreturn Str_format(MENU_SAVE, number);\n};\n</code></pre> <pre><code>func string GetLoadSlotString (var int number)\n{\nreturn Str_format(MENU_LOAD, number);\n};\n</code></pre> <p>Tip</p> <p>Since the whole translatable string is saved in one constant, it is very easy for translators to change the word order. This was not possible to do without code change to the <code>ConcatStrings</code> function calls within the scripts. With this simple change, translators have to translate only 2 strings instead of 30 (15 + 15 slots) and only 2 strings are compiled into the compiled <code>Menu.dat</code> file.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlocalizedstring","title":"Str_GetLocalizedString","text":"<p>Returns a string in the current language, otherwise in English. Arguments MUST be encoded in UTF-8! The result string will be converted to appropriate ANSI string.</p> <pre><code>func string Str_GetLocalizedString( var string russian,\nvar string english,\nvar string german,\nvar string polish ) {};\n</code></pre> <ul> <li><code>russian</code> - Russian string</li> <li><code>english</code> - English string</li> <li><code>german</code> -  German string</li> <li><code>polish</code> -  Polish string</li> <li><code>return</code> - string in the current language</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlocalizedstringex","title":"Str_GetLocalizedStringEx","text":"<p>Returns a string in the current language, otherwise in English. Offers additional languages</p> <pre><code>func string Str_GetLocalizedStringEx(   var string russian,\nvar string english,\nvar string german,\nvar string polish,\nvar string romanian,\nvar string italian,\nvar string czech,\nvar string spanish ) {};\n</code></pre> <ul> <li><code>russian</code> -  Russian string</li> <li><code>english</code> -  English string</li> <li><code>german</code> -   German string</li> <li><code>polish</code> -   Polish string</li> <li><code>romanian</code> - Romanian string</li> <li><code>italian</code> -  Italian string</li> <li><code>czech</code> -    Czech  string</li> <li><code>spanish</code> -  Spanish string</li> <li><code>return</code> - string in the current language</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_utf8_to_ansi","title":"Str_UTF8_to_ANSI","text":"<p>Converts UTF-8 string into an ANSI string with codePage</p> <pre><code>func string Str_UTF8_to_ANSI( var string utf8, var int codePage ) {};\n</code></pre> <ul> <li><code>utf8</code> - string encoded in UTF8</li> <li><code>codePage</code> - codePage id, can be obtained from Str_GetCurrentCP</li> <li><code>return</code> -</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getcurrentcp","title":"Str_GetCurrentCP","text":"<p>Return the code page corresponding to the current language set in the Union System </p><pre><code>func int Str_GetCurrentCP() {};\n</code></pre> <ul> <li><code>return</code> - code page corresponding to the current language</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/string/#str_getlength","title":"Str_GetLength","text":"<p>Returns the length of a string</p> <pre><code>func int Str_GetLength( var int str ) {};\n</code></pre> <ul> <li><code>str</code> - string to be measured</li> <li><code>return</code> - length of the string</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/","title":"VOB functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob---functions-for-object-manipulation","title":"VOB - functions for object manipulation","text":"<p>VOB functions allow you to manipulate game world objects.</p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getvobposition","title":"Vob_GetVobPosition","text":"<p>Returns the current position of the object in the world</p> <pre><code>func C_Position Vob_GetVobPosition( var C_Vob vob ) {};\n</code></pre> <ul> <li><code>vob</code> - vob to ge the position of</li> <li><code>return</code> - C_Position instance - position of the VOB</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setvobposition","title":"Vob_SetVobPosition","text":"<p>Sets the current position of the object in the world</p> <pre><code>func void Vob_SetVobPosition( var C_Vob vob, var C_Position pos ) {};\n</code></pre> <ul> <li><code>vob</code> - vob to get the position of</li> <li><code>pos</code> - new position of the vob</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getvobdata","title":"Vob_GetVobData","text":"<p>Returns the universal data of the zCVob object</p> <pre><code>func C_Vob_Data Vob_GetVobData( var C_Vob vob ) {};\n</code></pre> <ul> <li><code>vob</code> - VOB to get the position of</li> <li><code>return</code> - general vob data C_Vob_Data</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setvobdata","title":"Vob_SetVobData","text":"<p>Sets the universal data to a zCVob object</p> <pre><code>func void Vob_SetVobData( var C_Vob vob, var C_Vob_Data data ) {};\n</code></pre> <ul> <li><code>vob</code> - VOB to get the position of</li> <li><code>data</code> - general vob data C_Vob_Data</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getlightdata","title":"Vob_GetLightData","text":"<p>Returns zCVobLight object data</p> <pre><code>func C_Light_Data Vob_GetLightData( var C_Vob vobLight ) {};\n</code></pre> <ul> <li><code>vobLight</code> - vobLight object</li> <li><code>return</code> - C_Light_Data of the light</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setlightdata","title":"Vob_SetLightData","text":"<p>Sets the data of a zCVobLight object</p> <pre><code>func void Vob_SetLightData( var C_Vob vobLight, var C_Light_Data data ) {};\n</code></pre> <ul> <li><code>vobLight</code> - object to apply the light data to</li> <li><code>data</code> - C_Light_Data light data to be set</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_clearlightanilist","title":"Vob_ClearLightAniList","text":"<p>Clears the list of animation colours for the light source</p> <pre><code>func void Vob_ClearLightAniList( var C_Vob vobLight ) {};\n</code></pre> <ul> <li><code>vobLight</code> - light vob</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_addlightanicolor","title":"Vob_AddLightAniColor","text":"<p>Adds a color to the colour list</p> <pre><code>func void Vob_AddLightAniColor( var C_Vob vobLight, var C_Color col ) {};\n</code></pre> <ul> <li><code>vobLight</code> - object to apply the colour to</li> <li><code>col</code> - colour to be applied</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_addlightanicolorrgb","title":"Vob_AddLightAniColorRGB","text":"<p>Adds a color to the colour list</p> <pre><code>func void Vob_AddLightAniColorRGB(  var C_Vob vobLight,\nvar int r,\nvar int g,\nvar int b ) {};\n</code></pre> <ul> <li><code>vobLight</code> - object to apply the colour to</li> <li><code>r</code> - red colour channel</li> <li><code>g</code> - green colour channel</li> <li><code>b</code> - blue colour channel</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobdata","title":"Vob_GetMobData","text":"<p>Returns the data of the oCMOB object</p> <pre><code>func C_Mob_Data Vob_GetMobData( var C_Vob mob ) {};\n</code></pre> <ul> <li><code>mob</code> - oCMOB object</li> <li><code>return</code> - mob data</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobdata","title":"Vob_SetMobData","text":"<p>Sets the data of the oCMOB object</p> <pre><code>func void Vob_SetMobData( var C_Vob mob, var C_Mob_Data data ) {};\n</code></pre> <ul> <li><code>mob</code> - oCMOB object</li> <li><code>data</code> - C_Mob_Data to be set</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobinterdata","title":"Vob_GetMobInterData","text":"<p>Returns the data of the oCMobInter object</p> <pre><code>func MobInter_Data Vob_GetMobInterData( var C_Vob mobInter ) {};\n</code></pre> <ul> <li><code>mobInter</code> - oCMobInter object</li> <li><code>return</code> - MobInter_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobinterdata","title":"Vob_SetMobInterData","text":"<p>Sets the data of the oCMobInter object</p> <pre><code>func void Vob_SetMobInterData( var C_Vob mobInter, var C_MobInter_Data data ) {};\n</code></pre> <ul> <li><code>mobInter</code> - oCMobInter object</li> <li><code>data</code> - MobInter_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_getmobinterdata_1","title":"Vob_GetMobInterData","text":"<p>Returns the data of the oCMobLockable object</p> <pre><code>func C_MobLockable_Data Vob_GetMobInterData( var C_Vob mobLock ) {};\n</code></pre> <ul> <li><code>mobLock</code> - oCMobLockable object</li> <li><code>data</code> - MobInter_Data of the object</li> <li><code>return</code> - C_MobLockable_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/vob/#vob_setmobinterdata_1","title":"Vob_SetMobInterData","text":"<p>Sets the data of the oCMobLockable object</p> <pre><code>func void Vob_SetMobInterData( var C_Vob mobLock, var C_MobLockable_Data data ) {};\n</code></pre> <ul> <li><code>mobLock</code> - oCMobLockable object</li> <li><code>data</code> - C_MobLockable_Data of the object</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/","title":"WLD functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld---world-manipulation-functions","title":"WLD - world manipulation functions","text":"<p>Functions related to the world. </p>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_changelevel","title":"Wld_ChangeLevel","text":"<p>Trigger level change.</p> <pre><code>func void Wld_ChangeLevel( var string world, var string waypoint ) {};\n</code></pre> <ul> <li><code>world</code> - name of the world</li> <li><code>waypoint</code> - target waypoint</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_findvob","title":"Wld_FindVob","text":"<p>Return the VOB instance based on its name.</p> <pre><code>func instance Wld_FindVob( var string vobname ) {};\n</code></pre> <ul> <li><code>vobname</code> - name of the vob</li> <li><code>return</code> - zCVob pointer</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_playeffectvob","title":"Wld_PlayEffectVob","text":"<p>Play a visual effect at specified vob</p> <pre><code>func void Wld_PlayEffectVob(    var string effect,\nvar instance pvob,\nvar int level,\nvar int damage,\nvar int damage_type,\nvar int damage_speed ) {};\n</code></pre> <ul> <li><code>effect</code> - effect name</li> <li><code>pvob</code> - zCVob to play the effect at</li> <li><code>level</code> - effect level</li> <li><code>damage</code> - damage amount</li> <li><code>damage_type</code> - damage type</li> <li><code>damage_speed</code> - damage interval</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_playeffectat","title":"Wld_PlayEffectAt","text":"<p>Play a visual effect at specified world coordinates</p> <pre><code>func void Wld_PlayEffectAt( var string effect,\nvar instance coord,\nvar int level,\nvar int damage,\nvar int damage_type,\nvar int damage_speed ) {};\n</code></pre> <ul> <li><code>effect</code> - effect name</li> <li><code>coord</code> - world coordinates (<code>zVEC3</code>) to play the effect at</li> <li><code>level</code> - effect level</li> <li><code>damage</code> - damage amount</li> <li><code>damage_type</code> - damage type</li> <li><code>damage_speed</code> - damage interval</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_togglerain","title":"Wld_ToggleRain","text":"<p>Turns on the rain</p> <pre><code>func void Wld_ToggleRain( var float weight, var float time ) {};\n</code></pre> <ul> <li><code>weight</code> - the strength of the rain</li> <li><code>time</code> - rain duration</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_setweathertype","title":"Wld_SetWeatherType","text":"<p>Sets the weather type. Types:</p> <p><code>0</code> - snow <code>1</code> - rain</p> <pre><code>func void Wld_SetWeatherType( var int type ) {};\n</code></pre> <ul> <li><code>type</code> - weather type</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/externals/wld/#wld_getweathertype","title":"Wld_GetWeatherType","text":"<p>Returns the weather type. Types:</p> <p><code>0</code> - snow <code>1</code> - rain</p> <pre><code>func int Wld_GetWeatherType() {};\n</code></pre> <ul> <li><code>return</code> - weather type</li> </ul>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/dialogues/","title":"Dialogue constants","text":""},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/dialogues/#dialogue-constants","title":"Dialogue constants","text":"<p>To simplify dialogues, you can define up to 2 auxiliary variables or constants. Values corresponding to the current <code>C_Info</code> instance will be dynamically written there.</p>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/dialogues/#dia_currentinstance","title":"DIA_CurrentInstance","text":"<pre><code>var int DIA_CurrentInstance\n</code></pre> Contains the ID of the current <code>C_Info</code> instance. Can greatly simplify code or make it more reusable. Should be defined in scripts.   Example usage<pre><code>Info_ClearChoices(DIA_CurrentInstance);\nInfo_AddChoice(DIA_CurrentInstance, /*text*/, /*func*/);\nNpc_KnowsInfo(hero, DIA_CurrentInstance); // In this case DIA_CurrentInstance contains the last C_Info instance??\n</code></pre> Create a wrapper function based on this variable<pre><code>func int C_HeroKnowsCurrentInfo()\n{\nreturn Npc_KnowsInfo(hero, DIA_CurrentInstance);\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/dialogues/#dia_currentname","title":"DIA_CurrentName","text":"<pre><code>var string DIA_CurrentName;\n</code></pre> Contains the name of the current instance of <code>C_Info</code>. Can be useful for debugging purposes. Should be defined in scripts. Usage scenarios: <pre><code>Hlp_PrintConsole(DIA_CurrentName);\nHlp_PrintConsole(Str_Format(\"%s[%s]\", DIA_CurrentName, self.name);\nHlp_StrCmp(DIA_CurrentName, \"DIA_DiegoOw_Teach\");\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/events/","title":"Event functions","text":""},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/events/#event-functions","title":"Event functions","text":"<p>Event functions are functions sharing the same name. It can be defined multiple times but only once per file. Such functions are useful for implementing callback type functions. Every time an event is called, all instances of the same name will be called. The event is <code>func</code> with a return type <code>event</code>. Events are defined globally, meaning they ignore namespace they are in. To call an event from a script, use the external function <code>Hlp_DoEvent(var string funcName)</code>.</p> <pre><code>func void GiveXP()\n{\nHlp_DoEvent(\"OnGiveXP\");\n};\nfunc event OnGiveXP()\n{\n// TODO\n// This function can be defined in many files to do different things\n// more appropriate for that file's context and all of them will be\n// called, when function GiveXP (above) is called.\n};\n</code></pre> <p>Plugin implements two of these event functions</p> <ul> <li><code>func event GameInit()</code> - called when entering the main menu on game start</li> <li><code>func event GameLoop()</code> - called every frame when a world is loaded</li> </ul> <p>Define these in any file in your scripts, they will be automatically called</p>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/extern/","title":"Extern binding","text":""},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/extern/#extern-binding","title":"Extern binding","text":"<p>The <code>extern</code> binding allows you to secure your code against overriding or undefined symbol. Keyword <code>extern</code> before declaration means that if object of the same name exists, source object should be used. If not, a new one will be created. </p><pre><code>extern instance PC_Hero(C_Npc) {\n// TODO\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/namespaces/","title":"Namespaces","text":""},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/namespaces/#namespaces","title":"Namespaces","text":"<p>zParserExtender also implements namespaces. Namespaces ensure that all symbols inside the namespace are unique.</p>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/namespaces/#defining-a-namespace","title":"Defining a namespace","text":"<p>To define a namespace the new keyword <code>namespace</code> is used.</p> Regular scriptsInjectable scripts <pre><code>namespace zTestNamespace\n{\nvar int var01;\nfunc void func01() { };\n};\n</code></pre> <pre><code>META\n{\nNamespace = zTestNamespace;\n};\nvar int var01;\nfunc void func01() { };\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/namespaces/#namespace-nesting","title":"Namespace nesting","text":"<p>Namespaces can be nested for finer control. In case of injection, the namespace defined in META is applied to all code inside the script.</p> <p>To go deeper into the namespaces you use the namespace operator <code>:</code>. This code shows function with the same name within three different namespaces. The call in <code>GameInit</code> is made from the global namespace. </p><pre><code>namespace zTestNamespace01\n{\nfunc void func01() { };\n};\nnamespace zTestNamespace02\n{\nfunc void func01() { };\n};\nnamespace zTestNamespace03\n{\nnamespace zTestNamespace04\n{\nfunc void func01() { };\n};\n};\nfunc event GameInit()\n{\n// In this case, the reference is from global namespace to zTestNamespace\nzTestNamespace01:func01();\nzTestNamespace02:func01();\nzTestNamespace03:zTestNamespace04:func01();\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/namespaces/#namespace-traversal","title":"Namespace traversal","text":"<p>To go up a namespace tree you use the namespace operator <code>:</code> without specifying a namespace. Number of operators determines how many levels you go up.</p> Exiting nested namespaces<pre><code>func void func01()\n{\nHlp_MessageBox(\"#1\");\n};\nnamespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#2\");\n};\nnamespace zTestNamespace02\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#3\");\n};\nnamespace zTestNamespace03\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#4\");\n};\nfunc event GameInit()\n{\n:::func01(); // Calls the function 3 levels up\n::func01();  // Calls the function 2 levels up\n:func01();   // Calls the function 1 level up\nfunc01();    // Calls the function from the current namespace\n};\n};\n};\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/namespaces/#optional-namespace-specification","title":"Optional namespace specification","text":"<p>There are three cases where the namespace prefix is optional</p> Shares the same namespaceIf the function is in higher level namespaceIf <code>using</code> is specified in the META block <pre><code>namespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#1\");\n};\nfunc event GameInit()\n{\n// Function call from the current namespace\nfunc01();\n};\n};\n</code></pre> <pre><code>func void func01()\n{\nHlp_MessageBox(\"#1\");\n};\nnamespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#2\");\n};\nnamespace zTestNamespace02\n{\nfunc event GameInit()\n{\n// Function call from the global namespace\nfunc01();\n};\n};\n};\n</code></pre> <pre><code>META\n{\nusing = zTestNamespace01;\n};\nnamespace zTestNamespace01\n{\nfunc void func01()\n{\nHlp_MessageBox(\"#1\");\n};\n};\nfunc event GameInit()\n{\n// Calls the function with the namespace specified in the META block\nfunc01();\n};\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/namespaces/#global-namespace-and-daedalus-hooking","title":"Global namespace and Daedalus hooking","text":"<p>Namespace can not only be defined to an existing symbol but also to define new ones. Next code example shows how to implement a hook to a global instance.</p> <p></p><pre><code>namespace zTestNamespace01\n{\nconst string Var01 = \"New instance name\";\n// Hooking the global instance\ninstance :ItAr_Pir_L_Addon(C_Item)\n{\nItAr_Pir_L_Addon_Old();\nname = Var01;\n};\n};\n</code></pre> To hook an object, both signature and namespace has to match. It is syntactically allowed to hook an instance from a different space. Specify explicitly to which namespace the object will belong. This means that to hook instance <code>ItAr_Pir_L_Addon</code> from the namespace <code>zTestNamespace01</code> to a global namespace, you have to refer to the global namespace using the namespace operator <code>:</code>. Since the function will be defined globally (as every symbol in ZenGin), it will be a part of the <code>zTestNamespace01</code> which means that all functions will be local to this namespace."},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/testelse/","title":"Test-else binding","text":""},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/testelse/#test-else-statements","title":"Test-else statements","text":"<p>The test-else bind statement can be used to define sections of code to be compiled. If the code is within the boundaries of the inactive test-else branch, it will not be compiled. This operator can take values as input that are converted to logical values. For example, if an object is passed as an argument, the parser will check for its existence. If it is an engine tag, it will return the result of matching the current engine with the tag:</p> <p>Valid values:</p> <ul> <li>instance name - <code>PC_HERO</code>, <code>ItMi_Gold</code>, ...</li> <li>engine tag - <code>G1</code>, <code>G1A</code>, <code>G2</code>, <code>G2A</code></li> <li>Steam Overlay activity - <code>Steam</code></li> </ul> <p>The result can be combined from several arguments. Round brackets <code>()</code> ca be used to specify priority and expressions support the logical negation operator <code>!</code>, logical AND <code>&amp;&amp;</code> and OR <code>||</code>.</p> <p>The operator can be used anywhere in the script file. It is syntactically similar to <code>if else</code> statement, but curly braces <code>{}</code> can be omitted for single-line operations. For example: </p>SteamActivated constant is set only when Steam is active<pre><code>test Steam var const SteamActivated = 1;\n</code></pre> Example of a logical expression with an else branch<pre><code>test SteamActivated &amp;&amp; G2A {\n// TODO\n}\nelse {\n// TODO\n}\n</code></pre>"},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/while/","title":"While loop","text":""},{"location":"zengin/scripts/extenders/zparserextender/syntax_extensions/while/#native-while-loop","title":"Native WHILE loop","text":"<p>Just like Ikarus zParserExtender implements a while loop.</p> <pre><code>var int value; value = 10;\nwhile(value &gt; 0)\n{\nif (value == 8)\n{\ncontinue;\n};\nif (value == 2)\n{\nbreak;\n};\n};\n</code></pre> <p>Note</p> <p>To activate <code>while</code> it is necessary to set <code>NativeWhile</code> setting in SystemPack.ini </p><pre><code>[ZPARSE_EXTENDER]\nNativeWhile = true\n</code></pre> <p>Compiled while loop works in vanilla engine without the plugin.</p>"},{"location":"zengin/scripts/externals/","title":"Externals","text":""},{"location":"zengin/scripts/externals/#externals","title":"Externals","text":"<p>External functions are Daedalus functions (defined in the engine itself), that are used to interface with the engine. Gothic 1 and Gothic 2 implements slightly different set of external functions. There are some external functions, that were used in the course of Gothics development, but are now obsolete/deprecated because the underlying systems implemented in the engine were either turned off, or broken all together.</p>"},{"location":"zengin/scripts/externals/doc/","title":"Doc functions","text":""},{"location":"zengin/scripts/externals/doc/#doc-external-functions","title":"Doc external functions","text":"<p>Doc functions are used to control the document manager. They allow you to fine tune the display of maps, letters and books.</p>"},{"location":"zengin/scripts/externals/doc/#doc_create","title":"<code>Doc_Create</code>","text":"<p>Creates a new instance of the document manager and returns its ID. </p><pre><code>func int Doc_Create() {};\n</code></pre> <p>Return value Returns the ID of the document manager instance.</p> <p>Example</p> <pre><code>var int nDocID; // Variable to store the id in\nnDocID = Doc_Create();\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_createmap","title":"<code>Doc_CreateMap</code>","text":"<p>Creates a new instance of the document manager with the arrow showing players position on the map and returns its ID. </p><pre><code>func int Doc_CreateMap() {};\n</code></pre> <p>Return value Returns the ID of the document manager instance.</p> <p>Example</p> <pre><code>var int nDocID; // Variable to store the id in\nnDocID = Doc_CreateMap();\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_setlevel","title":"<code>Doc_SetLevel</code>","text":"<p>Set a world level to a map. This maps the texture of the document to the bounding box of the provided level. </p><pre><code>func void Doc_SetLevel(var int docID, var string level) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var string level</code> - name of the ZEN file</li> </ul> <p>Example</p> <pre><code>nDocID = Doc_CreateMap();\nDoc_SetLevel(nDocID, \"WORLD.ZEN\");\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_setlevelcoords","title":"<code>Doc_SetLevelCoords</code>","text":"<p>Warning</p> <p>This function is only available in Gothic 2</p> <p>Sets the map coordinates. This is used to map smaller portions of the world map to the document map to correctly show players position on the map. </p><pre><code>func void Doc_SetLevelCoords(var int docID, var int left, var int top, var int right, var int bottom) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var int left</code> - left coordinate</li> <li><code>var int top</code> - top coordinate</li> <li><code>var int right</code> - right coordinate</li> <li><code>var int bottom</code> - bottom coordinate</li> </ul> <p>Example</p> <pre><code>Doc_SetLevelCoords(nDocID, -28000, 50500, 95500, -42500);\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_setfont","title":"<code>Doc_SetFont</code>","text":"<p>Sets a <code>font</code> to be used on a <code>page</code> in a document with <code>docID</code>. Can be called multiple times to diplay different lines with different fonts.</p> <pre><code>func void Doc_SetFont(var int docID, var int page, var string font) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var int page</code> - page index, if set to <code>-1</code>, fonts will be applied to all pages </li> <li><code>var string font</code> - font to be used</li> </ul> <p>Example</p> <pre><code>Doc_SetFont(nDocID, -1, \"FONT_10_BOOK.TGA\");\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_setpages","title":"<code>Doc_SetPages</code>","text":"<p>Sets the number of pages <code>numOfPages</code> of the document. </p><pre><code>func void Doc_SetPages(var int docID, var int numOfPages) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var int numOfPages</code> - number of pages</li> </ul> <p>Example</p> <pre><code>nDocID = Doc_Create();\nDoc_SetPages(nDocID, 2);\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_setpage","title":"<code>Doc_SetPage</code>","text":"<p>Set <code>page</code> to have <code>texture</code> as a background with <code>scale</code>. </p><pre><code>func void Doc_SetPage(var int docID, var int page, var string texture, var int scale) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var int page</code> - page index, if set to <code>-1</code>, settings are applied to all pages</li> <li><code>var string texture</code> - texture of the background</li> <li><code>var int scale</code> - scale of the texture, <code>TRUE</code> to scale the page, <code>FALSE</code> to not scale </li> </ul> <p>Example</p> <pre><code>Doc_SetPage(nDocID, 0, \"Book_Mage_L.tga\", FALSE);\nDoc_SetPage(nDocID, 1, \"Book_Mage_R.tga\", FALSE);\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_setmargins","title":"<code>Doc_SetMargins</code>","text":"<p>Sets text margins of the page </p><pre><code>func void Doc_SetMargins(var int docID,\nvar int page,\nvar int left,\nvar int top,\nvar int right,\nvar int bottom,\nvar int pixels) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var int page</code> - page index, if set to <code>-1</code>, settings are applied to all pages</li> <li><code>var int left</code> - left margin</li> <li><code>var int top</code> - top margin</li> <li><code>var int right</code> - right margin</li> <li><code>var int bottom</code> - bottom margin</li> <li><code>var int pixels</code> - <code>TRUE</code> to use pixels, <code>FALSE</code> to use virtual coordinates</li> </ul> <p>Warning</p> <p>After a thorough examination of this external function in the decompiler, it looks like the function works in pixels only regardless of this parameter.</p> <p>Example</p> <pre><code>Doc_SetMargins(nDocID, 0, 275, 20, 30, 20, TRUE);\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_printline","title":"<code>Doc_PrintLine</code>","text":"<p>Prints a line of <code>text</code> (font is set using Doc_SetFont) onto the document with <code>docID</code>, onto the <code>page</code>. Does not split the text into multiple lines if they do not fit onto the page. </p><pre><code>func void Doc_PrintLine(var int docID, var int page, var string text) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var int page</code> - page index</li> <li><code>var string text</code> - text to be printed</li> </ul> <p>Example</p> <pre><code>Doc_PrintLine(nDocID, 0, \"\"); // insert empty line\nDoc_PrintLine(nDocID, 0, \"The Book\");\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_printlines","title":"<code>Doc_PrintLines</code>","text":"<p>Prints a line of <code>text</code> (font is set using Doc_SetFont) onto the document with <code>docID</code>, onto the <code>page</code>. Splits the text into multiple lines if they do not fit onto the page. </p><pre><code>func void Doc_PrintLines(var int docID, var int page, var string text) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> <li><code>var int page</code> - page index</li> <li><code>var string text</code> - text to be printed</li> </ul> <p>Example</p> <pre><code>Doc_PrintLines(nDocID, 0, \"The war had been decided. Varant had lost its seaports, vital to army supplies. King Rhobar had not lingered on the battle fields for a long time, but left his generals to deal with the few remaining enemy troops. Varant had only one large force left, commanded by Lukkor, the most capable warlord of the Varant army, who had more than once turned defeat into victory.\");\nDoc_PrintLines(nDocID, 0, \"But now his army was trapped. The situation was hopeless, even though his army greatly outnumbered the enemy. Lee, a war hero from Myrtana, had lured him into this trap. The heavy cavalry had been unable to fight on the thick, swamped ground of the narrow valley. Lee's soldiers had occupied the range of hills surrounding the swamp, and they had struck repeatedly, decimating the army. The desperate sallies his troops had launched had been cut short in pools of blood. He was beaten.\");\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#doc_show","title":"<code>Doc_Show</code>","text":"<p>Display the document using the document manager ID </p><pre><code>func void Doc_Show(var int docID) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var int docID</code> - document manager ID</li> </ul> <p>Example</p> <pre><code>var int nDocID; // Variable to store the id in\nnDocID = Doc_Create();\n// ... document configuration\nDoc_Show(nDocID);\n</code></pre>"},{"location":"zengin/scripts/externals/doc/#externals-with-docu-comments","title":"Externals with docu comments","text":"<pre><code>/// Creates a new instance of the document manager and returns its ID.\n///\n/// @return Returns the ID of the document manager instance.\nfunc int Doc_Create() {};\n/// Create a new instance of the document manager with the arrow showing players position on the map and returns its ID.\n///\n/// @return Returns the ID of the document manager instance.\nfunc int Doc_CreateMap() {};\n/// Prints a line of `text` onto the document with `docID`, onto the `page`.\n/// Does not line break\n/// \n/// @param docID document manager ID\n/// @param page page index\n/// @param text text to be printed\nfunc void Doc_PrintLine(var int docID, var int page, var string text) {};\n/// Prints a line of `text` onto the document with `docID`, onto the `page`. The `text` is automatically split into multiple lines\n/// \n/// @param docID document manager ID\n/// @param page page index\n/// @param text text to be printed\nfunc void Doc_PrintLines(var int docID, var int page, var string text) {};\n/// Sets a `font` to be used on a `page` in a document with `docID`. Can be called multiple times to diplay different lines with different fonts.\n///\n/// @param docID document manager ID\n/// @param page page index\n/// @param font font to be used\nfunc void Doc_SetFont(var int docID, var int page, var string font) {};\n/// Sets the number of pages `numOfPages` of the document.\n///\n/// @param docID document manager ID\n/// @param numOfPages number of pages\nfunc void Doc_SetPages(var int docID, var int numOfPages) {};\n/// Set `page` to have `texture` as a background with `scale`. \n///\n/// @param docID document manager ID\n/// @param page page index, if set to `-1`, settings are applied to all pages\n/// @param texture texture of the background\n/// @param scale scale of the texture, if set to 1, there will be no resizing\nfunc void Doc_SetPage(var int docID, var int page, var string texture, var int scale) {};\n/// Set a world level to a map.\n///\n/// @param docID document manager ID\n/// @param level name of the ZEN file\nfunc void Doc_SetLevel(var int docID, var string level) {};\n/// Sets the map coordinates. \n/// \n/// @param docID document manager ID\n/// @param left left\n/// @param top top\n/// @param right top\n/// @param bottom bottom\nfunc void Doc_SetLevelCoords(var int docID, var int left, var int top, var int right, var int bottom) {};\n/// Sets text margins of the page\n///\n/// @param docID document manager ID\n/// @param page page index, if set to `-1`, settings are applied to all pages\n/// @param left left margin\n/// @param top top margin\n/// @param right right margin\n/// @param bottom bottom margin\n/// @param pixels `TRUE` to use pixels, `FALSE` to use virtual coordinates\nfunc void Doc_SetMargins(var int docID,\nvar int page,\nvar int left,\nvar int top,\nvar int right,\nvar int bottom,\nvar int pixels) {};\n/// Display the document using the document manager ID\n///\n/// @param docID document manager ID\nfunc void Doc_Show(var int docID) {};\n/// deprecated\nfunc void Doc_Open (var string Texture) {};\n/// deprecated\nfunc void Doc_Font(var string Font) {};\n/// deprecated\nfunc void Doc_Print (var string Text) {};\n/// deprecated\nfunc void Doc_MapCoordinates(var string s0,\nvar float r1,\nvar float r2,\nvar float r3,\nvar float r4,\nvar float r5,\nvar float r6,\nvar float r7,\nvar float r8) {};\n</code></pre>"},{"location":"zengin/scripts/externals/log/","title":"Log functions","text":""},{"location":"zengin/scripts/externals/log/#log-external-functions","title":"Log external functions","text":"<p>Log externals are used to manipulate players log and to track quest progress.</p>"},{"location":"zengin/scripts/externals/log/#log_createtopic","title":"<code>Log_CreateTopic</code>","text":"<p>Creates a new log topic with the name <code>topicName</code> under the section <code>logSection</code></p> <p></p><pre><code>func void Log_CreateTopic(var string topicName, var int logSection) {};\n</code></pre> Parameters <ul> <li><code>var string topicName</code>      Unique string used to identify and name the topic</li> <li><code>var int logSection</code>      Indicates in which section to create the topic in.     Takes constants <code>LOG_MISSION</code>, <code>LOG_NOTE</code> as values</li> </ul>"},{"location":"zengin/scripts/externals/log/#log_addentry","title":"<code>Log_AddEntry</code>","text":"<p>Adds an entry to a log topic with the name <code>topicName</code> under the section <code>logSection</code></p> <p></p><pre><code>func void Log_AddEntry(var string topicName, var string entry) {};\n</code></pre> Parameters <ul> <li><code>var string topicName</code>      Unique string used to identify and name the topic</li> <li><code>var string entry</code>      Content of the new entry</li> </ul> <p>Info</p> <p>In the engine the <code>Log_AddEntry()</code> is wrapped in a <code>B_LogEntry()</code> function. This function also handles printing the \"New Journal Entry\" message to the screen and playing the sound effect. </p><pre><code>func void B_LogEntry(var string topic, var string entry)\n{\nPrintDebugNpc(PD_ZS_DETAIL, \"B_LogEntry\"); // Logging\nLog_AddEntry(topic, entry);\nPrintScreen(NAME_NewLogEntry, -1, _YPOS_MESSAGE_LOGENTRY, \"font_old_10_white.tga\", _TIME_MESSAGE_LOGENTRY);\nSnd_Play(\"LogEntry\");\n};\n</code></pre>"},{"location":"zengin/scripts/externals/log/#log_settopicstatus","title":"<code>Log_SetTopicStatus</code>","text":"<p>Changes the status of the topic with the name <code>topicName</code></p> <p></p><pre><code>func void Log_SetTopicStatus(var string topicName, var int status) {};\n</code></pre> Parameters <ul> <li><code>var string topicName</code>      Unique string used to identify and name the topic</li> <li><code>var int status</code>      The status to be set.     Takes constants <code>LOG_RUNNING</code>, <code>LOG_SUCCESS</code>, <code>LOG_FAILED</code>, <code>LOG_OBSOLETE</code> as values</li> </ul>"},{"location":"zengin/scripts/externals/log/#zparserextender","title":"zParserExtender","text":"<p>The log external function selection is missing functions to retrieve the status of a log entry. There are only functions to read the log status (as discussed on Inside Gothic). As a result of this the original scriptwriters had to define additional variable to track the log status in the scripts, even though the value is being already tracked by the engine.  zParserExtender fixes this by introducing new log external functions.</p>"},{"location":"zengin/scripts/externals/log/#externals-with-docu-comments","title":"Externals with docu comments","text":"<pre><code>/// Creates a new log topic with the name `topicName` under the section `logSection`\n/// \n/// @param topicName unique string used to identifiy and name the topic\n/// @param logSection [LOG_MISSION, LOG_NOTE] indicates in which section to create the topic in\nfunc void Log_CreateTopic(var string topicName, var int logSection) {};\n/// Creates a new log topic with the name `topicName` under the section `logSection`\n/// \n/// @param topicName unique string used to identifiy and name the topic\n/// @param logSection [LOG_MISSION, LOG_NOTE] indicates in which section to create the topic in\nfunc void Log_AddEntry(var string topicName, var string entry) {};\n/// Changes the status of the topic with the name `topicName`\n///\n/// @param topicName unique string used to identifiy and name the topic\n/// @param status [LOG_RUNNING, LOG_SUCCESS, LOG_FAILED, LOG_OBSOLETE] the status to be set\nfunc void Log_SetTopicStatus(var string topicName, var int status) {};\n</code></pre>"},{"location":"zengin/scripts/externals/mdl/","title":"MDL functions","text":""},{"location":"zengin/scripts/externals/mdl/#mdl-functions","title":"MDL functions","text":"<p>Functions to tweak animation and other model related settings.</p>"},{"location":"zengin/scripts/externals/mdl/#mdl_applyoverlaymds","title":"<code>Mdl_ApplyOverlayMDS</code>","text":"<p>Apply an animation overlay with <code>overlay_name</code> for the specified <code>npc</code> </p><pre><code>func void Mdl_ApplyOverlayMDS(var c_npc npc, var string overlay_name) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC to apply the overlay to</li> <li><code>var string overlay_name</code>      Name of the animation overlay</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_applyoverlaymdstimed","title":"<code>Mdl_ApplyOverlayMDSTimed</code>","text":"<p>Apply an animation overlay with <code>overlay_name</code> for the specified <code>npc</code> for <code>duration</code> milliseconds </p><pre><code>func void Mdl_ApplyOverlayMDSTimed(var c_npc npc, var string overlay_name, var float duration) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC to apply the overlay to</li> <li><code>var string overlay_name</code>      Name of the animation overlay</li> <li><code>var float duration</code>      Overlay duration in milliseconds</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_removeoverlaymds","title":"<code>Mdl_RemoveOverlayMDS</code>","text":"<p>Remove the animation overlay <code>overlay_name</code> from specified <code>npc</code> </p><pre><code>func void Mdl_RemoveOverlayMDS(var c_npc npc, var string overlay_name) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC to remove the overlay from</li> <li><code>var string overlay_name</code>      Name of the animation overlay</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_applyrandomani","title":"<code>Mdl_ApplyRandomAni</code>","text":"<p>Assign a random animation <code>ani2</code> to random animation list of animation <code>ani1</code> </p><pre><code>func void Mdl_ApplyRandomAni(var c_npc npc, var string ani1, var string ani2) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC owning the animation</li> <li><code>var string ani1</code>      The animation to assign random animation to</li> <li><code>var string ani2</code>      Animation to be assigned</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_applyrandomanifreq","title":"<code>Mdl_ApplyRandomAniFreq</code>","text":"<p>Sets the random animation frequency for animation <code>ani1</code> </p><pre><code>func void Mdl_ApplyRandomAniFreq(var c_npc npc, var string ani1, var float frequency) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC owning the animation</li> <li><code>var string ani1</code>      The animation to set the random frequency</li> <li><code>var float frequency</code>      Number of seconds between random animations</li> </ul> Example <pre><code>// Attach T_WOUNDED_TRY animation to the S_WOUNDED animation\nMdl_ApplyRandomAni(self, \"S_WOUNDED\", \"T_WOUNDED_TRY\");\n// Make the random animation attached play every 8 seconds\nMdl_ApplyRandomAniFreq(self, \"S_WOUNDED\", 8);\n</code></pre>"},{"location":"zengin/scripts/externals/mdl/#mdl_setmodelfatness","title":"<code>Mdl_SetModelFatness</code>","text":"<p>Set the procedural model fatness </p><pre><code>func void Mdl_SetModelFatness(var c_npc npc, var float fatness) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC to apply the fatness to </li> <li><code>var float fatness</code>      Fatness value</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_setmodelscale","title":"<code>Mdl_SetModelScale</code>","text":"<p>Set model scale per axis </p><pre><code>func void Mdl_SetModelScale(var c_npc npc, var float x, var float y, var float z) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC to apply the scale to </li> <li><code>var float x</code>      Scale along the x-axis, 1.0 = 100%, 1.5 = 150%, 0.9 = 90% </li> <li><code>var float y</code>      Scale along the y-axis, 1.0 = 100%, 1.5 = 150%, 0.9 = 90% </li> <li><code>var float z</code>      Scale along the z-axis, 1.0 = 100%, 1.5 = 150%, 0.9 = 90% </li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_setvisualbody","title":"<code>Mdl_SetVisualBody</code>","text":"<p>Sets up the visual of an NPC </p><pre><code>func void Mdl_SetVisualBody(var instance npc,\nvar string body_mesh,\nvar int body_tex,\nvar int skin,\nvar string head_mesh,\nvar int head_tex,\nvar int teeth_tex,\nvar int armor_inst       ) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var instance npc</code>      NPC to be affected</li> <li><code>var string body_mesh</code>      Mesh to be used as the body e.g. <code>HUN_BODY_NAKED0</code></li> <li><code>var int body_tex</code>      Body texture assigned to this body mesh</li> <li><code>var int skin</code>      Body texture variant</li> <li><code>var string head_mesh</code>      Head mesh</li> <li><code>var int head_tex</code>      Head texture</li> <li><code>var int teeth_tex</code>      Teeth texture</li> <li><code>var int armor_inst</code>      Armor (<code>C_ITEM</code> instance) to be equipped or <code>-1</code> for no armor </li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_setvisual","title":"<code>Mdl_SetVisual</code>","text":"<p>Set the animation set (also dictates models you can set using the <code>Mdl_SetVisualBody</code>) </p><pre><code>func void Mdl_SetVisual(var instance npc, var string animation_set) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var instance npc</code>      NPC to apply the animation set to </li> <li><code>var string animation_set</code>      Name of the MDS file that contains the animation set</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_startfaceani","title":"<code>Mdl_StartFaceAni</code>","text":"<p>Start a face animation </p><pre><code>func void Mdl_StartFaceAni(var c_npc npc,\nvar string name,\nvar float intensity,\nvar float holdtime) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC to apply the animation to </li> <li><code>var string name</code>      Animation name</li> <li><code>var float intensity</code>      Intensity of the animation 0.0 to 1.0</li> <li><code>var float holdtime</code>      How long should the animation be held for <code>-2</code> will use the MMS defined value, '-1' will make the hold time infinite</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#mdl_applyrandomfaceani","title":"<code>Mdl_ApplyRandomFaceAni</code>","text":"<p>Start a random face animation </p><pre><code>func void Mdl_ApplyRandomFaceAni(var c_npc npc,\nvar string name,\nvar float timemin,\nvar float timeminvar,\nvar float timemax,\nvar float timemaxvar,\nvar float probmin) {};\n</code></pre> <p>Parameters</p> <ul> <li><code>var c_npc npc</code>      NPC to apply the animation to </li> <li><code>var string name</code>      Animation name</li> <li><code>var float timemin</code>      Minimum time after which the ani should be started (in seconds)</li> <li><code>var float timeminvar</code>      Minimum boundary variation (in seconds)</li> <li><code>var float timemax</code>      Maximum time after which the ani should be started (in seconds)</li> <li><code>var float timemaxvar</code>      Maximum boundary variation (in seconds)</li> <li><code>var float probmin</code>      Probablity (0.0 to 1.0) to choose the lower boundary time</li> </ul>"},{"location":"zengin/scripts/externals/mdl/#externals-with-docu-comments","title":"Externals with docu comments","text":"<pre><code>/// Apply an animation overlay with `overlay_name` for the specified `npc`\n/// \n/// @param npc NPC to apply the overlay to\n/// @param overlay_name name of the animation overlay\nfunc void Mdl_ApplyOverlayMDS(var c_npc npc, var string overlay_name) {};\n/// Apply an animation overlay with `overlay_name` for the specified `npc` for `duration` milliseconds\n///\n/// @param npc NPC to apply the overlay to\n/// @param overlay_name name of the animation overlay\n/// @param duration overlay duration in milliseconds\nfunc void Mdl_ApplyOverlayMDSTimed(var c_npc npc, var string overlay_name, var float duration) {};\n/// Remove the animation overlay `overlay_name` from specified `npc` \n/// \n/// @param npc NPC to remove the overlay from\n/// @param overlay_name name of the animation overlay\nfunc void Mdl_RemoveOverlayMDS(var c_npc npc, var string overlay_name) {};\n/// Assign a random animation `ani2` to random animation list of animation `ani1`\n///\n/// @param npc NPC owning the animation\n/// @param ani1 the animation to asign random animation to\n/// @param ani2 animation to be assigned\nfunc void Mdl_ApplyRandomAni(var c_npc npc, var string ani1, var string ani2) {};\n/// Sets the random animation frequency for animation `ani1`\n///\n/// @param npc NPC owning the animation\n/// @param ani1 the animation to set the random frequency\n/// @param frequency number of seconds between random animations\nfunc void Mdl_ApplyRandomAniFreq(var c_npc npc, var string ani1, var float frequency) {};\n/// Set the procedural model fatness\n///\n/// @param npc NPC to apply the fatness to \n/// @param fatness fatness value\nfunc void Mdl_SetModelFatness(var c_npc npc, var float fatness) {};\n/// Set model scale per axis\n///\n/// @param npc NPC to apply the scale to \n/// @param x scale along the x axis, 1.0 = 100%, 1.5 = 150%, 0.9 = 90% \n/// @param y scale along the y axis, 1.0 = 100%, 1.5 = 150%, 0.9 = 90% \n/// @param z scale along the z axis, 1.0 = 100%, 1.5 = 150%, 0.9 = 90% \nfunc void Mdl_SetModelScale(var c_npc npc, var float x, var float y, var float z) {};\n/// Sets up the visual of an NPC\n///\n/// @param npc NPC to be affected\n/// @param body_mesh mesh to be used as the body e.g. `HUN_BODY_NAKED0`\n/// @param body_tex body texture assigned to this body mesh\n/// @param skin body texture variant\n/// @param head_mesh head mesh\n/// @param head_tex head texture\n/// @param teeth_tex teeth texture\n/// @param armor_inst armor (C_ITEM instance) to be equipped or `-1` for no armor \nfunc void Mdl_SetVisualBody(var instance npc,\nvar string body_mesh,\nvar int body_tex,\nvar int skin,\nvar string head_mesh,\nvar int head_tex,\nvar int teeth_tex,\nvar int armor_inst       ) {};\n/// Set the animation set (also dictates models you can set using the `Mdl_SetVisualBody`)\n///\n/// @param npc NPC to apply the animation set to \n/// @param animation_set name of the MDS file that contains the animation set\nfunc void Mdl_SetVisual(var instance npc, var string animation_set) {};\n/// Start a face animation\n///\n/// @param npc NPC to apply the animation to \n/// @param name animation name\n/// @param intensity intensity of the animation 0.0 to 1.0\n/// @param holdtime how long should the animation be held for `-2` will use the MMS defined value, '-1' will make the hold time infinite\nfunc void Mdl_StartFaceAni(var c_npc npc,\nvar string name,\nvar float intensity,\nvar float holdtime) {};\n/// Start a random face animation\n///\n/// @param npc NPC to apply the animation to \n/// @param name animation name\n/// @param timemin minimum time after which the ani should be started (in seconds)\n/// @param timeminvar minimum boundary variation (in seconds)\n/// @param timemax maximum time after which the ani should be started (in seconds)\n/// @param timemaxvar maximum boundary variation (in seconds)\n/// @param probmin probablity (0.0 to 1.0) to choose the lower boundary time\nfunc void Mdl_ApplyRandomFaceAni(var c_npc npc,\nvar string name,\nvar float timemin,\nvar float timeminvar,\nvar float timemax,\nvar float timemaxvar,\nvar float probmin) {};\n</code></pre>"},{"location":"zengin/sound/","title":"Sound","text":""},{"location":"zengin/sound/#sound","title":"Sound","text":"<p>ZenGin uses <code>.wav</code> files for playing Sound Effects and Dubbing.</p> <p>Info</p> <p>In-game soundtrack isn't saved in <code>.wav</code> sound files. See Music.</p>"},{"location":"zengin/sound/#poperties","title":"Poperties","text":"<p>Original gothic sound files has following properties:</p> <ul> <li>One channel (Mono)</li> <li>44100 Hz frequency</li> <li>32-bit depth</li> </ul>"},{"location":"zengin/sound/#sfx","title":"SFX","text":"<p>Sound effects (SFX) are sounds made by monsters, spells, weapons etc. Sound effects are defined in multiple places, in <code>.mds</code> files as part of the animation EventBlocks, or in the SFX Daeduls scripts. Sounds are located in the <code>_work/Data/Sound/SFX</code> directory. </p>"},{"location":"zengin/sound/#speech","title":"Speech","text":"<p>Dubbing for dialogues is located into <code>_work/Data/Sound/Speech</code> folder. Every single <code>AI_Output</code> has its own sound file with name defined in the function itself.</p> <p>For this dialogue line </p><pre><code>AI_Output(self,hero,\"Info_Diego_Gamestart_11_00\"); //I'm Diego.\n</code></pre> the engine will play <code>Info_Diego_Gamestart_11_00.wav</code> sound file (if it exists)."},{"location":"zengin/sound/tutorials/change_sfx/","title":"Changing Sound Effect","text":""},{"location":"zengin/sound/tutorials/change_sfx/#changing-sound-effect","title":"Changing Sound Effect","text":"<p>This is Gothic VDFS. It is a tool that allows you to pack and unpack files in .VDF and .MOD format.</p> <p></p> <p>Let us start with unpacking \"Sound\" file:</p> <ol> <li>In the \"(Viewer)\" tab, in the \"Filename\", go to your Gothic or Gothic II/Data folder and choose \"Sound.VDF\".</li> <li>Create a folder on your desktop or any other easily accessible place on your computer. Name it however you want.</li> <li>Go to \"Root path\" and choose the folder you just created.</li> <li>Press \"Extract volume\" if you want to unpack all sound files.</li> </ol> <p>The chosen file should be unpacking right now. </p> <p>Here are the files we just extracted: </p> <p>It can oftentimes be tricky to find the sound you are looking for, but we will leave that for later. Let's just see how can we change a sound file in the game now.</p> <ol> <li>Get yourself any short sound file.</li> <li>In order for the sound to work in the game, it needs to be in mono .wav format. A lot of programs let you convert a file such as Audacity, so do just that;</li> <li>Rename your converted file into \"INV_CHANGE.WAV\" and replace it in SFX folder you just extracted;</li> <li>Go back to Gothic VDFS, go to (Builder) tab;</li> <li>In \"Filename\" you choose how do you want your file to be called and its location. I recommend creating separate folder and putting it there. You can also name the file however you want, as long as it has higher time stamp (more on that later) than original Sounds file. To create it as .VDF file, choose \"All file\" in the \"Save file as\" and call it \"Sounds.VDF\";</li> <li>In \"Root path\" go to and choose \"_WORK\" folder;</li> <li>In the field just below \"Comment\", add a * character and then click on the + next to it;</li> <li>Press \"Build\", and if you did everything right, the folder is being packed back into .VDF file;</li> </ol> <p>That's how a successful process looks like: </p> <p>Now get the file you just created, and put it in your Gothic/Data folder replacing the old one. The file we just replaced changes the sound in main menu and the inventory. If you can hear it, congratulations, you did it!</p>"},{"location":"zengin/tools/","title":"Tools","text":""},{"location":"zengin/tools/#tools","title":"Tools","text":"<p>The community has developed many tools to help with the creation of Gothic mods.</p> <p>Note</p> <p>This list is a work in progress.</p> <p>Daedalus</p> <ul> <li>Daedalus Language Server - a VS Code/VS Codium extension that adds IDE like functionality for Daedalus scripting language</li> <li>Ikarus - A daedalus library for the game Gothic. Exploits the interpreter to allow arbitrary memory access and defines a lot of useful functions for interfacing with the engine. </li> <li>LeGo - A daedalus library for the game Gothic. It contains various packages to support modders.</li> <li>AFSP - Fawkes' &amp; Auronen's script package for Gothic 1 and Gothic 2: Night of the Raven.</li> <li>Ninja - Ninja introduces the possibility of true modular modifications for the video games Gothic and Gothic 2 Night of the Raven.</li> </ul> <p>VDFS tools</p> <ul> <li>GothicVDFS - NiceDE's viewer, extractor and builder for <code>.vdf</code> and <code>.mod</code> volumes</li> <li>VDFS Tool - Gratt's Union VDFS viewer, extractor, builder, optimizer and ZIP compressor for <code>.vdf</code> and <code>.mod</code> volumes</li> </ul> <p>World Editors</p> <ul> <li>Spacer - the original world editor for ZenGin, ships with the MDK</li> <li>Union Gothic World Editor - Saturas' world editor, supports new object classes created with Union</li> <li>Gothic World Editor - World editor for vanilla worlds, works with G1, G2 and G2 NotR worlds</li> <li>Spacer.NET - A modernised version of Spacer available as a Gothic Mod.</li> </ul>"},{"location":"zengin/tools/gothic_sourcer/","title":"Gothic Sourcer","text":""},{"location":"zengin/tools/gothic_sourcer/#gothic-sourcer","title":"Gothic Sourcer","text":"<p>Gothic Sourcer can be used to do a lot of things.</p> <p>Todo</p> <p>TODO</p>"},{"location":"zengin/tools/zSpy/","title":"zSpy","text":""},{"location":"zengin/tools/zSpy/#zspy","title":"zSpy","text":"<p>zSpy is a debugging tool that displays most of the operations performed by the engine during the Gothic or Spacer running.</p> Example image of running zSpy <p></p> <p>Warning</p> <p>zSpy must be started before Gothic or the Spacer is started so that the program can find it. Sometimes in Gothic I this has to be done manually, in Gothic II This is done by the GothicStarter_mod. </p> <p>In order to be able to follow the messages in zSpy, Gothic should be started in the window. The corresponding startup option can be found in GothicStarter (mod). Within Gothic, when Marvin mode is activated, you can switch between window and full-screen mode at any time with the <code>F3</code> key.</p>"},{"location":"zengin/tools/zSpy/#log-level","title":"Log Level","text":"<p>With the <code>-zlog#</code> command in GothicStarter, you can specify how many messages zSpy will output. <code>#</code> can be a number between -1 and 9. Used for: </p> <ul> <li> <p><code>-1</code> - Disable every message (expect fatal errors)</p> </li> <li> <p><code>0</code> - Shows only warnings, faults and fatal errors</p> </li> <li> <p><code>1 - 9</code> - Display more information. Every Information has their priority. If you select 1, the program displays only messages with priority <code>=&lt; 1</code>, with 5 only priority <code>=&lt; 5</code>, and with 9, almost everything that Gothic can produce. </p> </li> </ul> <p>For general debugging, recommended value is 5.</p>"},{"location":"zengin/tools/zSpy/#output","title":"Output","text":"<p>The zSpy issues its reports in the following form: </p> <pre><code>Time  Type  Priority  User   Message              ...      &lt;filename,       #line&gt;\n00:21 Info:  3        B:     GOTHIC: Exiting game ... .... &lt;oGameManager.cpp,#617&gt;\n</code></pre>"},{"location":"zengin/tools/zSpy/#time","title":"Time","text":"<p>Time elapsed since the start of Gothic.exe</p>"},{"location":"zengin/tools/zSpy/#type","title":"Type","text":"<p>Type of message. The following message types are distinguished:</p> <ul> <li> <p><code>Fatal:</code> - Critical error causing application to close. </p> </li> <li> <p><code>Fault:</code> - A simple bug that will not cause the application to stop, but display or performance issues may occur. </p> </li> <li> <p><code>Warn:</code> - A warning of possible consequences. An error that follows soon afterwards could have something to do with it. </p> </li> <li> <p><code>Info:</code> - General information about the progress of the program. </p> </li> </ul>"},{"location":"zengin/tools/zSpy/#priority","title":"Priority","text":"<p>Priority level of the message. Messages with lower priority (higher number) can be disabled. See log level.</p>"},{"location":"zengin/tools/zSpy/#user","title":"User","text":"<p>User ID - a letter defined by every engine developer to highlight its logs</p> <ul> <li><code>D</code> - Dieter</li> <li><code>U</code> - Ulf </li> <li><code>B</code> - Bert </li> <li><code>C</code> - Carsten</li> <li><code>A</code> - Andre</li> <li><code>X</code> - Kurt</li> </ul>"},{"location":"zengin/tools/zSpy/#message","title":"Message","text":"<p>The most important part. A message that contains:</p> <ul> <li> <p>Symbol representing a program module. The names are mostly self-explanatory, so there is no need to type them all (<code>MDL</code> = 3D models, <code>PAR</code> = Parser etc.).</p> </li> <li> <p>The message for the user.</p> </li> </ul>"},{"location":"zengin/tools/zSpy/#configuration","title":"Configuration","text":"<p>In zSpy, you can customize the font and its color depending on the type of message. </p> <p>In addition, you can configure the logging options:</p> <ul> <li>Filtering various messages (Info, Warn, Fault, Fatal).</li> <li>Auto show/hide zSpy when starting/stopping Gothic.</li> <li>Saving the log file to a separate file.</li> </ul>"},{"location":"zengin/tools/zSpy/#console-commands","title":"Console commands","text":"<p>List of console commands related with zSpy.</p> <p>Note</p> <p>The list is work in progress. Console commands needs a separate article or section.</p>"},{"location":"zengin/tools/zSpy/#zerr-level","title":"<code>zerr level</code>","text":"<p>Sets a level of logging. </p><pre><code>zerr level &lt;#&gt;\n</code></pre> <ul> <li><code>&lt;#&gt;</code> - max message priority. See log level.</li> </ul>"},{"location":"zengin/tools/zSpy/#zerr-searchspy","title":"<code>zerr searchspy</code>","text":"<p>Links zSpy with Gothic. Useful when you run zSpy when the game is already running. </p><pre><code>zerr searchspy\n</code></pre>"},{"location":"zengin/tools/zSpy/#zerr-authors","title":"<code>zerr authors</code>","text":"<p>Sets a filter to display only messages of one author.  </p><pre><code>zerr authors &lt;letter&gt;\n</code></pre> <ul> <li><code>&lt;letter&gt;</code> - One of the letters listed here.</li> </ul>"},{"location":"zengin/tools/zSpy/#zerr-rem","title":"<code>zerr rem</code>","text":"<p>Includes a remark into the log. </p><pre><code>zerr rem\n</code></pre> Looks like that: <pre><code>00:46 Info:  3 B:       OPT: Blood-Details: Value=2 .... &lt;oGameManager.cpp,#1302&gt;\n00:57 ---------------\n00:57 ---------------\n01:01 Info:  3 B:     GMAN: Leaving Menu-Section .... &lt;oGameManager.cpp,#1537&gt;\n</code></pre>"},{"location":"zengin/tools/zSpy/#zerr-status","title":"<code>zerr status</code>","text":"<p>Displays a current status of zSpy in the console. </p><pre><code>zerr status\n</code></pre>"},{"location":"zengin/tools/daedalus_tools/daedalus_language_server/","title":"Daedalus Language Server","text":""},{"location":"zengin/tools/daedalus_tools/daedalus_language_server/#daedalus-language-server","title":"Daedalus Language Server","text":"<p>Daedalus Language Server</p> <p>Todo</p> <p>TODO</p>"},{"location":"zengin/tools/vdfs_tools/gothic_vdfs/","title":"GothicVDFS","text":""},{"location":"zengin/tools/vdfs_tools/gothic_vdfs/#gothicvdfs","title":"GothicVDFS","text":"<p>Gothic VDFS is still the most popular VDFS tool. It was created by NicoDE.</p>"},{"location":"zengin/tools/vdfs_tools/gothic_vdfs/#download","title":"Download","text":"<p>You can download the tool from NicoDE's website - direct link.</p>"},{"location":"zengin/tools/vdfs_tools/gothic_vdfs/#quick-overview","title":"Quick overview","text":""},{"location":"zengin/tools/vdfs_tools/vdfs_tool/","title":"VDFS Tool","text":""},{"location":"zengin/tools/vdfs_tools/vdfs_tool/#vdfs-tool","title":"VDFS Tool","text":"<p>VDFS Tool is a new program that supports new features introduced to VDFS by the Union team. Like ZIP compression or drag and drop support.</p>"},{"location":"zengin/tools/vdfs_tools/vdfs_tool/#download","title":"Download","text":"<p>You can download the tool from the post on WoP.ru - VDFS Tool or using the Resource Manager</p>"},{"location":"zengin/tools/vdfs_tools/vdfs_tool/#quick-overview","title":"Quick overview","text":""},{"location":"zengin/union/","title":"Union","text":""},{"location":"zengin/union/#union","title":"Union","text":"<p>Union is a system to patch and extend Gothic's engine the ZenGin. It allows you to load <code>.dll</code> files - ZenGin extensions created using the Gothic/Union SDK and <code>.patch</code> files - files designed to patch the game's executable. The Union installer also contains the SystemPack a collection of bug fixes and engine edits that improve performance.</p>"},{"location":"zengin/union/#plug-ins","title":"Plug-ins","text":"<p>Union plugins are shipped in the form of a <code>.dll</code> library. This library contains the compiled C++ code with the Union SDK and an embedded <code>.patch</code> file.</p>"},{"location":"zengin/union/#union-sdk--gothic-api","title":"Union SDK &amp; Gothic API","text":"<p>Union software development kit is a collection of tools and the Gothic API that allow you to create Union plugins and alter the engine's behavior.   Gothic API is a set of 4 interfaces (each for one different ZenGin version) that allow you to interface with the engine, access the engine objects, change their behavior and introduce new classes and functionality.</p>"},{"location":"zengin/union/#patch-file-format","title":"PATCH file format","text":"<p>The <code>.patch</code> file contains one or more small programs that are designed to change the engine code (game executable). This is usually done to fix bugs. Union plug-ins contain an embedded <code>.patch</code> file and this file usually contains changes to the binary necessary for the proper function of the plug-in.</p>"},{"location":"zengin/union/plugins/zbassmusic/","title":"zBassMusic","text":""},{"location":"zengin/union/plugins/zbassmusic/#zbassmusic","title":"zBassMusic","text":"<p>zBassMusic is a modern music system for Gothic I and Gothic II NotR based on BASS Audio Library made by Silver Ore Team. It replaces the old DirectMusic system to let the modders create music for Gothic as regular audio files instead of DirectMusic format.</p> <p>Info</p> <p>For the plugin documentation, visit the github site of a project. The documentation is build into the code.</p> Contacts Authors  Silver Ore Team - tehe GitHub  zBassMusic Discord  Gothic Modding Community server"},{"location":"zengin/union/plugins/zbassmusic/#features","title":"Features","text":"<ul> <li>Music playback with modern audio formats like WAV, MP3, OGG</li> <li>Out-of-the-box support for existing C_MUSICTHEME instances</li> <li>Scriptable interface to take full control of music scheduling</li> <li>Loading music files from VDFS volumes (excluding .sgt)</li> <li>Backwards compatibility with DirectMusic .sgt files</li> </ul>"},{"location":"zengin/union/plugins/zgamepad/","title":"zGamePad","text":""},{"location":"zengin/union/plugins/zgamepad/#zgamepad","title":"zGamePad","text":"<p>zGamePad plugin adds gamepad support for ZenGin games.  </p> <p>Important</p> <p>Visit the excellent original GitHub wiki page.</p> Contacts Author  Gratt GitHub  zGamePad Forum  zGamePad"},{"location":"zengin/union/plugins/zgamepad/#gamepad-support","title":"Gamepad support","text":"<ul> <li>All xinput compatible (including emulators)</li> <li>Xbox controller family</li> <li>Dualshock 4</li> <li>Dualsense</li> <li>Nintendo Switch Joy-Cons</li> <li>Nintendo Switch Pro Controller</li> </ul>"},{"location":"zengin/union/plugins/zgamepad/#features","title":"Features","text":"<ul> <li>Natural Movements Intuitiveness and smoothness of movement controls is the main goal of this plugin. Touch the world of Gothic with your hands.</li> <li>Interactive hints Interactive hints will help you in mastering the controls. You can always customize their appearance or disable them.</li> <li>Quick access The plugin has two quick access rings - **weapons and items. Use them to always have access to your items.</li> <li>Automatic save naming Sit comfortably. You do not have to reach for your keyboard, because the plugin itself will give a name to your saves.</li> <li>Saves rotation The best alternative to quicksaves for gamepad controls.</li> <li>Vibration response Immerse yourself in the game even more. Vibration will allow you to feel your character and everything that happens in the world.</li> <li>Target locking The plugin will always help you win. Keeping the enemy in focus will allow you to fight much more effectively.</li> <li>Stuck protection Oops! If you get stuck, hold both analogue sticks for a few seconds and the character will reset.</li> </ul>"},{"location":"zengin/union/plugins/zgamepad/controls/","title":"Controls customization","text":""},{"location":"zengin/union/plugins/zgamepad/controls/#gamepad-controls","title":"Gamepad controls","text":"<p>The zGamePad plugin comes with a default control scheme, but it is possible to create your own. The plugin will search for any file with the <code>.gamepad.overlay</code> extension placed in <code>Gothic/System</code> directory or in any of the loaded <code>.mod</code> and <code>.vdf</code> archives.</p>"},{"location":"zengin/union/plugins/zgamepad/controls/#control-file-syntax","title":"Control file syntax","text":"<p>Gamepad controls are set using the <code>.gamepad</code> configuration file. This file encodes the controls for different actions in the game and the hint string in multiple languages.</p> <p>Warning</p> <p>The <code>.gamepad</code> file must be encoded in Unicode or UTF-8 to accommodate the multilingual hint strings.</p>"},{"location":"zengin/union/plugins/zgamepad/controls/#regions","title":"Regions","text":"<p>The format supports code blocks specified by the <code>#region</code> and <code>#endregion</code> keywords. These regions do not have any syntactical meaning, they only offer a convenient way to collapse sections of the code in editors with the syntax highlighting capabilities such as Notepad++</p> Regions<pre><code>#region strings\n    // TODO\n#endregion\n\n#region fight scheme\n    // TODO\n#endregion\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/controls/#comments","title":"Comments","text":"<p>Comments are useful for quick information or just to disable some old code that might come in handy later. The <code>.gamepad</code> file syntax supports C++ line comments using two forward slashes <code>//</code>.</p> <p>Warning</p> <p>Comments can only be used at the start of any given line!</p> Comments<pre><code>// this is a comment\nKeyRecord // this is NOT a comment\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/controls/#strings","title":"Strings","text":"<p>Strings are used for interactive hints. They should be defined at the top of the file. To define a string, use the keyword <code>String</code>. Strings have the following format: </p>Multilang string syntax<pre><code>String [id]\n    [langTag] [text]\n    [langTag] [text]\n    [langTag] [text]\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/controls/#example","title":"Example","text":"<pre><code>String interact\n    Rus \"\u0412\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c\"\n    Eng \"Interact\"\n    Pol \"Interakcja\"\n    Deu \"Interagieren\"\n\nString remove_weapon\n    Rus \"\u0423\u0431\u0440\u0430\u0442\u044c \u043e\u0440\u0443\u0436\u0438\u0435\"\n    Eng \"Remove weapon\"\n    Pol \"Chowanie broni\"\n    Deu \"Waffe entfernen\"\n</code></pre> The string <code>name</code> must be unique and is used to reference the string while defining hints. The language tag matches the language in <code>SystemPack.ini</code>. If the file does not contain the user's language, English will be taken by default. If there is no English, then the first one."},{"location":"zengin/union/plugins/zgamepad/controls/#control-bindings","title":"Control bindings","text":"<p>A binding is a description of an event that includes emulation object and conditions. Hints are part of the binding. The general structure of the bind starts with the keyword <code>KeyRecord</code> and has the following format: </p>Control binding<pre><code>KeyRecord [modifier]\n    Id          [key name]\n    Combination [gamepad keys]\n    Emulation   [engine logical and absolute keys]\n    Condition   [engine logical, absolute keys or logical functions]\n    Help        [name of the hint string]\n</code></pre> <ul> <li><code>Id</code> - unique identifier used by other users to override this control binding</li> <li><code>[modifier]</code> - can be empty or take the value of <code>Toggled</code> If the value is empty, the control binding will work as long as the player holds down the specified button or button combination.       If the value is <code>Toggled</code>, the control binding will work only when the player toggles the button or button combination. (One press to start sneaking, another press to stop sneaking)</li> <li><code>Combination</code> - these are the gamepad buttons that the player must press or hold to activate the control binding.</li> <li><code>Emulation</code> - specify which buttons will be emulated. You can specify absolute buttons, or that are defined in the game settings (logical).</li> <li><code>Condition</code> - specify the condition under which the control binding can be activated. To invert condition, use the operator <code>!</code> before the operand (!Cond_IsOverlayTop, !JOY_B)</li> <li> <p><code>Help</code> - name of the text string with a hint which will be displayed when the Conditions are met.</p> </li> <li> <p><code>[gamepad keys]</code> - Gamepad key list</p> </li> <li><code>[engine logical keys]</code> - Engine logical key list</li> <li><code>[engine absolute keys]</code> - Engine absolute key list</li> <li><code>[logical functions]</code> - Logical function list</li> </ul> <p>Tip</p> <p>All operators are optional! This means that if a binding should only show a hint, it doesn't have to contain Combination.</p>"},{"location":"zengin/union/plugins/zgamepad/controls/#example_1","title":"Example","text":"Control binding examples<pre><code>KeyRecord\n    Id          StopUsingPicklock\n    Combination JOY_B\n    Emulation   KEY_DOWN\n    Condition   Cond_InterfaceIsOpen, Cond_UsesPicklock, !JOY_B\n\nKeyRecord Toggled\n    Id          ReturnToHumanForm\n    Combination JOY_A\n    Emulation   KEY_RETURN\n    Condition   Cond_InTransformation\n    Help        end_transform\n\nKeyRecord\n    Id          QuickRingSelectSlot\n    Combination JOY_RSTICK_FULL\n    Condition   !Cond_InventoryIsOpen, Cond_IsOverlayTop\n    Help        focus_item\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/controls/#controls-override","title":"Controls override","text":"<p>If you want to change or remove bindings from another controls file, use the <code>KeyDisable</code> keyword.   Default controls file</p> <p></p>Controls override syntax<pre><code>KeyDisable [fileName].[Id]\n</code></pre> Where <code>fileName</code> is the name of the controls file without extension and <code>id</code> is a key of the binding."},{"location":"zengin/union/plugins/zgamepad/controls/#example_2","title":"Example","text":"Controls override example<pre><code>// remove key from the main controls file\nKeyDisable Controls.ArrowDown\n\n// create new key based on the same buttons\nKeyRecord Toggled\n    Id          ArrowDownNew\n    Combination JOY_DOWN\n    Emulation   GAME_DOWN\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/keys_engine_absolute/","title":"Engine absolute keys","text":""},{"location":"zengin/union/plugins/zgamepad/keys_engine_absolute/#engine-absolute-keys","title":"Engine absolute keys","text":"<p>Absolute keys are the physical keys on your keyboard. </p><pre><code>MOUSE_DX\nMOUSE_DY\nMOUSE_UP\nMOUSE_DOWN\nMOUSE_LEFT\nMOUSE_RIGHT\nMOUSE_WHEELUP\nMOUSE_WHEELDOWN\nMOUSE_BUTTONLEFT\nMOUSE_BUTTONRIGHT\nMOUSE_BUTTONMID\nMOUSE_XBUTTON1\nMOUSE_XBUTTON2\nMOUSE_XBUTTON3\nMOUSE_XBUTTON4\nMOUSE_XBUTTON5\nKEY_ESCAPE\nKEY_1\nKEY_2\nKEY_3\nKEY_4\nKEY_5\nKEY_6\nKEY_7\nKEY_8\nKEY_9\nKEY_0\nKEY_MINUS\nKEY_EQUALS\nKEY_BACK\nKEY_TAB\nKEY_Q\nKEY_W\nKEY_E\nKEY_R\nKEY_T\nKEY_Y\nKEY_U\nKEY_I\nKEY_O\nKEY_P\nKEY_LBRACKET\nKEY_RBRACKET\nKEY_RETURN\nKEY_LCONTROL\nKEY_A\nKEY_S\nKEY_D\nKEY_F\nKEY_G\nKEY_H\nKEY_J\nKEY_K\nKEY_L\nKEY_SEMICOLON\nKEY_APOSTROPHE\nKEY_GRAVE\nKEY_LSHIFT\nKEY_BACKSLASH\nKEY_Z\nKEY_X\nKEY_C\nKEY_V\nKEY_B\nKEY_N\nKEY_M\nKEY_COMMA\nKEY_PERIOD\nKEY_SLASH\nKEY_RSHIFT\nKEY_MULTIPLY\nKEY_LMENU\nKEY_SPACE\nKEY_CAPITAL\nKEY_F1\nKEY_F2\nKEY_F3\nKEY_F4\nKEY_F5\nKEY_F6\nKEY_F7\nKEY_F8\nKEY_F9\nKEY_F10\nKEY_NUMLOCK\nKEY_SCROLL\nKEY_NUMPAD7\nKEY_NUMPAD8\nKEY_NUMPAD9\nKEY_SUBTRACT\nKEY_NUMPAD4\nKEY_NUMPAD5\nKEY_NUMPAD6\nKEY_ADD\nKEY_NUMPAD1\nKEY_NUMPAD2\nKEY_NUMPAD3\nKEY_NUMPAD0\nKEY_DECIMAL\nKEY_OEM_102\nKEY_F11\nKEY_F12\nKEY_F13\nKEY_F14\nKEY_F15\nKEY_KANA\nKEY_ABNT_C1\nKEY_CONVERT\nKEY_NOCONVERT\nKEY_YEN\nKEY_ABNT_C2\nKEY_NUMPADEQUALS\nKEY_PREVTRACK\nKEY_AT\nKEY_COLON\nKEY_UNDERLINE\nKEY_KANJI\nKEY_STOP\nKEY_AX\nKEY_UNLABELED\nKEY_NEXTTRACK\nKEY_NUMPADENTER\nKEY_RCONTROL\nKEY_MUTE\nKEY_CALCULATOR\nKEY_PLAYPAUSE\nKEY_MEDIASTOP\nKEY_VOLUMEDOWN\nKEY_VOLUMEUP\nKEY_WEBHOME\nKEY_NUMPADCOMMA\nKEY_DIVIDE\nKEY_SYSRQ\nKEY_RMENU\nKEY_PAUSE\nKEY_HOME\nKEY_UP\nKEY_PRIOR\nKEY_LEFT\nKEY_RIGHT\nKEY_END\nKEY_DOWN\nKEY_NEXT\nKEY_INSERT\nKEY_DELETE\nKEY_LWIN\nKEY_RWIN\nKEY_APPS\nKEY_POWER\nKEY_SLEEP\nKEY_WAKE\nKEY_WEBSEARCH\nKEY_WEBFAVORITES\nKEY_WEBREFRESH\nKEY_WEBSTOP\nKEY_WEBFORWARD\nKEY_WEBBACK\nKEY_MYCOMPUTER\nKEY_MAIL\nKEY_MEDIASELECT\nKEY_BACKSPACE\nKEY_NUMPADSTAR\nKEY_LALT\nKEY_CAPSLOCK\nKEY_NUMPADMINUS\nKEY_NUMPADPLUS\nKEY_NUMPADPERIOD\nKEY_NUMPADSLASH\nKEY_RALT\nKEY_UPARROW\nKEY_PGUP\nKEY_LEFTARROW\nKEY_RIGHTARROW\nKEY_DOWNARROW\nKEY_PGDN\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/keys_engine_logical/","title":"Engine logical keys","text":""},{"location":"zengin/union/plugins/zgamepad/keys_engine_logical/#engine-logical-keys","title":"Engine logical keys","text":"<p>Logical keys are the keys you set in keyboard settings in the game menu. These can fill multiple roles in different situations and the gamepad controls can be set to emulate these logical keys. </p><pre><code>GAME_LEFT\nGAME_RIGHT\nGAME_UP\nGAME_DOWN\nGAME_ACTION\nGAME_SLOW\nGAME_ACTION2\nGAME_WEAPON\nGAME_SMOVE\nGAME_SMOVE2\nGAME_SHIFT\nGAME_END\nGAME_INVENTORY\nGAME_LOOK\nGAME_SNEAK\nGAME_STRAFELEFT\nGAME_STRAFERIGHT\nGAME_SCREEN_STATUS\nGAME_SCREEN_LOG\nGAME_SCREEN_MAP\nGAME_LOOK_FP\nGAME_LOCK_TARGET\nGAME_PARADE\nGAME_ACTIONLEFT\nGAME_ACTIONRIGHT\nGAME_LAME_POTION\nGAME_LAME_HEAL\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/keys_gamepad/","title":"Gamepad keys","text":""},{"location":"zengin/union/plugins/zgamepad/keys_gamepad/#gamepad-keys","title":"Gamepad keys","text":"<p>In order to set gamepad keys, you have to know the key codes as they are listed below. </p><pre><code>JOY_UP\nJOY_DOWN\nJOY_LEFT\nJOY_RIGHT\nJOY_MENU\nJOY_VIEW\nJOY_LSTICK\nJOY_RSTICK\nJOY_LB\nJOY_RB\nJOY_A\nJOY_B\nJOY_X\nJOY_Y\nJOY_LSTICK_LOWUP\nJOY_LSTICK_UP\nJOY_LSTICK_DOWN\nJOY_LSTICK_LEFT\nJOY_LSTICK_RIGHT\nJOY_RT\nJOY_LT\nJOY_DPAD\nJOY_UPDOWN\nJOY_LEFTRIGHT\nJOY_LSTICK_FULL\nJOY_RSTICK_FULL\n</code></pre>"},{"location":"zengin/union/plugins/zgamepad/logical_functions/","title":"Logical functions","text":""},{"location":"zengin/union/plugins/zgamepad/logical_functions/#logical-function-names","title":"Logical function names","text":"<p>Conditions for when to show or allow the control binding to work are specified using these logic functions. They describe different useful states of the game or user interface, allowing the user to set when will a certain control work.  </p><pre><code>Cond_FightMode        - player is in the fight mode\nCond_FightModeMelee   - player is in the melee fight mode\nCond_FightModeRange   - player is in the ranged fight mode\nCond_FightModeMagic   - player is in the magical fight mode\nCond_CanShoot         - player is in the aim mode and can shoot now\nCond_CanSneaking      - player is sneaking now\nCond_Diving           - player is diving now\nCond_HasFocusVob      - player has a focus vob\nCond_HasFocusNpc      - player has a focus npc\nCond_OnChooseWeapon   - weapon selection is active\nCond_InventoryIsOpen  - inventory is open\nCond_InTransformation - player is transformed\nCond_VideoIsOpen      - video is playing\nCond_CanLockTarget    - player in the fight mode now and can lock the focus vob\nCond_G1               - this engine is a Gothic 1 (or sequel)\nCond_G2               - this engine is a Gothic 2 NoTR (or classic)\nCond_IsDialogTop      - dialog window is open on the top\nCond_IsDocumentTop    - document object is open on the top\nCond_IsOverlayTop     - gamepad overlay object is open on the top\nCond_IsMenuTop        - game menu is open on the top\nCond_OnSpellBook      - magic selection ring is active\nCond_IsPlayerTalking  - player is talking to someone\nCond_InterfaceIsOpen  - open any interface element\nCond_HasLeftContainer - the left container is open (chest, plunder, trader)\nCond_UsesPicklock     - player is picking a lock now\nCond_IsOnTrade        - player is trading\nCond_IsOverlayTop     - gamepad overlay object is open on the top\nCond_IsMenuTop        - game menu is open on the top\n</code></pre>"},{"location":"zengin/union/sdk/","title":"Union SDK","text":""},{"location":"zengin/union/sdk/#union-sdk","title":"Union SDK","text":"<p>Union SDK is a software development kit for making Union plugins that directly interact with Gothic engines. It contains a project template for Visual Studio IDE, a C++ library for hooking into a Gothic executable, and Gothic API with methods' addresses for the engines of Gothic I, Gothic II, Gothic II NotR, and also for the not released Gothic Sequel. </p> <p>Working with Union SDK requires at least basic knowledge of C++ programming. Knowledge of the x86 (32-bit) architecture, dynamically linked libraries, and reverse engineering is also welcomed as we need to understand what the Gothic engine does under the hood to use it effectively. </p>"},{"location":"zengin/union/sdk/#requirements","title":"Requirements","text":"<p>Union SDK requires Visual Studio IDE, NET Framework 4.7.2, and Visual C++ 2010 libraries. They are available on Microsoft websites:</p> <ul> <li>Visual Studio - https://visualstudio.microsoft.com/vs/</li> <li>NET Framework 4.7.2 - https://dotnet.microsoft.com/download/dotnet-framework/net472</li> <li>Visual C++ 2010 - https://www.microsoft.com/download/details.aspx?id=26999</li> </ul>"},{"location":"zengin/union/sdk/#resource-manager","title":"Resource Manager","text":"<p>The official installation of Union SDK is provided through Resource Manager. After the installation, Visual Studio will have a new project template \"Union Plugin 1.0\" that creates a basic Union plugin project.</p>"},{"location":"zengin/union/sdk/events/","title":"Game Events","text":""},{"location":"zengin/union/sdk/events/#game-events","title":"Game Events","text":"<p>Union defines several Game Events that are dispatched when a specific event occurs in-game. Handlers are defined in <code>Plugin.cpp</code> and we can use them to execute our code during specific moments of the application lifetime.</p>"},{"location":"zengin/union/sdk/events/#events","title":"Events","text":""},{"location":"zengin/union/sdk/events/#initialization","title":"Initialization","text":""},{"location":"zengin/union/sdk/events/#game_entry","title":"Game_Entry","text":"<p>Executes at the entry point of the Gothic executable. During this time the engine classes are not yet initialized, so using them may cause an access violation. The entry point be used to execute some logic before Gothic loads itself. </p><pre><code>void Game_Entry() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_defineexternals","title":"Game_DefineExternals","text":"<p>Executes before the Daedalus parser starts loading scripts. It's meant to define custom external functions. </p><pre><code>void Game_DefineExternals() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_init","title":"Game_Init","text":"<p>Executes right after DAT files are loaded and just before the main menu shows up. </p><pre><code>void Game_Init() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#level-change","title":"Level Change","text":""},{"location":"zengin/union/sdk/events/#game_loadbegin","title":"Game_LoadBegin","text":"<p>Executes when we initiate a level change by one of the possible actions. The default plugin template uses a common <code>LoadBegin()</code> function to handle all events but we also can write different logic for different cases.</p> <pre><code>void LoadBegin() {\n}\n// When player clicks \"New Game\"\nvoid Game_LoadBegin_NewGame() {\nLoadBegin();\n}\n// When player loads a saved game\nvoid Game_LoadBegin_SaveGame() {\nLoadBegin();\n}\n// When player changes ZEN by a trigger\nvoid Game_LoadBegin_ChangeLevel() {\nLoadBegin();\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_loadend","title":"Game_LoadEnd","text":"<p>Executes when the level loading finishes. The default plugin template uses a common <code>LoadEnd()</code> function to handle all events but we also can write different logic for different cases.</p> <pre><code>void LoadEnd() {\n}\n// When player clicks \"New Game\"\nvoid Game_LoadEnd_NewGame() {\nLoadEnd();\n}\n// When player loads a saved game\nvoid Game_LoadEnd_SaveGame() {\nLoadEnd();\n}\n// When player changes ZEN by a trigger\nvoid Game_LoadEnd_ChangeLevel() {\nLoadEnd();\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_loadbegin_trigger","title":"Game_LoadBegin_Trigger","text":"<p>Executes when the player enters a trigger that initiates ZEN change.</p> <pre><code>void Game_LoadBegin_Trigger() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_loadend_trigger","title":"Game_LoadEnd_Trigger","text":"<p>Executes after the player has entered a trigger that initiates ZEN change.</p> <pre><code>void Game_LoadEnd_Trigger() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_applyoptions","title":"Game_ApplyOptions","text":"<p>Executes after <code>Game_LoadEnd</code>, when we save the game, and also when we exit the game. It's meant to be used to apply options from INI files. </p><pre><code>void Game_ApplyOptions() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game-loop","title":"Game Loop","text":""},{"location":"zengin/union/sdk/events/#game_preloop","title":"Game_PreLoop","text":"<p>Executes at the start of every frame.</p> <pre><code>void Game_PreLoop() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_loop","title":"Game_Loop","text":"<p>Executes at every frame.</p> <pre><code>void Game_Loop() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_postloop","title":"Game_PostLoop","text":"<p>Executes at the end of every frame.</p> <pre><code>void Game_PostLoop() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_menuloop","title":"Game_MenuLoop","text":"<p>Executes at every frame when the game menu is active.</p> <pre><code>void Game_MenuLoop() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_savebegin","title":"Game_SaveBegin","text":"<p>Executes when the player started saving a game.</p> <pre><code>void Game_SaveBegin() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_saveend","title":"Game_SaveEnd","text":"<p>Executes when the game save finishes.</p> <pre><code>void Game_SaveEnd() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_pause","title":"Game_Pause","text":"<p>Executes when the player opens the in-game menu.</p> <pre><code>void Game_Pause() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#game_unpause","title":"Game_Unpause","text":"<p>Executes when the player leaves the in-game menu and also when the player loads a saved game.</p> <pre><code>void Game_Unpause() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/events/#shutdown","title":"Shutdown","text":""},{"location":"zengin/union/sdk/events/#game_exit","title":"Game_Exit","text":"<p>Executes when the player exits the game.</p> <pre><code>void Game_Exit() {\n}\n</code></pre>"},{"location":"zengin/union/sdk/externals/","title":"Externals","text":""},{"location":"zengin/union/sdk/externals/#externals","title":"Externals","text":"<p>Externals are functions defined by the Gothic engine that can be called from scripts. Union SDK provides symbols for pointers to global <code>zCParser</code> instances that we can use to interact with the parser and to define a custom external function.</p> <pre><code>extern zCParser*    parser;\nextern zCParser*&amp;   parserSoundFX;\nextern zCParser*&amp;   parserParticleFX;\nextern zCParser*&amp;   parserVisualFX;\nextern zCParser*&amp;   parserCamera;\nextern zCParser*&amp;   parserMenu;\nextern zCParser*&amp;   parserMusic;\n</code></pre>"},{"location":"zengin/union/sdk/externals/#creating-custom-external","title":"Creating custom external","text":"<p>To create an external we need to define a function handler and register it in the parser. Before we start, it's good to write down a Daedalus function signature so we can see the return and argument types that will be important later. </p><pre><code>func string AddNumbers(var int FirstArgument, var int SecondArgument, var string ThirdArgument)  {}\n</code></pre>"},{"location":"zengin/union/sdk/externals/#function-handler","title":"Function handler","text":"<p>External function handler signature must:</p> <ul> <li>return <code>int</code> or <code>bool</code></li> <li>use <code>__cdecl</code> calling convention (default in C++)</li> <li>take no arguments</li> </ul> <p>Inside the handler, we can use the global <code>parser</code> to pop function arguments and push the return value from/to the stack. It's important to pop the arguments in reverse order and to pop all of them even if we are not going to use them. Similarly, the return value must always be set if any and must never be set if the function returns <code>void</code>. If we don't follow the rules, the stack may get corrupted and lead to the Gothic crash.</p> <pre><code>// __cdecl is optional because it's the default calling convention\nint __cdecl AddNumbers_External()\n{\n// Declare arguments\nint FirstArgument;\nint SecondArgument;\nzSTRING ThirdArgument;\n// Pop arguments from the stack **IN REVERSE ORDER**\nparser-&gt;GetParameter(ThirdArgument);\nparser-&gt;GetParameter(SecondArgument);\nparser-&gt;GetParameter(FirstArgument);\n// Execute function logic\nint result = FirstArgument + SecondArgument;\nzSTRING output = ThirdArgument + zSTRING(result);\n// Push return value\nparser-&gt;SetReturn(output);\n// Return value is ignored, so 0 or 1 is fine.\nreturn 0;\n}\n</code></pre>"},{"location":"zengin/union/sdk/externals/#register-external","title":"Register external","text":"<p>Externals should be registered in the parser during the <code>Game_DefineExternals</code> game event. We need to call <code>parser-&gt;DefineExternal</code> with variadic arguments:</p> <ul> <li>external function name in Daedalus</li> <li>reference to function handler</li> <li>return type </li> <li>...argument types</li> <li><code>zPAR_TYPE_VOID</code> indicates the end of the argument types list</li> </ul> <pre><code>void Game_DefineExternals() {\nparser-&gt;DefineExternal(\"AddNumbers\", AddNumbers_External, zPAR_TYPE_STRING, zPAR_TYPE_INT, zPAR_TYPE_INT, zPAR_TYPE_STRING, zPAR_TYPE_VOID);\n}\n</code></pre> <p>Available types are defined by an enum: </p><pre><code>enum {\nzPAR_TYPE_VOID,\nzPAR_TYPE_FLOAT,\nzPAR_TYPE_INT,\nzPAR_TYPE_STRING,\nzPAR_TYPE_CLASS,\nzPAR_TYPE_FUNC,\nzPAR_TYPE_PROTOTYPE,\nzPAR_TYPE_INSTANCE\n};\n</code></pre>"},{"location":"zengin/union/sdk/getting_started/","title":"Getting Started","text":""},{"location":"zengin/union/sdk/getting_started/#getting-started","title":"Getting Started","text":"<p>This article provides a beginner-friendly tutorial for setting up and compiling a Union project. Instructions for installing Union SDK are located at Union SDK.</p>"},{"location":"zengin/union/sdk/getting_started/#creating-union-plugin","title":"Creating Union plugin","text":""},{"location":"zengin/union/sdk/getting_started/#create-a-visual-studio-project","title":"Create a Visual Studio project","text":"<p>To create a Union plugin project inside Visual Studio we need to use File -&gt; New -&gt; Project. On the next screen, we select \"Union Plugin 1.0m\", and click Next. For the project configuration, we should choose:</p> Key Value Project name eg. MyPlugin Location Directory where to store the source code Solution Create new solution Solution name eg. MyPlugin <p>We will also check \"Place solution and project in the same directory\" because our plugin consists of only one project, so there is no need to complicate the file structure.</p>"},{"location":"zengin/union/sdk/getting_started/#file-structure","title":"File Structure","text":"Folder / File Description Engine\u00a0SDK/ In this folder, we have the Gothic Engine API in the form of header files. Most of the files between engines are very similar to each other but they can't be used interchangeably because each engine has slighly different API and addresses of functions. Engine\u00a0SDK/User\u00a0API/ These are empty files that are included in the corresponding engine headers. There are meant for placing additional methods extending classes that can be used for example in Hooks. Plugin/System/ DLL entry point generated by Union. We shouldn't modify anything here. Plugin/Workspace/Interface/ These are header files containing headerss and source files important in correct order and an <code>Interface.cpp</code> file that merges all the code into one file. Plugin/Workspace/Plugin/ Finally, this is the source code of the plugin and especially <code>Plugin.cpp</code> where we can create code executed on Game Events."},{"location":"zengin/union/sdk/getting_started/#build-configuration","title":"Build Configuration","text":"<p>Each Union plugin may target one or many versions of the Gothic engine and to select the proper API, Union SDK defines several build configurations for every engine, configuration, and also multiplatform build options. Each Target/Configuration combination is named <code>[ENGINE] [CONFIGURATION]</code>.</p> <p>Configurations:</p> <ul> <li>Debug: Unoptimized build with debug symbols for development.</li> <li>MD Release: Optimized build for release versions. Runtime Library: Multi-threaded DLL (/MD)</li> <li>MT Release: Optimized build for release versions. Runtime Library: Multi-threaded (/MT)</li> </ul> <p>Engines:</p> <ul> <li>G1: Gothic I</li> <li>G1A: Gothic Sequel</li> <li>G2: Gothic II</li> <li>G2A: Gothic II NotR</li> <li>MP x2: Multiplatform target for both Gothic I (G1) and Gothic II NotR (G2A)</li> <li>MP x4: Multiplatform target for all engine versions (Gothic I, Gothic Sequel, Gothic II, Gothic II NotR)</li> </ul> <p>For learning Union, it's suggested to select G2A Debug for Gothic II NotR or G1 Debug for Gothic I.</p>"},{"location":"zengin/union/sdk/getting_started/#project-configuration","title":"Project Configuration","text":"<p>The Union plugin is a regular C++ Visual Studio project so it's possible to configure the project, compiler, linker, and debugger as we wish by going into Project -&gt; Properties. For a starter, we should go to the General tab and check if Platform Toolset is installed and selected. If not, we should select one that's available on our system. Union was created with v100 but it also supports the newest toolkits, so it's best to select a modern one.</p> <p>In the General tab, we can also specify the Output Directory where the plugin DLL will be placed after the build. During development, we can set it to <code>&lt;GOTHIC_DIR&gt;/System/Autorun</code> where <code>&lt;GOTHIC_DIR&gt;</code> is the root folder of the Gothic installation with Union that we will use for testing. Each DLL file placed in <code>System/Autorun</code> is automatically loaded by Union runtime.</p> <p>Another method is to put the DLL in the <code>System</code> directory and modify <code>Gothic.ini</code> to include </p><pre><code>[PLUGIN]\n# Plugin file names without .dll \nPluginList = MyPlugin </code></pre>"},{"location":"zengin/union/sdk/getting_started/#build-the-plugin","title":"Build the plugin","text":"<p>After the initial configuration, we are ready to code something and see if our configuration is working. Let's collect some information about Union and display it with a MessageBox when the game starts. To do so, we locate the <code>Plugin.cpp</code> file and put our logic in one of the Game Events handlers. The best for that is <code>Game_Init()</code> because it's executed right after the engine loads every DAT file but before anything else:</p> <pre><code>void Game_Init() {\nconst CPlugin* myPlugin = CPlugin::GetCurrentPlugin();\nCStringA gothicVersion;\nswitch (Union.GetEngineVersion()) {\ncase Engine_G1:  gothicVersion = \"Gothic I\";\ncase Engine_G1A:  gothicVersion = \"Gothic Sequel\";\ncase Engine_G2:  gothicVersion = \"Gothic II\";\ncase Engine_G2A:  gothicVersion = \"Gothic II NoTR\";\n}\nCStringA message = \"Plugin: \" + myPlugin-&gt;GetName() + \"\\n\";\nmessage = message + \"Union Version: \" + Union.GetUnionVersion().ToString() + \"\\n\";\nmessage = message + \"Gothic Version: \" + gothicVersion;\nMessage::Info(message, \"Hello World\");\n}\n</code></pre> <p>Now we can Build (F7) the project to create the DLL. If we have set up Output Directory before, the plugin will deploy directly to the game. Otherwise, we can copy it manually from <code>Bin</code> to <code>&lt;GOTHIC_DIR&gt;/System/Autorun/MyPlugin.dll</code>. When we launch the game, a MessageBox should appear right before the main menu:  </p>"},{"location":"zengin/union/sdk/getting_started/#couldnt-build-the-plugin","title":"Couldn't build the plugin?","text":"<p>If you could not build the plugin or it crashed the game, you have to do some debugging and find the root cause of that. For compilation errors look at the Visual Studio Output tab and read the errors. </p> <p>If they say something about missing toolset, make sure that you selected a Platform Toolset that's installed. </p> <p>If the proper toolset is selected but doesn't work, make sure that you are configuring the same Configuration that is used for building. </p> <p>If the plugin was built but the game crashed, you probably selected Configuration for the wrong platform. Gothic 2 Night of the Raven is <code>G2A</code> and doesn't work with <code>G2</code> or <code>G1A</code>. If you are playing Gothic II Classic from Steam, please be advised that it still uses the Night of The Raven engine so the plugin must target <code>G2A</code>.</p>"},{"location":"zengin/union/sdk/getting_started/#debugging","title":"Debugging","text":"<p>Union plugins are regular DLLs with executable code hooked to Gothic.exe and running on it, so they can be debugged using the same techniques as any other software. </p>"},{"location":"zengin/union/sdk/getting_started/#visual-studio-debugger","title":"Visual Studio Debugger","text":"<p>Visual Studio Debugger lets us set breakpoints on any line of code to stop the execution when we reach it. It also gives us a lot of information about the program state at this point. To use the debugger we only need to attach it to the Gothic.exe progress and compile the plugin with Debug configuration.</p> <p>Option #1: Open Project -&gt; Properties and in the Debugging tab, set Command to the path of our Gothic.exe. Then we can run \"Local Windows Debugger\" in Visual Studio and it starts Gothic with a debugger attached automatically.</p> <p>Option #2: Open Debug -&gt; Attach to process... and filter process list by \"Gothic\". Run the game separately and when the process appears in Visual Studio, select it and attach to it. </p> <p>Caveats:</p> <ul> <li>If we attach to the process early, we may get an \"Exception thrown at 0x7B11DB86 (Shw32.dll) in Gothic2.exe: 0xC0000005: Access violation writing location 0x00ABD000.\" right at the beginning. It's fine, just click Continue and Gothic will start properly. </li> <li>If a breakpoint hits when our cursor is locked by Gothic, we may not be able to get the cursor back until execution continues. In this case, we can still use Alt+Tab to switch to Visual Studio and use F5 to continue or F10 to step over. Disabling mouse support in the config may also fix this problem.</li> </ul>"},{"location":"zengin/union/sdk/getting_started/#print-debugging","title":"Print Debugging","text":"<p>Printing to some output is probably the simplest form of debugging and Union provides us with several choices.</p>"},{"location":"zengin/union/sdk/getting_started/#logging-to-zspy","title":"Logging to zSPY","text":"<p>zSPY can be accessed using a global <code>zerr</code> object. zSPY uses a message filtering system based on the first letter of the message, so our logs should follow the standard format used by other parts of ZenGine. Otherwise, the message may not be visible. </p><pre><code>zerr-&gt;Message(\"X:   MyPlugin: message to zSPY\");\n</code></pre>"},{"location":"zengin/union/sdk/getting_started/#logging-to-union-console","title":"Logging to Union console","text":"<p>Union console needs to be enabled inside <code>SystemPack.ini</code> first: </p><pre><code>[CORE]\nShowDebugWindow = true\n</code></pre> Then we can use a global <code>cmd</code> object behaving like C++ <code>std::cout</code> to log into the Union console: <pre><code>cmd &lt;&lt; \"message to Union console\";\n</code></pre>"},{"location":"zengin/union/sdk/getting_started/#logging-to-visual-studio","title":"Logging to Visual Studio","text":"<p>Visual Studio can also receive logs from our plugin using: </p><pre><code>OutputDebugString(\"message to Visual Studio\");\n</code></pre> This method works only when we have a debugger attached, so it's not recommended for general logging."},{"location":"zengin/union/sdk/hooks/","title":"Hooks","text":""},{"location":"zengin/union/sdk/hooks/#hooks","title":"Hooks","text":"<p>Union provides a hooks system that lets us intercept calls to the engine functions and methods with our custom interceptor. To hook a function or method we need to know its address which can be acquired either from <code>Engine SDK/[Engine]/Names_[Engine].hpp</code> or from the engine classes headers <code>Engine SDK/[Engine]/Headers</code>.</p>"},{"location":"zengin/union/sdk/hooks/#intercepting-functions","title":"Intercepting functions","text":"<p>To declare a hook we can use <code>CInvoke</code> class or <code>HOOK AS</code> macros. </p><pre><code>CInvoke&lt;function_type&gt; Ivk_HookName(orignal_function_address, our_interceptor_function, hook_flags);\nHOOK Ivk_HookName AS(orignal_function_address, our_interceptor_function, hook_flags);\n</code></pre>"},{"location":"zengin/union/sdk/hooks/#regular-functions","title":"Regular functions","text":"<p>Regular functions are the functions declared outside of classes. </p><pre><code>// 0x0042C450 int __cdecl Apply_Options_Video(void)\n// Forward declaration\nint Apply_Options_Video(); // Hook declaration\nCInvoke&lt;int(*)()&gt; Ivk_Apply_Options_Video(0x0042C450, &amp;Apply_Options_Video);\n// Equivalent:\n// HOOK Ivk_Apply_Options_Video AS(0x0042C450, &amp;Apply_Options_Video);\n// Implementation of interceptor\nint Apply_Options_Video() {\nMessage::Info(\"Before original Apply_Options_Video()\");\n// Original function can be called using CInvoke pointer.\nint result = Ivk_Apply_Options_Video();\nMessage::Info(\"After original Apply_Options_Video()\");\nreturn result;\n}\n</code></pre>"},{"location":"zengin/union/sdk/hooks/#member-function","title":"Member function","text":"<p>Member functions are the functions declared as non-static class members and they take a class instance pointer as an implicit first argument (<code>__thiscall</code> calling convention). We can hook them in two ways using either a regular function or declaring a new method in User API.</p>"},{"location":"zengin/union/sdk/hooks/#option-1---regular-function","title":"Option #1 - Regular function","text":"<pre><code>// 0x006015D0 public: virtual int __fastcall zCVob::Render(struct zTRenderContext &amp;)\n// Forward declaration\nint __fastcall zCVob_Render(zCVob* _this, zTRenderContext&amp; context);\n// Hook declaration\nCInvoke&lt;int(__fastcall *)(zCVob* _this, zTRenderContext&amp; context)&gt; Ivk_zCVob_Render(0x006015D0, &amp;zCVob_Render);\n// Equivalent:\n// HOOK Ivk_zCVob_Render AS(0x006015D0, &amp;zCVob_Render);\n// Implementation of interceptor as regular function\n// Notice the first argument that's a pointer to class instance (this)\nint __fastcall zCVob_Render(zCVob* _this, zTRenderContext&amp; context) {\nif(_this == player) {\nscreen-&gt;PrintCX(1000, \"Rendering a player zCVob\");\n}\n// Call original method\nreturn Ivk_zCVob_Render(_this, context);\n}\n</code></pre>"},{"location":"zengin/union/sdk/hooks/#option-2---user-api","title":"Option #2 - User API","text":"<p>In <code>Engine SDK/User API</code> we can find a <code>.inc</code> file for the class we are hooking and define a new member method there. In this case, we are looking for <code>zCVob.inc</code>: </p><pre><code>// Supported with union (c) 2020 Union team\n// User API for zCVob\n// Add your methods here\nint RenderUnion(zTRenderContext&amp; context);\n</code></pre> <p>Then we can declare the hook pointing to our member method: </p><pre><code>// 0x006015D0 public: virtual int __fastcall zCVob::Render(struct zTRenderContext &amp;)\n// Hook declaration\nCInvoke&lt;int(__fastcall zCVob::*)(zTRenderContext&amp; context)&gt; Ivk_zCVob_Render(0x006015D0, &amp;zCVob::RenderUnion);\n// Equivalent:\n// HOOK Ivk_zCVob_Render AS(0x006015D0, &amp;zCVob::RenderUnion);\n// Implementation of interceptor  method\nint zCVob::RenderUnion(zTRenderContext&amp; context) {\nif(this == player) {\nscreen-&gt;PrintCX(1000, \"Rendering a player zCVob\");\n}\n// Call original method\nreturn Ivk_zCVob_Render(this, context);\n}\n</code></pre>"},{"location":"zengin/union/sdk/hooks/#hook-flags","title":"Hook flags","text":"<p>In the third argument of <code>CInvoke</code> we can provide hook flags. The default value is <code>IVK_AUTO</code>.</p> <pre><code>enum EInterMode\n{\n// Hook will not intercept the function.\nIVK_DISABLED  = 1 &lt;&lt; 1,\n// Normal hook. If other hook is alredy defined for the same address, an error pops up.\nIVK_NORMAL    = 1 &lt;&lt; 2,\n// Hook will automatically create an interception tree to allow multiple hooks for the same address.\nIVK_AUTO      = 1 &lt;&lt; 3,\n// Overrides any hook defined for the same address before.\nIVK_REDEFINE  = 1 &lt;&lt; 4,\n// Makes it impossible to override or disable the hook.\n// It should be used only in very specific cases.\nIVK_PROTECTED = 1 &lt;&lt; 5,\n// Same as IVK_DISABLED\nIVK_READONLY  = IVK_DISABLED\n};\n</code></pre>"},{"location":"zengin/union/sdk/hooks/#credits","title":"Credits","text":"<p>Examples are taken from the Union lessons in Russian created by Gratt on worldofplayers.ru/threads/41490/</p>"},{"location":"zengin/worlds/","title":"Worlds","text":""},{"location":"zengin/worlds/#worlds","title":"Worlds","text":"<p>Acknowledgment</p> <p>This article is heavily inspired by various tutorials from the polish TheModders forums.</p> <p>Worlds, saved as <code>.ZEN</code> files in ZenGin, are archives that contain the world mesh (model), BSP tree and the information of all objects in the world. These objects are called VOBs (\"virtual objects\"). ZEN files can be saved in two ways; compiled and uncompiled. The compiled version is a full-fledged level with a terrain model. Uncompiled ZENs only save the VOB tree and are meant for specific use-cases.</p> <p>Spacer is used to create these <code>.ZEN</code> files. There are also other world editors. The way of doing things can vary between these editors, so the specifics will be discussed in separate articles for those tools; at the same time, a lot of knowledge carries over between them. Also have in mind that Spacer is the least comfortable of the editors.</p>"},{"location":"zengin/worlds/#world-contents","title":"World contents","text":"<p>The content of worlds in Gothic can be roughly separated in the following way:</p> <ul> <li>Base level mesh: terrain and buildings, sometimes also trees</li> <li>VOBs: all interactive objects, items, foliage, small rocks, huts, furniture, ramps etc.</li> </ul> <p>Asides from those elements, there are also many invisible VOBs, such as:</p> <ul> <li>Waypoints - used for NPC navigation</li> <li>Freepoints (zCVobSpot) - used mainly for NPC routines and roaming behavior for monsters</li> <li>Startpoints - used only to spawn the player when starting a new game. Teleporting between levels is handled with scripts and uses freepoints to determine where the player will appear.</li> <li>Sound emitters</li> <li>Music zones</li> <li>oCZoneMusic - music which plays inside the bounding box of this zone</li> <li>oCZoneMusicDefault - default music which plays whenever the player is not inside some oCZoneMusic</li> <li>Fog zones (zCZoneZFog) - areas which add fog, e.g. like in swamp areas where the sky is not visible. The setting to fade out the sky is optional though.</li> <li>PFX - particle effects (fire, smoke, fireflies, falling leaves etc.)</li> </ul> <p>Note</p> <p>This list isn't exhaustive.</p>"},{"location":"zengin/worlds/#creating-a-zen-file","title":"Creating a ZEN file","text":"<p>Before VOBs can be added to a world model, the world needs to be compiled. After importing a 3ds model, the world can be compiled as an outdoor or indoor world and saved as a ZEN.</p> <p>The submeshes used in ZEN files have triangle count limits (it is also advisable to keep triangle count for each submesh under 50k for performance reasons). To get around this limitation and to parallelize work on various areas, it is possible to join multiple ZEN files together, which is done with special macros.</p> <p>If you take a look at the original maps for Gothic 2, you can notice that they are in folders, where there's e.g. a file called <code>NEWWORLD.ZEN</code> and multiple <code>.ZEN</code> files with \"part\" in their name. The latter are the sub-zens used to create the full level.</p> <p>However, a possibly more comfortable workflow is to have a single world mesh which is internally separated into multiple submeshes. This way triangle count limits won't be exceeded and the world won't need compiling from parts. As a trade-off, it is likely that it won't be possible for multiple people to work on the ZEN world at the same time.</p>"},{"location":"zengin/worlds/#lighting","title":"Lighting","text":"<p>There are two light types in the game:</p> <ul> <li>Static lights, which are baked onto the level. They can cast shadows (these only take static VOBs into consideration) and don't leak through walls. These have to be recompiled after making changes, but this process should only take moments. Static lights have the downside of only working in indoor worlds and in rooms which are closed with portals.</li> <li>Dynamic lights are calculated during runtime, which allows them to move and change properties (their color, for example), but has a performance cost. Additionally, they don't look the best and will often leak through walls.</li> </ul> <p>It is generally advised to use static lights whenever possible.</p>"},{"location":"zengin/worlds/#portals","title":"Portals","text":"<p>Portals are special parts of outdoor world meshes which separate interiors from exteriors. This allows the level to have dark areas: otherwise interiors are lit the same way as any outside area. Additionally, portals help with performance (interiors aren't rendered unless the player is nearby). Creation of portals has many caveats and will be discussed in a separate article. Portals are also related to NPC behavior (e.g. setting ownership of a room).</p>"},{"location":"zengin/worlds/#optimisation","title":"Optimisation","text":"<p>The game uses occlusion culling, which means that if an object is covered by another object, it is not rendered and saves performance. This means that the performance in a level can be boosted by a lot by creating city walls and mountains and valleys which separate areas.</p> <p>Occlusion culling isn't a perfect process, so there's also the option of adding GHOSTOCCLUDERs, which are invisible walls which stop areas behind them from rendering. They are a part of the world mesh and are created by assigning a material called GHOSTOCCLUDER to chosen faces. The color of the material is traditionally purplish-blue or pink, but the material itself is not rendered in-game, so this is only to make them stand apart from the rest of the level during modelling. To get more technical, these occluder walls are used to help the BSP algorithm which runs during world compilation.</p> <p>As mentioned before, another ways of optimisation are portals and limiting the number of dynamic lights. It is also not advisable to make many VOBs be affected by wind.</p>"},{"location":"zengin/worlds/spacer/","title":"Spacer","text":""},{"location":"zengin/worlds/spacer/#spacer","title":"Spacer","text":"<p>Spacer is the original world editor used to create maps in Gothic and it's installed by the MDK installer.</p> <p>A good <code>.ZEN</code> file to start experimenting with Spacer is Toten Insel. It's a simple level which should load without issues for everyone. The map contains a custom texture, but it can be safely ignored.</p>"},{"location":"zengin/worlds/spacer/#introduction","title":"Introduction","text":"<p>Upon launching Spacer, multiple windows will appear. They are:</p> <ul> <li>The main viewport (black with text on launch)</li> <li>The vobtree - allows to browse and select the objects already placed in a level</li> <li>The object window - it has 3 tabs: Create, Modify and \"...\".</li> <li>Toolbars - there's two of them and each button has a hover hint.</li> <li>The help window - sometimes when clicking on something, this window will show a description. It's usually empty though.</li> <li>The objectpages window - allows access to specific VOB settings. The contents of this window be changed with buttons on the horizontal toolbar.</li> </ul> <p>Other windows dedicated to specific functionalities can also be opened or toggled (Window tab in the viewport or the horizontal toolbar).</p> <p>When importing a mesh instead of a <code>.ZEN</code> file, some things will change. In this mode, objectpages has material data, one of the toolbars changes completely and the vobtree window changes into a texture browser.</p>"},{"location":"zengin/worlds/spacer/#configuration","title":"Configuration","text":"<p>Before doing anything else, you will probably want to change a few settings first. Select <code>Settings: View</code> in the Settings tab in the main viewport to increase the viewport resolution. After doing that, press <code>Align Toolwindows at Screen</code> or <code>Align Toolwindows at Spacer</code> in the Window tab to clean up the window placement. You might still need to move some of the tool windows around after this, as they can overlap.</p> <p>The most comfortable option we found was to set the resolution to something slightly smaller than the screen resolution (e.g. 1600:900 on a 1920:1080 screen) and then aligning the tool windows to screen.</p> <p>To help with the control sensitivity issues, change the camera movement speed in the <code>Settings: General</code>.</p>"},{"location":"zengin/worlds/spacer/#viewport-controls","title":"Viewport controls","text":"<p>The camera has multiple modes of operation. Some of the controls may sound confusing, but will make sense once you try them.</p> <p>Default selection mode</p> <p>Arrows move the camera back and forward and rotate it sideways. <code>A</code> moves the camera up and <code>Y</code> lowers it.</p> <p><code>PageUp</code> and <code>PageDown</code> rotate the camera up and down. <code>End</code> resets this rotation.</p> <p>Selecting VOBs is done by simply pointing at them with the mouse and clicking.</p> <p>First-person selection mode</p> <p>Toggled by the <code>F3</code> button.</p> <p>In this mode, you can point the camera with your mouse, and selection is done by pointing the green reticle at a VOB and clicking <code>LMB</code>. Arrows now move the camera parallel to itself (including sideways).</p> <p><code>PageUp</code> and <code>PageDown</code> still rotate the camera up and down, but it's better not to use them because it affects how the arrow movement behaves. <code>End</code> resets this rotation.</p> <p>Default VOB movement mode</p> <p>When a VOB is selected, press <code>M</code> to enter and exit this mode.</p> <p>The arrows now move the VOB horizontally. Moving it up and down is done with <code>A</code> and <code>Y</code>.</p> <p>The keys above the arrows now rotate the VOB:</p> <ul> <li>Axis 1: <code>Delete</code> and <code>PageDown</code></li> <li>Axis 2: <code>Insert</code> and <code>PageUp</code></li> <li>Axis 3: <code>Home</code> and <code>End</code></li> </ul> <p>First-person VOB movement mode</p> <p>When a VOB is selected, press <code>T</code> to enter and exit this mode.</p> <p>The controls are the same as the default selection mode, but the camera is now placed at the selected VOB and it moves with the camera.</p> <p>One caveat is that the controls are in the local space of the object. What this basically means is that if you rotated the object in any other way than horizontally, the movement and rotation will now be skewed.</p> <p>Mixed VOB movement mode</p> <p>When a VOB is selected, press <code>C</code> to enter and exit this mode. The VOB is now controlled like in the first-person movement mode, but the camera is not placed at the VOB: in other words, the camera remains in the same place.</p> <p>General</p> <p>Holding down <code>Shift</code> speeds up the camera in all of the modes. The numpad can be used for rotating instead of the buttons above the arrows. Both movement modes can be used from either of the selection modes. Movement modes can be selected from the vertical toolbar. This toolbar also has a \"toggle camera position\" button; this switches between two camera placements, which can be controlled independently.</p> <p>The objects location can also be entered manually through the object window: open the Internals folder and select <code>trafoOSToWSPos</code> to input them at the bottom of the window. Don't forget to press \"Apply\". Unfortunately the rotation setting uses an odd format and can't be set manually.</p>"},{"location":"zengin/worlds/spacer/#basic-usage","title":"Basic usage","text":"<p>This section covers some of the basic things done in the editor.</p>"},{"location":"zengin/worlds/spacer/#inserting-a-vob","title":"Inserting a VOB","text":"<ul> <li>In the Create tab in the Objects window, select the VOB type. Choose <code>zcVob</code> to add a simple decorative model.</li> <li>Right click anywhere on the viewport</li> <li>Select the insert option (<code>Insert [zcVob]</code> in this case)</li> <li>A VOB without a mesh will be created in the middle of the screen. Try to not deselect it, but if you do, it can be found in the vobtree under the appropriate folder (<code>zcVob</code> in this case); it can be identified by a green dot.</li> <li>In the Modify tab in the Object window, select \"visual\". Insert the model name in the text form at the bottom of the window. You can use <code>pc_lob_sleeper3.3ds</code> for now; this mesh should be present in both Gothic 1 and 2. </li> <li>If you unpacked the meshes while installing the MDK or with GothicVDFS, you can also browse to the file using the file button next to the text form.</li> <li>Make sure to click the Apply button. Do this after making any changes in the Object window or they will be lost.</li> </ul> <p>Tip</p> <p>You can use the VOB Bilder tool to comfortably browse model images and names. An online version is currently available here. The UI on the website is in Polish but it's simple enough to not matter.</p> <ul> <li>To make the VOB have collision in-game, double click on <code>cdDyn</code> (\"collision detection dynamic\") to set it to true. Sometimes this is unadvised, e.g. with bushes or grass.</li> </ul> <p>Tip</p> <p>When placing pickable items, you can press the \"apply physics on selected VOB\" button in the vertical toolbar to make the item drop on the ground. It can save you a lot of work with placing those items. This won't work with a plain cVob though.</p>"},{"location":"zengin/worlds/spacer/#common-vob-settings","title":"Common VOB settings","text":"<p>VOB settings vary depending on what the VOB type is. They all have common parameters of the base VOB class though. The full descripton of a zCVob class can be found here.</p>"},{"location":"zengin/worlds/spacer/#issues","title":"Issues","text":"<p>Spacer 2 received the last update in 2003 and is a very buggy tool. Here are some known issues.</p> <p>Framerate dependence</p> <p>The speed of camera in Spacer depends on the framerate. Depending on the angle of the camera and the level, Spacer can have huge framerate, which will make the camera move too quick.</p> <p>You can try to limit the framerate of Spacer with external tools, but your mileage may vary. Such tools often only limit rendering using fake Vsync, but the underlying logic of the program can still run too fast.</p> <p>Using the grid snap function can help when the framerate is high, but again: your mileage may vary.</p> <p>Random freezes and crashes</p> <p>Spacer will freeze or crash quite often at seemingly random moments. It is extremely important to save often and back up your work.</p> <p>One of the common ways the editor can freeze is when rotating the camera vertically when the framerate is very high. In that case, changing the camera mode to F3 and back can sometimes help.</p> <p>Copying VOBs</p> <p>When copy-pasting a VOB in Spacer (right click menu), the new VOB might be created as a child of the original one and moving one of them will move both. This doesn't seem to be consistent, but it's worth checking before you accidentally ruin the careful placement of the original VOB.</p>"},{"location":"zengin/worlds/spacer/#troubleshooting","title":"Troubleshooting","text":"<p>You can have issues with loading a ZEN or a world model for a multitude of reasons. Here is some of the known ones.</p> <ul> <li>Some terrain models aren't set up or exported properly.</li> <li>Maps which use custom assets will cause issues or won't even load unless these assets are included in appropriate directories. The severity of this is different depending on the asset type. For example, textures will be replaced with a placeholder, but animations will cause crashes.</li> </ul> <p>Note</p> <p>This section is not exhaustive.</p>"},{"location":"zengin/worlds/spacer/#creating-zens","title":"Creating ZENs","text":"<p>Presented here are the ways of working with new terrain models.</p>"},{"location":"zengin/worlds/spacer/#compiling-a-world-mesh","title":"Compiling a world mesh","text":"<p>To create a completely new ZEN, you will first need a level mesh. These can be made from scratch or downloaded, but be aware that meshes, which aren't properly prepared won't compile correctly (you won't be able to move in the viewport). As with any other mesh in Gothic, it has to be in the 3ds format. It is recommended to place the mesh file somewhere in the <code>_work/Data/Meshes</code> (can be your own subfolder).</p> <p>You can find free terrain models here if you want to practice this. Note that not all of them might compile properly; this one should be fine though.</p> <p>First, load the mesh from the File tab of the viewport. To compile the mesh, press <code>Compile World</code> in the World tab. From here, multiple options are available:</p> <ul> <li>Indoor/Outdoor: determines if the world will have a sky and the way that lighting behaves.</li> <li>Detect leaks: might be related to checking if indoor (\"underground\") worlds have holes in them. In some games such holes can cause performance issues, perhaps it's the same here. Doesn't hurt to enable it.</li> <li>Quick compile: self-explanatory, but the exact effects of this are unknown.</li> <li>Polycheck: presumably checks if the model doesn't exceed triangle limits.</li> <li> <p>Editormode:</p> <ul> <li> <p>On: Spacer will load the mesh in editor mode, which allows you to change materials assigned to triangles and other mesh operations. It is more comfortable to do these things in an external 3D editor, but sometimes using this is recommended, e.g. for setting up portals. You can save the model as a <code>.3ds</code> in this mode.</p> </li> <li> <p>Off: Spacer will create a ZEN where you can normally place VOBs. You can now save the world as a compiled ZEN and add VOBs to it.</p> </li> </ul> </li> </ul>"},{"location":"zengin/worlds/spacer/#compiling-a-world-from-multiple-meshes","title":"Compiling a world from multiple meshes","text":"<p>First and foremost, the models used for this must be properly positioned and separated in your 3D editor of choice. Then each section must be exported as separate <code>.3ds</code> files. After that, compile each model and save it as a compiled ZEN. Place them in their own folder. You can place VOBs in those ZEN files, the VOB trees will be merged too.</p> <p>Now, to join these zens together, you will need to define a macro in <code>Tools&gt;Macros</code>. These are pretty much identical except for the ZEN list; for example, the Mining Colony ZEN in Gothic 2 (<code>OLDWORLD.ZEN</code>) is comprised of two models, and the macro looks like this:</p> <pre><code>reset\nset error 3\nLoad world oldworld\\SURFACE.ZEN\nLoad world oldworld\\OLDCAMP.ZEN\ncompile world outdoor\ncompile light high\n</code></pre> <p>Then you double-click the macro name to run it and wait. The macro contains the reset directive, but it's worth doing it on a freshly opened Spacer instance just to be safe.</p> <p>Keep in mind that compiling a world from multiple ZENs is meant as a final step in level production. This is because doing it will cause issues with culling and stop interiors from rendering (and thus stop you from editing it). Instead, the part ZENs are filled with VOBs separately and the world is compiled as a final step before testing the map.</p>"},{"location":"zengin/worlds/spacer/#updating-world-meshes-in-a-compiled-zen","title":"Updating world meshes in a compiled ZEN","text":"<p>Ideally, updating the world mesh would be avoided, but it's an inevitable need when iterating a map design. Doing this in the original Spacer might not be impossible, but it is generally avoided and Spacer.NET or other editors are used for this instead.</p>"},{"location":"zengin/worlds/Classes/zCVob/","title":"zCVob","text":""},{"location":"zengin/worlds/Classes/zCVob/#zcvob","title":"zCVob","text":"<p>zCVob is a base class for all objects placed in a world.</p> <p>Acknowledgment</p> <p>Heavily inspired by the amazing documentation site Gothic library</p>"},{"location":"zengin/worlds/Classes/zCVob/#class-members","title":"Class members","text":"G1G2A <p>Properties of a zCVob class are split into two parts. The Internals are hardly ever needed to be edited manually, they are changeed by e.g. moving an object in Spacer. On the other hand the Vob properties can only be changed by the Objects context menu in Spacer.</p> <p>Internals</p> <ul> <li>pack</li> <li>presetName</li> <li>bbox3DWS</li> <li>trafoOSToWSRot</li> <li>trafoOSToWSPos</li> </ul> <p>Vob</p> <ul> <li>vobName</li> <li>visual</li> <li>showVisual</li> <li>visualCamAlign</li> <li>CdStatic</li> <li>CdDyn</li> <li>staticVob</li> <li>dynShadow</li> </ul> <p> </p> <p>Properties of a zCVob class are split into two parts. The Internals are hardly ever needed to be edited manually, they are changeed by e.g. moving an object in Spacer. On the other hand the Vob properties can only be changed by the Objects context menu in Spacer.</p> <p>Internals</p> <ul> <li>pack</li> <li>presetName</li> <li>bbox3DWS</li> <li>trafoOSToWSRot</li> <li>trafoOSToWSPos</li> </ul> <p>Vob</p> <ul> <li>vobName</li> <li>visual</li> <li>showVisual</li> <li>visualCamAlign</li> <li>visualAniMode</li> <li>visualAniModeStrength</li> <li>vobFarClipZScale</li> <li>CdStatic</li> <li>CdDyn</li> <li>staticVob</li> <li>dynShadow</li> <li>zbias</li> <li>isAmbient</li> </ul>"},{"location":"zengin/worlds/Classes/zCVob/#class-member-overview","title":"Class member overview","text":""},{"location":"zengin/worlds/Classes/zCVob/#pack","title":"pack","text":"<p>No Information provided.</p>"},{"location":"zengin/worlds/Classes/zCVob/#presetname","title":"presetName","text":"<p>The name of the template that was used to create the item.</p>"},{"location":"zengin/worlds/Classes/zCVob/#bbox3dws","title":"bbox3DWS","text":"<p>Volume of virtual object. Defined by two opposite diagonal points of the BoundingBox (<code>1x, 1y, 1z</code>, <code>2x, 2y, 2z</code>). The volume is needed to calculate collisions and interactions with other game objects. For example, with dynamic objects, which include characters (class C_NPC), items (class C_ITEM ), etc. </p> <p>Interaction processing begins when object volumes intersect. For example, when the player enters the world change trigger area, the engine loads another game level based on the parameters this trigger. All this happens when the main character's BoundingBox intersects with the trigger's BoundingBox. </p> <p>The BoundingBox can only be changed using the <code>Edit the Bbox</code> button in Spcaer. </p>"},{"location":"zengin/worlds/Classes/zCVob/#trafoostowsrot","title":"trafoOSToWSRot","text":"<p>Orientation relative to the coordinate center. </p> <p>Note</p> <p>This refers to the center of coordinates of the <code>.3DS</code> file of the game world on which the <code>ZEN</code> file is built. </p>"},{"location":"zengin/worlds/Classes/zCVob/#trafoostowspos","title":"trafoOSToWSPos","text":"<p>Coordinates of the position in space relative to the center of coordinates. </p> <p>The coordinates are set automatically the first time an instance of the class is inserted into the game world. You can change them either directly by entering numerical values \u200b\u200bin the corresponding fields of the parameter, by moving the vob in spacer.</p>"},{"location":"zengin/worlds/Classes/zCVob/#vobname","title":"vobName","text":"<p>An identifier of a zCVob shown in the editor and sometimes used in scripts. The name can be left blank.</p> <p>For some object classes, entering a name is required: zCVobSpot , zCVobWaypoint , zCTrigger , etc.</p> <p>Danger</p> <p>Setting a name for every static and insignificant object can lead to an error when parsing the game world. </p>"},{"location":"zengin/worlds/Classes/zCVob/#visual","title":"visual","text":"<p>The name of the file that will be responsible for the visual display of the object. </p> <p>Different file formats are used for different object classes: </p> <ul> <li><code>*.3DS</code> - Static objects</li> <li><code>*.PFX</code> - Particle effects</li> <li><code>*.TGA</code> - Textures</li> <li><code>*.MDS</code>, <code>*.ASC</code> - Interactive objects</li> <li><code>*.MMS</code> - Animated objects</li> </ul>"},{"location":"zengin/worlds/Classes/zCVob/#showvisual","title":"showVisual","text":"<p>This option is responsible for displaying the object.</p> <p>Accepted values:</p> <ul> <li>TRUE - Display.</li> <li>FALSE - Do not display.</li> </ul>"},{"location":"zengin/worlds/Classes/zCVob/#visualcamalign","title":"visualCamAlign","text":"<p>Option to align objects relative to the camera. </p> <p>Accepted values:</p> <ul> <li>NONE - Not used.</li> <li>YAW - The object always faces the player.</li> <li>FULL - The object is aligned relative to the world axes.</li> </ul> <p>Note</p> <p>For example, in order for the grass model to always face the character, you need to set this parameter to YAW.</p>"},{"location":"zengin/worlds/Classes/zCVob/#visualanimode","title":"visualAniMode","text":"<p>Wind simulation option. Used in conjunction with the visualAniModeStrength parameter.</p> <p>Accepted values:</p> <ul> <li>NONE - Not used.</li> <li>WIND - Strong wind effect. Acceptable for herbs.</li> <li>WIND2 - Light wind effect. Acceptable for trees.</li> </ul> <p>Warning</p> <p>This option is only available in Gothic 2 (Spacer2).</p>"},{"location":"zengin/worlds/Classes/zCVob/#visualanimodestrength","title":"visualAniModeStrength","text":"<p>Wind power animation multiplier. Small values such as <code>0.001</code> are typically used. Used in conjunction with the visualAniMode parameter.</p> <p>Warning</p> <p>This option is only available in Gothic 2 (Spacer2).</p>"},{"location":"zengin/worlds/Classes/zCVob/#vobfarclipzscale","title":"vobFarClipZScale","text":"<p>Sets the loading range of the VOB object. Depends on the VOB drawing distance specified using the <code>zCZoneVobFarPlane</code> object.</p> <p>The range of values is from <code>0.0</code> to <code>2.0</code>.</p> <p>With a value of <code>0.0</code>, the object is not visible, but collisions are calculated. With a value of <code>2.0</code>, the VOB drawing range is identical to the VOB drawing range of objects specified by the <code>zCZoneVobFarPlane</code> object.</p> <p>Warning</p> <p>This option is only available in Gothic 2 (Spacer2).</p>"},{"location":"zengin/worlds/Classes/zCVob/#cdstatic","title":"CdStatic","text":"<p>Determines if the VOB will collide with the static objects (world mesh and other VOBs with cdStatic on).</p> <p>Accepted values:</p> <ul> <li>TRUE - Collision handling for static objects is enabled.</li> <li>FALSE - Collision handling for static objects is disabled.</li> </ul> <p>Tip</p> <p>A situation often arises when objects \u201crefuse\u201d to move beyond a certain point on the surface. This happens when cdStatic is set to TRUE, i.e. the object cannot cross the surface another static object. In this case, it is enough to disable the cdStatic parameter for the duration of the move, and turn it on again after the move.</p>"},{"location":"zengin/worlds/Classes/zCVob/#cddyn","title":"CdDyn","text":"<p>Determines if the VOB will collide with dynamic objects (NPCs, items, etc.). This basically determines if the object has collision during gameplay.</p> <p>Accepted values:</p> <ul> <li>TRUE - Collision handling for dynamic objects is enabled.</li> <li>FALSE - Collision handling for dynamic objects is disabled.</li> </ul>"},{"location":"zengin/worlds/Classes/zCVob/#staticvob","title":"staticVob","text":"<p>Determines if the VOB is taken into consideration in static lighting calculations in Indoor spaces. Usually enabled in decorative Vobs, but some of the interactive ones have it disabled.</p> <p>Accepted values:</p> <ul> <li>TRUE - Calculate the shadow of the object.</li> <li>FALSE - Do not calculate the shadow of the object.</li> </ul> <p>Note</p> <p>The shadow is calculated when compiling light in Low, Middle or High mode.</p>"},{"location":"zengin/worlds/Classes/zCVob/#dynshadow","title":"dynShadow","text":"<p>Determine if the object will cast a shadow when affected by dynamic light (e.g. torches).</p> <p>Accepted values:</p> <ul> <li>DS_NONE - No shadow.</li> <li>DS_BLOB - Casts a circular shadow.</li> </ul>"},{"location":"zengin/worlds/Classes/zCVob/#zbias","title":"zbias","text":"<p>Option to remove texture flickering if a <code>.TGA</code> file is used as rendering.</p> <p>Warning</p> <p>This option is only available in Gothic 2 (Spacer2).</p>"},{"location":"zengin/worlds/Classes/zCVob/#isambient","title":"isAmbient","text":"<p>Sets the calculation of refracted lighting of objects.</p> <p>Accepted values:</p> <ul> <li>TRUE - Calculate the refraction of light.</li> <li>FALSE - Do not calculate light refraction.</li> </ul> <p>Warning</p> <p>This option is only available in Gothic 2 (Spacer2).</p>"},{"location":"pl/","title":"Witamy na stronie Gothic Modding Community","text":""},{"location":"pl/#witamy-na-stronie-gothic-modding-community","title":"Witamy na stronie Gothic Modding Community","text":"<p>Ta strona GitHub jest zaprojektowana w celu zawarcia zbioru artyku\u0142\u00f3w, poradnik\u00f3w oraz innej dokumentacji o Gothicu utrzymywanych przez spo\u0142eczno\u015b\u0107.</p> <p>Dwie pierwsze cz\u0119\u015bci gier Gothic korzystaj\u0105 z silnika o nazwie ZenGin, stworzonego przez Piranha Bytes oraz grup\u0119 programist\u00f3w o nazwie Mad Scientists. Je\u017celi chcesz wiedzie\u0107 wi\u0119cej o historii tworzenia, to jest masa informacji na Gothic Archive.</p> <p>Zawarto\u015b\u0107 strony nie jest przeznaczona, aby by\u0107 uznan\u0105 za \u015bwi\u0119te s\u0142owa moddingu. Jeste\u015bmy tylko modderami dziel\u0105cymi si\u0119 do\u015bwiadczeniami, wiedz\u0105 oraz naszym ulubionym tokiem pracy.</p> <p>Nie kr\u0119puj si\u0119, aby otworzy\u0107 pro\u015bb\u0119 o po\u0142\u0105czenie (ang. pull request) z twoim artyku\u0142em, lub z propozycj\u0105 zmian. Po wi\u0119cej informacji jak to zrobi\u0107 zobacz, Jak Si\u0119 Udzieli\u0107.</p> <p>Mo\u017cesz otworzy\u0107 pro\u015bb\u0119 o po\u0142\u0105czenie wzgl\u0119dem tego repozytorium.</p>"},{"location":"pl/contribute/","title":"Jak si\u0119 udzieli\u0107","text":""},{"location":"pl/contribute/#jak-si\u0119-udzieli\u0107","title":"Jak si\u0119 udzieli\u0107","text":"<p>Gothic Modding Community jest projektem nap\u0119dzanym przed spo\u0142eczno\u015b\u0107. Zach\u0119camy osoby do wnoszenia swojego wk\u0142adu.</p> <p>Ta strona jest budowana przy pomocy statycznego generatora stron MkDocs oraz sk\u00f3rki Material for MkDocs, wraz z wieloma innymi wtyczkami do MkDocs.</p> <p>Zale\u017cnie od skali i typu kontrybucji, trzeba spe\u0142ni\u0107 inne wymagania wst\u0119pne.</p>"},{"location":"pl/contribute/#zg\u0142oszenia","title":"Zg\u0142oszenia","text":"<p>Po angielsku mo\u017cna zg\u0142osi\u0107 problem lub inny komentarz o funkcjonowaniu strony poprzez otworzenie problemu (ang. issue) na serwisie GitHub albo do\u0142\u0105cz do nas na platformie Discord.</p>"},{"location":"pl/contribute/#wk\u0142ad-bezpo\u015bredni","title":"Wk\u0142ad bezpo\u015bredni","text":"<p>Wk\u0142ad bezpo\u015bredni wykonuje si\u0119 poprzez stworzenie kopii tego repozytorium (ang. fork) oraz stworzenie pro\u015bby o po\u0142\u0105czenie (ang. pull request PR) na serwisie GitHub wraz ze zmianami do zatwierdzenia.</p> <p>Nie zmarnuj czasu</p> <p>Prosz\u0119 si\u0119 upewni\u0107, \u017ce tre\u015b\u0107, jaka zostanie dodana, nie wyst\u0119puje ju\u017c na wersji dev strony. Mo\u017cna skorzysta\u0107 z funkcjonalno\u015bci wyszukiwania, \u017ceby przefiltrowa\u0107 GMC r\u00f3\u017cnymi s\u0142owami kluczowymi i tre\u015bciami.</p> <p>Jak edytowa\u0107 pliki \u017ar\u00f3d\u0142owe?</p> <p>Pliki \u017ar\u00f3d\u0142owe artyku\u0142\u00f3w s\u0105 pisane wykorzystuj\u0105c format plik\u00f3w Markdown <code>.md</code> (Markdown cheatsheet). Poza tym ta strona wykorzystuje wtyczk\u0119 Python Markdown Extensions, kt\u00f3ra rozszerza sk\u0142adni\u0119 o dodatkowe zasady pozwalaj\u0105ce na wstawienie wzmianek jak ta, kt\u00f3r\u0105 w\u0142a\u015bnie czytasz.</p>"},{"location":"pl/contribute/#mniejsze-zmiany","title":"Mniejsze zmiany","text":"<p>Mniejsze zmiany, jak poprawianie b\u0142\u0119d\u00f3w ortograficzny, gramatycznych, czy usuwanie/dodawanie s\u0142\u00f3w do akapit\u00f3w w jednym pliku, mog\u0105 by\u0107 zrobione szybko poprzez klikni\u0119cie przycisku  w prawym g\u00f3rnym rogu artyku\u0142u. Otworzy to interfejs edytowania pliku w serwisie GitHub, kt\u00f3re po zapisaniu zmian, automatycznie utworzy kopi\u0119 (ang. fork) oraz ga\u0142\u0105\u017a (ang. brach) z \u0142atk\u0105, a nast\u0119pnie otworzy pro\u015bb\u0119 o po\u0142\u0105czenie (ang. pull request) wzgl\u0119dem ga\u0142\u0119zi <code>dev</code>.</p> <p>Poprawna ga\u0142\u0105\u017a dla pro\u015bby o po\u0142\u0105czenie</p> <p>Upewnij si\u0119, \u017ce pro\u015bba o po\u0142\u0105czenie (ang. pull request) jest skierowana do ga\u0142\u0119zi <code>dev</code> albo specjalnej ga\u0142\u0119zi <code>pre-merge</code>, a nie do ga\u0142\u0119zi <code>main</code>.</p>"},{"location":"pl/contribute/#wi\u0119ksze-zmiany","title":"Wi\u0119ksze zmiany","text":"<p>Bardziej z\u0142o\u017cone zmiany takie jak, edycja wielu plik\u00f3w naraz, dodawanie nowych artyku\u0142\u00f3w, obrazk\u00f3w, czy innych plik\u00f3w, albo zmiana konfiguracji strony jest \u0142atwiej zrobi\u0107 poprzez u\u017cycie zewn\u0119trznych narz\u0119dzi na lokalnym PC. Wi\u0119kszo\u015b\u0107 z tych operacji mo\u017cna zrobi\u0107 poprzez interfejs serwisu GitHub, ale jest to raczej uci\u0105\u017cliwe oraz trudniej zauwa\u017cy\u0107 problemy wynikaj\u0105ce z procesu zmian, poniewa\u017c nie s\u0105 one widoczne w przegl\u0105darce w ich ostatecznej formie.</p> <p>Troch\u0119 przygotowa\u0144 jest potrzebnych przed rozpocz\u0119ciem prac nad plikami, poniewa\u017c do dzia\u0142ania MkDocs wymaga zainstalowanego w systemie Pythona. GitHub dzia\u0142a nad systemem kontroli wersji git, wi\u0119c jego instalacja jest te\u017c wymagana. Podstawowa znajomo\u015b\u0107 obs\u0142ugi Terminala/Konsoli polece\u0144/Powershell jest pomocna.</p>"},{"location":"pl/contribute/#przygotowanie-systemu-wideo","title":"Przygotowanie Systemu (wideo)","text":"<p>Po pierwsze, trzeba zainstalowa\u0107 Python. Mo\u017cna pod\u0105\u017ca\u0107 wed\u0142ug tego poradnika krok po kroku dla Windowsa albo macOS jak zainstalowa\u0107 Python.</p> <p>Wideo jest z 2017?!</p> <p>Proces instalacji Pythona nie zmieni\u0142 si\u0119 od tamtego czasu. Jednak\u017ce prosz\u0119 instalowa\u0107 najnowsz\u0105 wersj\u0119 Python 3.</p> <p>Aby m\u00f3c pracowa\u0107 zdalnie z GitHub, mo\u017cna zainstalowa\u0107 najnowsz\u0105 wersj\u0119 git, pod\u0105\u017caj\u0105c wed\u0142ug tego poradnika.</p> <p>Je\u017celi planujesz tylko edytowa\u0107 zawarto\u015b\u0107 artyku\u0142\u00f3w Markdown, mo\u017cesz po prostu zainstalowa\u0107 najnowsz\u0105 wersj\u0119 Visual Studio Code, \u017ceby mie\u0107 interfejs graficzny do zarz\u0105dzania git oraz podgl\u0105d Markdown, albo pracuj z dowolnym znanym edytorem tekstu i omi\u0144 konfiguracj\u0119 \u015brodowiska.</p> <p>Je\u017celi planujesz bardziej z\u0142o\u017cone programowanie w Python, mo\u017cesz pod\u0105\u017cy\u0107 wed\u0142ug tego poradnika krok po kroku dla Windowsa lub macOS jak skonfigurowa\u0107 \u015brodowisko developerskie z Visual Studio Code (VS Code).</p>"},{"location":"pl/contribute/#przygotowanie-systemu-tekst","title":"Przygotowanie Systemu (tekst)","text":"<p>\u017beby przygotowa\u0107 system do uruchomienia projektu lokalnie, pod\u0105\u017caj wed\u0142ug tych instrukcji.</p> <ol> <li> <p>Zainstaluj najnowsz\u0105 wersj\u0119 Pythona.     Upewnij si\u0119, \u017ceby zaznaczy\u0107 opcj\u0119 \"Add Python to PATH\" podczas instalacji.</p> </li> <li> <p>Otw\u00f3rz okno Terminala/Konsoli polece\u0144/PowerShell.</p> </li> <li> <p>Sprawd\u017a, \u017ce instalacja Pythona by\u0142a pomy\u015blna, korzystaj\u0105c z tego polecenia (mo\u017cliwa jest potrzeba restartu okna konsoli):</p> <pre><code>python --version\n</code></pre> </li> <li> <p>Zainstaluj najnowsz\u0105 wersj\u0119 git, pod\u0105\u017caj\u0105c wed\u0142ug tego poradnika.</p> </li> <li> <p>Sprawd\u017a, \u017ce instalacja git by\u0142a pomy\u015blna, korzystaj\u0105c z tego polecenia (mo\u017cliwa jest potrzeba restartu okna konsoli):</p> <pre><code>git --version\n</code></pre> </li> <li> <p>(opcjonalne) Zainstaluj najnowsz\u0105 wersj\u0119 Visual Studio Code dla interfejsu graficznego do zarz\u0105dzania git i podgl\u0105dem Markdown.</p> </li> </ol>"},{"location":"pl/contribute/#praca-lokalna","title":"Praca lokalna","text":"<p>Aby m\u00f3c pracowa\u0107 lokalnie:</p> <ol> <li>Stw\u00f3rz kopi\u0119 (ang. fork) na serwisie GitHub.</li> <li>Na lokalnym PC nawiguj do folderu, w kt\u00f3rym chcesz sklonowa\u0107 kopi\u0119 repozytorium, oraz otw\u00f3rz okno konsoli wewn\u0105trz niego.</li> <li> <p>Sklonuj kopi\u0119 repozytorium, korzystaj\u0105c z tego polecenia:</p> <pre><code>git clone https://github.com/user-name/forked-repository-name.git &lt;DIR-PATH&gt;\n</code></pre> <p>Zamiast <code>https://github.com/user-name/forked-repository-name.git</code> skorzystaj z w\u0142asnego linku, kt\u00f3ry jest widoczny po klikni\u0119ciu zielonego przycisku <code>&lt;&gt; Code</code> i wybraniu zak\u0142adki <code>HTTPS</code>.    </p> <p>Zamie\u0144 <code>&lt;DIR-PATH&gt;</code> ze \u015bcie\u017ck\u0105 do folderu, do kt\u00f3rego ma by\u0107 sklonowane repozytorium albo <code>.</code> je\u017celi ju\u017c jeste\u015b wewn\u0105trz folderu gdzie pliki projektu maj\u0105 si\u0119 znajdowa\u0107.</p> <p>To automatycznie utworzy zdalne repozytorium <code>origin</code> skierowane wzgl\u0119dem twojej kopii.</p> </li> <li> <p>Dodaj zdalne repozytorium <code>upstream</code> korzystaj\u0105c z tego polecenia:</p> <pre><code>git remote add upstream https://github.com/Gothic-Modding-Community/gmc.git\n</code></pre> </li> <li> <p>(opcjonalne) Stw\u00f3rz wirtualne \u015brodowisko i aktywuj je.</p> <p>Je\u017celi pracujesz przy kilku projektach Python, warto stworzy\u0107 wirtualne \u015brodowisko (ang. Virtual Environment) dla ka\u017cdego z tych projekt\u00f3w, \u017ceby ka\u017cdy m\u00f3g\u0142 korzysta\u0107 z w\u0142asnego folderu bibliotek z zainstalowanymi modu\u0142ami/wtyczkami.</p> <pre><code>python -m venv venv\n</code></pre> <p>To utworzy folder <code>venv</code> wewn\u0105trz obecnie wybranego folderu w oknie konsoli. Prosz\u0119, zostaw t\u0119 nazw\u0119, poniewa\u017c jest dodana do pliku <code>.gitignore</code> projektu.</p> <p>Zale\u017cnie od systemu, skorzystaj z jednego z tych polece\u0144 do aktywacji wirtualnego \u015brodowiska.</p> <p></p>Linux / macOS<pre><code>source venv/bin/activate\n</code></pre> Windows Powershell<pre><code>venv\\Scripts\\activate.ps1\n</code></pre> Windows Konsola Polece\u0144 (cmd)<pre><code>venv\\Scripts\\activate.bat\n</code></pre> <p>Po aktywacji indykator <code>(venv)</code> b\u0119dzie wy\u015bwietlany przy nazwie folderu w oknie polece\u0144.</p> <p>Nie zamykaj okna polece\u0144</p> <p>Wirtualne \u015brodowisko musi by\u0107 ponownie aktywowane, przy ka\u017cdym otwarciu okna polece\u0144.</p> </li> <li> <p>Zainstaluj MkDocs wraz z wtyczkami korzystaj\u0105c z tego polecenia:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>To zainstaluje wszystkie zale\u017cno\u015bci.</p> </li> <li> <p>Pobierz (ang. fetch) stan historii git z repozytorium <code>upstream</code> korzystaj\u0105c z tego polecenia:</p> <pre><code>git fetch upstream\n</code></pre> </li> <li> <p>Otw\u00f3rz (ang. checkout) lokaln\u0105 ga\u0142\u0105\u017a opieraj\u0105c\u0105 si\u0119 o ga\u0142\u0105\u017a <code>dev</code> repozytorium <code>upstream</code> korzystaj\u0105c z tego polecenia:</p> <pre><code>git checkout -b name-of-branch --track upstream/dev\n</code></pre> <p>W miejscu <code>name-of-branch</code> podaj kr\u00f3tk\u0105 nazw\u0119 po angielsku. Odpowiedni\u0105 nazw\u0105 ga\u0142\u0119zi jest albo nazwa funkcjonalno\u015bci, albo kr\u00f3tki opis wprowadzonych zmian np. <code>3ds-articles</code>, <code>fix-typos-for-contribution</code>. Nie musz\u0105 by\u0107 zbyt skomplikowane, do 4 s\u0142\u00f3w wystarczy.</p> </li> <li> <p>Uruchom serwer ze zbudowan\u0105 stron\u0105 projektu, korzystaj\u0105c z tego polecenia:</p> <pre><code>mkdocs serve\n</code></pre> <p>Odwied\u017a lokaln\u0105 stron\u0119 pod tym adresem <code>http://127.0.0.1:8000/gmc/</code>. Po ka\u017cdej zmianie w plikach projektu strona automatycznie si\u0119 przebuduje i po chwili przegl\u0105darka automatycznie si\u0119 od\u015bwie\u017cy.</p> <p>Serwer mo\u017ce by\u0107 zamkni\u0119ty poprzez skorzystanie ze skr\u00f3tu klawiszowego <code>Control-C</code> w trakcie gdy okno polece\u0144 jest aktywne.</p> </li> <li> <p>Je\u017celi uko\u0144czysz fragment swojej pracy, dodaj pliki i wstaw wpis do historii gita (ang. commit) korzystaj\u0105c z tego polecenia:</p> <pre><code>git add .\ngit commit -m \"add 3 articles about ZenGin\"\n</code></pre> <p>Jak wida\u0107 wiadomo\u015b\u0107 (ang. message) / nazwa do wpisu historii r\u00f3wnie\u017c powinna by\u0107 w j\u0119zyku angielskim. Odpowiedni\u0105 wiadomo\u015bci\u0105 jest zdanie opisuj\u0105ce zmiany.</p> </li> <li> <p>Po sko\u0144czeniu wszystkich prac wy\u015blij (ang. push) swoj\u0105 ga\u0142\u0105\u017a do zdalnego repozytorium <code>origin</code>, korzystaj\u0105c z tego polecenia:</p> <pre><code>git push origin name-of-branch\n</code></pre> </li> <li> <p>Stw\u00f3rz pro\u015bb\u0119 o po\u0142\u0105czenie (ang. pull request) wzgl\u0119dem odpowiedniej ga\u0142\u0119zi.</p> <p>Po wys\u0142aniu lokalnej ga\u0142\u0119zi do zdalnego repozytorium <code>origin</code> w oknie polece\u0144 b\u0119dzie dost\u0119pne \u0142\u0105cze, kt\u00f3re otworzy stron\u0119 tworzenia pro\u015bby o po\u0142\u0105czenie. Upewnij si\u0119, \u017ce jest skierowana wzgl\u0119dem ga\u0142\u0119zi <code>dev</code> oraz, \u017ce posiada wszystkie wprowadzone zmiany.</p> </li> <li> <p>Kolejna kontrybucja:</p> <p>Przed kolejn\u0105 kontrybucj\u0105, zawsze skorzystaj z tego polecenia: </p><pre><code>git fetch upstream </code></pre> \u017ceby mie\u0107 pewno\u015b\u0107, \u017ce posiadasz najnowsz\u0105 histori\u0119 zmian z repozytorium <code>upstream</code>. Nast\u0119pnie pod\u0105\u017caj ponownie od 8. podpunktu i zawsze tw\u00f3rz now\u0105 ga\u0142\u0105\u017a przed wprowadzeniem zmian. <pre><code>git status\n</code></pre> <p>Tym poleceniem mo\u017cesz sprawdzi\u0107, czy nie masz \u017cadnych zmian w strukturze projektu wzgl\u0119dem repozytorium <code>upstream</code>.</p> </li> </ol>"},{"location":"pl/contribute/#preferencje-budowy-strony","title":"Preferencje budowy strony","text":"<p>Podczas pracy z projektem mo\u017cna ustawi\u0107 r\u00f3\u017cne zmienne \u015brodowiskowe, \u017ceby przystosowa\u0107 konfiguracj\u0119 do w\u0142asnych preferencji:</p> <ul> <li><code>GMC_DEV_LOCALE</code> - to dwuznakowy identyfikator j\u0119zyka (np. <code>en</code>, <code>pl</code>), ustawia j\u0119zyk testowy. To ustawi ten j\u0119zyki jako domy\u015blny oraz jedyny renderowany podczas budowy strony. Pomaga w zmniejszeniu czasu budowy strony oraz pozwala na \u0142atwe zmienianie j\u0119zyka zamiast modyfikowania pliku konfiguracyjnego. Przez zmiany w pluginie <code>mkdocs-static-i18n</code> jest to jedyny spos\u00f3b na tymczasow\u0105 zmian\u0119 domy\u015blnego j\u0119zyka</li> <li><code>GMC_BUILD_ALTERNATES</code> - warto\u015b\u0107 <code>True</code> albo <code>False</code>, aktywuje budowanie strony wraz z alternatywnymi j\u0119zykami. Domy\u015blnie alternatywne j\u0119zyki s\u0105 pomijane, aby zmenijszy\u0107 czas budowy strony. </li> <li><code>GMC_ENABLE_ON_PUBLISH</code> - warto\u015b\u0107 <code>True</code> albo <code>False</code>, aktywuje wszystkie finalne procesy, jak dodanie daty ostatniej aktualizacji, minimalizacja zasob\u00f3w itp. </li> </ul> <p>Dla otwartego okna polece\u0144 mo\u017cna tymczasowo je ustawi\u0107:</p> Linux<pre><code>export GMC_DEV_LOCALE=en export GMC_BUILD_ALTERNATES=False; mkdocs serve\n</code></pre> Windows Powershell<pre><code>$env:GMC_DEV_LOCALE=\"en\"\n$env:GMC_BUILD_ALTERNATES=\"False\"\nmkdocs serve\n</code></pre> Windows Konsola Polece\u0144 (cmd)<pre><code>set GMC_DEV_LOCALE=en\nset GMC_BUILD_ALTERNATES=False\nmkdocs serve\n</code></pre>"},{"location":"pl/contribute/#wydajno\u015b\u0107-budowy-strony","title":"Wydajno\u015b\u0107 budowy strony","text":"<p>Aby przy\u015bpieszy\u0107 proces budowy strony podczas pracy, upewnij si\u0119, \u017ce tylko 1 j\u0119zyk jest budowany i rozwa\u017c u\u017cycie opcji <code>--dirtyreload</code>:</p> <pre><code>mkdocs serve --dirtyreload\n</code></pre> <p>To sprawi, \u017ce tylko zmienione pliki <code>.md</code> b\u0119d\u0105 na nowo budowane. Jednak\u017ce, zmiany plik\u00f3w szablonowych (ang. template) w folderze <code>overrides</code> nie b\u0119d\u0105 widoczne, poniewa\u017c takie zmiany wymagaj\u0105 pe\u0142nej przebudowy.</p>"},{"location":"pl/contribute/#prze\u015blij-plik","title":"Prze\u015blij plik","text":"<p>Je\u017celi praca z git albo Markdown jest nieprzyst\u0119pna lub niemo\u017cliwa to mo\u017cesz przes\u0142a\u0107 plik w formacie Google Docs na serwer Discord GMC, sformatujemy go i dodamy tre\u015b\u0107 do strony.</p> <p>Tylko nowa zawarto\u015b\u0107 po angielsku</p> <p>Ta opcja jest ograniczona tylko dla nowej tre\u015bci w j\u0119zyku angielskim. Nie mo\u017cemy wykorzysta\u0107 tego sposobu dla t\u0142umacze\u0144. Dla t\u0142umacze\u0144 wy\u015blij przet\u0142umaczony plik <code>.md</code> poprzez zg\u0142oszenie, je\u017celi nie chcesz pracowa\u0107 bezpo\u015brednio z git, ani doda\u0107 pliku poprzez interfejs GitHub.</p>"},{"location":"pl/contribute/#translations","title":"T\u0142umaczenia","text":"<p>\u017beby dostarczy\u0107 wsparcie dla wielu j\u0119zyk\u00f3w, nasza strona korzysta ze wtyczki MkDocs i18n.</p>"},{"location":"pl/contribute/#dodaj-wsparcie-dla-nowego-j\u0119zyka","title":"Dodaj wsparcie dla nowego j\u0119zyka","text":"<p>\u017beby wspiera\u0107 nowy j\u0119zyk, musi by\u0107 dodany:</p> <p>Wci\u0119cia maj\u0105 znaczenie</p> <p>Musisz zachowa\u0107 poprawn\u0105 ilo\u015b\u0107 wci\u0119\u0107, czyli odst\u0119p\u00f3w mi\u0119dzy wpisami.</p> <ol> <li> <p>W konfiguracji <code>mkdocs.yml</code>, w tym przyk\u0142adzie dodajemy j\u0119zyk <code>xx</code>:</p> <pre><code>plugins:\n- i18n:\n# ...\nlanguages:\nen:\nname: en - English\nbuild: true\nxx:\nname: xx - Language Name\nbuild: true\n</code></pre> </li> <li> <p>W pliku <code>overrides/main.html</code>, \u017ceby doda\u0107 tekst og\u0142oszenia dla zawarto\u015bci nieprzet\u0142umaczonej:</p> <pre><code>{%\n    set announcement = {\n        \"en\": \"This page has not yet been translated into LANGUAGE, therefore it is displayed in English.\",\n        \"xx\": \"yyy\",\n    }\n%}\n{%\n    set call_to_action = {\n        \"en\": \"Support us and translate!\",\n        \"xx\": \"yyy\",\n    }\n%}\n</code></pre> </li> <li> <p>Odwied\u017a oficjaln\u0105 stron\u0119 sk\u00f3rki.     Upewnij si\u0119, \u017ce t\u0142umaczenie sk\u00f3rki jest tam kompletne. Je\u017celi nie jest, pod\u0105\u017caj wed\u0142ug poradnika kontrybucji sk\u00f3rki i wr\u00f3\u0107 tutaj, nie trzeba czeka\u0107 na zmiany w sk\u00f3rce.</p> </li> </ol>"},{"location":"pl/contribute/#dodaj-przet\u0142umaczone-strony","title":"Dodaj przet\u0142umaczone strony","text":"<p>Ka\u017cdy plik <code>.md</code> w folderze <code>docs</code> mo\u017ce mie\u0107 przet\u0142umaczon\u0105 wersj\u0119. \u017beby doda\u0107 t\u0142umaczenie strony dla danego j\u0119zyka, stw\u00f3rz kopi\u0119 strony z dodan\u0105 ko\u0144c\u00f3wk\u0105 tego j\u0119zyka.  Na przyk\u0142ad <code>index.md</code> b\u0119dzie <code>index.xx.md</code> dla j\u0119zyka <code>xx</code> bazuj\u0105c na ustawieniach z pliku <code>mkdocs.yml</code>.</p> <p>Ka\u017cdy nieprzet\u0142umaczony artyku\u0142 posiada przycisk  w g\u00f3rnym prawym rogu obok tytu\u0142u. Pozwala na szybkie dodanie t\u0142umaczenia poprzez interfejs serwisu GitHub bez potrzeby konfiguracji plik\u00f3w lokalnie.</p>"},{"location":"pl/genome/","title":"Genome Engine","text":""},{"location":"pl/genome/#genome-engine","title":"Genome Engine","text":"<p>Genome Engine to nowy silnik autorstwa Piranha Bytes stworzony na potrzeby gry Gothic 3, a nast\u0119pnie wykorzystany w serii gier Risen i ELEX.</p>"},{"location":"pl/zengin/#zengin","title":"ZenGin","text":"<p>Silnik gry ZenGin jest u\u017cywany w grach Gothic 1 i 2. Ta sekcja zawiera dokumentacj\u0119 r\u00f3\u017cnych aspekt\u00f3w modowania ZenGin.</p>"},{"location":"pl/zengin/music/","title":"Muzyka","text":""},{"location":"pl/zengin/music/#muzyka","title":"Muzyka","text":"<p>Zengin u\u017cywa DirectMusic do odtwarzania \u015bcie\u017cki d\u017awi\u0119kowej w grze. Aby edytowa\u0107 pliki muzyczne Gothica, potrzebujesz programu Direct Music Producer, kt\u00f3ry zosta\u0142 wydany przez Microsoft i by\u0142 dostarczany do starszych zestaw\u00f3w SDK DirectX.</p> <p>Ostrze\u017cenie</p> <p>Pliki muzyczne nie mog\u0105 by\u0107 spakowane do archiw\u00f3w <code>.vdf</code> lub <code>.mod</code>, wszystkie takie pliki musz\u0105 znajdowa\u0107 si\u0119 w katalogu <code>/_work/Data/Music</code>.</p>"},{"location":"pl/zengin/music/#formaty-plik\u00f3w","title":"Formaty plik\u00f3w","text":"<p>Katalog <code>Music</code> zawiera nast\u0119puj\u0105ce typy plik\u00f3w:</p> <ul> <li> <p><code>.dls</code> - Plik formatu Downloadable Sound. Jest baz\u0105 dla wszystkich innych plik\u00f3w. Zawiera:</p> <ul> <li>Kolekcje wirtualnych instrument\u00f3w muzycznych.</li> <li>Pliki <code>.wav</code> u\u017cywane przez instrumenty.</li> </ul> </li> <li> <p><code>.sty</code> - Plik stylu. Zawiera:</p> <ul> <li>Zespo\u0142y (Bands) - ustawienia instrument\u00f3w wirtualnych z <code>.dls</code>.</li> <li>Wzory (Patterns) - fragmenty utwor\u00f3w, kt\u00f3re mo\u017cna p\u00f3\u017aniej \u0142\u0105czy\u0107, zap\u0119tla\u0107 i nak\u0142ada\u0107 na siebie.</li> </ul> </li> <li> <p><code>.sgt</code> - Plik z odpowiednio po\u0142\u0105czonymi wzorami (patternami) - ko\u0144cowy utw\u00f3r</p> </li> </ul>"},{"location":"pl/zengin/music/#alternatywny-system-muzyczny","title":"Alternatywny System Muzyczny","text":"<p>Plugin zBassMusic zast\u0119puje domy\u015bln\u0105 bibliotek\u0119 muzyczn\u0105 Zengina, du\u017co nowsz\u0105 bibliotek\u0105 BASS. Umo\u017cliwia to mi\u0119dzy innymi odtwarzanie muzyki w takich formatach jak <code>.mp3</code> lub <code>.ogg</code>, oraz pakownie utwor\u00f3w do archiw\u00f3w <code>.vdf</code> i <code>.mod</code>.</p>"},{"location":"pl/zengin/scripts/","title":"Skrypty","text":""},{"location":"pl/zengin/scripts/#skrypty","title":"Skrypty","text":"<p>ZenGin u\u017cywa w\u0142asnego j\u0119zyka skryptowego o nazwie Daedalus. Jest podobny do j\u0119zyka programowania C, wi\u0119c je\u015bli wiesz troch\u0119 o programowaniu w C, to rozpocz\u0119cie pracy b\u0119dzie do\u015b\u0107 \u0142atwe.</p> <p>Katalog <code>Scripts</code> to miejsce, w kt\u00f3rym znajduj\u0105 si\u0119 skrypty. Znajdziesz tam pliki skrypt\u00f3w Daedalusa - o rozszerzeniach <code>.d</code> i <code>.src</code>, kt\u00f3re zawieraj\u0105 list\u0119 wszystkich plik\u00f3w do skompilowania.</p> <p>Skrypty Daedalusa mo\u017cna edytowa\u0107 w dowolnym edytorze tekstu. Aby uzyska\u0107 przydatne funkcjonalno\u015bci typu pod\u015bwietlanie sk\u0142adni, mo\u017cesz u\u017cy\u0107 narz\u0119dzi stworzonych przez spo\u0142eczno\u015b\u0107, takich jak </p> <ul> <li>Gothic Sourcer</li> <li>Daedalus VS Code extension</li> </ul>"},{"location":"pl/zengin/scripts/extenders/","title":"Extendery Daedalusa","text":""},{"location":"pl/zengin/scripts/extenders/#extendery-daedalusa","title":"Extendery Daedalusa","text":"<p>Extendery to pakiety skryptowe rozszerzaj\u0105ce sk\u0142adni\u0119 Daedalusa, kt\u00f3ra mo\u017ce by\u0107 dosy\u0107 ograniczaj\u0105ca. Przez lata spo\u0142eczno\u015b\u0107 stworzy\u0142a ca\u0142kiem sporo takich extender\u00f3w. Zanim pojawi\u0142 si\u0119 Union, standardow\u0105 metod\u0105 na interfejs z silnikiem by\u0142o wykorzystanie Ikarusa i zbudowanej na jego bazie kolekcji pakiet\u00f3w LeGo. Nie tak niedawno powsta\u0142 dodatkowy pakiet skryptowy (a prace nad nim wci\u0105\u017c trwaj\u0105) AF Script Packet, kt\u00f3ry oferuje jeszcze wi\u0119cej funkcji i jest zbudowany na bazie Ikarusa i LeGo.  Wraz z pojawieniem si\u0119 Uniona i jego systemu plugin\u00f3w powsta\u0142 nowy extender o nazwie zParserExtender. Oczywi\u015bcie r\u00f3wnie\u017c inne pluginy mog\u0105 implementowa\u0107 w\u0142asne funkcje zewn\u0119trzne. Wiele skrypt\u00f3w jest r\u00f3wnie\u017c rozsianych po forach Gothicowych, a dokumentacje niekt\u00f3rych z nich mo\u017cna znale\u017a\u0107 w sekcji Samodzielne.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/#ikarus","title":"Ikarus","text":"<p>Ikarus jest bibliotek\u0105 Daedalusa - j\u0119zyka skryptowego Gothica. Wykorzystuje interpreter, aby umo\u017cliwi\u0107 dowolny dost\u0119p do pami\u0119ci i definiuje mn\u00f3stwo przydatnych funkcji do pracy z silnikiem.</p> Kontakt Autor  Sektenspinner i wsp\u00f3\u0142tw\u00f3rcy GitHub  Ikarus Forum  Ikarus <p>Notatka autora (Sektenspinner)</p> <p>Ten pakiet skrypt\u00f3w niebez powodu nazywa si\u0119 Ikarus:</p> <p>Mo\u017cna opu\u015bci\u0107 granice Dedala, ale mo\u017cna te\u017c rozbi\u0107 si\u0119 i spali\u0107. Na przyk\u0142ad odczyt z nieprawid\u0142owych adres\u00f3w nie wywo\u0142a ostrze\u017cenia zSpy, ale spowoduje wyj\u015bcie do pulpitu wraz z Access Violation. Nie jest to pow\u00f3d do paniki, ale wymaga tolerancji na frustracj\u0119 (co mo\u017ce by\u0107 og\u00f3lnie przydatne dla skrypter\u00f3w).</p> <p>Oczywi\u015bcie tak spektakularnie wygl\u0105daj\u0105ce b\u0142\u0119dy mo\u017cna naprawi\u0107, a przy systematycznej pracy w skupieniu mo\u017cna osi\u0105gn\u0105\u0107 co\u015b sensownego.</p> <p>W skr\u00f3cie: wymagana jest dodatkowa ostro\u017cno\u015b\u0107! B\u0142\u0105d prowadz\u0105cy do awarii nie jest czym\u015b, czego chcia\u0142by\u015b w wydanej wersji. Ale je\u015bli pracujesz czysto i intensywnie testujesz, nie jest to taka wielka sprawa.</p> <p>Dobrym przyjacielem w debugowaniu awarii jest niew\u0105tpliwie <code>PrintDebug</code>. Umo\u017cliwia wysy\u0142anie wiadomo\u015bci do zSpy (na przyk\u0142ad w celu zaw\u0119\u017cenia miejsca wyst\u0105pienia awarii). Warto w\u0142\u0105czy\u0107 komunikaty debugowania za pomoc\u0105 <code>MEM_SetShowDebug</code> i filtr tekstowy (Opcje -&gt; Textfilter) w zSpy.</p> <p>Note</p> <p>Ikarus jest hostowany na GitHubie i posiada wbudowan\u0105 dokumentacje. Jej t\u0142umaczenie jest w planach.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#dost\u0119p-do-plik\u00f3w-konfiguracyjnych","title":"Dost\u0119p do plik\u00f3w konfiguracyjnych","text":"<p>Ta cz\u0119\u015b\u0107 Ikarusa umo\u017cliwia dost\u0119p do <code>Gothic.ini</code> i pliku konfiguracyjnego za\u0142adowanej modyfikacji.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#inicjalizacja","title":"Inicjalizacja","text":"<p>Najlepszym sposobem na zainicjowanie Ikarusa jest wywo\u0142anie <code>MEM_InitAll()</code> w funkcji <code>Init_Global()</code>. </p> <p>Warning</p> <p>Je\u017celi chcesz u\u017cywa\u0107 Ikarusa z Gothiciem 1, najlepiej b\u0119dzie, je\u015bli zdefiniujesz w\u0142asn\u0105 funkcj\u0119 <code>Init_Global()</code> i wywo\u0142asz j\u0105 w ka\u017cdej funkcji inicjuj\u0105cej \u015bwiat.</p> <pre><code>MEM_InitAll();\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#implementacja","title":"Implementacja","text":"<p> Ikarus.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#funkcje-odczytu","title":"Funkcje odczytu","text":""},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getcommandline","title":"<code>MEM_GetCommandLine</code>","text":"<p>Zwraca zawarto\u015b\u0107 linii polece\u0144 przekazan\u0105 do Gothica. </p><pre><code>func string MEM_GetCommandLine()\n</code></pre> Return value <p>Funkcja zwraca zawarto\u015b\u0107 linii polece\u0144 przekazan\u0105 do Gothica. Mo\u017ce to wygl\u0105da\u0107 na przyk\u0142ad tak:</p> <p><code>\"-TIME:7:35 -GAME:TEST_IKARUS.INI -ZREPARSE -ZWINDOW -ZLOG:5,S -DEVMODE -ZMAXFRAMERATE:30\"</code></p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getgothopt","title":"<code>MEM_GetGothOpt</code>","text":"<p>Przeszukuje <code>Gothic.ini</code> w poszukiwaniu opcji </p><pre><code>func string MEM_GetGothOpt(var string sectionname, var string optionname)\n</code></pre> Parametry <ul> <li><code>var string sectionname</code>     Nazwa sekcji np. <code>[GAME]</code></li> <li><code>var string optionname</code>     Szukana opcja np. <code>playLogoVideos</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca warto\u015b\u0107 opcji w postaci ci\u0105gu znak\u00f3w, albo pust\u0105 zmienn\u0105, gdy opcja nie istnieje w danej sekcji.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getmodopt","title":"<code>MEM_GetModOpt</code>","text":"<p>Przeszukuje ini za\u0142adowanej modyfikacji w poszukiwaniu opcji. </p><pre><code>func void MEM_GetModOpt(var string sectionname, var string optionname)\n</code></pre> Parametry <ul> <li><code>var string sectionname</code>     Nazwa sekcji np. <code>[INFO]</code></li> <li><code>var string optionname</code>     Szukana opcja np. <code>Title</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca warto\u015b\u0107 opcji w postaci ci\u0105gu znak\u00f3w, albo pust\u0105 zmienn\u0105, gdy opcja nie istnieje w danej sekcji.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_gothoptsectionexists","title":"<code>MEM_GothOptSectionExists</code>","text":"<p>Sprawdza, czy dana sekcja istnieje w <code>Gothic.ini</code> </p><pre><code>func int MEM_GothOptSectionExists(var string sectionname)\n</code></pre> Parametry <ul> <li><code>var string sectionname</code>     Nazwa sekcji np. <code>[GAME]</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca warto\u015b\u0107 <code>TRUE</code> je\u015bli sekcja istnieje, inaczej <code>FALSE</code>.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_modoptsectionexists","title":"<code>MEM_ModOptSectionExists</code>","text":"<p>Sprawdza, czy dana sekcja istnieje w ini za\u0142adowanej modyfikacji. </p><pre><code>func int MEM_ModOptSectionExists(var string sectionname)\n</code></pre> Parametry <ul> <li><code>var string sectionname</code>     Nazwa sekcji np. <code>[INFO]</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca warto\u015b\u0107 <code>TRUE</code> je\u015bli sekcja istnieje, inaczej <code>FALSE</code>.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_gothoptexists","title":"<code>MEM_GothOptExists</code>","text":"<p>Sprawdza, czy dana opcja istnieje w <code>Gothic.ini</code> </p><pre><code>func int MEM_GothOptExists(var string sectionname, var string optionname)\n</code></pre> Parametry <ul> <li><code>var string sectionname</code>     Nazwa sekcji np. <code>[GAME]</code></li> <li><code>var string optionname</code>     Szukana opcja np. <code>playLogoVideos</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca warto\u015b\u0107 <code>TRUE</code> je\u015bli opcja w danej sekcji istnieje, inaczej <code>FALSE</code>.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_modoptexists","title":"<code>MEM_ModOptExists</code>","text":"<p>Sprawdza, czy dana opcja istnieje w ini za\u0142adowanej modyfikacji. </p><pre><code>func int MEM_ModOptExists(var string sectionname, var string optionname)\n</code></pre> Parametry <ul> <li><code>var string sectionname</code>     Nazwa sekcji np. <code>[INFO]</code></li> <li><code>var string optionname</code>     Szukana opcja np. <code>Title</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca warto\u015b\u0107 <code>TRUE</code> je\u015bli opcja w danej sekcji istnieje, inaczej <code>FALSE</code>.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#funkcje-zapisu","title":"Funkcje zapisu","text":"<p>Warning</p> <p>Plik konfiguracyjny modyfikacji nigdy nie jest zapisywany na dysku, dlatego nie ma oddzielnej funkcji do jego zapisu.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setgothopt","title":"<code>MEM_SetGothOpt</code>","text":"<p>Opcja <code>option</code> w sekcji <code>section</code> jest ustawiana na <code>value</code>. Je\u015bli sekcja i/lub opcja nie istnieje, zostanie utworzona. </p><pre><code>func void MEM_SetGothOpt(var string section, var string option, var string value)\n</code></pre> Parametry <ul> <li><code>var string section</code>     Sekcja, w kt\u00f3rej znajduje si\u0119 opcja</li> <li><code>var string option</code>     Opcja do zapisania/nadpisania</li> <li><code>var string value</code>     Warto\u015b\u0107, na jak\u0105 ustawiana jest opcja</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_applygothopt","title":"<code>MEM_ApplyGothOpt</code>","text":"<p>Stosuje zmiany i zapisuje plik ini na dysku. </p><pre><code>func void MEM_ApplyGothOpt()\n</code></pre> <p>Tip</p> <p>Je\u015bli wprowadzasz nowe opcje, najlepiej kierowa\u0107 si\u0119 paroma zasadami. Dobr\u0105 praktyk\u0105 jest nazywanie swoich opcji tak, aby inni mogli je zrozumie\u0107 i umieszczanie ich w sekcji o takiej samej nazwie jak tw\u00f3j mod. Nie umieszczaj opcji swojej modyfikacji w sekcji <code>[GAME]</code> lub <code>[PERFORMANCE]</code>.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#funkcje-klawiszy","title":"Funkcje klawiszy","text":"<p><code>Gothic.ini</code> zawiera przypisanie klawiszy fizycznych (np. \"W\") do klawiszy logicznych (np. \"keyUp\").</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getkey","title":"<code>MEM_GetKey</code>","text":"<p>Zwraca podstawowy klawisz przypisany do klawisza logicznego. </p><pre><code>func int MEM_GetKey(var string name)\n</code></pre> Parametry <ul> <li><code>var string name</code>     Nazwa klawisza logicznego</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca klawisz przypisany do klawisza logicznego.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_getsecondarykey","title":"<code>MEM_GetSecondaryKey</code>","text":"<p>Zwraca zapasowy klawisz przypisany do klawisza logicznego. </p><pre><code>func int MEM_GetSecondaryKey(var string name)\n</code></pre> Parametry <ul> <li><code>var string name</code>     Nazwa klawisza logicznego</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca klawisz przypisany do klawisza logicznego.</p>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setkeys","title":"<code>MEM_SetKeys</code>","text":"<p>Ustawia klawisze klawiatury dla podanego klawisza logicznego. </p><pre><code>func void MEM_SetKeys(var string name, var int primary, var int secondary)\n</code></pre> Parametry <ul> <li><code>var string name</code>     Nazwa klawisza logicznego</li> <li><code>var int primary</code>     Podstawowy klawisz do przypisania, mo\u017cna go pobra\u0107 z pliku Ikarus_Const_G1 / Ikarus_Const_G2.</li> <li><code>var int secondary</code>     Zapasowy klawisz do przypisania, mo\u017cna go pobra\u0107 z plikuIkarus_Const_G1 / Ikarus_Const_G2.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setkey","title":"<code>MEM_SetKey</code>","text":"<p>Ustawia podstawowy klawisz klawiatury dla klawisza logicznego. </p><pre><code>func void MEM_SetKey(var string name, var int key)\n</code></pre> Parametry <ul> <li><code>var string name</code>     Nazwa klawisza logicznego</li> <li><code>var int key</code>     Podstawowy klawisz do przypisania, mo\u017cna go pobra\u0107 z pliku Ikarus_Const_G1 / Ikarus_Const_G2.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/ikarus/functions/ini_access/#mem_setsecondarykey","title":"<code>MEM_SetSecondaryKey</code>","text":"<p>Ustawia zapasowy klawisz klawiatury dla klawisza logicznego. </p><pre><code>func void MEM_SetSecondaryKey(var string name, var int key)\n</code></pre> Parametry <ul> <li><code>var string name</code>     Nazwa klawisza logicznego</li> <li><code>var int key</code>     Zapasowy klawisz do przypisania, mo\u017cna go pobra\u0107 z pliku Ikarus_Const_G1 / Ikarus_Const_G2.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/#lego","title":"LeGo","text":"<p>LeGo (LehonaGottfried) to pakiet skryptowy zbudowany na bazie Ikarusa.</p> Kontakt Autor  Lehona, Gottfried i wsp\u00f3\u0142tw\u00f3rcy GitHub  LeGo Forum  LeGo <p>Note</p> <p>Kod LeGo jest hostowany na GitHubie, a sam pakiet skryptowy ma w\u0142asn\u0105 stron\u0119 z dokumentacj\u0105. </p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bars---paski","title":"Bars - paski","text":"<p>Ten pakiet bardzo u\u0142atwia dodawanie nowych pask\u00f3w, dla wy\u015bwietlania np. wytrzyma\u0142o\u015bci.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>PermMem</li> <li>View</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_Bars</code>. </p><pre><code>LeGo_Init(LeGo_Bars);\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#implementacja","title":"Implementacja","text":"<p> Bars.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#funkcje","title":"Funkcje","text":"<p>Note</p> <p>Je\u015bli prototyp <code>GothicBar</code> jest wybrany jako typ pocz\u0105tkowy (<code>GothicBar@</code> jako konstruktor), paski u\u017cytkownika s\u0105 wizualnie nie do odr\u00f3\u017cnienia od tych u\u017cywanych w Gothicu.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_create","title":"<code>Bar_Create</code>","text":"<p>Tworzy nowy pasek z instancji konstruktora. </p><pre><code>func int Bar_Create(var int inst)\n</code></pre> <p>Parametry</p> <ul> <li><code>var int inst</code>     Instancja konstruktora klasy <code>Bar</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca handler do nowego paska.</p> Examples <p><code>var int bar; bar = Bar_Create(GothicBar@);</code></p> <pre><code>var int bar; bar = Bar_Create(GothicBar@); // Tworzy nowy pasek\nBar_SetPercent(bar, 50);                   // Ustawia jego warto\u015b\u0107 na 50%\n</code></pre> <pre><code>func void Example_1()\n{\nvar int bar; bar = Bar_Create(GothicBar@); // Tworzy nowy pasek\nBar_SetPercent(bar, 50);                   // Ustawia jego warto\u015b\u0107 na 50%\n};\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_delete","title":"<code>Bar_Delete</code>","text":"<p>Usuwa pasek z ekranu i pami\u0119ci.  </p><pre><code>func void Bar_Delete(var int bar)\n</code></pre> <p>Parametry</p> <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_setmax","title":"<code>Bar_SetMax</code>","text":"<p>Zmienia maksymalna warto\u015b\u0107 paska, ale nie aktualizuje jego d\u0142ugo\u015bci (tylko <code>Bar_SetPercent</code>, <code>Bar_SetPromille</code> i <code>Bar_SetValue</code> to robi\u0105) </p><pre><code>func void Bar_SetMax(var int bar, var int max)\n</code></pre> Parametry <ul> <li> <p><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></p> </li> <li> <p><code>var int max</code>     Nowa maksymalna warto\u015b\u0107</p> </li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_setvalue","title":"<code>Bar_SetValue</code>","text":"<p>Ustawia warto\u015b\u0107 paska. </p><pre><code>func void Bar_SetValue(var int bar, var int val)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int val</code>     Nowa warto\u015b\u0107 paska</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_setpercent","title":"<code>Bar_SetPercent</code>","text":"<p>Ustawia warto\u015b\u0107 paska, ale w procentach (0..100). </p><pre><code>func void Bar_SetPercent(var int bar, var int perc)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int perc</code>     Nowa warto\u015b\u0107 paska w procentach</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_setpromille","title":"<code>Bar_SetPromille</code>","text":"<p>Ustawia warto\u015b\u0107 paska, ale w promilach (0..1000). </p><pre><code>func void Bar_SetPromille(var int bar, var int pro)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int pro</code>     Nowa warto\u015b\u0107 paska w promilach</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_hide","title":"<code>Bar_Hide</code>","text":"<p>Ukrywa pasek, ale go nie usuwa. </p><pre><code>func void Bar_Hide(var int bar)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_show","title":"<code>Bar_Show</code>","text":"<p>Wy\u015bwietla pasek ponownie po u\u017cyciu <code>Bar_Hide</code>.  </p><pre><code>func void Bar_Show(var int bar)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_moveto","title":"<code>Bar_MoveTo</code>","text":"<p>Przenosi pasek do danej pozycji wirtualnej.  </p><pre><code>func void Bar_MoveTo(var int bar, var int x, var int y)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int x</code>     Nowa pozycja w osi x</li> <li><code>var int y</code>     Nowa pozycja w osi y</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_movetopxl","title":"<code>Bar_MoveToPxl</code>","text":"<p>Przenosi pasek do danej pozycji wyra\u017conej w pikselach. </p><pre><code>func void Bar_MoveToPxl(var int bar, var int x, var int y)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int x</code>     Nowa pozycja w osi x</li> <li><code>var int y</code>     Nowa pozycja w osi y</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_setalpha","title":"<code>Bar_SetAlpha</code>","text":"<p>Ustawia przezroczysto\u015b\u0107 paska. </p><pre><code>func void Bar_SetAlpha(var int bar, var int alpha)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int alpha</code>     Warto\u015b\u0107 przezroczysto\u015bci (0..255) </li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_setbartexture","title":"<code>Bar_SetBarTexture</code>","text":"<p>Ustawia tekstur\u0119 warto\u015bci paska. </p><pre><code>func void Bar_SetBarTexture(var int bar, var string barTex)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var string barTex</code>     Nowa tekstura</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_setbacktexture","title":"<code>Bar_SetBackTexture</code>","text":"<p>Ustawia tekstur\u0119 t\u0142a paska. </p><pre><code>func void Bar_SetBackTexture(var int bar, var string backTex)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var string backTex</code>     Nowa tekstura t\u0142a</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_resize","title":"<code>Bar_Resize</code>","text":"<p>Zmienia rozmiar istniej\u0105cego paska. </p><pre><code>func void Bar_Resize(var int bar, var int width, var int height)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int width</code>     Nowa szeroko\u015b\u0107</li> <li><code>var int height</code>     Nowa szeroko\u015b\u0107</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#bar_resizepxl","title":"<code>Bar_ResizePxl</code>","text":"<p>Resize existing bar (in pixels). </p><pre><code>func void Bar_ResizePxl(var int bar, var int x, var int y)\n</code></pre> Parametry <ul> <li><code>var int bar</code>     Handler zwr\u00f3cony przez <code>Bar_Create</code></li> <li><code>var int x</code>     Nowa szeroko\u015b\u0107 w pikselach</li> <li><code>var int y</code>     Nowa szeroko\u015b\u0107 w pikselach</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#przyk\u0142ady","title":"Przyk\u0142ady","text":"<p>Note</p> <p>Ten pakiet zak\u0142ada podstawowe zrozumienie modu\u0142u PermMem. </p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/bars/#dedykowany-pasek-do\u015bwiadczenia","title":"Dedykowany pasek do\u015bwiadczenia","text":"<p>Pakiet Bars implementuje klas\u0119 <code>Bar</code>. Kt\u00f3ra wygl\u0105da tak: </p><pre><code>class Bar\n{\nvar int x;          // Pozycja na ekranie w osi X (\u015brodka paska)\nvar int y;          // Pozycja na ekranie w osi Y (\u015brodka paska)\nvar int barTop;     // Pasek odst\u0119pu t\u0142a - g\u00f3ra/d\u00f3\u0142\nvar int barLeft;    // Pasek odst\u0119pu t\u0142a - lewo/prawo\nvar int width;      // Szeroko\u015b\u0107\nvar int height;     // Wysoko\u015b\u0107\nvar string backTex; // Tekstura t\u0142a\nvar string barTex;  // Tekstura warto\u015bci paska\nvar int value;      // Pocz\u0105tkowa warto\u015b\u0107\nvar int valueMax;   // Maksymalna warto\u015b\u0107\n};\n</code></pre> Prototyp <code>GothicBar</code> jest paskiem, kt\u00f3ry na\u015bladuje standardowy pasek u\u017cywany w grze. <pre><code>prototype GothicBar(Bar)\n{\nx = Print_Screen[PS_X] / 2;\ny = Print_Screen[PS_Y] - 20;\nbarTop = 3;\nbarLeft = 7;\nwidth = 180;\nheight = 20;\nbackTex = \"Bar_Back.tga\";\nbarTex = \"Bar_Misc.tga\";\nvalue = 100;\nvalueMax = 100;\n};\n</code></pre> <p>O wiele \u0142atwiej jest skonfigurowa\u0107 now\u0105 instancj\u0119 przy u\u017cyciu tego prototypu. <code>GothicBar</code> bez zmian mo\u017cna znale\u017a\u0107 jako instancj\u0119 <code>GothicBar@</code>, kt\u00f3r\u0105 u\u017cyli\u015bmy do stworzenia paska w powy\u017cszym przyk\u0142adzie. <code>GothicBar</code> znajduje si\u0119 na \u015brodku ekranu i wygl\u0105da tak samo, jak pasek wy\u015bwietlany podczas nurkowania. </p><pre><code>// Instancja stworzona z pomoc\u0105 prototypu GothicBar \ninstance Bar_1(GothicBar)\n{\nx = 100;\ny = 20;\n};\nfunc void Example_1()\n{\n// Example_1 mo\u017ce by\u0107 wywo\u0142any np. w Init_Global\nFF_ApplyOnce(Loop_1);\n};\nfunc void Loop_1()\n{\n// Example_1 uruchamia t\u0119 p\u0119tl\u0119.\n// Tutaj pasek powinien by\u0107 stworzony raz\n// a potem sparowany z punktami do\u015bwiadczenia:\nvar int MyBar;\nif(!Hlp_IsValidHandle(MyBar))\n{\nMyBar = Bar_Create(Bar_1); // Our Bar_1\n};\n// Reszta jest chyba oczywista:\nBar_SetMax(MyBar, hero.exp_next);\nBar_SetValue(MyBar, hero.exp);\n};\n</code></pre> <p>Note</p> <p>Jest to t\u0142umaczenie artyku\u0142u napisanego oryginalnie przez Gottfrieda i Lehone i umieszczonego w oficjalnej dokumentacji pakietu LeGo.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#console-commands---polecenia-konsoli","title":"Console Commands - polecenia konsoli","text":"<p>Ten Pakiet pozwala na tworzenie nowych polece\u0144 konsoli dost\u0119pnej po naci\u015bni\u0119ciu klawisza F2 w trybie marvin.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>PermMem</li> <li>HookEngine</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_ConsoleCommands</code>. </p><pre><code>LeGo_Init(LeGo_ConsoleCommands);\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#implementacja","title":"Implementacja","text":"<p> ConsoleCommands.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#cc_register","title":"<code>CC_Register</code>","text":"<p>Rejestruje nowe polecenie konsoli. </p><pre><code>func void CC_Register(var func f, var string cmdPrefix, var string description)\n</code></pre> Parametry <ul> <li><code>var func f</code>     Ta funkcja jest wykonywana po wprowadzeniu polecenia <code>cmdPrefix</code> w konsoli. Sygnatura funkcji to <code>func string f(var string p0)</code>. Przekazany string to wszystko, co zosta\u0142o okre\u015blone w konsoli po faktycznym poleceniu. Zwracana warto\u015b\u0107 jest nast\u0119pnie wy\u015bwietlana w konsoli.</li> <li><code>var string cmdPrefix</code>     Jest to polecenie, kt\u00f3re mo\u017cna wprowadzi\u0107 w konsoli.</li> <li><code>var string description</code>     Ten tekst pojawia si\u0119 obok polecenia (w zSpy), gdy u\u017cywasz polecenia <code>help</code> w konsoli.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#cc_remove","title":"<code>CC_Remove</code>","text":"<p>Usuwa funkcje z konsoli komend. </p><pre><code>func void CC_Remove(var func f)\n</code></pre> Parametry <ul> <li><code>var func f</code>     Ta funkcja zostanie usuni\u0119ta, a powi\u0105zane z ni\u0105 polecenie przestanie dzia\u0142a\u0107.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#cc_active","title":"<code>CC_Active</code>","text":"<p>Sprawdza, czy dana funkcja jest ju\u017c cz\u0119\u015bci\u0105 polecenia konsoli. </p><pre><code>func int CC_Active(var func f)\n</code></pre> Parametry <ul> <li><code>var func f</code>     Sprawdzana funkcja</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca <code>TRUE</code> je\u015bli znajdzie odpowiedni\u0105 funkcj\u0119, inaczej <code>FALSE</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#przyk\u0142ady","title":"Przyk\u0142ady","text":""},{"location":"pl/zengin/scripts/extenders/lego/applications/console_commands/#proste-polecenie-konsoli","title":"Proste polecenie konsoli","text":"<p>Jako prosty przyk\u0142ad stw\u00f3rzmy polecenie version, kt\u00f3re wy\u015bwietli nam wersj\u0119 modyfikacji.  Po pierwsze, deklarujemy sta\u0142\u0105 zmienn\u0105 <code>string</code> do przechowywania informacji o wersji. </p><pre><code>const string Mod_Version = \"Wersja modyfikacji - 0.1alpha\";\n</code></pre> Nast\u0119pnie tworzymy now\u0105 funkcj\u0119.  <p>Note</p> <p>Zwr\u00f3\u0107 uwag\u0119 na poprawn\u0105 sygnatur\u0119 funkcji. Je\u015bli b\u0119dzie ona b\u0142\u0119dna, polecenie spowoduje awari\u0119 gry.</p> <p></p><pre><code>// Ta funkcja jest wywo\u0142ywana przez nasze nowe polecenie\nfunc string CC_ModVersion(var string param)\n{\nreturn Mod_Version;\n};\n</code></pre> Nast\u0119pnie musimy zarejestrowa\u0107 polecenie. Dla wygody stworzy\u0142em now\u0105 funkcj\u0119 <code>RegisterConsoleFunctions</code>, kt\u00f3ra inicjuje wszystkie polecenia konsoli. Funkcja jest naprawd\u0119 prosta. <pre><code>func void RegisterConsoleFunctions()\n{\nCC_Register (CC_ModVersion, \"version\", \"Wersja mojej modyfikacji.\");\n};\n</code></pre> Na koniec musimy wywo\u0142a\u0107 t\u0119 funkcj\u0119 w <code>INIT_GLOBAL</code>. <pre><code>func void INIT_GLOBAL()\n{\nGame_InitGerman(); // tylko w G2\n// Inicjalizacja Ikarusa\nMEM_InitAll();\n// Inicjalizacja LeGo\nLeGo_Init(LeGo_ConsoleCommands);\n// Tutaj rejstrujemy nasze polecenia\nRegisterConsoleFunctions();\n// Reszta kodu\n};\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#gamestate---stan-gry","title":"Gamestate - stan gry","text":"<p>Pakiet Gamestate pozwala sprawdzi\u0107 stan gry (rozpocz\u0119cie gry, \u0142adowanie gry lub zmiana poziomu).</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>EventHandler</li> <li>Saves</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_Gamestate</code>. </p><pre><code>LeGo_Init(LeGo_Gamestate);\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#implementacja","title":"Implementacja","text":"<p> Gamestate.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#gamestate_addlistener","title":"<code>Gamestate_AddListener</code>","text":"<p>Dodaje listener/handler zmiany stanu gry. </p><pre><code>func void Gamestate_AddListener(var func listener)\n</code></pre> Parametry <ul> <li><code>var func listener</code>     Ta funkcja zostanie wywo\u0142ana przy zmianie stanu gry. Bie\u017c\u0105cy stan gry jest przekazywany jako parametr.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#gamestate_removelistener","title":"<code>Gamestate_RemoveListener</code>","text":"<p>Usuwa listener zmiany stanu gry. </p><pre><code>func void Gamestate_RemoveListener(var func listener)\n</code></pre> Parametry <ul> <li><code>var func listener</code>     Listener do usuni\u0119cia.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#przyk\u0142ady","title":"Przyk\u0142ady","text":"<p>Istniej\u0105 teraz dwie mo\u017cliwo\u015bci. Wszystko mo\u017cna zrobi\u0107 bezpo\u015brednio w <code>Init_Global</code> lub za pomoc\u0105 EventHandler.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#init_global","title":"Init_Global","text":"<pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame) {\nMEM_Info(\"Nowa gra rozpocz\u0119ta.\");\n}\nelse if(Gamestate == Gamestate_Loaded)\n{\nMEM_Info(\"\u0141adowanie gry.\");\n}\nelse if(Gamestate == Gamestate_WorldChange)\n{\nMEM_Info(\"Zmiana \u015bwiata.\");\n}\nelse\n{\nMEM_Info(\"Brak zmiany stanu gry\");\n};\n};\n</code></pre> <p>Mo\u017cna to r\u00f3wnie\u017c zrobi\u0107 tak: </p><pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nif(Gamestate == Gamestate_NewGame)\n{\nFF_Apply(MyLoop);\nFF_Apply(My2ndLoop);\n};\n};\n</code></pre> Da\u0142oby to taki sam efekt jak: <pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nFF_ApplyOnce(MyLoop);\nFF_ApplyOnce(My2ndLoop);\n};\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/gamestate/#eventhandler","title":"EventHandler","text":"<pre><code>func void Init_Global()\n{\n// [...]\nLeGo_Init(LeGo_All);\nGamestate_AddListener(MyGamestateListener);\n};\nfunc void MyGamestateListener(var int state)\n{\nif(state == Gamestate_NewGame)\n{\nMEM_Info(\"Nowa gra rozpocz\u0119ta.\");\n}\nelse if(state == Gamestate_Loaded)\n{\nMEM_Info(\"\u0141adowanie gry.\");\n}\nelse if(state == Gamestate_WorldChange)\n{\nMEM_Info(\"Zmiana \u015bwiata.\");\n}\nelse\n{\nMEM_Info(\"Brak zmiany stanu gry.\");\n};\n};\n</code></pre> Daje taki sam efekt jak przyk\u0142ad z <code>Init_Global</code> ale dla niekt\u00f3rych mo\u017ce lepiej wygl\u0105da\u0107.  <p>Note</p> <p>Jest to t\u0142umaczenie artyku\u0142u napisanego oryginalnie przez Gottfrieda i Lehone i umieszczonego w oficjalnej dokumentacji pakietu LeGo.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#trialogi","title":"Trialogi","text":"<p>Ten pakiet pozwala na tworzenie rozm\u00f3w z dowoln\u0105 liczb\u0105 NPC i sterowanie kamer\u0105 podczas dialogu.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>AI_Function</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_Trialoge</code>. </p><pre><code>LeGo_Init(LeGo_Trialoge);\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#implementacja","title":"Implementacja","text":"<p> Trialoge.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#equipweapon","title":"<code>EquipWeapon</code>","text":"<p>Funkcja Sektenspinnera. Sprawia, \u017ce NPC wyposa\u017ca bro\u0144. </p><pre><code>func void EquipWeapon(var C_NPC slf, var int ItemInstance)\n</code></pre> Parametry <ul> <li><code>var C_NPC slf</code>     NPC kt\u00f3ry wyposa\u017ca bro\u0144</li> <li><code>var int ItemInstance</code>     Instancja broni do wyposa\u017cenia</li> </ul> <p>Konfigurcja</p> <p><code>const int EquipWeapon_TogglesEquip = 1</code></p> <p>Powy\u017csza sta\u0142a ustala zachowanie funkcji podczas pr\u00f3by za\u0142o\u017cenia ju\u017c za\u0142o\u017conej bronii:</p> <ul> <li><code>0</code> - <code>EquipWeapon</code> nic nie zrobi</li> <li><code>1</code> - <code>EquipWeapon</code> zdejmie t\u0105 bro\u0144</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#npc_getarmor","title":"<code>Npc_GetArmor</code>","text":"<p>Pobiera pancerz wyposa\u017cony przez NPC. </p><pre><code>func int Npc_GetArmor(var C_NPC slf)\n</code></pre> Parametry <ul> <li><code>var C_NPC slf</code>     NPC kt\u00f3rego pancerz jest pobierany</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca ID instancji pancerza za\u0142o\u017conego przez NPC.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#npc_getmeleeweapon","title":"<code>Npc_GetMeleeWeapon</code>","text":"<p>Pobiera wyposa\u017con\u0105 przez NPC bro\u0144 bia\u0142\u0105. </p><pre><code>func int Npc_GetMeleeWeapon(var C_NPC slf)\n</code></pre> Parametry <ul> <li><code>var C_NPC slf</code>     NPC kt\u00f3rego bro\u0144 jest pobierana</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca ID instancji broni bia\u0142ej wyposa\u017conej przez NPC.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#npc_getrangedweapon","title":"<code>Npc_GetRangedWeapon</code>","text":"<p>Pobiera wyposa\u017con\u0105 przez NPC bro\u0144 dystansow\u0105. </p><pre><code>func int Npc_GetRangedWeapon(var C_NPC slf)\n</code></pre> Parametry <ul> <li><code>var C_NPC slf</code>     NPC kt\u00f3rego bro\u0144 jest pobierana</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca ID instancji broni dystansowej wyposa\u017conej przez NPC.</p>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#npc_tradeitem","title":"<code>Npc_TradeItem</code>","text":"<p>Podmienia bro\u0144 za\u0142o\u017con\u0105 przez NPC. </p><pre><code>func void Npc_TradeItem(var c_npc slf, var int itm0, var int itm1) </code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC na kt\u00f3rym wykonywana jest operacja</li> <li><code>var int itm0</code>     ID instancji przedmiotu do usuni\u0119cia</li> <li><code>var int itm1</code>     ID instancji przedmiotu do stworzenia i za\u0142o\u017cenia</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#diacam_update","title":"<code>DiaCAM_Update</code>","text":"<p>Funkcja Sektenspinnera. Aktualizuje kamer\u0119 dialogow\u0105. (U\u017cywana wewn\u0119trznie) </p><pre><code>func void DiaCAM_Update()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#diacam_disable","title":"<code>DiaCAM_Disable</code>","text":"<p>Ca\u0142kowicie wy\u0142\u0105cza kamery dialogowe. </p><pre><code>func void DiaCAM_Disable()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#diacam_enable","title":"<code>DiaCAM_Enable</code>","text":"<p>Resetuje kamery dialogowe do ustawie\u0144 domy\u015blnych. </p><pre><code>func void DiaCAM_Enable()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#tria_wait","title":"<code>TRIA_Wait</code>","text":"<p>Sprawia \u017ce <code>self</code> i <code>other</code> czekaj\u0105 na siebie, np. podaczas dla synchronizacji po wywo\u0142aniu <code>AI_GotoWP</code>.  </p><pre><code>func void TRIA_Wait()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#tria_invite","title":"<code>TRIA_Invite</code>","text":"<p>Zaprasza NPC do rozmowy. Nale\u017cy wywo\u0142a\u0107 przed <code>TRIA_Start</code>.<code>TRIA_Start</code>. </p><pre><code>func void TRIA_Invite(var C_NPC slf)\n</code></pre> Parametry <ul> <li><code>var C_NPC slf</code>     Zapraszany NPC</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#tria_start","title":"<code>TRIA_Start</code>","text":"<p>Rozpoczyna trialog. Wcze\u015bniej wszyscy NPC powinni zosta\u0107 zaproszeni przez <code>TRIA_Invite</code>. </p><pre><code>func void TRIA_Start()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#tria_barrier","title":"<code>TRIA_Barrier</code>","text":"<p>Robi to samo co <code>TRIA_Wait</code>, ale dotyczy wszystkich uczestnicz\u0105cych NPC. </p><pre><code>func void TRIA_Barrier()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#tria_next","title":"<code>TRIA_Next</code>","text":"<p>Ustawia podanego npc na <code>self</code>. </p><pre><code>func void TRIA_Next(var C_NPC n0)\n</code></pre> Parametry <ul> <li><code>var C_NPC n0</code>     NPC ustawiany na <code>self</code></li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#tria_cam","title":"<code>TRIA_Cam</code>","text":"<p>Rozpoczyna zdefiniowany wcze\u015bniej ruch kamery. </p><pre><code>func void TRIA_Cam(var string evt)\n</code></pre> Parametry <ul> <li><code>var string evt</code>     Nazwa ruchu kamery w Spacerze. Je\u015bli zostanie przekazany pusty ci\u0105g znak\u00f3w, nast\u0105pi przerwanie ruchu kamery.</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#tria_finish","title":"<code>TRIA_Finish</code>","text":"<p>Ko\u0144czy trwaj\u0105cy trialog. Musi by\u0107 zawsze wywo\u0142ywana na ko\u0144cu, w przeciwnym razie dalsze trialogi nie b\u0119d\u0105 mog\u0142y zosta\u0107 rozpocz\u0119te. </p><pre><code>func void TRIA_Finish()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#przyk\u0142ady","title":"Przyk\u0142ady","text":""},{"location":"pl/zengin/scripts/extenders/lego/applications/trialoge/#prosty-trialog","title":"Prosty Trialog","text":"<p>Poni\u017csza konwersacja zostanie zaimplementowana za pomoc\u0105 trialog\u00f3w:</p> <ol> <li>Arto: Wybacz bohaterze, ale nie mo\u017cesz t\u0119dy przej\u015b\u0107.</li> <li>Bohater: Dlaczego nie?</li> <li>Horka: Miasto zosta\u0142o zamkni\u0119te.</li> <li>Bohater: Mam troch\u0119 z\u0142ota przy sobie, mo\u017cemy pohandlowa\u0107?</li> <li>Squelto: Nie. Nie jeste\u015bmy otwarci na przekupstwo.</li> <li>Bohater: Na pewno?</li> <li>Arto: Musz\u0119 prosi\u0107, aby\u015b teraz odszed\u0142.</li> <li>Bohater: Niech b\u0119dzie... <pre><code>instance TRIA_Test (C_INFO)\n{\nnpc         = PAL_100_Friend;\nnr          = 10;\ncondition   = TRIA_Test_condition;\ninformation = TRIA_Test_info;\nimportant   = FALSE;\npermanent   = 1;\ndescription = \"TRIALOGTEST\";\n};\nfunc int TRIA_Test_condition()\n{\nreturn TRUE;\n};\nfunc void TRIA_Test_info()\n{\nvar C_NPC Arto;       Arto = Hlp_GetNpc(PAL_100_Friend); // On jest w\u0142a\u015bcicielem dialogu\nvar C_NPC Horka;     Horka = Hlp_GetNpc(PAL_101_Horka);\nvar C_NPC Squelto; Squelto = Hlp_GetNpc(PAL_102_Squelto);\nTRIA_Invite(Horka);   // Zapro\u015b Horka do dialogu\nTRIA_Invite(Squelto); // Zapro\u015b Squelto do dialogu\nTRIA_Start();         // Rozpocznij rozmow\u0119\n// Bohater i Arto nie musz\u0105 by\u0107 zaproszeni. Domy\u015blnie nale\u017c\u0105 do dialogu.\n// Bohater m\u00f3wi do Arto (self = Arto, other = Hero)\nTRIA_Next(Arto);\nDIAG_Reset();\nAI_Output (self, other, \"TRIA_TEST_00\"); //Wybacz bohaterze, ale nie mo\u017cesz t\u0119dy przej\u015b\u0107.\n// Bohater m\u00f3wi teraz do Horka (self = Horka, other = Hero)\nTRIA_Next(Horka);\nAI_Output (other, self, \"TRIA_TEST_01\"); //Dlaczego nie?\nAI_GotoNpc(self, other);\nAI_TurnToNpc(other, self);\nAI_Output (self, other, \"TRIA_TEST_02\"); //Miasto zosta\u0142o zamkni\u0119te.\n// Bohater rozgl\u0105da si\u0119 woko\u0142o w trakcie nast\u0119pnej sceny\nDIAG(\"Nervous\", 1, 2);\nAI_Output (other, self, \"TRIA_TEST_03\"); //Mam troch\u0119 z\u0142ota przy sobie, mo\u017cemy pohandlowa\u0107?\n// Bohater powinien rusza\u0107 si\u0119 teraz znowu normalnie\nDIAG_Reset();\n// Rozpocznij ruch kamery\nTRIA_Cam(\"CAMERASTART\");\n// Bohater m\u00f3wi teraz do Squelto (self = Squelto, other = Hero)\nTRIA_Next(Squelto);\nAI_TurnToNpc(other, self);\nDIAG(\"No\", 0, 1);\nAI_Output (self, other, \"TRIA_TEST_04\"); //Nie. Nie jeste\u015bmy otwarci na przekupstwo.\n// Bohater m\u00f3wi ponowni do Arto (self = Arto, other = Hero)\nTRIA_Next(Arto);\n// Bohater powinien teraz pytaj\u0105co gestykulowa\u0107\nDIAG(\"NotSure\", 0, 1);\nAI_Output(other, self, \"TRIA_TEST_05\"); //Na pewno?\nAI_TurnToNpc(other, self);\n// Zako\u0144cz ruch kamery\nTRIA_Cam(\"\");\n// Arto powinien zareagowa\u0107 w\u015bciekle\nDIAG(\"Angry\", 0, 4);\nAI_Output (self, other, \"TRIA_TEST_06\"); //Musz\u0119 prosi\u0107, aby\u015b teraz odszed\u0142.\n// Bohater powinien ponownie porusza\u0107 si\u0119 normalnie\nDIAG_Reset();\nAI_Output (other, self, \"TRIA_TEST_07\"); //Niech b\u0119dzie...\nTRIA_Finish(); // Koniec\n};\n</code></pre></li> </ol> <p>Note</p> <p>Dodatkowo w powy\u017cszym przyk\u0142adzie u\u017cyty jest te\u017c pakiet Dialoggestures.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/ai_function/#ai_function---funkcje-ai","title":"AI_Function - Funkcje AI","text":"<p>Ten pakiet umo\u017cliwia wywo\u0142ywanie funkcji op\u00f3\u017anionych w czasie poprzez kolejkowanie ich w kolejce AI danego NPC. Mo\u017ce to by\u0107 bardzo przydatne przy pisaniu przerywnik\u00f3w filmowych na silniku lub implementacji nowych rutyn.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/ai_function/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>HookEngine</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/ai_function/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_AI_Function</code>. </p><pre><code>LeGo_Init(LeGo_AI_Function);\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/ai_function/#implementacja","title":"Implementacja","text":"<p> AI_Function.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/ai_function/#functions","title":"Functions","text":"<p>Funkcja <code>function</code> jest wywo\u0142ywana z op\u00f3\u017anieniem: do\u0142\u0105cza do kolejki AI <code>slf</code>. </p><pre><code>func void AI_Function(var C_NPC slf, var func function)\n</code></pre> Parameters <ul> <li><code>var C_NPC slf</code>     NPC, do kt\u00f3rego kolejki AI do\u0142\u0105cza funkcja</li> <li><code>var func function</code>     Funkcja wywo\u0142ywana z op\u00f3\u017anieniem</li> </ul> <p>Dodatkowo istniej\u0105 pewne przeci\u0105\u017cenia <code>AI_Function</code>, kt\u00f3re pozwalaj\u0105 na wywo\u0142ywanie funkcji z parametrami. </p><pre><code>func void AI_Function_I  (var C_NPC slf, var func function, var int    param) {}; // Int\nfunc void AI_Function_N  (var C_NPC slf, var func function, var int    param) {}; // Instance (e.g. NPC)\nfunc void AI_Function_S  (var C_NPC slf, var func function, var string param) {}; // String\nfunc void AI_Function_II (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Int, Int\nfunc void AI_Function_NN (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Instance, Instance\nfunc void AI_Function_SS (var C_NPC slf, var func function, var string param1, var string param2) {}; // String, String\nfunc void AI_Function_IS (var C_NPC slf, var func function, var int    param1, var string param2) {}; // Int, String\nfunc void AI_Function_SI (var C_NPC slf, var func function, var string param1, var int    param2) {}; // String, Int\nfunc void AI_Function_NS (var C_NPC slf, var func function, var int    param1, var string param2) {}; // Instance, String\nfunc void AI_Function_SN (var C_NPC slf, var func function, var string param1, var int    param2) {}; // String, Istance\nfunc void AI_Function_IN (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Int, Instance\nfunc void AI_Function_NI (var C_NPC slf, var func function, var int    param1, var int    param2) {}; // Instance, Int\n</code></pre> Nie mo\u017cna wywo\u0142ywa\u0107 funkcji z wi\u0119cej ni\u017c dwoma parametrami, ale parametry mo\u017cna przekazywa\u0107 po\u015brednio przez zmienne globalne. <p>W wywo\u0142anej funkcji dost\u0119p do <code>self</code> mo\u017cna uzyska\u0107 w nast\u0119puj\u0105cy spos\u00f3b: </p><pre><code>var oCNpc slf; slf = _^(ECX);\n</code></pre> <p>Info</p> <p>Od LeGo 2.7.2 globalna instancja <code>self</code> jest dostarczana poprawnie i mo\u017ce by\u0107 u\u017cywana bezpo\u015brednio.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/ai_function/#przyk\u0142ady","title":"Przyk\u0142ady","text":""},{"location":"pl/zengin/scripts/extenders/lego/tools/ai_function/#kolejkowanie-prostej-funkcji","title":"Kolejkowanie prostej funkcji","text":"<p>Zanim funkcja zostanie wywo\u0142ana, ka\u017cdy NPC powinien najpierw zako\u0144czy\u0107 swoj\u0105 kolejk\u0119 AI.</p> <p>Tutaj bohater ma biec do Waypointu i dopiero po dotarciu na miejsce ma rozpocz\u0105\u0107 si\u0119 ruch kamery. </p><pre><code>func void Example1() {\nNpc_ClearAIQueue(hero);\nAI_GotoWP(hero, \"MYWAYPOINT\");\nAI_Function_S(hero, Wld_SendTrigger, \"CAMERASTART\");\n};\n</code></pre> Gdy tylko bohater dotrze do Waypointu, wywo\u0142ywane jest <code>Wld_SendTrigger(\"CAMERASTART\");</code>."},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#binarymachines","title":"BinaryMachines","text":"<p>Ten pakiet pozwala tworzy\u0107 i zapisywa\u0107 w\u0142asne pliki w dowolnym miejscu w systemie plik\u00f3w.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<p>Brak</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#inicjalizacja","title":"Inicjalizacja","text":"<p>Brak</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#implementacja","title":"Implementacja","text":"<p> BinaryMachines.d na GitHub</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_newfile","title":"<code>BW_NewFile</code>","text":"<p>Tworzy plik o nazwie <code>file</code> i otwiera strumie\u0144. Nie dzia\u0142a, je\u015bli strumie\u0144 jest ju\u017c otwarty. </p><pre><code>func int BW_NewFile(var string file)\n</code></pre> Parametry <ul> <li><code>var string file</code>     Nazwa tworzonego pliku</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca <code>TRUE</code> je\u015bli plik zosta\u0142 pomy\u015blnie utworzony i zainicjalizowany, w przeciwnym razie zwracane jest <code>FALSE</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_close","title":"<code>BW_Close</code>","text":"<p>Zamyka aktualny strumie\u0144 zapisu. </p><pre><code>func void BW_Close()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw","title":"<code>BW</code>","text":"<p>Zapisuje <code>length</code> bajt\u00f3w z <code>data</code> do strumienia, maksymalnie 4 bajty. </p><pre><code>func void BW(var int data, var int length)\n</code></pre> Parametry <ul> <li><code>var int data</code>     Warto\u015b\u0107 bajt\u00f3w</li> <li><code>var int length</code>     Liczba bajt\u00f3w</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_int","title":"<code>BW_Int</code>","text":"<p>Zapisuje 4 bajty z <code>data</code> do strumienia. To samo co <code>BW(data, 4)</code>. </p><pre><code>func void BW_Int(var int data)\n</code></pre> Parametry <ul> <li><code>var int data</code>     Warto\u015b\u0107 ca\u0142kowita do zapisania</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_char","title":"<code>BW_Char</code>","text":"<p>Zapisuje pierwszy znak z <code>data</code> do strumienia. To samo co <code>BW(Str_GetCharAt(data, 0), 1)</code>. </p><pre><code>func void BW_Char(var string data)\n</code></pre> Parametry <ul> <li><code>var string data</code>     Znak do zapisania</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_string","title":"<code>BW_String</code>","text":"<p>Zapisuje <code>data</code> zako\u0144czone znakiem <code>\\0</code> do strumienia. </p><pre><code>func void BW_String(var string data)\n</code></pre> Parametry <ul> <li><code>var string data</code>     Ci\u0105g znak\u00f3w do zapisania</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_byte","title":"<code>BW_Byte</code>","text":"<p>Zapisuje bajt z <code>data</code> do strumienia. To samo co <code>BW(data, 1)</code>. </p><pre><code>func void BW_Byte(var int data)\n</code></pre> Parametry <ul> <li><code>var int data</code>     Warto\u015b\u0107 bajtowa do zapisania</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_bytes","title":"<code>BW_Bytes</code>","text":"<p>Zapisuje <code>length</code> bajt\u00f3w ze wska\u017anika <code>dataPtr</code> do strumienia. </p><pre><code>func void BW_Bytes(var int dataPtr, var int length)\n</code></pre> Parametry <ul> <li><code>var int dataPtr</code>     Wska\u017anik danych do zapisania</li> <li><code>var int length</code>     Liczba bajt\u00f3w</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_text","title":"<code>BW_Text</code>","text":"<p>Zapisuje ci\u0105g znak\u00f3w do strumienia bez jego zako\u0144czenia. Nie mo\u017cna go ju\u017c odczyta\u0107. </p><pre><code>func void BW_Text(var string data)\n</code></pre> Parametry <ul> <li><code>var string data</code>     Tekst do zapisania</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#bw_nextline","title":"<code>BW_NextLine</code>","text":"<p>Zapisuje akapit do strumienia. </p><pre><code>func void BW_NextLine()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_openfile","title":"<code>BR_OpenFile</code>","text":"<p>Otwiera plik o nazwie <code>file</code> i otwiera strumie\u0144. Nie dzia\u0142a, je\u015bli strumie\u0144 jest ju\u017c otwarty. </p><pre><code>func int BR_OpenFile(var string file)\n</code></pre> Parametry <ul> <li><code>var string file</code>     Plik, kt\u00f3ry ma by\u0107 otwarty</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca <code>TRUE</code> je\u015bli plik zosta\u0142 pomy\u015blnie otworzony i zainicjalizowany, w przeciwnym razie zwracane jest <code>FALSE</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_close","title":"<code>BR_Close</code>","text":"<p>Zamyka aktualny strumie\u0144 odczytu. </p><pre><code>func void BR_Close()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br","title":"<code>BR</code>","text":"<p>Odczytuje bajty ze strumienia. </p><pre><code>func int BR(var int length)\n</code></pre> Parametry <ul> <li><code>var int length</code>     Liczba bajt\u00f3w do odczytania (maksymalnie 4)</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca odczytan\u0105 warto\u015b\u0107 bajt\u00f3w.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_int","title":"<code>BR_Int</code>","text":"<p>Odczytuje 4 bajty ze strumienia. To samo co <code>BR(4)</code>. </p><pre><code>func int BR_Int()\n</code></pre> Zwracana warto\u015b\u0107 <p>Funkcja zwraca odczytan\u0105 liczb\u0119 ca\u0142kowit\u0105.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_char","title":"<code>BR_Char</code>","text":"<p>Odczytuje znak ze strumienia. To samo co <code>BR(1)</code>. </p><pre><code>func string BR_Char()\n</code></pre> Zwracana warto\u015b\u0107 <p>Funkcja zwraca odczytany znak jako <code>string</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_string","title":"<code>BR_String</code>","text":"<p>Odczytuje ci\u0105g znak\u00f3w zako\u0144czony znakiem <code>\\0</code> ze strumienia. </p><pre><code>func string BR_String()\n</code></pre> Zwracana warto\u015b\u0107 <p>Funkcja zwraca odczytany ci\u0105g znak\u00f3w.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_byte","title":"<code>BR_Byte</code>","text":"<p>Odczytuje bajt ze strumienia. </p><pre><code>func int BR_Byte()\n</code></pre> Zwracana warto\u015b\u0107 <p>Funkcja zwraca odczytany bajt.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_bytes","title":"<code>BR_Bytes</code>","text":"<p>Odczytuje bajty ze strumienia. </p><pre><code>func int BR_Bytes(var int length)\n</code></pre> Parametry <ul> <li><code>var int length</code>     Liczba bajt\u00f3w do odczytania</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca wska\u017anik do odczytanych bajt\u00f3w.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_textline","title":"<code>BR_TextLine</code>","text":"<p>Odczytuje lini\u0119 ze strumienia. </p><pre><code>func string BR_TextLine()\n</code></pre> Zwracana warto\u015b\u0107 <p>Funkcja zwraca odczytan\u0105 lini\u0119.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_text","title":"<code>BR_Text</code>","text":"<p>Odczytuje ci\u0105g znak\u00f3w o podanej d\u0142ugo\u015bci ze strumienia. </p><pre><code>func string BR_Text(var int length)\n</code></pre> Parametry <ul> <li><code>var int length</code>     Liczba znak\u00f3w do odczytania</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca odczytany ci\u0105g znak\u00f3w.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#br_nextline","title":"<code>BR_NextLine</code>","text":"<p>Zmienia pozycj\u0119 odczytu na nast\u0119pny akapit, utworzony za pomoc\u0105 <code>BW_NextLine</code>. </p><pre><code>func void BR_NextLine()\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#wywo\u0142ania-funkcji-silnika","title":"Wywo\u0142ania funkcji silnika","text":""},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#win_getlasterror","title":"<code>WIN_GetLastError</code>","text":"<p>Wywo\u0142anie funkcji <code>GetLastError</code> z Win32 API. </p><pre><code>func int WIN_GetLastError()\n</code></pre> Zwracana warto\u015b\u0107 <p>Funkcja zwraca kod ostatniego b\u0142\u0119du w\u0105tku wywo\u0142uj\u0105cego.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#win_createfile","title":"<code>WIN_CreateFile</code>","text":"<p>Wywo\u0142anie funkcji <code>CreateFileA</code> z Win32 API. </p><pre><code>func int WIN_CreateFile(var string lpFileName,var int dwDesiredAccess,var int dwShareMode,var int lpSecurityAttributes,var int dwCreationDisposition,var int dwFlagsAndAttributes,var int hTemplateFile)\n</code></pre> Parametry <p>Pe\u0142ny opis parametr\u00f3w mo\u017cna znale\u017a\u0107 tutaj</p> <p>Zwracana warto\u015b\u0107</p> <p>Informacje o zwracanej warto\u015bci znajdziesz tutaj</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#win_writefile","title":"<code>WIN_WriteFile</code>","text":"<p>Wywo\u0142anie funkcji <code>WriteFile</code> z Win32 API. </p><pre><code>func void WIN_WriteFile(var int hFile,var int lpBuffer,var int nNumberOfBytesToWrite,var int lpNumberOfBytesWritten,var int lpOverlapped)\n</code></pre> Parametry <p>Pe\u0142ny opis parametr\u00f3w mo\u017cna znale\u017a\u0107 tutaj</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#win_readfile","title":"<code>WIN_ReadFile</code>","text":"<p>Wywo\u0142anie funkcji <code>ReadFile</code> z Win32 API. </p><pre><code>func void WIN_ReadFile(var int hFile,var int lpBuffer,var int nNumberOfBytesToRead,var int lpNumberOfBytesRead,var int lpOverlapped)\n</code></pre> Parametry <p>Pe\u0142ny opis parametr\u00f3w mo\u017cna znale\u017a\u0107 tutaj</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#win_closehandle","title":"<code>WIN_CloseHandle</code>","text":"<p>Wywo\u0142anie funkcji <code>CloseHandle</code> z Win32 API. </p><pre><code>func void WIN_CloseHandle(var int hObject)\n</code></pre> Parametry <p>Pe\u0142ny opis parametr\u00f3w mo\u017cna znale\u017a\u0107 tutaj</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#win_getfilesize","title":"<code>WIN_GetFileSize</code>","text":"<p>Wywo\u0142anie funkcji <code>GetFileSize</code> z Win32 API. </p><pre><code>func int WIN_GetFileSize(var int hFile,var int lpFileSizeHigh)\n</code></pre> Parametry <p>Pe\u0142ny opis parametr\u00f3w mo\u017cna znale\u017a\u0107 tutaj</p> <p>Zwracana warto\u015b\u0107</p> <p>Informacje o zwracanej warto\u015bci znajdziesz tutaj</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#constants","title":"Constants","text":"<p>Dodatkowo istniej\u0105 pewne sta\u0142e zdefiniowane do u\u017cycia z okre\u015blonymi wywo\u0142aniami funkcji silnika. </p><pre><code>const int CREATE_ALWAYS = 2;\nconst int OPEN_EXISTING = 3;\nconst int GENERIC_ALL = 1073741824;\nconst int GENERIC_READ = -2147483648;\nconst int FILE_SHARE_READ = 1;\nconst int FILE_SHARE_WRITE = 2;\nconst int FILE_SHARE_DELETE = 4;\nconst int FILE_ATTRIBUTE_NORMAL = 128;\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#przyk\u0142ady","title":"Przyk\u0142ady","text":""},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#zapisywanie-i-wczytywanie-zmiennych","title":"Zapisywanie i wczytywanie zmiennych","text":"<pre><code>const string filename = \"System\\MySave.sav\";\nvar string s0; // ci\u0105g znak\u00f3w\nvar int    i1; // liczba ca\u0142kowita\nvar int    b2; // bajt\nvar string c3; // znak\nfunc void SaveMyData()\n{\nif(BW_NewFile(filename))  // Utw\u00f3rz nowy plik:\n{ BW_String(s0);\nBW_Int(i1);\nBW_Byte(b2);\nBW_Char(c3);          // Zapisz dane...\nBW_Close();           // ...i zamknij.\n};\n};\nfunc void LoadMyData() {\nif(BR_OpenFile(filename)) // Spr\u00f3buj otworzy\u0107 plik:\n{ s0 = BR_String();\ni1 = BR_Int();\nb2 = BR_Byte();\nc3 = BR_Char();       // Odczytaj warto\u015bci...\nBR_Close();           // ...i zamknij.\n}\nelse {\nSaveMyData();         // W przeciwnym razie utw\u00f3rz plik z zapisem.\n};\n};\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#gratulacje-dla-gracza","title":"Gratulacje dla gracza","text":"<pre><code>func void Certificate(var string Username, var int Score) {\nvar string filename; filename = ConcatStrings(Username, \"'s Certificate.txt\");\nBW_NewFile(filename); // Nazwa u\u017cytkownika + \"s Certificate.txt\". Plik jest w katalogu Gothic.\nBW_Text(\"Gratulacje \"); BW_Text(Username);\nBW_TextLine(\"!\");\nBW_Text(\"Zdoby\u0142e\u015b \");\nBW_Text(IntToString(Score)); // Nie BW_Int!\nBW_TextLine(\" punkt\u00f3w w tej grze.\");\nBW_NextLine();\nBW_Text(\"Z wyrazami szacunku, Autor\");\nBW_Close();\n/*\n       Przy wywo\u0142aniu:  Certificate(\"Player\", 1000);\n       zostanie utworzony plik o nazwie 'Player's Certificate.txt', kt\u00f3ry zawiera\u0107 b\u0119dzie:\n        Gratulacje NazwaGracza!\n        Zdoby\u0142e\u015b 1000 punkt\u00f3w w tej grze.\n        Z wyrazami szacunku, Autor\n    */\n};\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/binary_machines/#po\u0142o\u017cenie-postaci-npc","title":"Po\u0142o\u017cenie postaci NPC","text":"<pre><code>func void BW_NpcPosition(var C_NPC slf) {\nvar int ptr; ptr = MEM_Alloc(60);                // 16 * 4\nMEM_CopyBytes(MEM_InstToPtr(slf) + 60, ptr, 60); // Skopiuj slf.trafoObjToWorld\nBW_Bytes(ptr, 60);                               // Zapisz skopiowane 60 bajt\u00f3w\nMEM_Free(ptr);                                   // I posprz\u0105taj...\n};\nfunc void BR_NpcPosition(var C_NPC slf) {\nvar int ptr; ptr = BR_Bytes(60);                 // Odczytaj 60 bajt\u00f3w\nMEM_CopyBytes(ptr, MEM_InstToPtr(slf) + 60, 60); // Wklej z powrotem do slf\nMEM_Free(ptr);                                   // I posprz\u0105taj ponownie...\n};\n/*\n   U\u017cycie standardowe:\n     BW_NewFile(file);\n     BW_NpcPosition(hero);\n     BW_Close();\n*/\n</code></pre> <p>Uwaga</p> <p>Przyk\u0142ady zosta\u0142y pierwotnie napisane przez Gottfrieda i opublikowane na forum World of Gothic.</p> <p>`</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/item_helper/#itemhelper---pomocnik-do-przedmiot\u00f3w","title":"ItemHelper - pomocnik do przedmiot\u00f3w","text":"<p>Ten pakiet jest bardzo prosty - pobiera wska\u017anik <code>oCItem</code> z instancji <code>C_ITEM</code> wa\u017cnej dla bie\u017c\u0105cego \u015bwiata i sesji.</p> <p>Warning</p> <p>Upewnij si\u0119, \u017ce ka\u017cdy \u015bwiat ma waypoint o nazwie <code>TOT</code> (po niemiecku \"martwy\"). Ikarus i LeGo potrzebuj\u0105 tego punktu nawigacyjnego, aby odradza\u0107 pomocniczych NPC. Jest to szczeg\u00f3lnie wa\u017cne w Gothicu 1, poniewa\u017c jego \u015bwiaty nie maj\u0105 waypointu <code>TOT</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/item_helper/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<p>Nie dotyczy.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/item_helper/#inicjalizacja","title":"Inicjalizacja","text":"<p>Nie dotyczy.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/item_helper/#implementacja","title":"Implementacja","text":"<p> ItemHelper.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/item_helper/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/tools/item_helper/#itm_getptr","title":"<code>Itm_GetPtr</code>","text":"<pre><code>func int Itm_GetPtr(var int instance)\n</code></pre> Parametry <ul> <li><code>var int instance</code>     Instancja <code>C_ITEM</code>, z kt\u00f3rej ma zosta\u0107 pobrany wska\u017anik</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca wska\u017anik <code>oCItem</code> instancji <code>C_ITEM</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#misc---r\u00f3\u017cne","title":"Misc - r\u00f3\u017cne","text":"<p>Pakiet Misc wprowadza r\u00f3\u017cne funkcje pomocnicze, kt\u00f3re nie pasowa\u0142y do \u017cadnego innego pakietu.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<p>Nie dotyczy.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#inicjalizacja","title":"Inicjalizacja","text":"<p>Nie dotyczy.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#implementacja","title":"Implementacja","text":"<p> Misc.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#sta\u0142e","title":"Sta\u0142e","text":"<p>Pakiet Misc implementuje sat\u0142\u0105 <code>phi</code> </p><pre><code>const int phi = 1070141312; // PI/2\n</code></pre> kt\u00f3ra w rzeczywisto\u015bci jest liczb\u0105 <code>pi</code> podzielon\u0105 przez 2 zapisan\u0105 jako ikarusowy float. <p>Decymalnie: <code>1.5707...</code></p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#atan2f","title":"<code>atan2f</code>","text":"<p>Oblicza arcus tangens k\u0105ta mi\u0119dzy pocz\u0105tkiem a punktem (x, y). </p><pre><code>func int atan2f(var int x, var int y)\n</code></pre> Parametry <ul> <li><code>var int x</code>     Wsp\u00f3\u0142rz\u0119dna x</li> <li><code>var int y</code>     Wsp\u00f3\u0142rz\u0119dna y</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca arcus tangens w radianach, jako ikarusowy <code>float</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#sin","title":"<code>sin</code>","text":"<p>Oblicza sinus k\u0105ta podanego w radianach. </p><pre><code>func int sin(var int angle)\n</code></pre> Parametry <ul> <li><code>var int angle</code>     K\u0105t w radianach jako ikarusowy <code>float</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca sinus k\u0105ta, jako ikarusowy <code>float</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#cos","title":"<code>cos</code>","text":"<p>Oblicza cosinus k\u0105ta podanego w radianach. </p><pre><code>func int cos(var int angle)\n</code></pre> Parametry <ul> <li><code>var int angle</code>     K\u0105t w radianach jako ikarusowy <code>float</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca cosinus k\u0105ta, jako ikarusowy <code>float</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#tan","title":"<code>tan</code>","text":"<p>Oblicza tangens k\u0105ta podanego w radianach. </p><pre><code>func int tan(var int angle)\n</code></pre> Parametry <ul> <li><code>var int angle</code>     K\u0105t w radianach jako ikarusowy <code>float</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca tangens k\u0105ta, jako ikarusowy <code>float</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#asin","title":"<code>asin</code>","text":"<p>Oblicza arcus sinus </p><pre><code>func int asin(var int sine)\n</code></pre> Parametry <ul> <li><code>var int sine</code>     Sinus k\u0105ta jako ikarusowy <code>float</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca arcus sinus k\u0105ta, jako ikarusowy <code>float</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#acos","title":"<code>acos</code>","text":"<p>Oblicza arcus cosinus </p><pre><code>func int acos(var int cosine)\n</code></pre> Parametry <ul> <li><code>var int cosine</code>     Cosinus k\u0105ta jako ikarusowy <code>float</code></li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca arcus cosinus k\u0105ta, jako ikarusowy <code>float</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#distance2d","title":"<code>distance2D</code>","text":"<p>Oblicza odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami na p\u0142aszczy\u017anie dwuwymiarowej. </p><pre><code>func int distance2D(var int x1, var int x2, var int y1, var int y2)\n</code></pre> Parametry <ul> <li><code>var int x1</code>     wsp\u00f3\u0142rz\u0119dna x pierwszego punktu</li> <li><code>var int x2</code>     wsp\u00f3\u0142rz\u0119dna x drugiego punktu</li> <li><code>var int y1</code>     wsp\u00f3\u0142rz\u0119dna y pierwszego punktu</li> <li><code>var int y2</code>     wsp\u00f3\u0142rz\u0119dna y drugiego punktu</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/misc/#distance2df","title":"<code>distance2Df</code>","text":"<p>Oblicza odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami na p\u0142aszczy\u017anie dwuwymiarowej, ale na liczbach zmiennoprzecinkowych (float). </p><pre><code>func int distance2Df(var int x1, var int x2, var int y1, var int y2)\n</code></pre> Parametry <ul> <li><code>var int x1</code>     wsp\u00f3\u0142rz\u0119dna x pierwszego punktu</li> <li><code>var int x2</code>     wsp\u00f3\u0142rz\u0119dna x drugiego punktu</li> <li><code>var int y1</code>     wsp\u00f3\u0142rz\u0119dna y pierwszego punktu</li> <li><code>var int y2</code>     wsp\u00f3\u0142rz\u0119dna y drugiego punktu</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca odleg\u0142o\u015b\u0107 mi\u0119dzy dwoma punktami, jako ikarusowy <code>float</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#talents---talenty","title":"Talents - talenty","text":"<p>Ten pakiet robi dwie rzeczy:</p> <ol> <li>Zapisuje dowoln\u0105 liczb\u0119 warto\u015bci dla okre\u015blonego NPC (efektywne rozszerzenie tablicy AIVar).</li> <li>Pozwala zidentyfikowa\u0107 NPC za pomoc\u0105 unikalnego ID.</li> </ol> <p>Pakiet <code>Talents</code> u\u017cywa jednego wolnego AIVara, domy\u015blnie jest to AIVar z numerem 89, kt\u00f3ry mo\u017cna dostosowa\u0107 w <code>Userconst.d</code> <code>AIV_TALENT</code>.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#zale\u017cno\u015bci","title":"Zale\u017cno\u015bci","text":"<ul> <li>PermMem</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#inicjalizacja","title":"Inicjalizacja","text":"<p>Zainicjuj za pomoc\u0105 flagi <code>LeGo_PermMem</code>. </p><pre><code>LeGo_Init(LeGo_PermMem);\n</code></pre>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#implementacja","title":"Implementacja","text":"<p> Talents.d na GitHubie</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#funkcje","title":"Funkcje","text":""},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#npc_getid","title":"<code>NPC_GetID</code>","text":"<p>Zwraca unikalne ID dla podanego NPC.</p> <p></p><pre><code>func int NPC_GetID(var C_NPC slf)\n</code></pre> Parametry <ul> <li><code>var C_NPC slf</code>     NPC</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca unikalne ID dla podanego NPC.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#npc_findbyid","title":"<code>NPC_FindByID</code>","text":"<p>Znajduje wska\u017anik NPC o podanym ID. </p><pre><code>func int NPC_FindByID(var int ID)\n</code></pre> Parametry <ul> <li><code>var int ID</code>     ID postaci</li> </ul> <p>Zwracana warto\u015b\u0107</p> <p>Funkcja zwraca wska\u017anik podanej postaci (NPC).</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#tal_createtalent","title":"<code>TAL_CreateTalent</code>","text":"<p>Tworzy talent, w kt\u00f3rym mo\u017cesz p\u00f3\u017aniej zapisa\u0107 warto\u015b\u0107 dla ka\u017cdego NPC (tak jak w AIVarze). </p><pre><code>func int TAL_CreateTalent()\n</code></pre> Zwracana warto\u015b\u0107 <p>Funkcja zwraca warto\u015b\u0107, kt\u00f3ra jest p\u00f3\u017aniej wykorzystywana jako ID talentu.</p>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#tal_setvalue","title":"<code>TAL_SetValue</code>","text":"<p>Ustawia now\u0105 warto\u015b\u0107 dla okre\u015blonego talentu. </p><pre><code>func void TAL_SetValue(var C_NPC npc, var int talent, var int value)\n</code></pre> Parametry <ul> <li><code>var C_NPC npc</code>     NPC dla kt\u00f3rego ustawiana jest warto\u015b\u0107</li> <li><code>var int talent</code>     ID talentu</li> <li><code>var int value</code>     Ustawiana warto\u015b\u0107</li> </ul>"},{"location":"pl/zengin/scripts/extenders/lego/tools/talents/#tal_getvalue","title":"TAL_GetValue","text":"<p>Zwraca warto\u015b\u0107 talentu dla okre\u015blonego NPC. </p><pre><code>func int TAL_GetValue(var C_NPC npc, var int talent)\n</code></pre> Parametry <ul> <li><code>var C_NPC npc</code>     NPC, kt\u00f3rego warto\u015b\u0107 talentu jest zwracana</li> <li><code>var int talent</code>     ID talentu</li> </ul>"},{"location":"pl/zengin/scripts/extenders/standalone/","title":"Samodzielne skrypty","text":""},{"location":"pl/zengin/scripts/extenders/standalone/#samodzielne-skrypty","title":"Samodzielne skrypty","text":"<p>Przez lata moderzy Gothica stworzyli wiele przydatnych funkcji do wykorzystania ze skryptami Zengin. Ta sekcja zawiera dokumentacj\u0119 niekt\u00f3rych skrypt\u00f3w, kt\u00f3re s\u0105 \u201esamodzielne\u201d, co oznacza, \u017ce nie s\u0105 cz\u0119\u015bci\u0105 wi\u0119kszych pakiet\u00f3w, ale cz\u0119sto s\u0105 to ma\u0142e funkcje u\u0142atwiaj\u0105ce \u017cycie modderom.</p>"},{"location":"pl/zengin/scripts/extenders/standalone/#script-biny","title":"Script Biny","text":"<p>Kilka os\u00f3b wpad\u0142o na pomys\u0142 zebrania rozsianych po forach skrypt\u00f3w, w wyniku czego powsta\u0142y tzw. Script Biny.</p> <p>Warning</p> <p>Script biny nie s\u0105 cz\u0119sto aktualizowane, wi\u0119c najnowsze aktualizacje i nowe skrypty mo\u017cna znale\u017a\u0107 w w\u0105tku ScriptBin na niemieckim forum WoG.</p>"},{"location":"pl/zengin/scripts/extenders/standalone/#wog-script-bin","title":"WoG Script Bin","text":"<p>Script bin stworzony przez Kiridesa zawieraj\u0105cy skrypty z niemieckiego forum WoG.</p> <p>https://apps.kirides.de/wog-script-bin/</p>"},{"location":"pl/zengin/scripts/extenders/standalone/#repozytorium-scriptbin-na-githubie","title":"Repozytorium ScriptBin na GitHubie","text":"<p>Repozytorium GitHub stworzone przez Lehone, kt\u00f3re zawiera skrypty niekt\u00f3rych modder\u00f3w.</p> <p>https://github.com/Lehona/ScriptBin</p>"},{"location":"pl/zengin/scripts/extenders/zparserextender/syntax_extensions/while/","title":"P\u0119tla while","text":""},{"location":"pl/zengin/scripts/extenders/zparserextender/syntax_extensions/while/#natywna-p\u0119tla-while","title":"Natywna p\u0119tla WHILE","text":"<p>Podobnie jak Ikarus zParserExtender implementuje p\u0119tl\u0119 while.</p> <pre><code>var int value; value = 10;\nwhile(value &gt; 0)\n{\nif (value == 8)\n{\ncontinue;\n};\nif (value == 2)\n{\nbreak;\n};\n};\n</code></pre> <p>Note</p> <p>Aby aktywowa\u0107 <code>while</code> konieczne jest ustawienie <code>NativeWhile</code> w SystemPack.ini </p><pre><code>[ZPARSE_EXTENDER]\nNativeWhile = true\n</code></pre> <p>Skompilowana p\u0119tla while dzia\u0142a w silniku vanilla bez pluginu.</p>"},{"location":"cs/","title":"V\u00edtejte na str\u00e1nce Gothic Modding Community","text":""},{"location":"cs/#v\u00edtejte-na-str\u00e1nce-gothic-modding-community","title":"V\u00edtejte na str\u00e1nce Gothic Modding Community","text":"<p>Tato Github str\u00e1nka obsahuje komunitou vytvo\u0159en\u00e9 a udr\u017eovan\u00e9 \u010dl\u00e1nky, n\u00e1vody a dokumentaci o v\u0161em, co se t\u00fdk\u00e1 her Gothic.</p> <p>Prvn\u00ed dv\u011b hry s\u00e9rie Gothic b\u011b\u017e\u00ed na enginu, kter\u00fd se jmenuje ZenGin, vyvinut\u00e9m studiem Piranha Bytes a skupinou program\u00e1tor\u016f Mad Scientists. Pokud se chcete o historii v\u00fdvoje dozv\u011bd\u011bt v\u00edce, hromadu informac\u00ed m\u016f\u017eete naj\u00edt na str\u00e1nce Gothic Archive.</p> <p>Obsah t\u00e9to str\u00e1nky by nem\u011bl b\u00fdt br\u00e1n jako jedin\u00fd validn\u00ed zp\u016fsob moddingu. Jsme pouze nad\u0161enci, kte\u0159\u00ed sd\u00edl\u00ed sv\u00e9 zku\u0161enosti, znalosti a na\u0161e nejobl\u00edben\u011bj\u0161\u00ed postupy.</p> <p>Nev\u00e1hejte otev\u0159\u00edt pull request s va\u0161\u00edm \u010dl\u00e1nkem nebo n\u00e1vrhy na zm\u011bny.</p> <p>Pull request m\u016f\u017eete otev\u0159\u00edt v tomto repozit\u00e1\u0159i.</p>"}]}